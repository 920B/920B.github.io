/* This file was generated by the Hex-Rays decompiler version 8.2.0.221215.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int pre_c_init();
int pre_cpp_init();
// _DWORD __cdecl __tmainCRTStartup(char); weak
int __cdecl WinMainCRTStartup(char a1);
int __cdecl atexit(void (__cdecl *)());
int __gcc_register_frame();
void __cdecl __gcc_deregister_frame(); // idb
int __cdecl show_help(const char *a1);
void __cdecl __noreturn show_version(const char *a1);
int __cdecl parse_options(int a1, char **a2);
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl getComPort(_BYTE *a1, _BYTE *a2);
int __cdecl enumerateSerialPortsFriendlyNames(_BYTE *a1, char a2);
int __cdecl serialFindPorts(char *, char *Destination); // idb
void __cdecl serialSleep(DWORD dwMilliseconds);
char *__cdecl serialOpen(char *Str);
int __cdecl serialConfig(int a1, int a2, int a3, int a4, int a5);
int __cdecl serialSetTimeout(HANDLE *a1, signed int a2);
void __cdecl serialClose(char *Block);
BOOL __cdecl serialFlush(HANDLE *a1);
int __cdecl serialWrite(HANDLE *a1, const void *a2, DWORD nNumberOfBytesToWrite);
int __cdecl serialRead(HANDLE *a1, void *a2, DWORD nNumberOfBytesToRead);
DWORD getppid();
BOOL verifyppid();
int __cdecl getNextStdioChar(HANDLE hFile, char a2);
void __cdecl __noreturn serialReadUserData(int (__cdecl *a1)(char *, int, char *), char a2);
int __cdecl v5_ExitStatusJson(int a1, int a2, const char *a3);
int __cdecl v5_SetBrainStatus(int a1);
int __cdecl v5_SetSystemStatus(unsigned __int8 *a1);
int v5_SetDeviceStatus();
int v5_SetProgramStatus();
int __cdecl v5_GetSystemInfoJson(const char *a1, const char *a2);
int __cdecl v5_GetDirJson(unsigned __int8 a1);
int __cdecl v5_showCatalogJson(int a1, int a2);
int v5_GetPrograms();
int v5_GetProgramsJson();
int __cdecl v5_SystemStatusJson(int a1, const char *a2, const char *a3);
int __cdecl appVersionJson(const char *a1, const char *a2, const char *a3, const char *a4);
BOOL __cdecl isControllerProductId(int a1);
BOOL __cdecl isV5ControllerProductId(int a1);
BOOL __cdecl isV5ProductId(int a1);
BOOL __cdecl isV5BrainProductId(int a1);
BOOL __cdecl isIq2ProductId(int a1);
BOOL __cdecl isIq2BrainProductId(int a1);
BOOL __cdecl isExpProductId(int a1);
BOOL __cdecl isExpBrainProductId(int a1);
BOOL __cdecl isSlowEraseProductId(int a1);
BOOL __cdecl isV5ProtocolProductId(int a1);
BOOL __cdecl isGpsProductId(int a1);
BOOL __cdecl isTestProductId(int a1);
char *systemVersionString();
char *__cdecl versionString(unsigned int a1);
const char *__cdecl v5GetTime(__time32_t *Time);
long double __cdecl v5TransferTimer(int a1, int a2, const char *a3, char a4);
unsigned int __cdecl read_file(char *FileName, void **a2);
void *__cdecl decodeBase64(char *Str);
int __cdecl gzip_compress_binary(int a1, unsigned int a2, void **a3);
void vexLoggerInit();
int __cdecl vexlogLevel(int a1);
int vexlog(int a1, char *Format, ...);
int vexlogFlush();
int vexerr(int a1, char *Format, ...);
int __cdecl v5_FileTransferProgress(int a1, int a2);
char *__cdecl v5_FileTransferMetadata(char *Source, char *a2, char *a3);
int __cdecl v5_FileTransferShowProgressBash(int a1);
int __cdecl v5_FileTransferShowProgressJson(int a1);
int __cdecl v5_FileTransferShowProgress(int a1, int a2, char a3);
char *__cdecl replace_str(char *Str, char *SubStr, const char *a3);
char *__cdecl create_ini_file(char *Source, int a2, unsigned int a3, const char *a4);
int __cdecl v5_TransferParameterSet(char a1, char a2, char a3, int a4);
int __cdecl v5_GetDir(unsigned __int8 a1);
int v5_GetFdt();
BOOL __cdecl v5_LoadAndRun(unsigned __int8 a1, char *Source, char a3);
BOOL __cdecl v5_LoadAndRunSlot(unsigned __int8 a1, int a2, char a3);
BOOL __cdecl v5_Erase(unsigned __int8 a1, char *Str);
int __cdecl v5_SetRadioChannel(unsigned __int8 a1);
int __cdecl v5_Download(char a1, char *Source, _BYTE *a3, int a4, unsigned __int8 a5, char a6, void (__cdecl *a7)(size_t, int));
int __cdecl v5_Upload(char a1, char *Source, void **a3, int *a4, unsigned __int8 a5, char a6, void (__cdecl *a7)(int, int));
int __cdecl v5_ScreenCapture(char *FileName); // idb
// int __usercall v5_AutorunFlagSet@<eax>(int a1@<eax>, unsigned __int8 a2, char *Source, char a4);
int v5_ReadUserData();
int __cdecl iq2_GetControllerVersions(_DWORD *a1, _DWORD *a2);
int __cdecl iq2_GetControllerLocalPairId(_DWORD *a1);
int __cdecl iq2_GetControllerRemotePairId(_DWORD *a1);
BOOL iq2_ControllerAtmelRadioBootloaderEntry();
BOOL iq2_ControllerAtmelRadioBootloaderExit();
int iq2_ControllerAtmelCdcBootloaderEntry();
int __cdecl iq2_ControllerAtmelStatus(_BYTE *a1, _DWORD *a2);
int __cdecl v5_ControllerVersionsGet(void *); // idb
int __cdecl v5_ControllerVersionsExpectGet(void *); // idb
int __cdecl v5_ControllerEraseFlash(int a1, int a2);
int __cdecl v5_ControllerWriteFlash(int a1, void *Src, int a3, unsigned __int8 a4);
int __cdecl v5_ControllerValidateFlash(int a1, int a2, int a3, int a4, int a5);
int v5_ControllerForceRadioUpdate();
int __cdecl v5_ControllerRadioInfo(void *); // idb
int __cdecl v5_DownloadPythonVm(int a1, char *FileName, char a3, unsigned __int8 a4);
int __cdecl v5_VerboseCommsSet(unsigned __int8 a1);
int v5_VerboseCommsGet();
int __cdecl v5_Cdc2TargetSet(int a1);
int __cdecl v5_Cdc2ExtCmdSet(int a1);
int *__cdecl v5_TypeToString(int a1);
int __cdecl v5_StringToType(char *a1);
unsigned int __cdecl v5_FileNameToType(char *Str);
int __cdecl v5_SendCommand(unsigned __int8 *a1, signed int nNumberOfBytesToWrite, char *a3, int Size);
int __cdecl v5_SimpleMessage(char a1, int a2);
int __cdecl v5_SystemAlive(int a1);
int __cdecl v5_SystemVersion(_DWORD *a1);
int __cdecl v5_ExtendedMessage(char a1, int a2, void *Src, int Size);
// int __usercall v5_FileCtrl@<eax>(int a1@<eax>, char a2, char a3, _DWORD *a4);
// int __usercall v5_FileTransferInitialize@<eax>(int a1@<eax>, void *Src, int a3);
// int __usercall v5_FileExit@<eax>(int a1@<eax>, char a2, _DWORD *a3);
// int __usercall v5_FileDataWrite@<eax>(int a1@<eax>, int a2, void *Src, size_t Size, _DWORD *a5);
// unsigned int __usercall v5_FileDataRead@<eax>(int a1@<eax>, int a2, unsigned __int16 a3, _DWORD *a4, void *a5);
// int __usercall v5_FileSetLinkedFile@<eax>(int a1@<eax>, char a2, char a3, char *Source, _DWORD *a5);
// int __usercall v5_FileGetDirCount@<eax>(int a1@<eax>, char a2, char a3, int a4);
// int __usercall v5_FileGetDirEntry@<eax>(int a1@<eax>, char a2, char a3, void *a4);
// int __usercall v5_FileLoadAndRun@<eax>(int a1@<eax>, char a2, char a3, char *Source, _DWORD *a5);
// int __usercall v5_FileMetadataGet@<eax>(int a1@<eax>, char a2, char a3, char *Source, int a5);
// int __usercall v5_FileMetadataSet@<eax>(int a1@<eax>, char a2, char a3, char *Source, int a5, _DWORD *a6);
// int __usercall v5_FileErase@<eax>(int a1@<eax>, char a2, char a3, char *Source, _DWORD *a5);
// int __usercall v5_SystemStatus@<eax>(int a1@<eax>, int a2);
// int __usercall v5_DeviceStatus@<eax>(int a1@<eax>, char *a2);
// int __usercall v5_BrainStatus@<eax>(int a1@<eax>, int a2);
// int __usercall v5_FdtStatus@<eax>(int a1@<eax>, char *a2);
// int __usercall v5_LogStatus@<eax>(int a1@<eax>, int a2);
// int __usercall v5_LogRead@<eax>(int a1@<eax>, char *a2, int a3, unsigned int a4);
// int __usercall v5_ProgramStatus@<eax>(int a1@<eax>, char a2, char a3, char *Source, int a5);
// int __usercall v5_SystemScreenCapture@<eax>(int a1@<eax>);
// int __usercall v5_ProgramSlotInfo_14@<eax>(int a1@<eax>, void *a2);
// int __usercall v5_ProgramSlotInfo_58@<eax>(int a1@<eax>, void *a2);
// size_t __usercall v5_GetUserData@<eax>(int a1@<eax>, void *Src, int Size, void *a4);
// int __usercall v5_UserProgramControl@<eax>(int a1@<eax>, char a2, char a3, void *a4);
// int __usercall v5_KVLoad@<eax>(int a1@<eax>, char *Str, void *a3, int Size);
// int __usercall v5_KVSave@<eax>(int a1@<eax>, char *Str, char *Source);
// int __usercall v5_FactoryEnable@<eax>(int a1@<eax>);
// int __usercall v5_FactoryResetBrain@<eax>(int a1@<eax>);
// int __usercall v5_FactorySpecial@<eax>(int a1@<eax>, char a2, char a3, char a4, char a5, char a6);
// int __usercall v5_FwUpdateStatus@<eax>(int a1@<eax>, _DWORD *a2);
// int __usercall iq2_CtrlGetPairId@<eax>(int a1@<eax>, void *a2);
// int __usercall iq2_CtrlGetDevState@<eax>(int a1@<eax>, void *a2);
// int __usercall iq2_CtrlGetVersions@<eax>(int a1@<eax>, void *a2);
// int __usercall iq2_CtrlGetInfo@<eax>(int a1@<eax>, void *a2);
// int __usercall v5_CtrlVersionsGet@<eax>(int a1@<eax>, void *a2);
// int __usercall v5_CtrlVersionsExpectGet@<eax>(int a1@<eax>, void *a2);
// int __usercall v5_CtrlEraseFlash@<eax>(int a1@<eax>, char a2, int a3);
// int __usercall v5_CtrlWriteFlash@<eax>(int a1@<eax>, char a2, void *Src, int a4, unsigned __int8 a5);
// int __usercall v5_CtrlValidateFlash@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5, int a6);
// int __usercall v5_CtrlForceRadioUpdate@<eax>(int a1@<eax>);
// int __usercall v5_CtrlRadioInfoGet@<eax>(int a1@<eax>, void *a2);
FILE *__cdecl fmemopenw(void *a1, size_t ElementSize);
_BYTE *__cdecl str_lower(_BYTE *a1);
int __cdecl V5_ZipReadLocalHeader(unsigned __int16 *Buffer, void *a2, signed int Size);
size_t __cdecl nextBufferFile(_DWORD *a1);
int __cdecl V5_ZipReadData(int a1, int a2, int a3);
int __cdecl V5_ZipReadEndRecord(void *); // idb
int __cdecl vexosZipLoad(char *FileName, _DWORD *a2, size_t ElementSize);
int __cdecl vexosZipLoadNamedEntry(char *FileName, _DWORD *a2, size_t ElementSize, char *SubStr);
int __cdecl V5_ZipInflateAlloc(int a1, int a2, int a3);
void V5_ZipInflateFree();
int __cdecl V5_ZipInflateBufferRaw(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int *));
int __cdecl V5_GzipInflateBuffer(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int *));
int __cdecl vexosProcessBootData(char *Src, int *a2, int *a3);
int __cdecl vexosIsXilinxImage(void *Src); // idb
int __cdecl vexosIsIq2Image(int a1);
int __cdecl vexosIsExpImage(int a1);
const char *__cdecl strsep(const char **a1, char *Control);
int __cdecl vexosFilenameToVersion(const void *a1);
int __cdecl vexosCatalogToLatestVersion(int a1);
char *__cdecl vexosVersionToString(int a1);
int __cdecl vexosRead(char *FileName, void **a2, size_t ElementSize);
int __cdecl versionFromManifest(int a1);
int __cdecl v5_firmwareWaitForControllerConnection(unsigned __int8 a1);
int __cdecl v5_firmwareWaitForCompletion(unsigned __int8 a1);
int __cdecl v5_VersionCheck(int a1, int a2);
int __cdecl v5_firmwareUpdate(char *Source, size_t ElementSize, int a3, unsigned __int8 a4, unsigned __int8 a5);
int curl_dylib_init();
int __cdecl curlWriteMemoryCallback(void *Src, int, int, int); // idb
int __cdecl v5_firmwareGetCatalog(const char *a1);
int __cdecl v5_firmwareGetVersion(const char *a1, const char *a2, int a3, void **a4);
int __cdecl writeImage(char *FileName, int, int, int, int, int); // idb
unsigned int Crc32GenerateTable();
unsigned int Crc16GenerateTable();
int Crc32GenerateReverseTable();
int __cdecl Crc32Reflect8(unsigned __int8 a1);
int __cdecl Crc32Reflect32(int a1);
int __cdecl Crc32Generate(_BYTE *a1, unsigned int a2, int a3);
int __cdecl Crc32GenerateReflectedInput(unsigned __int8 *a1, unsigned int a2, int a3);
int __cdecl Crc16Generate(_BYTE *a1, unsigned int a2, unsigned __int16 a3);
int debugRxBuffer();
int __cdecl cc264xSendData(unsigned __int8 *a1, signed int nNumberOfBytesToWrite);
int __cdecl cc2642OptimizeDownloadSize(_DWORD *a1);
int __cdecl cc264xSendBootloadCommand(int a1);
int cc264xBootloadSendAck();
int cc264xBootloadSendNak();
int cc264xBootloadSendHello();
BOOL __cdecl cc264xBootloadValidateChecksum(int a1);
int __cdecl cc264xBootloadClearCommand(int a1);
int __cdecl cc264xSendBootloaderPing(int a1);
int __cdecl cc264xSendBootloaderGetStatus(int a1);
int __cdecl cc264xSendBootloaderGetChipId(int a1);
int __cdecl cc264xSendBootloaderGetChecksum(int a1, int a2, int a3);
int __cdecl cc264xSendBootloaderReadMemory32(int a1, int a2, char a3);
int __cdecl cc264xSendBootloaderEraseBlock(int a1, int a2);
int __cdecl cc264xSendBootloaderDownload(int a1, int a2, int a3);
int __cdecl cc264xSendBootloaderWriteData(int a1, int a2, unsigned __int8 a3);
unsigned int __cdecl cc264xResponseToWordBE(unsigned int *a1);
int __cdecl cc264xResponseToWordLE(unsigned __int8 *a1);
int __cdecl cc264xCrc32Gen(unsigned __int8 *a1, unsigned int a2);
int __cdecl cc264xBootloaderCommsReply(unsigned __int8 a1);
int __cdecl cc264xWaitForReply(int a1, char a2);
BOOL __cdecl cc264xWaitForAck(int a1);
BOOL __cdecl cc264xWaitForResponse(int a1);
int __cdecl cc264xBootloaderGetChipId(_DWORD *a1);
int __cdecl cc264xBootloaderGetMemorySizes(int a1);
int __cdecl cc264xBootloaderGetChecksum(int a1);
int __cdecl cc264xBootloaderEraseFlash(int a1);
int __cdecl cc264xBootloaderWriteFlash(int a1);
int __cdecl cc264xFirmwareUpdateFromBuffer(int a1, unsigned int a2, unsigned __int8 a3);
int __cdecl cc264xFirmwareUpdateFromFile(char *FileName, unsigned __int8 a2);
int __cdecl V5_TarFileSize(int a1);
int __cdecl V5_TarReadNext(const void **a1, char *Destination, size_t Count, const void **a4);
const char *__cdecl getSystemProgramName(unsigned int a1);
const char *__cdecl getErrorString(unsigned int a1);
char *__cdecl getDevTypeString(unsigned int a1);
char *__cdecl getLogTypeString(unsigned int a1);
int __cdecl getLogDisplayType(_BYTE *a1);
char *__cdecl getLogDescription(unsigned __int8 *a1);
char *__cdecl timeToStr(unsigned int a1);
int __cdecl decodeLogEntry(int a1, int a2, char a3, char a4);
BOOL __cdecl read_log(int a1, char a2, unsigned __int8 a3);
_BYTE *__cdecl str_lower_0(_BYTE *a1);
int __cdecl iq2_controller_update(char *FileName, unsigned __int8 a2);
int __cdecl iq2_controller_atmel_update(char *FileName);
int __cdecl iq2_bootloader_update(char *FileName, size_t ElementSize, unsigned __int8 a3);
int __stdcall cJSON_GetErrorPtr();
int __stdcall cJSON_GetStringValue(int a1);
long double __stdcall cJSON_GetNumberValue(int a1);
char *__stdcall cJSON_Version();
int __cdecl case_insensitive_strcmp(_BYTE *a1, unsigned __int8 *a2);
void *__cdecl cJSON_strdup(char *Str, int (__cdecl **a2)(size_t));
void (__cdecl *__stdcall cJSON_InitHooks(int a1))(void *Block);
void *__cdecl cJSON_New_Item(int (__cdecl **a1)(int));
void **__stdcall cJSON_Delete(void **Block);
int get_decimal_point();
int __cdecl parse_number(int a1, _DWORD *a2);
long double __stdcall cJSON_SetNumberHelper(int a1, double a2);
void *__stdcall cJSON_SetValuestring(int a1, char *Str);
int __cdecl ensure(_DWORD *a1, int a2);
void __cdecl update_offset(_DWORD *a1);
BOOL __cdecl compare_double(double a1, double a2);
int __cdecl print_number(int a1, _DWORD *a2);
int __cdecl parse_hex4(int a1);
int __cdecl utf16_literal_to_utf8(int a1, int a2, _DWORD *a3);
int __cdecl parse_string(int a1, int a2);
int __cdecl print_string_ptr(_BYTE *Src, _DWORD *a2);
int __cdecl print_string(int a1, _DWORD *a2);
_DWORD *__cdecl buffer_skip_whitespace(_DWORD *a1);
_DWORD *__cdecl skip_utf8_bom(_DWORD *a1);
void *__stdcall cJSON_ParseWithOpts(char *Str, _DWORD *a2, int a3);
void *__stdcall cJSON_ParseWithLengthOpts(int a1, unsigned int a2, _DWORD *a3, int a4);
void *__stdcall cJSON_Parse(char *Str);
void *__stdcall cJSON_ParseWithLength(int a1, unsigned int a2);
void *__cdecl print(int a1, void *a2, int a3);
void *__stdcall cJSON_Print(int a1);
void *__stdcall cJSON_PrintUnformatted(int a1);
void *__stdcall cJSON_PrintBuffered(int a1, void *Size, void *a3);
int __stdcall cJSON_PrintPreallocated(int a1, int a2, int a3, int a4);
int __cdecl parse_value(int a1, _DWORD *a2);
int __cdecl print_value(int a1, _DWORD *a2);
int __cdecl parse_array(int a1, int a2);
int __cdecl print_array(int a1, _DWORD *a2);
int __cdecl parse_object(int a1, int a2);
int __cdecl print_object(int a1, _DWORD *a2);
int __stdcall cJSON_GetArraySize(int a1);
_DWORD *__cdecl get_array_item(int a1, int a2);
_DWORD *__stdcall cJSON_GetArrayItem(int a1, int a2);
int **__cdecl get_object_item(int a1, char *Str1, int a3);
int **__stdcall cJSON_GetObjectItem(int a1, char *Str1);
int **__stdcall cJSON_GetObjectItemCaseSensitive(int a1, char *Str1);
BOOL __stdcall cJSON_HasObjectItem(int a1, char *Str1);
int __cdecl suffix_object(_DWORD *a1, int a2);
_DWORD *__cdecl create_reference(void *Src, int (__cdecl **a2)(int));
int __cdecl add_item_to_array(_DWORD *a1, _DWORD *a2);
int __stdcall cJSON_AddItemToArray(_DWORD *a1, _DWORD *a2);
int __cdecl cast_away_const(int a1);
int __cdecl add_item_to_object(_DWORD *a1, char *Str, _DWORD *a3, int a4, int a5);
int __stdcall cJSON_AddItemToObject(_DWORD *a1, char *Str, _DWORD *a3);
int __stdcall cJSON_AddItemToObjectCS(_DWORD *a1, char *Str, _DWORD *a3);
int __stdcall cJSON_AddItemReferenceToArray(_DWORD *a1, void *Src);
int __stdcall cJSON_AddItemReferenceToObject(_DWORD *a1, char *Str, void *Src);
void **__stdcall cJSON_AddNullToObject(_DWORD *a1, char *Str);
void **__stdcall cJSON_AddTrueToObject(_DWORD *a1, char *Str);
void **__stdcall cJSON_AddFalseToObject(_DWORD *a1, char *Str);
void **__stdcall cJSON_AddBoolToObject(_DWORD *a1, char *Str, int a3);
double *__stdcall cJSON_AddNumberToObject(_DWORD *a1, char *Str, double a3);
void **__stdcall cJSON_AddStringToObject(_DWORD *a1, char *Str, char *a3);
void **__stdcall cJSON_AddRawToObject(_DWORD *a1, char *Str, char *a3);
void **__stdcall cJSON_AddObjectToObject(_DWORD *a1, char *Str);
void **__stdcall cJSON_AddArrayToObject(_DWORD *a1, char *Str);
_DWORD **__stdcall cJSON_DetachItemViaPointer(int a1, _DWORD **a2);
_DWORD **__stdcall cJSON_DetachItemFromArray(int a1, int a2);
void **__stdcall cJSON_DeleteItemFromArray(int a1, int a2);
_DWORD **__stdcall cJSON_DetachItemFromObject(int a1, char *Str1);
_DWORD **__stdcall cJSON_DetachItemFromObjectCaseSensitive(int a1, char *Str1);
void **__stdcall cJSON_DeleteItemFromObject(int a1, char *Str1);
void **__stdcall cJSON_DeleteItemFromObjectCaseSensitive(int a1, char *Str1);
int __stdcall cJSON_InsertItemInArray(_DWORD *a1, int a2, _DWORD *a3);
int __stdcall cJSON_ReplaceItemViaPointer(int a1, void **Block, void **a3);
int __stdcall cJSON_ReplaceItemInArray(int a1, int a2, void **a3);
int __cdecl replace_item_in_object(int, char *Str, int, int); // idb
int __stdcall cJSON_ReplaceItemInObject(int, char *Str, int); // idb
int __stdcall cJSON_ReplaceItemInObjectCaseSensitive(int, char *Str, int); // idb
_DWORD *__stdcall cJSON_CreateNull();
_DWORD *__stdcall cJSON_CreateTrue();
_DWORD *__stdcall cJSON_CreateFalse();
_DWORD *__stdcall cJSON_CreateBool(int a1);
double *__stdcall cJSON_CreateNumber(double a1);
void **__stdcall cJSON_CreateString(char *Str);
_DWORD *__stdcall cJSON_CreateStringReference(int a1);
_DWORD *__stdcall cJSON_CreateObjectReference(int a1);
_DWORD *__stdcall cJSON_CreateArrayReference(int a1);
void **__stdcall cJSON_CreateRaw(char *Str);
_DWORD *__stdcall cJSON_CreateArray();
_DWORD *__stdcall cJSON_CreateObject();
void **__stdcall cJSON_CreateIntArray(int a1, int a2);
void **__stdcall cJSON_CreateFloatArray(int a1, int a2);
void **__stdcall cJSON_CreateDoubleArray(int a1, int a2);
void **__stdcall cJSON_CreateStringArray(int a1, int a2);
double *__stdcall cJSON_Duplicate(int a1, int a2);
_DWORD *__cdecl skip_oneline_comment(_DWORD *a1);
unsigned __int8 **__cdecl skip_multiline_comment(unsigned __int8 **a1);
_DWORD *__cdecl minify_string(unsigned __int8 **a1, _DWORD *a2);
_BYTE *__stdcall cJSON_Minify(_BYTE *a1);
BOOL __stdcall cJSON_IsInvalid(int a1);
BOOL __stdcall cJSON_IsFalse(int a1);
BOOL __stdcall cJSON_IsTrue(int a1);
BOOL __stdcall cJSON_IsBool(int a1);
BOOL __stdcall cJSON_IsNull(int a1);
BOOL __stdcall cJSON_IsNumber(int a1);
BOOL __stdcall cJSON_IsString(int a1);
BOOL __stdcall cJSON_IsArray(int a1);
BOOL __stdcall cJSON_IsObject(int a1);
BOOL __stdcall cJSON_IsRaw(int a1);
BOOL __stdcall cJSON_Compare(int a1, int a2, int a3);
void *__stdcall cJSON_malloc(size_t Size);
void __stdcall cJSON_free(void *Block);
int __cdecl vsnwprintf_0(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, va_list Args); // idb
int __cdecl vswprintf(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, va_list ArgList);
int swprintf(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, ...);
HMODULE free_library_handles();
int lookup_functions();
_DWORD *new_hid_device();
void __cdecl free_hid_device(HANDLE *Block);
void __cdecl register_winapi_error_to_buffer(void **a1, wchar_t *String);
void __cdecl register_winapi_error(int a1, wchar_t *String);
void __cdecl register_string_error_to_buffer(void **a1, wchar_t *String);
void __cdecl register_string_error(int a1, wchar_t *String);
HANDLE __cdecl open_device(LPCWSTR lpFileName, int a2);
void *hid_version();
const char *hid_version_str();
int hid_init();
int hid_exit();
void *__cdecl hid_internal_get_devnode_property(int a1, int a2, int a3);
void *__cdecl hid_internal_get_device_interface_property(int a1, int a2, int a3);
void *__cdecl hid_internal_get_ble_info(void **a1, int a2);
int __cdecl hid_internal_get_interface_number(wchar_t *Str); // idb
void __cdecl hid_internal_get_info(int a1, int a2);
CHAR *__cdecl hid_internal_UTF16toUTF8(LPCWCH lpWideCharStr);
WCHAR *__cdecl hid_internal_UTF8toUTF16(LPCCH lpMultiByteStr);
_DWORD *__cdecl hid_internal_get_device_info(LPCWCH lpWideCharStr, int a2);
_DWORD *__cdecl hid_enumerate(__int16 a1, __int16 a2);
void *__cdecl hid_free_enumeration(void *a1);
_DWORD *__cdecl hid_open(__int16 a1, __int16 a2, wchar_t *String1);
_DWORD *__cdecl hid_open_path(LPCCH lpMultiByteStr);
DWORD __cdecl hid_write(int a1, void *Src, size_t Size);
size_t __cdecl hid_read_timeout(int a1, void *a2, unsigned int a3, int dwMilliseconds);
size_t __cdecl hid_read(int a1, void *a2, int a3);
int __cdecl hid_set_nonblocking(int a1, int a2);
size_t __cdecl hid_send_feature_report(int a1, void *Src, size_t Size);
DWORD __cdecl hid_get_report(HANDLE *a1, DWORD dwIoControlCode, _BYTE *lpInBuffer, DWORD nInBufferSize);
DWORD __cdecl hid_get_feature_report(HANDLE *a1, _BYTE *lpInBuffer, DWORD nInBufferSize);
DWORD __cdecl hid_get_input_report(HANDLE *a1, _BYTE *lpInBuffer, DWORD nInBufferSize);
void __cdecl hid_close(HANDLE *Block);
int __cdecl hid_get_manufacturer_string(int, wchar_t *Destination, size_t Count); // idb
int __cdecl hid_get_product_string(int, wchar_t *Destination, size_t Count); // idb
int __cdecl hid_get_serial_number_string(int, wchar_t *Destination, size_t Count); // idb
int __cdecl hid_get_indexed_string(_DWORD *a1, int a2, int a3, unsigned int a4);
int __cdecl hid_winapi_get_container_id(int a1, int a2);
const char *__cdecl hid_error(int a1);
int __cdecl exp_dfuGetProperty(char a1);
void __cdecl exp_dfuSendBlock(void *Src, int Size);
int __cdecl exp_dfuDownload(int a1, int a2);
int __cdecl exp_dfuLoadData(int a1, int a2, __int16 a3, __int16 a4);
int __cdecl exp_ram_bootloader(char *FileName, int); // idb
int dfu_dylib_init();
int __cdecl dfu_download(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, int a5);
int __cdecl dfu_getStatus(int a1, unsigned __int16 a2, int a3);
int __cdecl iq2_dfuSendBlock(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4);
int __cdecl iq2_dfuDownload(int a1, int a2, int a3, int a4);
int __cdecl iq2_dfuLoadData(int a1, int a2);
int __cdecl iq2_ram_bootloader(char *FileName, int); // idb
int __cdecl iq2_atmel_update(char *FileName, int); // idb
int __cdecl exp_atmel_update(char *FileName, int); // idb
int __cdecl dfu_check_device(int a1, _DWORD *a2, int a3, int a4, const char *a5, const char *a6);
int __cdecl usb_detect(char a1);
int __cdecl usb_detect_device(int a1, int a2, int a3);
int __cdecl usb_detect_device_iq2_ctrl(char a1);
int __cdecl usb_detect_device_exp_ctrl(char a1);
int __cdecl clock_getres(int a1, _DWORD *a2);
int __cdecl clock_gettime(int a1, _DWORD *a2);
int __cdecl clock_nanosleep(int a1, int a2, int *a3, _DWORD *a4);
int __cdecl clock_settime(int a1, int *a2);
int __cdecl nanosleep(int *a1, _DWORD *a2);
int __stdcall SetThreadName_VEH(_DWORD **a1);
// _DWORD *__usercall enterOnceObject@<eax>(int a1@<eax>);
DWORD pthread_tls_init();
// int __usercall __pthread_get_pointer@<eax>(unsigned int a1@<eax>);
// unsigned int __usercall __pthread_register_pointer@<eax>(int a1@<eax>);
// int __usercall push_pthread_mem_part_2@<eax>(int a1@<eax>);
// int __usercall leaveOnceObject_part_4@<eax>(int a1@<eax>);
int __cdecl _pthread_once_cleanup(int a1);
int pop_pthread_mem();
// int __usercall replace_spin_keys_constprop_10@<eax>(int result@<eax>);
int _pthread_once_raw_part_5_constprop_11();
LPVOID __pthread_self_lite();
int __cdecl __pth_gpointer_locked(unsigned int a1);
// int __usercall _pthread_cleanup_dest_part_8@<eax>(unsigned int a1@<eax>);
int __stdcall __dyn_tls_pthread(int a1, int a2, int a3);
void __stdcall __noreturn pthread_create_wrapper(volatile signed __int32 *a1);
int __cdecl thread_print_set(int a1);
int __cdecl thread_print(unsigned int a1, const char *a2);
int pthread_timechange_handler_np();
int pthread_num_processors_np();
int __cdecl pthread_set_num_processors_np(int a1);
int __cdecl pthread_once(int *a1, void (*a2)(void));
int __cdecl pthread_key_create(int *a1, int a2);
int __cdecl pthread_key_delete(unsigned int a1);
int __cdecl pthread_getspecific(unsigned int a1);
int __cdecl pthread_setspecific(unsigned int a1, int a2);
BOOL __cdecl pthread_equal(int a1, int a2);
int __cdecl _pthread_cleanup_dest(unsigned int a1);
int pthread_self();
int pthread_getevent();
int __cdecl pthread_gethandle(unsigned int a1);
char *pthread_getclean();
int __cdecl pthread_get_concurrency(_DWORD *a1);
int __cdecl pthread_set_concurrency(int a1);
void __cdecl __noreturn pthread_exit(unsigned int ReturnCode); // idb
int __pthread_shallcancel();
volatile signed __int32 *__cdecl _pthread_setnobreak(int a1);
void __noreturn _pthread_invoke_cancel();
// DWORD __usercall test_cancel_locked@<eax>(unsigned int a1@<eax>);
_BYTE *pthread_testcancel();
int __cdecl pthread_delay_np(int *a1);
int __cdecl pthread_delay_np_ms(DWORD); // idb
int __cdecl pthread_cancel(unsigned int a1);
int __cdecl pthread_kill(unsigned int a1, int a2);
int __cdecl _pthread_get_state(_DWORD *a1, int a2);
int __cdecl _pthread_set_state(int *a1, int a2, int a3);
int __cdecl pthread_attr_init(_DWORD *a1);
int __cdecl pthread_attr_destroy(_DWORD *a1);
int __cdecl pthread_attr_setdetachstate(unsigned int *a1, int a2);
int __cdecl pthread_attr_getdetachstate(_DWORD *a1, int *a2);
unsigned int __cdecl pthread_attr_setinheritsched(unsigned int *a1, int a2);
int __cdecl pthread_attr_getinheritsched(_DWORD *a1, int *a2);
int __cdecl pthread_attr_setscope(unsigned int *a1, int a2);
int __cdecl pthread_attr_getscope(_DWORD *a1, int *a2);
int __cdecl pthread_attr_getstackaddr(int a1, _DWORD *a2);
int __cdecl pthread_attr_setstackaddr(int a1, int a2);
int __cdecl pthread_attr_getstacksize(int a1, _DWORD *a2);
int __cdecl pthread_attr_setstacksize(int a1, int a2);
int __cdecl pthread_setcancelstate(int a1, int *a2);
int __cdecl pthread_setcanceltype(int a1, int *a2);
int __cdecl pthread_create(_DWORD *a1, _DWORD *a2, HANDLE *a3, HANDLE *a4);
int __cdecl pthread_join(unsigned int a1, _DWORD *a2);
int __cdecl _pthread_tryjoin(unsigned int a1, _DWORD *a2);
int __cdecl pthread_detach(unsigned int a1);
int pthread_getconcurrency();
int __cdecl pthread_setconcurrency(int a1);
int __cdecl pthread_setname_np(int, char *); // idb
int __cdecl pthread_getname_np(unsigned int a1, _BYTE *a2, signed int a3);
unsigned __int64 _pthread_time_in_ms();
__int64 __cdecl _pthread_time_in_ms_from_timespec(int *a1);
unsigned __int64 __cdecl _pthread_rel_time_in_ms(int *a1);
// _DWORD *__usercall mutex_impl_init@<eax>(volatile signed __int32 *a1@<eax>, signed __int32 a2@<edx>);
int __cdecl pthread_mutex_lock(volatile signed __int32 *a1);
int __cdecl pthread_mutex_timedlock(volatile signed __int32 *a1, int *a2);
int __cdecl pthread_mutex_unlock(volatile signed __int32 *a1);
int __cdecl pthread_mutex_trylock(volatile signed __int32 *a1);
int __cdecl pthread_mutex_init(int *a1, _DWORD *a2);
int __cdecl pthread_mutex_destroy(HANDLE **a1);
int __cdecl pthread_mutexattr_init(_DWORD *a1);
int __cdecl pthread_mutexattr_destroy(int a1);
int __cdecl pthread_mutexattr_gettype(_DWORD *a1, int *a2);
int __cdecl pthread_mutexattr_settype(unsigned int *a1, unsigned int a2);
int __cdecl pthread_mutexattr_getpshared(_DWORD *a1, int *a2);
int __cdecl pthread_mutexattr_setpshared(_DWORD *a1, unsigned int a2);
int __cdecl pthread_mutexattr_getprotocol(_DWORD *a1, int *a2);
int __cdecl pthread_mutexattr_setprotocol(unsigned int *a1, int a2);
int __cdecl pthread_mutexattr_getprioceiling(_DWORD *a1, _DWORD *a2);
int __cdecl pthread_mutexattr_setprioceiling(_DWORD *a1, int a2);
// int __usercall rwl_ref_destroy@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>);
// int __usercall rwl_ref_unlock@<eax>(_DWORD **a1@<eax>);
// int __usercall rwlock_gain_both_locks@<eax>(int a1@<eax>);
// int __usercall rwlock_free_both_locks@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl st_cancelwrite(int a1);
// int __usercall rwl_unref@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl rwl_print_set(int a1);
int __cdecl rwl_print(const void **a1, const char *a2);
int __cdecl pthread_rwlock_init(int **a1);
// int __usercall rwlock_static_init@<eax>(int **a1@<eax>);
// int __usercall rwl_ref_isra_0@<eax>(int **a1@<eax>);
int __cdecl pthread_rwlock_destroy(void **a1);
int __cdecl pthread_rwlock_rdlock(int **a1);
int __cdecl pthread_rwlock_timedrdlock(int **a1, int *a2);
int __cdecl pthread_rwlock_tryrdlock(int **a1);
int __cdecl pthread_rwlock_trywrlock(int **a1);
int __cdecl pthread_rwlock_unlock(_DWORD **a1);
int __cdecl pthread_rwlock_wrlock(int **a1);
int __cdecl pthread_rwlock_timedwrlock(int **a1, int *a2);
int __cdecl pthread_rwlockattr_destroy(int a1);
int __cdecl pthread_rwlockattr_init(_DWORD *a1);
int __cdecl pthread_rwlockattr_getpshared(_DWORD *a1, _DWORD *a2);
int __cdecl pthread_rwlockattr_setpshared(unsigned int *a1, unsigned int a2);
int __cdecl pthread_spin_init(_DWORD *a1);
int pthread_spin_destroy();
int __cdecl pthread_spin_lock(volatile __int32 *a1);
int __cdecl pthread_spin_trylock(volatile __int32 *a1);
int __cdecl pthread_spin_unlock(_DWORD *a1);
// int __usercall do_sema_b_release@<eax>(LPCRITICAL_SECTION lpCriticalSection@<ecx>, LONG lReleaseCount@<edx>, void *a3@<eax>, volatile signed __int32 *a4);
int __cdecl cond_print_set(int a1, FILE *a2);
int __cdecl cond_print(const void **a1, const char *a2);
int __cdecl pthread_condattr_destroy(_DWORD *a1);
int __cdecl pthread_condattr_init(_DWORD *a1);
int __cdecl pthread_condattr_getpshared(_DWORD *a1, _DWORD *a2);
int __cdecl pthread_condattr_getclock(int a1, _DWORD *a2);
int __cdecl pthread_condattr_setclock(int a1, int a2);
int __cdecl __pthread_clock_nanosleep(unsigned int a1, char a2, int *a3, _DWORD *a4);
int __cdecl pthread_condattr_setpshared(_DWORD *a1, unsigned int a2);
int __cdecl pthread_cond_init(_DWORD *a1, _DWORD *a2);
// int __usercall cond_static_init@<eax>(_DWORD *a1@<eax>);
int __cdecl do_sema_b_wait_intern(HANDLE hHandle, int, DWORD); // idb
// int __usercall do_sema_b_wait@<eax>(void *a1@<eax>, int a2@<edx>, DWORD a3@<ecx>, LPCRITICAL_SECTION lpCriticalSection, volatile signed __int32 *a5);
int __cdecl pthread_cond_destroy(int *a1);
int __cdecl pthread_cond_signal(int *a1);
int __cdecl pthread_cond_broadcast(int *a1);
int __cdecl pthread_cond_wait(int *a1, volatile signed __int32 *a2);
int __cdecl cleanup_wait(int *a1);
// int __usercall pthread_cond_timedwait_impl@<eax>(int *a1@<eax>, volatile signed __int32 *a2@<edx>, struct _RTL_CRITICAL_SECTION *a3@<ecx>, int a4);
int __cdecl pthread_cond_timedwait(int *a1, volatile signed __int32 *a2, struct _RTL_CRITICAL_SECTION *a3);
int __cdecl pthread_cond_timedwait_relative_np(int *a1, volatile signed __int32 *a2, struct _RTL_CRITICAL_SECTION *a3);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int __main();
int _setargv();
void __cdecl __security_init_cookie();
void __cdecl __noreturn __report_gsfailure();
int __stdcall __dyn_tls_dtor(int a1, int a2, int a3);
int __stdcall __dyn_tls_init(int a1, int a2, int a3);
int __tlregdtor();
int (__cdecl *__cdecl __mingw_raise_matherr(int a1, int a2, double a3, double a4, double a5))(_DWORD);
void __cdecl __mingw_setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
int __cdecl _matherr(struct _exception *Except);
void __cdecl fpreset();
int __cdecl _decode_pointer(int a1);
int __cdecl _encode_pointer(int a1);
// unsigned int __usercall mark_section_writable@<eax>(unsigned int result@<eax>);
void _pei386_runtime_relocator();
LONG __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void __mingwthr_run_key_dtors_part_0();
int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2);
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1);
int __cdecl __mingw_TLScallback(int a1, int a2);
// BOOL __usercall _ValidateImageBase_part_0@<eax>(int a1@<eax>);
BOOL __cdecl _ValidateImageBase(_WORD *a1);
int __cdecl _FindPESection(int a1, unsigned int a2);
const char *__cdecl _FindPESectionByName(char *Str);
int __cdecl __mingw_GetSectionForAddress(int a1);
int __mingw_GetSectionCount();
int _FindPESectionExec();
int _GetPEImageBase();
BOOL __cdecl _IsNonwritableInCurrentImage(int a1);
int __cdecl __mingw_enum_import_library_names(int a1);
DItype __cdecl __divmoddi4(DItype u, DItype v, DItype *rp);
long double __cdecl __mingw_strtod(unsigned __int8 *a1, unsigned __int8 **a2);
int __cdecl __fpclassify(int a1, int a2);
BOOL __cdecl isnan(double a1);
char *__cdecl mingw_getsp(char a1);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
char *__cdecl basename(char *Source);
// int __usercall permute_args@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
int warnx(char *Format, ...);
// int __usercall parse_long_options@<eax>(int a1@<eax>, _BYTE *a2@<edx>, const char **a3@<ecx>, int *a4, int a5);
// int __usercall getopt_internal@<eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>, const char **a4, int *a5, char a6);
int __cdecl getopt(int a1, int a2, char *a3);
int __cdecl getopt_long(int a1, int a2, char *a3, const char **a4, int *a5);
int __cdecl getopt_long_only(int a1, int a2, char *a3, const char **a4, int *a5);
int *__cdecl __increment_D2A(int *a1);
// int __usercall rvOK@<eax>(double *a1@<eax>, int *a2@<edx>, int *a3@<ecx>, _DWORD *a4, int a5, int a6, _DWORD *a7);
_DWORD *__cdecl __decrement_D2A(int a1);
int *__cdecl __set_ones_D2A(int *a1, int a2);
int __cdecl __strtodg(unsigned __int8 *a1, unsigned __int8 **a2, int *a3, int *a4, int *a5);
int *__cdecl __sum_D2A(int *a1, int *a2);
int __cdecl __gethex_D2A(unsigned __int8 **a1, int *a2, int *a3, int **a4, int a5);
int __cdecl __rshift_D2A(int a1, int a2);
int __cdecl __trailz_D2A(int a1);
int __mingw_hexdig_init_D2A();
int __cdecl __hexnan_D2A(unsigned __int8 **a1, int *a2, int *a3);
// void __usercall dtoa_lock(int a1@<eax>);
void __cdecl dtoa_lock_cleanup(); // idb
int *__cdecl __Balloc_D2A(int a1);
void __cdecl __Bfree_D2A(void *Block);
int *__cdecl __multadd_D2A(int *a1, int a2, int a3);
int *__cdecl __i2b_D2A(int a1);
int *__cdecl __mult_D2A(int a1, int a2);
int __cdecl __pow5mult_D2A(int *a1, int a2);
int *__cdecl __lshift_D2A(int *a1, int a2);
int __cdecl __cmp_D2A(int a1, int a2);
int *__cdecl __diff_D2A(int *a1, int *a2);
long double __cdecl __b2d_D2A(int a1, _DWORD *a2);
int *__cdecl __d2b_D2A(double a1, _DWORD *a2, _DWORD *a3);
int __cdecl __strcp_D2A(__int64 a1);
int *__cdecl __s2b_D2A(int a1, int a2, int a3, int a4, int a5);
long double __cdecl __ratio_D2A(int a1, int a2);
int __cdecl __match_D2A(char **a1, int a2);
unsigned int __cdecl __copybits_D2A(_DWORD *a1, int a2, int a3);
int __cdecl __any_on_D2A(int a1, int a2);
// size_t __cdecl wcstombs(char *Dest, const wchar_t *Source, size_t MaxCount);
// int __cdecl wcstol(const wchar_t *String, wchar_t **EndPtr, int Radix);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// wchar_t *__cdecl wcsncpy(wchar_t *Destination, const wchar_t *Source, size_t Count);
// size_t __cdecl wcslen(const wchar_t *String);
// int __cdecl wcscmp(const wchar_t *String1, const wchar_t *String2);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// wint_t __cdecl towupper(wint_t C);
// __time32_t __cdecl time(__time32_t *const Time);
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strrchr(const char *Str, int Ch);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// char *__cdecl strerror(int ErrorMessage);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl strchr(const char *Str, int Val);
// int sscanf(const char *const Buffer, const char *const Format, ...);
// int sprintf(char *const Buffer, const char *const Format, ...);
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// char *__cdecl setlocale(int Category, const char *Locale);
// void __cdecl rewind(FILE *Stream);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl puts(const char *Buffer);
// int __cdecl putchar(int Character);
// int printf(const char *const Format, ...);
// void __cdecl perror(const char *ErrMsg);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// size_t __cdecl mbstowcs(wchar_t *Dest, const char *Source, size_t MaxCount);
// void *__cdecl malloc(size_t Size);
// struct tm *__cdecl localtime(const __time32_t *const Time);
// struct lconv *__cdecl localeconv();
// char *__cdecl getenv(const char *VarName);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl fputc(int Character, FILE *Stream);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fflush(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// char *__cdecl ctime(const __time32_t *const Time);
// void *__cdecl calloc(size_t Count, size_t Size);
// void __cdecl __noreturn abort();
// char *__cdecl strdup(const char *String);
// int __cdecl setmode(int FileHandle, int Mode);
// int __cdecl _setjmp3(_DWORD, _DWORD); weak
// _onexit_t __cdecl _onexit(_onexit_t Func);
// int __cdecl fileno(FILE *Stream);
// int *__cdecl _errno();
// void __cdecl __setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
// void __cdecl __set_app_type(_crt_app_type Type);
// int *__cdecl __p__fmode();
// char ***__cdecl __p___argv();
// int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
FILE *__cdecl __acrt_iob_func(unsigned int Ix);
_invalid_parameter_handler __cdecl _get_invalid_parameter_handler();
_invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler Handler);
errno_t __cdecl _stub(int *a1, const char *a2, int a3, int a4, int a5);
int __cdecl _int_sopen_s(int *a1, char *FileName, int OpenFlag, int ShareFlag, int a5);
// int _sopen(const char *FileName, int OpenFlag, int ShareFlag, ...);
int __cdecl _tr_align(int a1);
int __cdecl _tr_flush_bits(int a1);
int __cdecl _tr_flush_block(int a1, void *a2, size_t a3, int a4);
int __cdecl _tr_init(int a1);
void *__cdecl _tr_stored_block(int a1, void *Src, size_t Size, unsigned __int16 a4);
BOOL __cdecl _tr_tally(_DWORD *a1, int a2, int a3);
int __cdecl adler32(_DWORD, _DWORD, _DWORD); // weak
int __cdecl adler32_combine(unsigned int a1, unsigned int a2, int a3);
int __cdecl adler32_combine64(unsigned int a1, unsigned int a2, int a3);
unsigned int __cdecl adler32_z(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
// int __usercall build_tree@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall compress_block@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl crc32(int a1, _BYTE *a2, unsigned int a3);
int __cdecl crc32_combine(unsigned int a1, int a2, int a3);
int __cdecl crc32_combine64(unsigned int a1, int a2, int a3);
// int __usercall crc32_combine_@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall crc32_little@<eax>(int result@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>);
int __cdecl crc32_z(int a1, _BYTE *a2, unsigned int a3);
size_t __cdecl deflate(_DWORD *a1, unsigned int a2);
// size_t __usercall deflate_part_3@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
int __cdecl deflateBound(_DWORD *a1, unsigned int a2);
int __cdecl deflateCopy(_DWORD *a1, _DWORD *a2);
int __cdecl deflateEnd(_DWORD *a1);
int __cdecl deflateGetDictionary(_DWORD *a1, void *a2, size_t *a3);
int __cdecl deflateInit2_(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6, _BYTE *a7, int a8);
int __cdecl deflateInit_(_DWORD *a1, unsigned int a2, _BYTE *a3, int a4);
int __cdecl deflateParams(_DWORD *a1, unsigned int a2, unsigned int a3);
int __cdecl deflatePending(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl deflatePrime(_DWORD *a1, int a2, int a3);
int __cdecl deflateReset(_DWORD *a1);
int __cdecl deflateResetKeep(_DWORD *a1);
int __cdecl deflateSetDictionary(int *a1, int a2, unsigned int a3);
int __cdecl deflateSetHeader(_DWORD *a1, int a2);
int __cdecl deflateTune(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl deflate_fast(int a1, int a2);
int __cdecl deflate_slow(int *a1, int a2);
int __cdecl deflate_stored(_DWORD *a1, int a2);
// char *__usercall fill_window@<eax>(int *a1@<eax>);
int *get_crc_table();
int __cdecl inflate(int a1, int a2);
int __cdecl inflateCodesUsed(_DWORD *a1);
int __cdecl inflateCopy(_DWORD *a1, _DWORD *a2);
int __cdecl inflateEnd(_DWORD *a1);
int __cdecl inflateGetDictionary(_DWORD *a1, char *a2, _DWORD *a3);
int __cdecl inflateGetHeader(_DWORD *a1, int a2);
int __cdecl inflateInit2_(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl inflateInit_(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl inflateMark(_DWORD *a1);
int __cdecl inflatePrime(_DWORD *a1, int a2, int a3);
int __cdecl inflateReset(_DWORD *a1);
int __cdecl inflateReset2(_DWORD *a1, int a2);
int __cdecl inflateResetKeep(_DWORD *a1);
int __cdecl inflateSetDictionary(_DWORD *a1, int a2, size_t Size);
int __cdecl inflateSync(_DWORD *a1);
int __cdecl inflateSyncPoint(_DWORD *a1);
int __cdecl inflateUndermine(_DWORD *a1);
int __cdecl inflateValidate(_DWORD *a1, int a2);
int __cdecl inflate_fast(unsigned __int8 **a1, int a2);
int __cdecl inflate_table(int a1, unsigned __int16 *a2, int a3, int *a4, unsigned int *a5, unsigned __int16 *a6);
// unsigned int __usercall longest_match@<eax>(_DWORD *a1@<eax>, unsigned int a2@<edx>);
// int __usercall make_ga_colormap@<eax>(int *a1@<eax>);
// int __usercall png_XYZ_from_xy@<eax>(int *a1@<eax>, int *a2@<edx>);
int png_access_version_number();
int __cdecl png_app_error(int a1);
int __cdecl png_app_warning(int a1);
int __cdecl png_benign_error(int a1);
// unsigned int __usercall png_build_16bit_table@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4);
// int __usercall png_build_8bit_table@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
int __cdecl png_build_gamma_table(void **a1, int a2);
int __cdecl png_calculate_crc(int a1, _BYTE *a2, unsigned int a3);
void *__cdecl png_calloc(int a1, size_t Count);
bool __cdecl png_check_IHDR(int a1, unsigned int a2, int a3, int a4, unsigned int a5, int a6, __int64 a7);
int __cdecl png_check_chunk_length(int a1, unsigned int a2);
unsigned int __cdecl png_check_chunk_name(int a1, unsigned int a2);
int __cdecl png_chunk_benign_error(int a1);
int __cdecl png_chunk_report(int a1, int a2, int a3);
// int __usercall png_colormap_compose@<eax>(int ***a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5, int a6);
// BOOL __usercall png_colorspace_endpoints_match@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
int __cdecl png_colorspace_set_chromaticities(int a1, int a2, int *a3, int a4);
int __cdecl png_colorspace_set_endpoints(int a1, int a2, int *a3, int a4);
int __cdecl png_colorspace_set_gamma(int a1, int a2, int a3);
void __cdecl png_colorspace_set_rgb_coefficients(int a1);
int __cdecl png_colorspace_set_sRGB(int a1, int a2, unsigned int a3);
void __cdecl png_colorspace_sync(int a1, int a2);
int __cdecl png_colorspace_sync_info(int a1, int a2);
char __cdecl png_combine_row(int a1, char *a2, int a3);
int __cdecl png_compress_IDAT(_DWORD *Block, int a2, int a3, int a4);
BOOL __cdecl png_crc_error(int a1);
int __cdecl png_crc_finish(int a1, unsigned int a2);
// int __usercall png_crc_finish_constprop_7@<eax>(int a1@<eax>);
int __cdecl png_crc_read(int a1, _BYTE *a2, unsigned int a3);
// int __usercall png_create_colormap_entry@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4, unsigned int a5, unsigned int a6, int a7);
// int __usercall png_create_colormap_entry_constprop_5@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4, unsigned int a5, int a6);
_DWORD *__cdecl png_create_info_struct(size_t Size);
size_t *__cdecl png_create_png_struct(char *a1, int a2, int a3);
size_t *__cdecl png_create_read_struct(char *a1, int a2, int a3);
size_t *__cdecl png_create_write_struct(char *a1, int a2, int a3);
int __cdecl png_data_freer(int a1, int a2, int a3, int a4);
void __cdecl png_default_read_data(int a1, void *Buffer, size_t ElementCount);
void __cdecl png_default_write_data(int a1, void *Buffer, size_t ElementCount);
void __cdecl png_destroy_gamma_table(void **Block);
void __cdecl png_destroy_info_struct(void *Block, void ***a2);
_DWORD *__cdecl png_destroy_png_struct(_DWORD *Block);
void ***__cdecl png_destroy_read_struct(int *a1, void ***a2, void ***a3);
void ***__cdecl png_destroy_write_struct(int *a1, void ***a2);
char *__cdecl png_do_bgr(int *a1, char *a2);
// int __usercall png_do_gray_to_rgb@<eax>(int *a1@<eax>, int a2@<edx>);
void __cdecl png_do_read_interlace(int *a1, int a2, int a3);
int __cdecl png_do_read_transformations(int a1, int a2);
unsigned int __cdecl png_do_strip_channel(int a1, _BYTE *a2, int a3);
int __cdecl png_do_swap(int a1, int a2);
void __cdecl __noreturn png_err(int a1);
// unsigned int __usercall png_exp@<eax>(int a1@<eax>);
void __cdecl png_free(void *Block, void *a2);
_DWORD *__cdecl png_free_buffer_list(void *Block, _DWORD **a2);
void __cdecl png_free_data(void *Block, int a2, int a3, int a4);
_DWORD *__cdecl png_free_jmpbuf(_DWORD *Block);
unsigned int __cdecl png_gamma_16bit_correct(unsigned int a1, int a2);
unsigned int __cdecl png_gamma_8bit_correct(unsigned int a1, int a2);
unsigned int __cdecl png_gamma_correct(int a1, unsigned int a2, int a3);
BOOL __cdecl png_gamma_significant(int a1);
int __cdecl png_get_IHDR(int a1, int a2, _DWORD *a3, int *a4, int *a5, unsigned int *a6, int *a7, unsigned int *a8, unsigned int *a9);
int __cdecl png_get_PLTE(int a1, int a2, _DWORD *a3, _DWORD *a4);
int __cdecl png_get_bKGD(int a1, int a2, _DWORD *a3);
int __cdecl png_get_cHRM_XYZ_fixed(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, _DWORD *a11);
int __cdecl png_get_cHRM_fixed(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10);
int __cdecl png_get_channels(int a1, int a2);
int __cdecl png_get_compression_buffer_size(int a1);
const char *png_get_copyright();
int __cdecl png_get_error_ptr(int a1);
int __cdecl png_get_gAMA_fixed(int a1, int a2, _DWORD *a3);
const char *png_get_header_ver();
const char *png_get_header_version();
int __cdecl png_get_io_ptr(int a1);
const char *png_get_libpng_ver();
int __cdecl png_get_rgb_to_gray_status(int a1);
int __cdecl png_get_rowbytes(int a1, int a2);
int __cdecl png_get_sBIT(int a1, int a2, _DWORD *a3);
int __cdecl png_get_sRGB(int a1, int a2, _DWORD *a3);
int __cdecl png_get_signature(int a1, int a2);
int __cdecl png_get_tRNS(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __cdecl png_get_uint_31(int a1, unsigned __int8 *a2);
int __cdecl png_get_valid(int a1, int a2, int a3);
int __cdecl png_handle_IEND(int a1, int a2, unsigned int a3);
void __cdecl png_handle_IHDR(int a1, int a2, int a3);
void __cdecl png_handle_PLTE(_DWORD *a1, int a2, unsigned int a3);
int __cdecl png_handle_bKGD(int a1, int a2, unsigned int a3);
void __cdecl png_handle_cHRM(int a1, int a2, unsigned int a3);
void __cdecl png_handle_gAMA(int a1, int a2, unsigned int a3);
int __cdecl png_handle_sBIT(int a1, int a2, unsigned int a3);
void __cdecl png_handle_sRGB(int a1, int a2, unsigned int a3);
void __cdecl png_handle_tRNS(_DWORD *a1, int a2, unsigned int a3);
int __cdecl png_handle_unknown(int a1, int a2, unsigned int a3);
// int __usercall png_icc_profile_error_constprop_9@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, char *a4);
int __cdecl png_image_begin_read_from_file(int *a1, char *FileName);
int __cdecl png_image_begin_read_from_memory(int *a1, int a2, int a3);
int __cdecl png_image_begin_read_from_stdio(int *a1, int a2);
int __cdecl png_image_error(int *a1, char *a2);
int __cdecl png_image_finish_read(int *a1, int a2, int a3, int a4, int a5);
void __cdecl png_image_free(int a1);
int __cdecl png_image_free_function(int **a1);
void *__cdecl png_image_memory_read(_DWORD *a1, void *a2, size_t Size);
int __cdecl png_image_read_and_map(int a1);
int __cdecl png_image_read_background(int a1);
int __cdecl png_image_read_colormap(int *a1);
int __cdecl png_image_read_colormapped(int a1);
int __cdecl png_image_read_composite(int a1);
int __cdecl png_image_read_direct(int a1);
int __cdecl png_image_read_header(int a1);
// int __usercall png_image_read_init_part_4@<eax>(int *a1@<eax>);
_DWORD *__cdecl png_info_init_3(_DWORD **a1, unsigned int a2);
int __cdecl png_init_io(int a1, int a2);
char __cdecl png_init_read_transformations(_DWORD *a1);
void __cdecl __noreturn png_longjmp(int a1, int a2);
void *__cdecl png_malloc(int a1, size_t Size);
void *__cdecl png_malloc_base(size_t Size, size_t a2);
void *__cdecl png_malloc_warn(size_t Size, size_t a2);
int __cdecl png_muldiv(int *a1, int a2, int a3, int a4);
// int __usercall png_muldiv_part_3@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
int __cdecl png_muldiv_warn(int a1, int a2, int a3, int a4);
int __cdecl png_read_IDAT_data(size_t, int, int); // idb
int __cdecl png_read_chunk_header(int a1);
int __cdecl png_read_data(int a1);
void __cdecl png_read_end(int a1, int a2);
int __cdecl png_read_filter_row(int a1, int a2, int a3, int a4, int a5);
_BYTE *__cdecl png_read_filter_row_avg(int a1, _BYTE *a2, unsigned __int8 *a3);
int __cdecl png_read_filter_row_paeth_1byte_pixel(int a1, _BYTE *a2, unsigned __int8 *a3);
char __cdecl png_read_filter_row_paeth_multibyte_pixel(int a1, unsigned int a2, unsigned int a3);
unsigned int __cdecl png_read_filter_row_sub(int a1, unsigned int a2);
unsigned int __cdecl png_read_filter_row_up(unsigned int a1, unsigned int a2, unsigned int a3);
void __cdecl png_read_finish_IDAT(_DWORD *a1);
unsigned int __cdecl png_read_finish_row(size_t a1);
void __cdecl png_read_image(size_t a1, int a2);
int __cdecl png_read_info(_DWORD *a1, int a2);
int __cdecl png_read_info_part_2(_DWORD *a1, int a2);
void __cdecl png_read_row(size_t a1, char *a2, char *a3);
void __cdecl png_read_row_constprop_6(size_t a1, char *a2);
void __cdecl png_read_rows(size_t a1, int a2, int a3, int a4);
int __cdecl png_read_sig(int a1, int a2);
int __cdecl png_read_start_row(unsigned __int8 *Block);
unsigned int __cdecl png_read_transform_info(int a1, int *a2);
int __cdecl png_read_update_info(unsigned __int8 *a1, int *a2);
int __cdecl png_reciprocal(int a1);
// int __usercall png_reciprocal_part_4@<eax>(int a1@<eax>);
int __cdecl png_reciprocal2(int a1, int a2);
int __cdecl png_reset_crc(int a1);
int __cdecl png_reset_zstream(int a1);
void __cdecl __noreturn png_safe_error(int a1, char *a2);
int __cdecl png_safe_execute(int a1, int (__cdecl *a2)(int), int a3);
unsigned int __cdecl png_safecat(int a1, unsigned int a2, unsigned int a3, char *a4);
// unsigned int __usercall png_safecat_part_0@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, char *a4);
__int16 __cdecl png_save_uint_16(_WORD *a1, __int16 a2);
unsigned __int32 __cdecl png_save_uint_32(unsigned __int32 *a1, unsigned int a2);
void __cdecl png_set_IHDR(int a1, int a2, unsigned int a3, int a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, unsigned __int8 a9);
void __cdecl png_set_PLTE(void *a1, int a2, void *Src, int a4);
void __cdecl png_set_add_alpha(int a1, __int16 a2, int a3);
void __cdecl png_set_alpha_mode_fixed(int a1, int a2, int a3);
int __cdecl png_set_bKGD(int a1, int a2, int *a3);
int __cdecl png_set_background_fixed(int a1, int a2, int a3, int a4, int a5);
unsigned int __cdecl png_set_benign_errors(int a1, int a2);
int __cdecl png_set_bgr(int a1);
void __cdecl png_set_cHRM_XYZ_fixed(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
void __cdecl png_set_cHRM_fixed(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
_DWORD *__cdecl png_set_compression_buffer_size(int a1, int a2);
int __cdecl png_set_crc_action(int a1, int a2, int a3);
int __cdecl png_set_error_fn(int a1, int a2, int a3);
int __cdecl png_set_expand(int a1);
int __cdecl png_set_expand_16(int a1);
int __cdecl png_set_expand_gray_1_2_4_to_8(int a1);
int __cdecl png_set_filler(int a1, __int16 a2, int a3);
int __cdecl png_set_filter(int a1, int a2, char a3);
int __cdecl png_set_gAMA_fixed(int a1, int a2, int a3);
int __cdecl png_set_gamma_fixed(int a1, int a2, int a3);
int __cdecl png_set_gray_to_rgb(int a1);
int __cdecl png_set_interlace_handling(int a1);
int __cdecl png_set_invalid(int a1, int a2, int a3);
_DWORD *__cdecl png_set_longjmp_fn(_DWORD *Size, int a2, size_t a3);
int __cdecl png_set_option(int a1, unsigned int a2, int a3);
int __cdecl png_set_packing(int a1);
int __cdecl png_set_palette_to_rgb(int a1);
_DWORD *__cdecl png_set_read_fn(_DWORD *a1, int a2, void (__cdecl *a3)(int a1, void *Buffer, size_t ElementCount));
int __cdecl png_set_read_status_fn(int a1, int a2);
void __cdecl png_set_rgb_to_gray_fixed(int a1, int a2, int a3, int a4);
int __cdecl png_set_sBIT(int a1, int a2, int *a3);
int __cdecl png_set_sRGB(int a1, int a2, unsigned int a3);
int __cdecl png_set_sRGB_gAMA_and_cHRM(int a1, int a2, unsigned int a3);
int __cdecl png_set_scale_16(int a1);
int __cdecl png_set_sig_bytes(int a1, int a2);
int __cdecl png_set_strip_16(int a1);
int __cdecl png_set_strip_alpha(int a1);
int __cdecl png_set_swap(int a1);
int __cdecl png_set_swap_alpha(int a1);
void __cdecl png_set_tRNS(void *a1, int a2, void *Src, size_t Size, int a5);
int __cdecl png_set_tRNS_to_alpha(int a1);
_DWORD *__cdecl png_set_write_fn(_DWORD *a1, int a2, void (__cdecl *a3)(int a1, void *Buffer, size_t ElementCount));
int __cdecl png_set_write_status_fn(int a1, int a2);
int __cdecl png_sig_cmp(int a1, unsigned int a2, unsigned int a3);
unsigned __int8 *__cdecl png_start_read_image(unsigned __int8 *Block);
int __cdecl png_user_version_check(int a1, char *a2);
int __cdecl png_write_IEND(int a1);
int __cdecl png_write_IHDR(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl png_write_PLTE(int a1, char *a2, unsigned int a3);
int __cdecl png_write_chunk(int a1, int *a2, _BYTE *a3, signed int a4);
int __cdecl png_write_chunk_data(int a1, _BYTE *a2, unsigned int a3);
int __cdecl png_write_chunk_end(int a1);
int __cdecl png_write_chunk_start(int a1, unsigned int *a2);
// int __usercall png_write_complete_chunk@<eax>(int result@<eax>, unsigned int a2@<edx>, _BYTE *a3@<ecx>, signed int a4);
int __cdecl png_write_data(int a1);
void __cdecl png_write_end(int a1);
unsigned int __cdecl png_write_find_filter(_DWORD *a1, int a2);
unsigned int __cdecl png_write_finish_row(_DWORD *a1);
void __cdecl png_write_image(_BYTE *a1, int a2);
int __cdecl png_write_info(int a1, int a2);
int __cdecl png_write_info_before_PLTE(int a1, int a2);
void __cdecl png_write_row(_BYTE *a1, void *Src);
void __cdecl png_write_rows(_BYTE *a1, int a2, int a3);
int __cdecl png_write_sig(int a1);
int __cdecl png_write_start_row(int a1);
// BOOL __usercall png_xy_from_XYZ@<eax>(int *a1@<eax>, int *a2@<edx>);
void *__cdecl png_zalloc(int a1, size_t a2, unsigned int a3);
int __cdecl png_zfree(_DWORD, _DWORD); // weak
int __cdecl png_zlib_inflate(int a1, int a2);
int __cdecl png_zstream_error(int a1, int a2);
// int __usercall pqdownheap_constprop_1@<eax>(int result@<eax>, int a2@<edx>);
// _WORD *__usercall scan_tree@<eax>(_WORD *result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall send_tree@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall updatewindow@<eax>(size_t Size@<ecx>, int a2@<eax>, size_t a3@<edx>);
char *__cdecl zError(int a1);
void *__cdecl zcalloc(size_t Size, int a2, int a3);
void __cdecl zcfree(void *Block, void *a2);
int zlibCompileFlags();
const char *zlibVersion();
void __cdecl __noreturn png_safe_error_cold_2();
void __noreturn __report_error(char *Format, ...);
FILE *__cdecl ___acrt_iob_func(unsigned int Ix);
// int __stdcall _IAT_start__(_DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

func_ptr __CTOR_LIST__[] = { (func_ptr)0xFFFFFFFF }; // idb
int (__cdecl *deregister_frame_fn)(_DWORD) = NULL; // weak
_BYTE _medic_0_e[10400] =
{
  -48,
  100,
  89,
  33,
  99,
  -18,
  -75,
  99,
  73,
  -64,
  -16,
  -125,
  55,
  -10,
  -123,
  -51,
  -33,
  -12,
  -94,
  -44,
  -47,
  74,
  108,
  -87,
  12,
  -93,
  -63,
  -2,
  -125,
  -4,
  78,
  -93,
  51,
  -61,
  75,
  -87,
  119,
  -88,
  81,
  117,
  70,
  -126,
  -111,
  -117,
  -77,
  -53,
  -17,
  14,
  25,
  59,
  83,
  -18,
  -107,
  -6,
  65,
  -64,
  66,
  -106,
  39,
  -94,
  -104,
  104,
  21,
  84,
  74,
  91,
  -76,
  -102,
  126,
  -95,
  123,
  -122,
  -118,
  119,
  -105,
  -65,
  -105,
  -60,
  -126,
  128,
  -95,
  -10,
  110,
  -59,
  -102,
  6,
  -85,
  18,
  10,
  -105,
  -76,
  -99,
  1,
  -94,
  -81,
  115,
  -77,
  -41,
  0,
  -9,
  73,
  110,
  -31,
  -65,
  -110,
  -102,
  -82,
  -4,
  -11,
  126,
  128,
  -36,
  122,
  50,
  62,
  24,
  88,
  -37,
  -105,
  19,
  14,
  -79,
  -26,
  -89,
  61,
  64,
  -115,
  92,
  91,
  90,
  -61,
  -113,
  54,
  88,
  81,
  -84,
  88,
  13,
  -82,
  28,
  -85,
  56,
  28,
  -51,
  -105,
  57,
  -36,
  78,
  17,
  -69,
  120,
  -103,
  109,
  -1,
  84,
  -67,
  123,
  29,
  106,
  78,
  3,
  38,
  -124,
  78,
  37,
  -47,
  0,
  -73,
  -112,
  52,
  83,
  -68,
  91,
  -29,
  -83,
  24,
  20,
  -116,
  -101,
  -81,
  -91,
  57,
  104,
  40,
  -42,
  -83,
  -125,
  6,
  -72,
  103,
  -18,
  127,
  -121,
  -16,
  -81,
  -74,
  99,
  7,
  120,
  -50,
  -31,
  56,
  -79,
  102,
  97,
  -74,
  39,
  -22,
  -44,
  30,
  -119,
  23,
  -80,
  59,
  -16,
  -2,
  -97,
  -37,
  110,
  -41,
  0,
  -123,
  46,
  91,
  -57,
  -73,
  -33,
  53,
  -88,
  11,
  117,
  22,
  -120,
  -21,
  -72,
  -37,
  47,
  103,
  13,
  -83,
  58,
  -72,
  39,
  81,
  -41,
  116,
  -26,
  44,
  -86,
  -25,
  61,
  89,
  56,
  77,
  -16,
  -53,
  -59,
  110,
  5,
  124,
  -11,
  86,
  67,
  -21,
  -44,
  101,
  -38,
  61,
  54,
  122,
  -69,
  -59,
  17,
  -67,
  -112,
  -53,
  110,
  13,
  -22,
  63,
  -80,
  -120,
  2,
  -49,
  -28,
  72,
  74,
  -65,
  56,
  -41,
  26,
  -97,
  -117,
  -34,
  -3,
  -3,
  -2,
  72,
  10,
  -9,
  26,
  -37,
  15,
  -45,
  3,
  104,
  -70,
  -18,
  -102,
  92,
  5,
  22,
  -55,
  60,
  -75,
  10,
  63,
  -28,
  74,
  -78,
  -61,
  -82,
  -44,
  -53,
  -25,
  115,
  62,
  106,
  -124,
  47,
  124,
  26,
  36,
  -74,
  93,
  -19,
  -96,
  70,
  -48,
  110,
  -16,
  -19,
  82,
  59,
  35,
  -92,
  114,
  -52,
  80,
  -26,
  2,
  106,
  -102,
  -65,
  94,
  -34,
  -27,
  -120,
  -101,
  -65,
  53,
  76,
  63,
  1,
  5,
  11,
  -104,
  -30,
  -31,
  4,
  53,
  -124,
  -38,
  -27,
  125,
  7,
  5,
  -80,
  100,
  -9,
  3,
  103,
  126,
  35,
  -104,
  118,
  -68,
  34,
  -33,
  19,
  7,
  -19,
  92,
  -27,
  -47,
  98,
  -59,
  -70,
  -79,
  116,
  22,
  -100,
  108,
  -61,
  -11,
  12,
  29,
  90,
  -50,
  -28,
  -43,
  24,
  127,
  -107,
  114,
  46,
  103,
  -98,
  84,
  65,
  -81,
  113,
  64,
  -47,
  -23,
  88,
  -92,
  51,
  -48,
  11,
  29,
  6,
  -103,
  -101,
  -37,
  -23,
  83,
  -17,
  -52,
  -20,
  -127,
  55,
  36,
  -60,
  -34,
  99,
  -3,
  127,
  87,
  99,
  -112,
  -84,
  -78,
  85,
  -52,
  94,
  36,
  -63,
  -122,
  27,
  -7,
  71,
  14,
  70,
  -88,
  84,
  -5,
  14,
  7,
  6,
  -110,
  121,
  -71,
  -82,
  34,
  -88,
  6,
  120,
  -62,
  36,
  38,
  59,
  -114,
  64,
  -28,
  -69,
  118,
  -66,
  -122,
  103,
  7,
  75,
  61,
  -108,
  86,
  -21,
  -62,
  -83,
  64,
  10,
  59,
  4,
  -14,
  -13,
  39,
  -102,
  -78,
  -80,
  2,
  -18,
  -95,
  115,
  79,
  75,
  94,
  -6,
  62,
  -72,
  -23,
  -49,
  81,
  -55,
  -83,
  -18,
  -56,
  -43,
  38,
  -118,
  100,
  -119,
  -105,
  -47,
  29,
  -95,
  -23,
  18,
  -94,
  -16,
  31,
  -76,
  72,
  -23,
  -115,
  -94,
  72,
  60,
  -8,
  -23,
  97,
  -38,
  55,
  -115,
  -74,
  -74,
  41,
  -2,
  -75,
  -86,
  -24,
  72,
  67,
  -107,
  73,
  3,
  -110,
  111,
  -63,
  -18,
  79,
  -125,
  97,
  -38,
  -7,
  36,
  -126,
  117,
  4,
  48,
  -11,
  -70,
  -84,
  20,
  -103,
  -113,
  -89,
  -91,
  7,
  108,
  56,
  107,
  -42,
  -82,
  -121,
  122,
  27,
  30,
  -68,
  31,
  28,
  -113,
  77,
  106,
  93,
  119,
  31,
  -68,
  118,
  -34,
  57,
  113,
  -49,
  87,
  -78,
  1,
  -31,
  70,
  16,
  107,
  -70,
  45,
  -31,
  -109,
  36,
  119,
  -101,
  103,
  -15,
  -49,
  59,
  -36,
  18,
  -2,
  95,
  -18,
  -35,
  -28,
  -69,
  -86,
  41,
  -21,
  -85,
  65,
  11,
  -73,
  40,
  30,
  46,
  -81,
  -58,
  -121,
  -126,
  78,
  128,
  0,
  -2,
  -38,
  95,
  -3,
  127,
  116,
  -101,
  -117,
  -61,
  -84,
  86,
  -62,
  -121,
  -53,
  -85,
  -111,
  -18,
  40,
  -47,
  68,
  -113,
  120,
  -106,
  -111,
  26,
  46,
  99,
  -68,
  68,
  -56,
  120,
  23,
  61,
  -19,
  106,
  117,
  116,
  54,
  -6,
  45,
  79,
  -7,
  57,
  39,
  56,
  122,
  -57,
  -115,
  -20,
  54,
  -62,
  -16,
  37,
  -4,
  11,
  -87,
  54,
  -60,
  -85,
  -66,
  -18,
  109,
  -32,
  -75,
  15,
  -127,
  115,
  -16,
  -43,
  6,
  -8,
  99,
  -9,
  74,
  -75,
  104,
  126,
  -110,
  -47,
  -59,
  18,
  44,
  108,
  -6,
  20,
  -23,
  74,
  -17,
  -101,
  -99,
  -12,
  36,
  3,
  -112,
  -101,
  -42,
  -24,
  73,
  43,
  19,
  113,
  -4,
  81,
  -69,
  -121,
  31,
  -16,
  -23,
  11,
  121,
  70,
  102,
  -60,
  -24,
  -9,
  -21,
  -32,
  -98,
  -121,
  33,
  -91,
  92,
  28,
  -93,
  104,
  54,
  -115,
  28,
  19,
  52,
  105,
  2,
  -70,
  82,
  -95,
  38,
  85,
  -68,
  -80,
  4,
  98,
  -18,
  13,
  82,
  -36,
  -113,
  69,
  -57,
  36,
  -121,
  30,
  124,
  -109,
  -46,
  49,
  66,
  96,
  -33,
  96,
  -62,
  8,
  92,
  -96,
  97,
  110,
  17,
  -40,
  -36,
  -24,
  -49,
  5,
  -82,
  -124,
  96,
  20,
  62,
  1,
  83,
  -65,
  12,
  -108,
  -102,
  -116,
  -78,
  -54,
  126,
  -18,
  -15,
  81,
  -11,
  74,
  11,
  112,
  97,
  96,
  -12,
  51,
  124,
  -112,
  -92,
  -56,
  88,
  -47,
  28,
  -28,
  -34,
  -80,
  5,
  34,
  55,
  121,
  -48,
  -96,
  94,
  117,
  -93,
  -23,
  -96,
  111,
  70,
  47,
  -88,
  -98,
  -25,
  69,
  -36,
  111,
  79,
  -21,
  -102,
  -22,
  39,
  -61,
  -84,
  -22,
  25,
  -103,
  -24,
  -104,
  78,
  -127,
  -66,
  -56,
  113,
  -118,
  -65,
  -23,
  70,
  -104,
  -122,
  119,
  57,
  104,
  12,
  -123,
  38,
  94,
  22,
  -73,
  -104,
  124,
  -2,
  -91,
  122,
  -14,
  9,
  -95,
  111,
  123,
  -30,
  41,
  -39,
  -14,
  -119,
  127,
  -64,
  -5,
  -119,
  19,
  54,
  -88,
  -55,
  47,
  -116,
  -50,
  -11,
  13,
  117,
  125,
  105,
  -101,
  -45,
  29,
  30,
  -63,
  -11,
  -87,
  -96,
  -109,
  69,
  11,
  47,
  -49,
  54,
  0,
  31,
  -74,
  -47,
  6,
  -113,
  19,
  -119,
  -22,
  47,
  -107,
  41,
  20,
  -26,
  -80,
  -126,
  53,
  -96,
  76,
  -125,
  -75,
  -22,
  67,
  49,
  -15,
  -124,
  -105,
  -125,
  -91,
  111,
  124,
  -72,
  36,
  43,
  23,
  8,
  112,
  -45,
  -70,
  -23,
  122,
  95,
  110,
  109,
  118,
  16,
  44,
  -114,
  32,
  60,
  128,
  28,
  19,
  -54,
  -50,
  32,
  -91,
  -7,
  -57,
  -7,
  -9,
  120,
  -85,
  65,
  -5,
  -65,
  59,
  51,
  -48,
  -90,
  -100,
  20,
  27,
  -32,
  120,
  81,
  103,
  -65,
  7,
  21,
  -70,
  54,
  6,
  29,
  103,
  49,
  -72,
  51,
  119,
  9,
  -78,
  14,
  -121,
  -50,
  -8,
  58,
  -66,
  110,
  92,
  -65,
  27,
  -3,
  -121,
  54,
  77,
  -50,
  -13,
  -41,
  -106,
  -118,
  -48,
  121,
  -74,
  -5,
  -22,
  54,
  79,
  -83,
  26,
  -40,
  86,
  90,
  -23,
  -79,
  -17,
  90,
  93,
  37,
  13,
  -52,
  16,
  109,
  -48,
  67,
  -90,
  55,
  60,
  -112,
  -32,
  101,
  17,
  -95,
  10,
  74,
  -83,
  12,
  113,
  125,
  59,
  90,
  120,
  76,
  -5,
  55,
  4,
  -39,
  -56,
  91,
  100,
  -13,
  -24,
  -14,
  111,
  -18,
  49,
  122,
  33,
  17,
  100,
  13,
  102,
  44,
  -14,
  103,
  112,
  -54,
  94,
  -73,
  127,
  44,
  -22,
  68,
  -37,
  6,
  85,
  -23,
  -66,
  -108,
  -78,
  -6,
  47,
  -68,
  57,
  61,
  -78,
  -31,
  -37,
  -96,
  16,
  -8,
  82,
  -103,
  16,
  24,
  95,
  58,
  -42,
  95,
  -47,
  -49,
  -103,
  37,
  64,
  -73,
  82,
  6,
  -43,
  69,
  -30,
  53,
  61,
  23,
  98,
  13,
  50,
  -28,
  91,
  -107,
  -70,
  103,
  76,
  20,
  -105,
  65,
  128,
  64,
  123,
  -75,
  -41,
  86,
  -9,
  -111,
  -124,
  -118,
  -25,
  -20,
  1,
  60,
  66,
  -59,
  -4,
  84,
  41,
  -37,
  50,
  -124,
  -47,
  69,
  23,
  3,
  -112,
  13,
  13,
  123,
  107,
  -100,
  -31,
  112,
  -120,
  -101,
  124,
  -72,
  86,
  -55,
  92,
  95,
  3,
  18,
  49,
  36,
  11,
  -93,
  -81,
  -66,
  -106,
  -96,
  62,
  -9,
  -87,
  -122,
  -17,
  128,
  118,
  21,
  30,
  57,
  25,
  -57,
  -116,
  37,
  -118,
  -122,
  98,
  -53,
  64,
  15,
  -61,
  -40,
  104,
  5,
  92,
  84,
  68,
  -3,
  -20,
  81,
  -62,
  13,
  -117,
  83,
  -113,
  -22,
  73,
  -9,
  -98,
  3,
  -3,
  83,
  64,
  99,
  28,
  -48,
  84,
  116,
  -81,
  103,
  123,
  108,
  -105,
  128,
  72,
  65,
  -97,
  62,
  7,
  53,
  78,
  112,
  58,
  -57,
  34,
  39,
  -122,
  -121,
  16,
  -65,
  63,
  -105,
  -53,
  21,
  -62,
  59,
  -71,
  -30,
  -68,
  -76,
  -68,
  -103,
  120,
  -103,
  11,
  -104,
  112,
  -92,
  55,
  5,
  -64,
  -125,
  -90,
  91,
  7,
  -40,
  33,
  115,
  54,
  -87,
  111,
  -112,
  21,
  93,
  -70,
  -27,
  90,
  -7,
  32,
  26,
  -91,
  -2,
  68,
  -29,
  28,
  -12,
  66,
  -27,
  -125,
  -110,
  -71,
  28,
  -56,
  88,
  -70,
  -83,
  61,
  -20,
  127,
  -56,
  106,
  -95,
  127,
  -48,
  -116,
  -55,
  84,
  -98,
  -48,
  49,
  -102,
  -119,
  107,
  -71,
  -87,
  123,
  77,
  -116,
  22,
  -8,
  103,
  -26,
  112,
  39,
  90,
  -39,
  40,
  124,
  -80,
  123,
  -62,
  -69,
  -102,
  -33,
  -106,
  39,
  -4,
  40,
  83,
  57,
  121,
  81,
  30,
  76,
  75,
  -25,
  83,
  -59,
  114,
  -37,
  -119,
  55,
  -2,
  7,
  123,
  -77,
  31,
  -83,
  -42,
  34,
  -42,
  67,
  -100,
  -61,
  -117,
  43,
  22,
  -15,
  -40,
  -61,
  42,
  44,
  -99,
  16,
  -19,
  107,
  116,
  -5,
  68,
  -92,
  -89,
  -88,
  5,
  -3,
  36,
  -91,
  -1,
  -30,
  -85,
  11,
  -88,
  -5,
  36,
  2,
  43,
  105,
  -5,
  33,
  -46,
  29,
  -14,
  -10,
  18,
  12,
  117,
  -15,
  102,
  -64,
  -48,
  99,
  63,
  -79,
  55,
  -71,
  -100,
  14,
  104,
  -114,
  6,
  -106,
  -127,
  104,
  23,
  111,
  -91,
  -117,
  -82,
  -113,
  38,
  73,
  -88,
  34,
  8,
  35,
  60,
  -106,
  85,
  -107,
  12,
  -109,
  120,
  -28,
  -100,
  -55,
  -94,
  -100,
  -96,
  -52,
  126,
  -25,
  77,
  103,
  -116,
  109,
  41,
  55,
  -125,
  2,
  -61,
  -127,
  -89,
  18,
  68,
  74,
  8,
  77,
  65,
  -89,
  72,
  90,
  3,
  53,
  -85,
  -41,
  74,
  50,
  -27,
  15,
  -104,
  -23,
  113,
  60,
  76,
  -25,
  7,
  -49,
  -100,
  37,
  60,
  -89,
  -57,
  73,
  105,
  15,
  -122,
  -73,
  57,
  -27,
  92,
  -103,
  -109,
  -102,
  0,
  28,
  -73,
  24,
  -92,
  -93,
  40,
  -70,
  70,
  31,
  -105,
  -81,
  -10,
  -110,
  76,
  18,
  -98,
  -80,
  -17,
  -84,
  76,
  55,
  -94,
  24,
  40,
  114,
  9,
  -104,
  -94,
  -39,
  92,
  33,
  95,
  -72,
  71,
  -98,
  -51,
  -100,
  30,
  -103,
  -104,
  105,
  61,
  3,
  73,
  119,
  -71,
  -125,
  73,
  107,
  -20,
  -123,
  -55,
  126,
  59,
  1,
  -98,
  -74,
  65,
  -69,
  -70,
  69,
  -63,
  -123,
  -47,
  74,
  69,
  82,
  93,
  -68,
  65,
  76,
  5,
  -80,
  -75,
  53,
  5,
  -1,
  95,
  53,
  56,
  73,
  124,
  64,
  -77,
  58,
  -28,
  -44,
  92,
  70,
  -69,
  -39,
  84,
  -100,
  127,
  -21,
  -72,
  35,
  -121,
  -19,
  -23,
  -85,
  80,
  120,
  29,
  85,
  10,
  94,
  -55,
  -74,
  116,
  12,
  -127,
  -62,
  -72,
  117,
  18,
  -48,
  -41,
  -45,
  64,
  -38,
  103,
  56,
  -106,
  -107,
  -77,
  -26,
  -94,
  71,
  85,
  61,
  -96,
  -5,
  -37,
  11,
  -104,
  -63,
  -124,
  20,
  71,
  78,
  -3,
  108,
  5,
  -22,
  -71,
  47,
  64,
  35,
  20,
  -2,
  -8,
  -20,
  27,
  -80,
  -64,
  47,
  81,
  13,
  -83,
  31,
  57,
  77,
  -39,
  -54,
  -18,
  -75,
  -102,
  29,
  114,
  -52,
  -103,
  -53,
  120,
  -111,
  92,
  -75,
  123,
  17,
  -1,
  96,
  -70,
  127,
  -37,
  127,
  -97,
  -66,
  -82,
  1,
  0,
  -125,
  47,
  -29,
  -5,
  48,
  115,
  -122,
  29,
  19,
  -42,
  -119,
  -22,
  -87,
  -115,
  73,
  11,
  -8,
  68,
  -101,
  -78,
  59,
  -38,
  -9,
  -45,
  -9,
  19,
  26,
  -84,
  11,
  -68,
  -54,
  -88,
  -1,
  -52,
  -82,
  84,
  17,
  -73,
  -53,
  111,
  -42,
  -8,
  76,
  107,
  -83,
  -56,
  -68,
  16,
  118,
  27,
  -42,
  45,
  125,
  40,
  -16,
  -113,
  64,
  65,
  -101,
  -121,
  -117,
  -117,
  -29,
  81,
  19,
  70,
  -54,
  -69,
  126,
  63,
  -59,
  -82,
  85,
  -65,
  -96,
  94,
  -14,
  72,
  -13,
  -110,
  62,
  94,
  45,
  107,
  -76,
  -11,
  6,
  118,
  -57,
  -3,
  -74,
  113,
  31,
  18,
  -11,
  111,
  -18,
  109,
  -120,
  81,
  -23,
  38,
  -105,
  12,
  -46,
  109,
  96,
  13,
  78,
  108,
  -96,
  -53,
  -98,
  -42,
  -72,
  -78,
  33,
  18,
  -97,
  20,
  37,
  114,
  2,
  -57,
  69,
  -108,
  -64,
  -93,
  -23,
  -113,
  -109,
  114,
  60,
  124,
  -116,
  127,
  70,
  -88,
  -74,
  17,
  77,
  -64,
  -24,
  95,
  41,
  -26,
  10,
  87,
  91,
  101,
  0,
  78,
  105,
  -75,
  -88,
  125,
  1,
  -87,
  -79,
  -96,
  59,
  47,
  67,
  69,
  27,
  68,
  12,
  -92,
  53,
  -47,
  -50,
  -85,
  96,
  75,
  -81,
  -51,
  -108,
  -89,
  0,
  -117,
  116,
  -25,
  74,
  -87,
  -116,
  -7,
  -98,
  -44,
  108,
  63,
  115,
  -51,
  -13,
  47,
  51,
  21,
  33,
  -31,
  10,
  49,
  49,
  29,
  73,
  126,
  -73,
  -57,
  -70,
  62,
  -62,
  30,
  42,
  127,
  47,
  94,
  42,
  -123,
  -66,
  37,
  -39,
  127,
  -85,
  0,
  -27,
  -32,
  -114,
  109,
  -99,
  -65,
  74,
  117,
  43,
  67,
  101,
  -57,
  22,
  104,
  52,
  -53,
  79,
  -107,
  -48,
  40,
  42,
  -16,
  112,
  -107,
  60,
  42,
  103,
  -62,
  115,
  -25,
  -15,
  24,
  -95,
  69,
  -8,
  102,
  69,
  67,
  -34,
  76,
  128,
  -71,
  59,
  -114,
  -50,
  -112,
  -70,
  82,
  -111,
  -111,
  120,
  -102,
  -67,
  -55,
  40,
  -67,
  -97,
  -59,
  102,
  90,
  32,
  76,
  -122,
  38,
  22,
  -41,
  42,
  31,
  11,
  33,
  106,
  106,
  11,
  64,
  12,
  90,
  74,
  -34,
  -12,
  45,
  7,
  42,
  -104,
  119,
  -58,
  83,
  15,
  -84,
  -17,
  -85,
  -100,
  13,
  121,
  -35,
  -34,
  88,
  -31,
  -121,
  103,
  33,
  97,
  55,
  -69,
  62,
  2,
  90,
  -95,
  -69,
  -118,
  -119,
  6,
  -39,
  121,
  108,
  -26,
  24,
  95,
  -75,
  -5,
  79,
  73,
  32,
  84,
  -75,
  125,
  121,
  -65,
  30,
  -59,
  -57,
  103,
  20,
  -18,
  104,
  -114,
  -41,
  97,
  34,
  15,
  19,
  71,
  -56,
  45,
  4,
  12,
  69,
  -18,
  -37,
  77,
  44,
  3,
  17,
  -126,
  -37,
  -92,
  -122,
  -9,
  81,
  -2,
  -87,
  -23,
  102,
  -77,
  84,
  54,
  -31,
  115,
  90,
  -100,
  -71,
  -34,
  -85,
  -49,
  38,
  -102,
  -51,
  95,
  73,
  -58,
  35,
  -109,
  -125,
  -123,
  18,
  78,
  45,
  -61,
  -39,
  105,
  119,
  -108,
  -32,
  -50,
  125,
  -117,
  103,
  -90,
  103,
  -109,
  -61,
  93,
  -103,
  -100,
  -73,
  74,
  88,
  -126,
  -67,
  -56,
  -76,
  90,
  19,
  6,
  0,
  126,
  -84,
  85,
  -17,
  -101,
  62,
  -10,
  95,
  -78,
  0,
  22,
  22,
  -32,
  7,
  -65,
  16,
  -39,
  77,
  -48,
  -61,
  -121,
  41,
  -14,
  104,
  -124,
  67,
  -62,
  -30,
  117,
  34,
  50,
  49,
  -68,
  65,
  3,
  56,
  -10,
  -28,
  -57,
  -80,
  -11,
  -99,
  -9,
  -77,
  56,
  -60,
  40,
  -9,
  -124,
  -64,
  84,
  85,
  -53,
  -1,
  121,
  -50,
  64,
  -15,
  -31,
  107,
  38,
  55,
  -109,
  86,
  -10,
  -103,
  -73,
  -100,
  60,
  107,
  127,
  -73,
  9,
  -74,
  116,
  25,
  91,
  -111,
  65,
  -83,
  -23,
  -96,
  82,
  72,
  54,
  -70,
  36,
  37,
  65,
  -65,
  -9,
  78,
  112,
  -3,
  126,
  121,
  32,
  -56,
  115,
  0,
  -111,
  26,
  41,
  -87,
  -18,
  -29,
  -23,
  -113,
  109,
  69,
  23,
  -14,
  73,
  77,
  117,
  -26,
  94,
  128,
  -14,
  -60,
  -12,
  92,
  -16,
  1,
  -85,
  77,
  83,
  42,
  -62,
  -44,
  106,
  48,
  18,
  108,
  -67,
  -19,
  -116,
  -124,
  -16,
  29,
  39,
  -36,
  49,
  94,
  89,
  91,
  97,
  -58,
  42,
  -53,
  -75,
  -38,
  -91,
  -68,
  -96,
  -77,
  -88,
  37,
  31,
  -91,
  50,
  -33,
  18,
  82,
  -13,
  5,
  -51,
  27,
  -91,
  71,
  117,
  -113,
  -16,
  81,
  65,
  -23,
  -125,
  -2,
  15,
  45,
  32,
  15,
  24,
  -10,
  113,
  -10,
  -9,
  -49,
  -97,
  -2,
  -7,
  -67,
  -108,
  -113,
  60,
  -88,
  80,
  77,
  -126,
  112,
  -107,
  -6,
  -103,
  -118,
  -102,
  123,
  -5,
  113,
  -85,
  -47,
  -86,
  -76,
  -74,
  -118,
  -113,
  -34,
  109,
  43,
  -72,
  -49,
  -94,
  -66,
  -7,
  -103,
  -9,
  63,
  119,
  -119,
  79,
  -26,
  118,
  74,
  82,
  -52,
  119,
  61,
  111,
  47,
  -103,
  117,
  -70,
  61,
  -116,
  -9,
  7,
  -77,
  -11,
  94,
  71,
  -80,
  -26,
  93,
  -14,
  123,
  -117,
  108,
  78,
  62,
  -30,
  84,
  83,
  32,
  -43,
  -93,
  13,
  15,
  115,
  11,
  115,
  -82,
  -50,
  -79,
  103,
  46,
  110,
  -62,
  -86,
  -35,
  31,
  -105,
  -23,
  62,
  -66,
  123,
  0,
  121,
  70,
  9,
  28,
  -44,
  -59,
  -76,
  -9,
  102,
  76,
  -54,
  105,
  -41,
  -8,
  45,
  -121,
  -37,
  -47,
  -77,
  -62,
  23,
  -122,
  -58,
  -50,
  67,
  41,
  125,
  36,
  -3,
  59,
  6,
  -91,
  -41,
  -77,
  111,
  -56,
  -97,
  28,
  -46,
  -47,
  122,
  -32,
  -10,
  -73,
  -37,
  108,
  43,
  1,
  71,
  -8,
  94,
  -61,
  113,
  121,
  84,
  98,
  42,
  -21,
  -15,
  125,
  64,
  23,
  11,
  103,
  21,
  5,
  85,
  59,
  -53,
  -5,
  -99,
  -10,
  9,
  16,
  44,
  60,
  -59,
  -15,
  -39,
  -60,
  21,
  -56,
  -31,
  -79,
  -19,
  71,
  -80,
  52,
  88,
  -50,
  99,
  -34,
  123,
  114,
  -20,
  100,
  -15,
  -117,
  -36,
  -28,
  68,
  48,
  69,
  -27,
  -102,
  120,
  9,
  79,
  -94,
  -111,
  8,
  -123,
  -61,
  -59,
  -44,
  28,
  -69,
  -47,
  -62,
  -57,
  52,
  -118,
  0,
  -1,
  94,
  -33,
  -96,
  97,
  35,
  -7,
  -50,
  -101,
  0,
  124,
  33,
  71,
  60,
  9,
  44,
  119,
  113,
  56,
  86,
  -94,
  -102,
  -75,
  -68,
  105,
  122,
  -102,
  -2,
  -13,
  -49,
  -70,
  52,
  -116,
  -101,
  84,
  77,
  -114,
  122,
  115,
  -19,
  -115,
  -32,
  108,
  -65,
  -37,
  -46,
  -71,
  115,
  5,
  16,
  18,
  -15,
  -6,
  111,
  90,
  -63,
  -15,
  -7,
  94,
  -21,
  99,
  17,
  -63,
  106,
  56,
  117,
  -98,
  -120,
  76,
  39,
  85,
  119,
  -106,
  -109,
  128,
  12,
  46,
  -64,
  73,
  128,
  43,
  119,
  79,
  -100,
  27,
  119,
  -43,
  -100,
  5,
  -7,
  -41,
  123,
  -92,
  33,
  34,
  97,
  -88,
  15,
  -40,
  1,
  68,
  10,
  -69,
  123,
  86,
  -7,
  119,
  119,
  127,
  16,
  -54,
  -15,
  28,
  25,
  -25,
  -94,
  35,
  107,
  7,
  -48,
  7,
  113,
  -115,
  -82,
  52,
  -127,
  -93,
  -94,
  94,
  2,
  -63,
  -43,
  128,
  110,
  63,
  -25,
  113,
  -42,
  -8,
  64,
  -107,
  -102,
  -21,
  76,
  -74,
  -47,
  15,
  38,
  -57,
  -107,
  75,
  51,
  48,
  28,
  52,
  -106,
  -29,
  -11,
  51,
  -123,
  -52,
  -72,
  -49,
  -110,
  -100,
  17,
  -16,
  -78,
  116,
  -34,
  -77,
  -117,
  -2,
  35,
  113,
  -21,
  -6,
  125,
  13,
  -75,
  -82,
  92,
  -122,
  -16,
  48,
  8,
  95,
  85,
  -101,
  30,
  -104,
  117,
  91,
  69,
  -36,
  110,
  105,
  90,
  -84,
  -30,
  -5,
  -23,
  -10,
  -81,
  -90,
  45,
  -3,
  28,
  -118,
  64,
  20,
  88,
  43,
  -17,
  -85,
  -48,
  123,
  -69,
  62,
  -35,
  86,
  14,
  110,
  113,
  43,
  -95,
  -109,
  55,
  -13,
  -94,
  77,
  62,
  -62,
  -103,
  23,
  -88,
  -66,
  15,
  112,
  -46,
  104,
  87,
  64,
  -21,
  -33,
  108,
  35,
  -54,
  -60,
  -79,
  45,
  75,
  1,
  53,
  19,
  -70,
  -80,
  79,
  48,
  10,
  -103,
  103,
  44,
  -52,
  58,
  61,
  38,
  3,
  -110,
  126,
  57,
  -100,
  -100,
  -125,
  -28,
  38,
  -17,
  5,
  -106,
  65,
  120,
  41,
  -68,
  -87,
  81,
  -96,
  -44,
  35,
  -118,
  -15,
  -54,
  -56,
  -19,
  78,
  -63,
  30,
  -71,
  -78,
  66,
  4,
  -95,
  41,
  47,
  -101,
  -18,
  128,
  92,
  -28,
  -71,
  115,
  8,
  -127,
  22,
  67,
  -95,
  16,
  92,
  -34,
  22,
  74,
  64,
  5,
  -105,
  -98,
  66,
  -55,
  16,
  -42,
  -95,
  106,
  101,
  46,
  -17,
  20,
  89,
  46,
  -123,
  -19,
  -3,
  106,
  61,
  -34,
  -78,
  -33,
  95,
  -52,
  76,
  52,
  109,
  13,
  30,
  127,
  39,
  55,
  9,
  99,
  -101,
  116,
  115,
  -55,
  30,
  -40,
  57,
  80,
  122,
  41,
  -88,
  64,
  125,
  101,
  103,
  73,
  -96,
  27,
  -22,
  -113,
  84,
  -32,
  -27,
  118,
  -117,
  -101,
  -12,
  44,
  77,
  47,
  52,
  -110,
  53,
  40,
  -81,
  45,
  111,
  31,
  21,
  102,
  -111,
  35,
  63,
  -104,
  -23,
  -100,
  70,
  105,
  121,
  -74,
  22,
  48,
  -38,
  0,
  -34,
  4,
  -118,
  -62,
  -119,
  106,
  -18,
  19,
  -74,
  111,
  56,
  44,
  -122,
  16,
  77,
  -48,
  -115,
  -115,
  -108,
  64,
  -78,
  0,
  110,
  74,
  -57,
  -65,
  -101,
  -31,
  72,
  -27,
  49,
  -42,
  -79,
  -43,
  12,
  2,
  43,
  45,
  -101,
  -31,
  16,
  -5,
  -74,
  42,
  47,
  16,
  60,
  -28,
  105,
  31,
  10,
  -101,
  -85,
  117,
  41,
  -101,
  35,
  -7,
  -57,
  -96,
  116,
  -93,
  -32,
  -78,
  -85,
  50,
  0,
  38,
  -81,
  36,
  -75,
  125,
  -11,
  2,
  -93,
  -49,
  -38,
  61,
  77,
  94,
  -26,
  10,
  -43,
  2,
  -42,
  57,
  56,
  -89,
  -20,
  -106,
  -14,
  -28,
  2,
  78,
  -93,
  79,
  -63,
  -67,
  76,
  -70,
  -8,
  27,
  121,
  119,
  54,
  -122,
  -20,
  83,
  -126,
  -52,
  13,
  -83,
  6,
  -53,
  -30,
  74,
  -71,
  -107,
  -23,
  61,
  55,
  -103,
  90,
  41,
  -78,
  -115,
  77,
  -122,
  114,
  -97,
  -89,
  50,
  -3,
  -48,
  -31,
  -26,
  28,
  -118,
  -25,
  -63,
  -5,
  64,
  -84,
  -11,
  -46,
  -29,
  45,
  -25,
  -81,
  -11,
  -60,
  -2,
  -76,
  83,
  18,
  -99,
  12,
  -48,
  -7,
  -123,
  -88,
  95,
  20,
  -1,
  87,
  26,
  18,
  -66,
  5,
  -88,
  -121,
  59,
  99,
  -7,
  -9,
  23,
  35,
  28,
  -107,
  -50,
  -25,
  -80,
  12,
  -35,
  -57,
  109,
  -30,
  65,
  -112,
  53,
  90,
  18,
  76,
  31,
  30,
  18,
  65,
  50,
  120,
  -121,
  -120,
  -110,
  -17,
  -29,
  -61,
  -18,
  -70,
  80,
  -119,
  13,
  85,
  38,
  78,
  116,
  126,
  -113,
  27,
  30,
  104,
  -52,
  -38,
  68,
  -4,
  47,
  -24,
  103,
  -6,
  124,
  -13,
  -105,
  120,
  -68,
  -54,
  51,
  -96,
  51,
  -75,
  -51,
  84,
  55,
  70,
  -63,
  -72,
  -93,
  -31,
  -2,
  35,
  64,
  -2,
  24,
  -93,
  -64,
  -50,
  105,
  40,
  -71,
  26,
  101,
  -80,
  -34,
  -8,
  -62,
  39,
  -40,
  -29,
  -89,
  -53,
  27,
  44,
  -31,
  -83,
  -102,
  14,
  -37,
  64,
  38,
  17,
  -116,
  110,
  11,
  63,
  -1,
  24,
  19,
  -122,
  69,
  12,
  79,
  -85,
  61,
  -63,
  20,
  -53,
  -20,
  -28,
  -42,
  -48,
  -75,
  -58,
  56,
  -46,
  26,
  -98,
  -105,
  76,
  -94,
  -65,
  -99,
  113,
  -46,
  -73,
  124,
  -90,
  78,
  115,
  127,
  7,
  -31,
  -108,
  -18,
  113,
  12,
  -62,
  -31,
  0,
  -57,
  -29,
  31,
  74,
  -25,
  -71,
  -70,
  -84,
  -31,
  86,
  -9,
  47,
  -32,
  -123,
  -69,
  50,
  -110,
  -112,
  -55,
  25,
  77,
  110,
  21,
  -49,
  -55,
  93,
  96,
  107,
  60,
  56,
  -9,
  -7,
  -36,
  -102,
  -125,
  118,
  68,
  111,
  -103,
  -40,
  -60,
  20,
  -71,
  66,
  53,
  52,
  -36,
  31,
  31,
  -55,
  60,
  69,
  86,
  -23,
  91,
  -15,
  21,
  8,
  100,
  -33,
  68,
  62,
  16,
  -55,
  65,
  -91,
  -83,
  9,
  123,
  127,
  -29,
  18,
  106,
  -41,
  -66,
  63,
  -95,
  -8,
  43,
  122,
  -65,
  -4,
  -48,
  59,
  -107,
  96,
  127,
  -101,
  -111,
  0,
  -102,
  110,
  -5,
  38,
  -85,
  -22,
  57,
  24,
  125,
  -96,
  6,
  -19,
  -76,
  52,
  -97,
  -85,
  93,
  -50,
  40,
  82,
  12,
  -112,
  -63,
  23,
  68,
  113,
  71,
  -5,
  -34,
  107,
  -37,
  -111,
  27,
  -116,
  109,
  -54,
  123,
  -1,
  16,
  -99,
  7,
  -44,
  -33,
  56,
  -82,
  83,
  26,
  -9,
  -44,
  19,
  -15,
  -115,
  -47,
  78,
  54,
  85,
  -48,
  -94,
  106,
  -18,
  106,
  0,
  60,
  -65,
  73,
  8,
  4,
  -44,
  -86,
  -26,
  71,
  -33,
  88,
  -74,
  -121,
  99,
  9,
  -66,
  -83,
  23,
  -13,
  112,
  107,
  -69,
  113,
  123,
  -28,
  -80,
  59,
  123,
  65,
  122,
  -11,
  86,
  87,
  -49,
  -40,
  74,
  -87,
  -3,
  -45,
  -108,
  62,
  47,
  23,
  -50,
  -28,
  4,
  -61,
  -107,
  60,
  9,
  -81,
  102,
  -69,
  -112,
  126,
  18,
  89,
  108,
  118,
  43,
  75,
  -112,
  49,
  -78,
  50,
  -4,
  125,
  -72,
  6,
  110,
  -53,
  -66,
  70,
  -125,
  -75,
  122,
  125,
  -3,
  51,
  45,
  42,
  56,
  -86,
  120,
  -41,
  -7,
  -78,
  -22,
  -59,
  125,
  110,
  -56,
  -16,
  -46,
  -10,
  60,
  -105,
  13,
  -87,
  69,
  74,
  128,
  -38,
  -64,
  -25,
  -42,
  -110,
  -66,
  74,
  -6,
  -62,
  -93,
  -37,
  -55,
  92,
  -106,
  -62,
  81,
  -68,
  104,
  -54,
  80,
  -9,
  118,
  -7,
  -69,
  63,
  35,
  73,
  -63,
  29,
  -86,
  24,
  -28,
  99,
  44,
  95,
  18,
  62,
  -11,
  -56,
  -34,
  -87,
  8,
  3,
  36,
  -60,
  -120,
  42,
  -121,
  -47,
  -112,
  3,
  30,
  56,
  -88,
  -57,
  -55,
  -83,
  94,
  89,
  23,
  44,
  62,
  -118,
  -37,
  -98,
  -18,
  -19,
  -54,
  -75,
  89,
  -38,
  -91,
  83,
  39,
  2,
  -43,
  110,
  52,
  -7,
  124,
  83,
  120,
  -98,
  10,
  -49,
  -29,
  -117,
  55,
  -10,
  -101,
  70,
  -22,
  100,
  18,
  15,
  -59,
  125,
  19,
  2,
  -121,
  -49,
  30,
  -50,
  92,
  -95,
  -73,
  19,
  -126,
  119,
  -50,
  0,
  9,
  -45,
  82,
  14,
  -64,
  106,
  -81,
  -59,
  -98,
  62,
  95,
  -72,
  -117,
  54,
  65,
  66,
  109,
  -51,
  -29,
  10,
  26,
  -30,
  -8,
  -99,
  -32,
  100,
  -110,
  29,
  -76,
  66,
  52,
  38,
  -44,
  -17,
  102,
  -109,
  -4,
  65,
  -10,
  88,
  45,
  55,
  -71,
  -42,
  -68,
  -52,
  -83,
  53,
  127,
  15,
  -31,
  51,
  -90,
  37,
  126,
  -79,
  -94,
  47,
  112,
  56,
  38,
  2,
  -20,
  -4,
  101,
  78,
  -47,
  53,
  -94,
  -78,
  -115,
  -109,
  -9,
  33,
  -32,
  52,
  115,
  101,
  -17,
  83,
  -85,
  -111,
  32,
  -109,
  -2,
  -107,
  -105,
  9,
  -12,
  -119,
  -116,
  -86,
  -30,
  107,
  -18,
  -43,
  -120,
  110,
  23,
  -127,
  -56,
  120,
  28,
  -2,
  -73,
  99,
  -123,
  -91,
  114,
  -43,
  47,
  -126,
  13,
  53,
  -44,
  49,
  24,
  -70,
  67,
  89,
  -40,
  15,
  23,
  101,
  -107,
  80,
  -4,
  -17,
  -56,
  116,
  -32,
  -125,
  -96,
  -81,
  61,
  -3,
  -39,
  -102,
  41,
  88,
  -87,
  101,
  38,
  22,
  -117,
  114,
  89,
  72,
  -10,
  -33,
  34,
  5,
  81,
  -10,
  82,
  -54,
  94,
  -84,
  11,
  -44,
  75,
  53,
  -120,
  89,
  41,
  -79,
  -23,
  43,
  -67,
  -71,
  -41,
  -68,
  -60,
  36,
  -25,
  30,
  -75,
  -24,
  85,
  19,
  73,
  -28,
  127,
  87,
  0,
  -29,
  -78,
  -79,
  24,
  -79,
  19,
  -73,
  -13,
  -114,
  6,
  -67,
  6,
  -39,
  120,
  70,
  -86,
  -63,
  101,
  -52,
  39,
  98,
  117,
  -76,
  -108,
  121,
  -44,
  -96,
  -77,
  122,
  80,
  13,
  -53,
  -8,
  -111,
  -39,
  -30,
  78,
  -38,
  79,
  12,
  40,
  17,
  -20,
  63,
  116,
  -119,
  -111,
  -45,
  20,
  -53,
  -64,
  124,
  -119,
  8,
  -41,
  -44,
  -87,
  -35,
  16,
  53,
  -36,
  -114,
  36,
  127,
  -11,
  -2,
  91,
  -5,
  14,
  82,
  -99,
  -77,
  48,
  -7,
  18,
  -30,
  52,
  -75,
  28,
  -3,
  -73,
  -108,
  71,
  74,
  115,
  -108,
  21,
  -122,
  -124,
  -104,
  -114,
  10,
  34,
  -94,
  44,
  99,
  -122,
  -76,
  -89,
  66,
  78,
  -2,
  -10,
  118,
  -41,
  127,
  127,
  77,
  9,
  5,
  9,
  9,
  34,
  126,
  48,
  27,
  102,
  78,
  128,
  -68,
  -33,
  43,
  2,
  55,
  -93,
  -93,
  62,
  92,
  -21,
  9,
  86,
  -74,
  -64,
  95,
  -45,
  1,
  -99,
  -10,
  71,
  -9,
  -66,
  -2,
  92,
  95,
  101,
  -64,
  -51,
  40,
  -92,
  -116,
  19,
  56,
  26,
  -28,
  68,
  17,
  14,
  104,
  -39,
  -65,
  -105,
  -88,
  -30,
  29,
  12,
  62,
  104,
  37,
  40,
  104,
  86,
  -84,
  -81,
  -111,
  72,
  -19,
  38,
  -42,
  90,
  48,
  45,
  -120,
  12,
  -121,
  85,
  57,
  2,
  55,
  -11,
  42,
  65,
  -35,
  -83,
  -104,
  13,
  104,
  -30,
  24,
  116,
  29,
  -54,
  4,
  -65,
  -30,
  29,
  72,
  -55,
  -89,
  -39,
  41,
  98,
  -79,
  -99,
  53,
  -3,
  -19,
  70,
  -91,
  64,
  -107,
  -73,
  -15,
  -124,
  72,
  38,
  50,
  62,
  -113,
  36,
  28,
  -102,
  115,
  88,
  55,
  24,
  -26,
  94,
  -24,
  76,
  92,
  -97,
  84,
  -29,
  33,
  -34,
  97,
  -20,
  -4,
  13,
  92,
  -100,
  -19,
  -6,
  -48,
  100,
  26,
  -41,
  -7,
  -31,
  -79,
  -58,
  -19,
  35,
  -48,
  89,
  -41,
  31,
  16,
  27,
  83,
  -33,
  -102,
  -80,
  -7,
  108,
  11,
  -70,
  -36,
  4,
  -48,
  47,
  -36,
  50,
  -123,
  100,
  29,
  52,
  16,
  -85,
  -91,
  -63,
  105,
  -22,
  65,
  -94,
  -45,
  -32,
  -4,
  39,
  -11,
  -76,
  -87,
  -51,
  -96,
  38,
  -125,
  102,
  -42,
  -5,
  -4,
  -9,
  -70,
  116,
  65,
  -58,
  -13,
  68,
  -39,
  -108,
  -103,
  -8,
  -116,
  -19,
  -68,
  -101,
  111,
  -89,
  87,
  120,
  -10,
  96,
  -67,
  -52,
  84,
  47,
  84,
  -21,
  -26,
  -38,
  -57,
  -97,
  -7,
  -107,
  -91,
  -113,
  25,
  53,
  -62,
  -67,
  36,
  -21,
  -51,
  -55,
  18,
  -31,
  17,
  96,
  32,
  -114,
  20,
  -21,
  -99,
  12,
  98,
  37,
  43,
  -38,
  -109,
  21,
  111,
  120,
  -48,
  -45,
  -8,
  -76,
  75,
  -47,
  49,
  -35,
  118,
  88,
  41,
  95,
  75,
  72,
  77,
  -60,
  -36,
  -42,
  7,
  41,
  23,
  72,
  105,
  66,
  67,
  -103,
  -108,
  88,
  -107,
  -77,
  -35,
  -96,
  -59,
  74,
  105,
  25,
  -31,
  -27,
  -44,
  -54,
  -43,
  11,
  125,
  -41,
  21,
  -71,
  -110,
  126,
  51,
  -96,
  -57,
  82,
  -41,
  -91,
  36,
  -65,
  42,
  28,
  65,
  62,
  -94,
  -81,
  79,
  -122,
  -125,
  -67,
  -93,
  30,
  105,
  27,
  -75,
  31,
  22,
  3,
  -64,
  -120,
  112,
  -82,
  -79,
  -26,
  -88,
  55,
  -32,
  -62,
  55,
  -47,
  13,
  -32,
  -46,
  -69,
  -123,
  -41,
  -1,
  88,
  -47,
  89,
  -5,
  69,
  74,
  20,
  -85,
  117,
  125,
  125,
  72,
  110,
  -27,
  -12,
  -85,
  87,
  111,
  8,
  -89,
  -62,
  -109,
  63,
  97,
  66,
  -85,
  62,
  -94,
  -20,
  58,
  -59,
  63,
  85,
  -121,
  30,
  -77,
  48,
  100,
  -45,
  -43,
  20,
  109,
  65,
  14,
  28,
  -91,
  -110,
  -9,
  98,
  78,
  63,
  -41,
  -23,
  -70,
  -98,
  -108,
  84,
  118,
  -4,
  125,
  69,
  67,
  -16,
  113,
  -31,
  111,
  -114,
  99,
  -104,
  -6,
  17,
  53,
  111,
  -123,
  -86,
  9,
  73,
  27,
  -118,
  -23,
  36,
  114,
  -115,
  -1,
  45,
  -2,
  78,
  123,
  95,
  -71,
  26,
  20,
  -91,
  11,
  -7,
  0,
  123,
  -27,
  8,
  -126,
  56,
  126,
  -77,
  -65,
  -15,
  86,
  -115,
  104,
  54,
  51,
  25,
  25,
  -40,
  3,
  -9,
  -102,
  -109,
  123,
  -71,
  -120,
  58,
  101,
  -74,
  17,
  46,
  -64,
  12,
  26,
  -50,
  -109,
  -119,
  -6,
  -33,
  127,
  -92,
  -103,
  81,
  -23,
  88,
  -114,
  111,
  -10,
  103,
  94,
  88,
  -124,
  72,
  91,
  -5,
  16,
  -4,
  -52,
  3,
  127,
  -56,
  54,
  27,
  -46,
  103,
  -59,
  0,
  -38,
  -32,
  -17,
  26,
  -10,
  100,
  20,
  37,
  -60,
  -91,
  -100,
  9,
  -61,
  71,
  -110,
  -62,
  82,
  4,
  -122,
  -59,
  31,
  89,
  -91,
  -20,
  89,
  50,
  -32,
  -109,
  71,
  -93,
  -11,
  -88,
  90,
  96,
  -83,
  101,
  55,
  -82,
  75,
  42,
  71,
  -16,
  81,
  -24,
  -80,
  29,
  33,
  -76,
  -62,
  10,
  -118,
  97,
  113,
  -103,
  -81,
  -59,
  96,
  70,
  2,
  -43,
  48,
  -82,
  32,
  -113,
  -9,
  -88,
  89,
  -121,
  -121,
  62,
  -104,
  1,
  78,
  58,
  -46,
  28,
  78,
  -78,
  -47,
  103,
  -58,
  86,
  -125,
  74,
  -40,
  -90,
  -118,
  124,
  107,
  -102,
  -100,
  89,
  106,
  111,
  -111,
  5,
  -46,
  96,
  17,
  -121,
  22,
  20,
  45,
  63,
  79,
  1,
  108,
  1,
  -57,
  19,
  -114,
  128,
  8,
  119,
  14,
  -7,
  -122,
  61,
  128,
  109,
  43,
  -108,
  -50,
  33,
  -3,
  95,
  -13,
  56,
  -15,
  117,
  54,
  -84,
  -63,
  -86,
  -20,
  -51,
  124,
  -109,
  -122,
  96,
  -29,
  -23,
  123,
  -19,
  12,
  -46,
  95,
  -12,
  22,
  -22,
  -94,
  -4,
  -95,
  -60,
  -26,
  94,
  -54,
  72,
  24,
  113,
  60,
  -28,
  -3,
  -119,
  -42,
  18,
  -46,
  112,
  -35,
  115,
  -83,
  -33,
  -30,
  -90,
  -43,
  -40,
  91,
  24,
  -64,
  -95,
  -122,
  -106,
  39,
  -56,
  -66,
  -1,
  -16,
  43,
  125,
  79,
  5,
  78,
  80,
  -115,
  -92,
  -13,
  -24,
  102,
  -25,
  16,
  -23,
  -99,
  -50,
  15,
  51,
  121,
  9,
  104,
  4,
  -79,
  4,
  29,
  36,
  25,
  -37,
  76,
  8,
  -91,
  -94,
  37,
  -43,
  -20,
  111,
  -15,
  -52,
  62,
  -15,
  -11,
  61,
  41,
  123,
  7,
  -43,
  114,
  -96,
  111,
  -103,
  64,
  113,
  37,
  25,
  31,
  64,
  43,
  89,
  107,
  -112,
  100,
  -70,
  53,
  -2,
  -2,
  -80,
  1,
  -69,
  -7,
  -121,
  -51,
  -62,
  -94,
  -48,
  23,
  -2,
  125,
  16,
  127,
  47,
  -60,
  -125,
  125,
  45,
  -76,
  61,
  110,
  -88,
  1,
  -30,
  54,
  39,
  79,
  -96,
  93,
  -9,
  30,
  -110,
  119,
  -20,
  -25,
  39,
  -110,
  6,
  -2,
  22,
  -97,
  -78,
  9,
  -40,
  58,
  -119,
  119,
  -117,
  74,
  -96,
  -62,
  -90,
  85,
  96,
  -71,
  39,
  -122,
  6,
  61,
  -42,
  51,
  -109,
  -101,
  123,
  32,
  -37,
  -77,
  -9,
  72,
  123,
  49,
  -105,
  43,
  58,
  -117,
  -49,
  43,
  71,
  44,
  -62,
  127,
  110,
  30,
  -2,
  -6,
  -90,
  4,
  -67,
  49,
  2,
  -119,
  106,
  111,
  -37,
  82,
  -67,
  2,
  -78,
  -66,
  -82,
  4,
  40,
  -30,
  102,
  45,
  18,
  17,
  -108,
  29,
  -13,
  85,
  -105,
  -113,
  89,
  105,
  -10,
  -31,
  -85,
  121,
  92,
  -34,
  24,
  1,
  -66,
  -44,
  22,
  46,
  60,
  -15,
  59,
  41,
  0,
  -68,
  -45,
  -66,
  36,
  105,
  50,
  93,
  100,
  27,
  -113,
  39,
  -89,
  -108,
  82,
  32,
  -69,
  55,
  -117,
  32,
  -16,
  -124,
  39,
  -32,
  19,
  -49,
  3,
  -83,
  46,
  56,
  124,
  106,
  -80,
  -88,
  51,
  -60,
  54,
  -67,
  -55,
  -27,
  113,
  54,
  -66,
  34,
  -126,
  -24,
  -40,
  2,
  36,
  -31,
  -103,
  57,
  -96,
  53,
  -2,
  37,
  11,
  9,
  -34,
  6,
  42,
  108,
  -15,
  69,
  103,
  -33,
  -38,
  19,
  20,
  117,
  -92,
  63,
  84,
  -57,
  -124,
  -88,
  -77,
  78,
  37,
  -92,
  71,
  -30,
  0,
  73,
  80,
  47,
  -79,
  109,
  56,
  92,
  -45,
  59,
  -64,
  -43,
  76,
  31,
  66,
  81,
  60,
  9,
  29,
  95,
  -83,
  -78,
  81,
  -80,
  -103,
  -106,
  -31,
  125,
  85,
  -43,
  70,
  1,
  21,
  0,
  18,
  -89,
  31,
  -17,
  -98,
  -1,
  69,
  91,
  -53,
  -36,
  -84,
  50,
  59,
  75,
  122,
  30,
  -39,
  11,
  85,
  -17,
  -81,
  -7,
  34,
  -123,
  -82,
  -102,
  93,
  -101,
  122,
  96,
  -17,
  -54,
  -89,
  14,
  125,
  29,
  -76,
  37,
  -85,
  43,
  -50,
  69,
  -57,
  52,
  123,
  -21,
  -87,
  -6,
  -22,
  83,
  71,
  65,
  -51,
  -65,
  64,
  82,
  7,
  41,
  117,
  20,
  -11,
  -70,
  7,
  16,
  54,
  -104,
  -35,
  52,
  55,
  -68,
  82,
  103,
  82,
  -127,
  87,
  -58,
  59,
  -16,
  -19,
  122,
  -27,
  120,
  97,
  31,
  -126,
  30,
  -125,
  -116,
  81,
  -81,
  -11,
  -73,
  -96,
  71,
  8,
  -115,
  -79,
  96,
  -63,
  93,
  -15,
  128,
  -46,
  78,
  25,
  44,
  121,
  44,
  0,
  121,
  115,
  -7,
  -26,
  -121,
  86,
  -55,
  -7,
  87,
  -127,
  -96,
  -51,
  -69,
  -38,
  9,
  55,
  -120,
  44,
  114,
  -81,
  -39,
  99,
  -107,
  71,
  54,
  127,
  -79,
  37,
  -60,
  -65,
  -6,
  117,
  79,
  51,
  21,
  11,
  -25,
  28,
  111,
  -114,
  -110,
  5,
  -123,
  49,
  25,
  -6,
  -54,
  68,
  -123,
  -67,
  116,
  26,
  -92,
  116,
  15,
  -95,
  -34,
  -123,
  124,
  33,
  -71,
  69,
  34,
  -33,
  -63,
  67,
  49,
  -61,
  -68,
  83,
  -87,
  124,
  -96,
  -23,
  -116,
  83,
  -3,
  95,
  -111,
  28,
  -5,
  -121,
  67,
  -71,
  -92,
  -56,
  -83,
  -42,
  106,
  70,
  116,
  -59,
  15,
  -118,
  -71,
  -89,
  -12,
  -114,
  -16,
  -9,
  107,
  44,
  -91,
  -122,
  -27,
  -17,
  33,
  89,
  52,
  98,
  -61,
  27,
  28,
  78,
  -64,
  -36,
  -38,
  63,
  -34,
  2,
  19,
  -50,
  38,
  33,
  -30,
  14,
  -101,
  53,
  58,
  75,
  112,
  107,
  -27,
  -76,
  -66,
  39,
  47,
  99,
  -93,
  66,
  45,
  13,
  73,
  107,
  79,
  96,
  49,
  -95,
  -119,
  2,
  -126,
  46,
  -60,
  -100,
  -83,
  53,
  -2,
  -34,
  110,
  -109,
  -107,
  -20,
  99,
  -5,
  26,
  36,
  -80,
  118,
  23,
  67,
  -113,
  -74,
  -110,
  -30,
  81,
  -21,
  28,
  -85,
  116,
  -9,
  -103,
  54,
  -58,
  -112,
  -80,
  66,
  93,
  59,
  42,
  124,
  43,
  -89,
  109,
  100,
  42,
  119,
  37,
  48,
  120,
  -62,
  -89,
  86,
  19,
  -96,
  65,
  -83,
  3,
  18,
  86,
  23,
  23,
  -113,
  70,
  -21,
  0,
  -24,
  52,
  -17,
  41,
  126,
  114,
  9,
  -127,
  36,
  -34,
  34,
  80,
  94,
  15,
  -51,
  -87,
  -85,
  22,
  -70,
  -72,
  -44,
  -88,
  123,
  82,
  97,
  -6,
  14,
  -40,
  -41,
  22,
  128,
  7,
  49,
  -35,
  71,
  118,
  -70,
  72,
  1,
  -106,
  -126,
  115,
  5,
  128,
  -66,
  81,
  52,
  -49,
  -58,
  22,
  46,
  74,
  -120,
  -51,
  -17,
  79,
  108,
  17,
  -48,
  32,
  -87,
  -91,
  -70,
  -47,
  18,
  -92,
  85,
  -96,
  56,
  72,
  5,
  126,
  -14,
  -18,
  88,
  29,
  49,
  -30,
  -46,
  106,
  69,
  -19,
  -28,
  29,
  121,
  -56,
  -118,
  42,
  36,
  -44,
  21,
  -83,
  -98,
  86,
  107,
  -116,
  85,
  16,
  101,
  84,
  -121,
  3,
  -26,
  21,
  53,
  44,
  -76,
  119,
  68,
  92,
  -80,
  -2,
  121,
  105,
  -20,
  -115,
  -7,
  4,
  39,
  107,
  -4,
  -83,
  -67,
  16,
  29,
  17,
  56,
  16,
  -118,
  -92,
  -12,
  80,
  -84,
  -91,
  124,
  -98,
  90,
  112,
  101,
  118,
  -49,
  -36,
  16,
  -68,
  -27,
  -67,
  82,
  -36,
  -33,
  4,
  88,
  -9,
  -98,
  -119,
  -44,
  -121,
  -55,
  41,
  109,
  -75,
  115,
  -85,
  100,
  113,
  -126,
  11,
  54,
  57,
  -74,
  51,
  -41,
  5,
  -66,
  2,
  92,
  -85,
  -113,
  63,
  59,
  25,
  -67,
  -82,
  110,
  -113,
  -87,
  -76,
  81,
  66,
  -31,
  10,
  -89,
  88,
  80,
  -27,
  35,
  -19,
  119,
  119,
  -26,
  81,
  110,
  -116,
  121,
  128,
  -41,
  83,
  -98,
  73,
  -22,
  109,
  25,
  -113,
  54,
  3,
  -19,
  -95,
  10,
  34,
  98,
  -122,
  -104,
  97,
  -54,
  105,
  -23,
  -32,
  -86,
  111,
  -52,
  107,
  7,
  -115,
  -19,
  101,
  3,
  -68,
  -60,
  -6,
  -89,
  -37,
  96,
  72,
  67,
  100,
  -58,
  -19,
  102,
  36,
  -50,
  -31,
  62,
  5,
  91,
  -55,
  127,
  78,
  56,
  -108,
  -116,
  68,
  -16,
  -75,
  -43,
  91,
  116,
  105,
  -58,
  -22,
  -82,
  -113,
  -15,
  41,
  -28,
  -63,
  -10,
  -72,
  100,
  47,
  -36,
  3,
  -3,
  109,
  90,
  -34,
  -93,
  94,
  -21,
  -16,
  107,
  -62,
  -85,
  37,
  96,
  -66,
  32,
  45,
  61,
  16,
  29,
  -49,
  21,
  -30,
  31,
  87,
  11,
  3,
  56,
  87,
  -85,
  85,
  68,
  -108,
  -32,
  33,
  56,
  -4,
  -81,
  100,
  -120,
  70,
  -56,
  9,
  49,
  -4,
  -39,
  -26,
  -56,
  -104,
  -96,
  -80,
  -64,
  -108,
  124,
  -95,
  -3,
  -19,
  -41,
  -32,
  -100,
  -37,
  -97,
  6,
  -77,
  1,
  101,
  19,
  -24,
  67,
  89,
  23,
  -103,
  88,
  -80,
  7,
  46,
  -36,
  115,
  65,
  97,
  26,
  127,
  -107,
  -96,
  108,
  -55,
  -29,
  9,
  102,
  88,
  -76,
  0,
  -3,
  -104,
  99,
  -99,
  24,
  -127,
  54,
  93,
  82,
  122,
  114,
  96,
  -116,
  34,
  -53,
  -114,
  -116,
  8,
  101,
  -60,
  15,
  -125,
  120,
  -21,
  50,
  8,
  13,
  121,
  -77,
  81,
  60,
  123,
  14,
  -112,
  -112,
  -64,
  51,
  94,
  115,
  -26,
  49,
  69,
  113,
  -62,
  -9,
  55,
  -98,
  6,
  64,
  116,
  86,
  63,
  100,
  -48,
  -85,
  -43,
  -74,
  -65,
  -1,
  -78,
  -80,
  89,
  -20,
  126,
  -97,
  -36,
  -17,
  -115,
  -68,
  3,
  32,
  89,
  16,
  56,
  102,
  -79,
  -50,
  -10,
  96,
  -18,
  110,
  -80,
  15,
  -71,
  98,
  -64,
  -107,
  4,
  55,
  -107,
  -19,
  -124,
  56,
  -46,
  58,
  -57,
  106,
  116,
  111,
  18,
  -66,
  128,
  -11,
  82,
  63,
  -116,
  49,
  86,
  -81,
  -111,
  81,
  -38,
  110,
  -119,
  116,
  87,
  16,
  9,
  -34,
  0,
  -106,
  -98,
  23,
  8,
  -3,
  88,
  -71,
  19,
  -110,
  2,
  -73,
  -60,
  116,
  8,
  24,
  -16,
  -58,
  90,
  31,
  80,
  -62,
  -46,
  -93,
  -10,
  -105,
  -1,
  100,
  -127,
  13,
  -48,
  -12,
  121,
  33,
  97,
  -77,
  72,
  -92,
  -109,
  67,
  95,
  120,
  43,
  47,
  30,
  128,
  88,
  73,
  -16,
  -106,
  16,
  18,
  112,
  33,
  -32,
  112,
  -65,
  -103,
  -30,
  -122,
  61,
  60,
  91,
  -13,
  -77,
  66,
  -9,
  -64,
  1,
  -29,
  -33,
  30,
  51,
  -14,
  -1,
  -80,
  -112,
  101,
  -123,
  89,
  58,
  58,
  -78,
  -63,
  -28,
  -114,
  110,
  38,
  -102,
  -96,
  111,
  -80,
  126,
  -107,
  -62,
  -6,
  -49,
  99,
  91,
  -106,
  0,
  -71,
  -115,
  -122,
  20,
  48,
  -16,
  116,
  -11,
  1,
  111,
  -112,
  -120,
  -28,
  -64,
  93,
  -12,
  12,
  115,
  121,
  90,
  51,
  -18,
  -92,
  -120,
  -106,
  1,
  -25,
  -18,
  -123,
  87,
  92,
  63,
  102,
  -30,
  -2,
  -89,
  -24,
  -14,
  -82,
  -82,
  68,
  40,
  -96,
  -37,
  -63,
  80,
  111,
  -110,
  36,
  95,
  15,
  -17,
  93,
  -79,
  -88,
  -113,
  17,
  95,
  -95,
  28,
  -88,
  87,
  85,
  -76,
  113,
  -123,
  -1,
  -53,
  8,
  -5,
  87,
  22,
  -57,
  -113,
  -43,
  94,
  -42,
  13,
  -56,
  128,
  -24,
  30,
  -73,
  109,
  -87,
  -56,
  13,
  110,
  -1,
  93,
  27,
  -103,
  81,
  -80,
  38,
  13,
  89,
  0,
  90,
  -57,
  66,
  -83,
  -56,
  35,
  64,
  12,
  20,
  112,
  3,
  -33,
  28,
  -16,
  -17,
  34,
  67,
  -28,
  -13,
  -66,
  -120,
  85,
  114,
  125,
  -52,
  88,
  87,
  52,
  95,
  74,
  73,
  17,
  66,
  94,
  84,
  94,
  36,
  38,
  -47,
  123,
  128,
  84,
  -111,
  -65,
  -69,
  52,
  -27,
  99,
  16,
  101,
  102,
  21,
  89,
  97,
  -126,
  76,
  -74,
  11,
  58,
  -23,
  96,
  -67,
  116,
  -29,
  -8,
  -57,
  -80,
  84,
  -73,
  77,
  101,
  -127,
  -31,
  -17,
  -43,
  19,
  82,
  -23,
  -86,
  -121,
  -117,
  111,
  -19,
  6,
  57,
  15,
  93,
  -39,
  112,
  -57,
  -102,
  -36,
  -19,
  10,
  -13,
  24,
  54,
  -30,
  -14,
  72,
  -59,
  106,
  43,
  -106,
  -15,
  -97,
  96,
  -44,
  -43,
  24,
  120,
  -51,
  32,
  -90,
  80,
  52,
  123,
  -59,
  105,
  -23,
  -109,
  46,
  98,
  88,
  121,
  22,
  -35,
  71,
  -105,
  11,
  -74,
  -94,
  -71,
  20,
  74,
  -58,
  93,
  -99,
  -63,
  39,
  -46,
  31,
  96,
  -76,
  -23,
  -3,
  89,
  9,
  22,
  110,
  61,
  77,
  -80,
  120,
  71,
  10,
  -94,
  9,
  66,
  -125,
  90,
  54,
  56,
  -55,
  65,
  69,
  103,
  31,
  -6,
  -43,
  41,
  120,
  -119,
  -48,
  36,
  -55,
  100,
  -85,
  64,
  -78,
  30,
  -65,
  49,
  9,
  -89,
  6,
  -103,
  -80,
  8,
  -14,
  -35,
  78,
  79,
  55,
  27,
  63,
  -86,
  -124,
  -99,
  77,
  18,
  -120,
  -106,
  116,
  101,
  7,
  -113,
  -28,
  34,
  48,
  -103,
  77,
  27,
  -75,
  -17,
  -104,
  -104,
  121,
  -78,
  -62,
  -28,
  -27,
  7,
  -118,
  -70,
  29,
  -88,
  67,
  -21,
  14,
  -21,
  -20,
  40,
  -42,
  6,
  -26,
  39,
  -82,
  -71,
  50,
  111,
  79,
  -22,
  106,
  69,
  101,
  118,
  -52,
  120,
  -43,
  -8,
  -25,
  -46,
  88,
  11,
  -61,
  41,
  46,
  47,
  71,
  106,
  32,
  -30,
  -68,
  -57,
  -117,
  111,
  52,
  -6,
  -5,
  17,
  -121,
  -109,
  94,
  -65,
  -114,
  -110,
  116,
  -77,
  84,
  -100,
  112,
  78,
  16,
  76,
  -126,
  127,
  -110,
  11,
  -90,
  125,
  -59,
  25,
  77,
  61,
  -2,
  -70,
  70,
  85,
  -112,
  9,
  26,
  -8,
  110,
  54,
  60,
  -47,
  36,
  -45,
  90,
  91,
  -79,
  40,
  -5,
  64,
  -125,
  54,
  64,
  -29,
  -39,
  -31,
  9,
  -124,
  8,
  19,
  17,
  -34,
  -20,
  72,
  -2,
  -120,
  -120,
  -14,
  -100,
  -32,
  15,
  -66,
  112,
  46,
  28,
  57,
  -86,
  70,
  -83,
  -49,
  -77,
  -48,
  -100,
  -27,
  -22,
  57,
  127,
  74,
  34,
  54,
  121,
  58,
  -89,
  -120,
  47,
  -112,
  13,
  -82,
  60,
  -47,
  90,
  36,
  -87,
  -69,
  106,
  -1,
  103,
  23,
  -33,
  53,
  113,
  -9,
  -69,
  -27,
  96,
  124,
  77,
  -127,
  33,
  -118,
  24,
  -27,
  48,
  105,
  108,
  -29,
  -73,
  -1,
  4,
  -116,
  -51,
  -57,
  127,
  104,
  -12,
  128,
  47,
  15,
  -90,
  -79,
  -42,
  -45,
  69,
  -112,
  55,
  -101,
  -104,
  -91,
  89,
  -90,
  32,
  -19,
  -78,
  -66,
  -58,
  -25,
  18,
  106,
  117,
  -94,
  -103,
  128,
  13,
  -6,
  -109,
  -44,
  -64,
  99,
  -58,
  -81,
  104,
  113,
  -12,
  -27,
  -35,
  -11,
  -126,
  101,
  100,
  -78,
  52,
  16,
  -115,
  116,
  3,
  104,
  -124,
  -3,
  17,
  86,
  -84,
  11,
  -41,
  81,
  70,
  36,
  -55,
  77,
  -46,
  118,
  -76,
  51,
  -123,
  42,
  -14,
  73,
  -87,
  114,
  28,
  -40,
  -46,
  58,
  3,
  123,
  -7,
  -93,
  1,
  -2,
  52,
  24,
  83,
  102,
  106,
  -115,
  -3,
  121,
  -63,
  -77,
  -102,
  98,
  70,
  120,
  88,
  -109,
  -38,
  46,
  42,
  64,
  -68,
  -68,
  -93,
  2,
  -108,
  27,
  -83,
  -12,
  103,
  -107,
  35,
  70,
  37,
  120,
  -79,
  -108,
  -49,
  -88,
  55,
  25,
  69,
  70,
  -101,
  85,
  -12,
  -50,
  -45,
  79,
  -72,
  -75,
  -10,
  -12,
  -15,
  -25,
  68,
  -18,
  3,
  15,
  68,
  5,
  -125,
  15,
  15,
  99,
  -105,
  45,
  -31,
  -79,
  19,
  -87,
  -50,
  87,
  12,
  85,
  116,
  1,
  -31,
  78,
  -99,
  20,
  -64,
  -54,
  11,
  22,
  -91,
  45,
  51,
  28,
  17,
  -36,
  -96,
  85,
  62,
  -86,
  -95,
  62,
  8,
  -16,
  75,
  -105,
  59,
  -92,
  -19,
  -58,
  -1,
  -106,
  68,
  14,
  -9,
  -23,
  -119,
  -104,
  7,
  45,
  -127,
  45,
  -94,
  113,
  38,
  -4,
  59,
  34,
  -53,
  -34,
  126,
  -45,
  -127,
  86,
  59,
  6,
  103,
  -121,
  24,
  50,
  95,
  8,
  -17,
  80,
  65,
  96,
  16,
  -44,
  -51,
  6,
  -62,
  0,
  79,
  -79,
  30,
  40,
  -106,
  98,
  77,
  -83,
  20,
  -78,
  -39,
  -121,
  52,
  127,
  59,
  -90,
  13,
  92,
  -42,
  89,
  35,
  15,
  -79,
  -12,
  -119,
  75,
  117,
  20,
  -43,
  -126,
  66,
  31,
  53,
  -94,
  102,
  75,
  36,
  -73,
  -19,
  41,
  8,
  -126,
  -64,
  32,
  -38,
  7,
  -47,
  92,
  -1,
  -45,
  -54,
  14,
  -5,
  63,
  -37,
  55,
  70,
  89,
  -18,
  25,
  -110,
  114,
  120,
  104,
  45,
  -81,
  -97,
  -49,
  -24,
  -63,
  37,
  -65,
  -107,
  -102,
  -89,
  32,
  -15,
  52,
  -108,
  28,
  -57,
  26,
  1,
  100,
  116,
  83,
  -43,
  -78,
  10,
  77,
  -107,
  38,
  73,
  81,
  -62,
  4,
  -33,
  67,
  -69,
  -121,
  77,
  -115,
  36,
  -118,
  101,
  -89,
  84,
  95,
  -10,
  -94,
  -18,
  71,
  -65,
  -2,
  -20,
  78,
  121,
  44,
  -28,
  43,
  85,
  6,
  37,
  43,
  111,
  -52,
  8,
  1,
  -16,
  73,
  119,
  -44,
  -44,
  -126,
  67,
  55,
  -105,
  61,
  -60,
  -92,
  86,
  -1,
  79,
  57,
  50,
  110,
  -114,
  -78,
  49,
  -100,
  -6,
  38,
  -126,
  71,
  -22,
  2,
  -102,
  75,
  -121,
  -111,
  -78,
  -83,
  -15,
  -20,
  -86,
  44,
  -31,
  -51,
  125,
  -1,
  -13,
  -63,
  -110,
  10,
  2,
  -37,
  41,
  -104,
  -67,
  -123,
  123,
  106,
  -78,
  -10,
  96,
  -118,
  -123,
  95,
  -101,
  7,
  82,
  -5,
  45,
  -116,
  -86,
  -18,
  58,
  39,
  29,
  64,
  -20,
  -65,
  -119,
  43,
  44,
  27,
  2,
  -56,
  -72,
  -126,
  -33,
  -88,
  -86,
  19,
  -10,
  -124,
  -123,
  -20,
  61,
  7,
  101,
  -12,
  -61,
  104,
  75,
  -17,
  -39,
  -102,
  -88,
  -37,
  -115,
  5,
  107,
  -48,
  -82,
  55,
  47,
  -93,
  61,
  -90,
  116,
  40,
  -67,
  -6,
  -110,
  -19,
  88,
  -32,
  59,
  -90,
  58,
  -87,
  10,
  -80,
  108,
  -127,
  -76,
  -71,
  -19,
  18,
  -72,
  -76,
  83,
  71,
  -36,
  -65,
  -10,
  -79,
  75,
  -84,
  73,
  -57,
  -53,
  1,
  110,
  -27,
  1,
  122,
  -33,
  49,
  81,
  115,
  -5,
  22,
  -96,
  51,
  7,
  113,
  -64,
  24,
  5,
  -70,
  -64,
  108,
  7,
  17,
  41,
  -111,
  -60,
  -68,
  45,
  101,
  -14,
  -20,
  -25,
  82,
  -93,
  1,
  -109,
  60,
  37,
  -99,
  37,
  -32,
  35,
  59,
  -6,
  -43,
  -40,
  -5,
  17,
  -26,
  115,
  81,
  -16,
  -96,
  58,
  29,
  26,
  111,
  -62,
  34,
  122,
  125,
  -16,
  -90,
  77,
  -116,
  100,
  -47,
  125,
  83,
  -28,
  19,
  -64,
  114,
  58,
  -24,
  -20,
  -46,
  -10,
  69,
  -110,
  127,
  -14,
  -61,
  29,
  -123,
  122,
  55,
  111,
  -107,
  -23,
  3,
  15,
  -44,
  -65,
  -117,
  -13,
  2,
  -23,
  -21,
  -51,
  14,
  105,
  -68,
  -111,
  43,
  26,
  -12,
  -96,
  -30,
  92,
  -52,
  110,
  -36,
  62,
  30,
  103,
  122,
  -20,
  28,
  72,
  49,
  79,
  -6,
  -14,
  -62,
  -42,
  -117,
  -10,
  58,
  -3,
  32,
  -43,
  -105,
  75,
  -15,
  113,
  -125,
  -97,
  -63,
  29,
  -40,
  -52,
  85,
  -96,
  -86,
  -126,
  -43,
  -46,
  5,
  -46,
  -18,
  25,
  -36,
  84,
  127,
  103,
  73,
  44,
  -125,
  -93,
  50,
  15,
  -12,
  -123,
  122,
  11,
  60,
  -91,
  16,
  45,
  -118,
  66,
  -9,
  -102,
  -52,
  -80,
  -6,
  -13,
  -69,
  -110,
  -65,
  79,
  -51,
  -80,
  61,
  -15,
  77,
  -95,
  28,
  -57,
  -31,
  -68,
  -33,
  -88,
  -23,
  81,
  15,
  -10,
  92,
  105,
  43,
  -117,
  -59,
  -20,
  -112,
  -127,
  -39,
  29,
  -116,
  22,
  101,
  106,
  110,
  116,
  121,
  92,
  9,
  19,
  -114,
  1,
  -58,
  -76,
  111,
  -20,
  3,
  78,
  50,
  -124,
  25,
  -72,
  -83,
  52,
  -116,
  78,
  96,
  57,
  100,
  -13,
  22,
  -97,
  -80,
  116,
  55,
  50,
  -23,
  3,
  8,
  83,
  49,
  69,
  111,
  118,
  30,
  60,
  36,
  98,
  81,
  -6,
  38,
  3,
  46,
  15,
  -90,
  90,
  109,
  -77,
  118,
  -122,
  -56,
  2,
  -105,
  -4,
  -124,
  57,
  13,
  -54,
  -48,
  82,
  -49,
  -115,
  -57,
  18,
  40,
  -50,
  -48,
  -48,
  104,
  -23,
  -121,
  42,
  103,
  39,
  47,
  -30,
  108,
  97,
  -27,
  6,
  108,
  100,
  -26,
  43,
  -109,
  -97,
  -29,
  -17,
  -5,
  92,
  -115,
  -96,
  -64,
  68,
  -47,
  71,
  -8,
  -124,
  -98,
  -7,
  -99,
  -94,
  -75,
  126,
  0,
  -21,
  -114,
  -114,
  27,
  1,
  107,
  43,
  -125,
  74,
  1,
  -32,
  -81,
  103,
  52,
  -71,
  82,
  126,
  -19,
  -7,
  -66,
  -70,
  5,
  51,
  -50,
  -52,
  76,
  74,
  115,
  -114,
  74,
  -17,
  41,
  12,
  -91,
  90,
  -80,
  -16,
  -9,
  110,
  -19,
  2,
  23,
  48,
  -95,
  -64,
  73,
  -13,
  -32,
  114,
  12,
  65,
  -29,
  -107,
  -40,
  -59,
  -80,
  2,
  -113,
  -62,
  -24,
  -42,
  -61,
  -15,
  76,
  18,
  38,
  -96,
  -55,
  -15,
  -31,
  46,
  -83,
  -29,
  127,
  -118,
  -1,
  -83,
  -103,
  36,
  82,
  -98,
  124,
  42,
  -36,
  -20,
  33,
  38,
  104,
  93,
  -73,
  -80,
  -51,
  -75,
  126,
  -6,
  -31,
  -11,
  -33,
  -83,
  3,
  79,
  -22,
  -15,
  -50,
  52,
  4,
  -107,
  9,
  -44,
  99,
  65,
  -20,
  65,
  60,
  56,
  -97,
  22,
  40,
  -102,
  107,
  -116,
  -53,
  -114,
  118,
  121,
  -37,
  -70,
  -30,
  -56,
  30,
  -92,
  -31,
  -123,
  27,
  -2,
  -123,
  -30,
  -60,
  -95,
  1,
  -122,
  3,
  44,
  52,
  -96,
  -55,
  16,
  -56,
  10,
  87,
  -52,
  73,
  -42,
  43,
  -4,
  -60,
  70,
  16,
  -42,
  -88,
  -105,
  -77,
  -39,
  116,
  -87,
  72,
  1,
  50,
  -8,
  -95,
  -125,
  -49,
  -71,
  67,
  80,
  44,
  126,
  -90,
  21,
  28,
  36,
  -71,
  -66,
  30,
  77,
  89,
  54,
  1,
  -99,
  97,
  -66,
  111,
  76,
  -103,
  19,
  -97,
  -115,
  69,
  -44,
  -86,
  -14,
  -95,
  88,
  93,
  16,
  -35,
  -100,
  7,
  -121,
  -62,
  15,
  123,
  -75,
  52,
  -33,
  39,
  87,
  -63,
  -124,
  -76,
  -29,
  -118,
  -14,
  47,
  116,
  -105,
  -11,
  -71,
  -1,
  -49,
  -78,
  -102,
  63,
  -24,
  14,
  -19,
  -15,
  -71,
  -112,
  121,
  -71,
  106,
  -75,
  -73,
  -108,
  -70,
  57,
  97,
  59,
  -5,
  -5,
  111,
  93,
  -82,
  34,
  28,
  -111,
  -98,
  77,
  -47,
  127,
  -10,
  -33,
  80,
  104,
  35,
  -68,
  -1,
  61,
  -113,
  95,
  57,
  -50,
  69,
  -20,
  -125,
  64,
  126,
  -120,
  -103,
  -31,
  39,
  125,
  97,
  98,
  28,
  123,
  71,
  -39,
  41,
  112,
  -59,
  21,
  -122,
  -6,
  113,
  -24,
  -126,
  26,
  36,
  -63,
  121,
  52,
  -124,
  -37,
  -60,
  101,
  100,
  -99,
  -89,
  82,
  -78,
  -62,
  34,
  -73,
  -124,
  -118,
  78,
  -94,
  -4,
  32,
  35,
  -28,
  -11,
  107,
  -35,
  119,
  52,
  24,
  12,
  -46,
  60,
  -53,
  110,
  -53,
  -16,
  -25,
  27,
  64,
  -34,
  -94,
  -123,
  -82,
  14,
  5,
  72,
  38,
  81,
  36,
  125,
  -106,
  -45,
  -21,
  -39,
  60,
  -11,
  -125,
  -3,
  -27,
  82,
  95,
  58,
  3,
  101,
  -38,
  20,
  121,
  128,
  -62,
  22,
  -71,
  51,
  -89,
  -127,
  43,
  -40,
  20,
  -63,
  31,
  -111,
  33,
  -64,
  42,
  -75,
  -86,
  96,
  118,
  86,
  -32,
  -8,
  75,
  -18,
  -6,
  40,
  121,
  43,
  -94,
  -77,
  -118,
  -65,
  -3,
  116,
  -95,
  -38,
  19,
  121,
  57,
  56,
  2,
  52,
  36,
  127,
  82,
  -4,
  40,
  6,
  45,
  78,
  125,
  25,
  125,
  -27,
  -24,
  -83,
  29,
  -110,
  56,
  -114,
  30,
  -56,
  120,
  -100,
  -107,
  -118,
  -77,
  -48,
  -114,
  -31,
  75,
  34,
  -107,
  93,
  24,
  79,
  30,
  73,
  -39,
  36,
  0,
  12,
  101,
  115,
  70,
  53,
  27,
  -36,
  -104,
  -31,
  -67,
  -98,
  127,
  37,
  -124,
  -80,
  8,
  -115,
  94,
  -75,
  -127,
  -68,
  92,
  66,
  90,
  125,
  47,
  61,
  -25,
  60,
  -79,
  13,
  -44,
  26,
  43,
  77,
  106,
  -69,
  -73,
  64,
  -70,
  112,
  -51,
  81,
  -22,
  -92,
  74,
  -15,
  81,
  24,
  -33,
  61,
  13,
  92,
  -6,
  91,
  61,
  125,
  -65,
  26,
  76,
  -62,
  36,
  23,
  -19,
  109,
  40,
  -19,
  -8,
  35,
  -98,
  101,
  -97,
  -38,
  114,
  7,
  128,
  114,
  92,
  8,
  65,
  -91,
  -125,
  88,
  39,
  -103,
  -102,
  -75,
  13,
  -75,
  37,
  -105,
  -82,
  64,
  -100,
  87,
  78,
  -27,
  -121,
  -8,
  91,
  105,
  -80,
  -13,
  111,
  -23,
  27,
  93,
  47,
  -126,
  -83,
  17,
  103,
  17,
  53,
  -63,
  104,
  -58,
  -46,
  55,
  38,
  -14,
  0,
  -88,
  107,
  -3,
  -11,
  -109,
  -122,
  54,
  11,
  -115,
  36,
  -6,
  42,
  24,
  -109,
  74,
  -91,
  -118,
  91,
  -46,
  115,
  -16,
  100,
  95,
  -38,
  -11,
  23,
  -75,
  74,
  -89,
  55,
  -86,
  120,
  -110,
  -94,
  45,
  30,
  109,
  11,
  -95,
  39,
  -121,
  -69,
  67,
  40,
  -109,
  -81,
  5,
  26,
  104,
  -36,
  -122,
  110,
  119,
  74,
  -84,
  -92,
  63,
  -62,
  71,
  75,
  48,
  -1,
  -68,
  88,
  -84,
  97,
  -101,
  92,
  97,
  75,
  -94,
  -8,
  95,
  42,
  27,
  -57,
  54,
  -33,
  7,
  17,
  49,
  -32,
  -77,
  -32,
  -26,
  -15,
  -85,
  -35,
  -37,
  -77,
  31,
  -100,
  -11,
  55,
  -10,
  0,
  -103,
  -93,
  15,
  41,
  -57,
  53,
  -122,
  51,
  -93,
  -78,
  -40,
  -112,
  -115,
  -60,
  -81,
  74,
  -109,
  70,
  32,
  -108,
  -36,
  -85,
  23,
  -9,
  30,
  10,
  49,
  56,
  -119,
  62,
  49,
  19,
  -103,
  -118,
  91,
  56,
  -70,
  53,
  -39,
  126,
  -37,
  26,
  28,
  -54,
  93,
  77,
  97,
  -37,
  -5,
  -37,
  -2,
  -1,
  -71,
  59,
  -87,
  -69,
  -81,
  15,
  64,
  -86,
  37,
  17,
  33,
  70,
  -71,
  -15,
  100,
  24,
  -74,
  -74,
  47,
  123,
  -73,
  -80,
  34,
  -79,
  -124,
  -19,
  19,
  35,
  55,
  -114,
  74,
  24,
  -1,
  -7,
  84,
  -79,
  -93,
  8,
  21,
  76,
  -93,
  81,
  100,
  -85,
  58,
  30,
  61,
  -24,
  4,
  21,
  -42,
  30,
  -108,
  107,
  -50,
  -17,
  32,
  -111,
  17,
  48,
  17,
  -97,
  -23,
  9,
  91,
  13,
  2,
  -29,
  -25,
  -94,
  90,
  118,
  -113,
  -120,
  75,
  -75,
  57,
  -49,
  -109,
  105,
  -61,
  83,
  -71,
  20,
  78,
  18,
  -42,
  22,
  -3,
  80,
  -119,
  126,
  47,
  46,
  -79,
  48,
  -44,
  -85,
  56,
  -75,
  83,
  127,
  -70,
  53,
  -37,
  -59,
  44,
  -65,
  -89,
  30,
  -38,
  52,
  -75,
  -107,
  -117,
  -21,
  112,
  -37,
  112,
  -15,
  116,
  99,
  10,
  -95,
  118,
  20,
  -3,
  -78,
  -77,
  45,
  -124,
  -89,
  -40,
  101,
  116,
  -98,
  18,
  -99,
  -118,
  -84,
  15,
  -55,
  29,
  -65,
  0,
  -121,
  -83,
  37,
  -52,
  49,
  20,
  -59,
  34,
  -108,
  -84,
  5,
  42,
  7,
  90,
  -86,
  -95,
  79,
  -117,
  54,
  27,
  6,
  84,
  -85,
  92,
  -49,
  85,
  101,
  -88,
  -32,
  -98,
  112,
  69,
  -34,
  -59,
  -1,
  -89,
  -19,
  -122,
  48,
  -2,
  -5,
  -95,
  105,
  -18,
  -124,
  -75,
  -8,
  92,
  -82,
  48,
  -15,
  67,
  -39,
  50,
  7,
  85,
  7,
  31,
  -67,
  -51,
  -32,
  26,
  -126,
  23,
  23,
  97,
  -91,
  112,
  102,
  -44,
  24,
  -94,
  51,
  106,
  -13,
  69,
  -29,
  93,
  51,
  -3,
  106,
  127,
  47,
  -37,
  47,
  80,
  37,
  -32,
  -108,
  -119,
  37,
  60,
  -9,
  74,
  118,
  41,
  -49,
  55,
  106,
  -105,
  21,
  58,
  89,
  -33,
  8,
  -92,
  -84,
  -58,
  5,
  -120,
  -93,
  -71,
  28,
  -21,
  76,
  -55,
  40,
  -85,
  72,
  -53,
  -34,
  -29,
  28,
  -75,
  -45,
  -18,
  -29,
  -48,
  -117,
  -87,
  -16,
  -18,
  -49,
  31,
  33,
  81,
  -111,
  -34,
  105,
  51,
  128,
  -96,
  47,
  33,
  -8,
  -122,
  -48,
  -12,
  -74,
  -91,
  -24,
  115,
  55,
  -47,
  -72,
  -75,
  -83,
  -5,
  -3,
  -38,
  121,
  68,
  127,
  -91,
  -110,
  -102,
  -50,
  -68,
  -1,
  48,
  79,
  114,
  9,
  41,
  73,
  53,
  -36,
  -18,
  -96,
  43,
  74,
  97,
  48,
  94,
  -19,
  74,
  -35,
  81,
  -33,
  52,
  46,
  8,
  23,
  95,
  77,
  23,
  -42,
  126,
  -32,
  5,
  -106,
  5,
  51,
  31,
  -94,
  -62,
  5,
  -57,
  -106,
  123,
  98,
  35,
  86,
  -90,
  -54,
  -23,
  -4,
  -41,
  -56,
  -66,
  -106,
  45,
  -98,
  -88,
  34,
  44,
  33,
  92,
  -94,
  -25,
  -96,
  -94,
  -62,
  35,
  -17,
  119,
  -77,
  91,
  64,
  50,
  125,
  -118,
  72,
  -94,
  105,
  19,
  -4,
  40,
  -104,
  37,
  120,
  109,
  17,
  -66,
  -97,
  57,
  -127,
  32,
  -46,
  -31,
  -120,
  -47,
  -97,
  66,
  -67,
  8,
  89,
  21,
  -59,
  31,
  9,
  -31,
  -17,
  83,
  107,
  -52,
  -115,
  30,
  22,
  -104,
  -56,
  -117,
  46,
  52,
  -29,
  -12,
  -33,
  1,
  -35,
  -73,
  87,
  -98,
  -25,
  26,
  -114,
  72,
  18,
  -58,
  -65,
  23,
  95,
  -6,
  -75,
  81,
  -110,
  110,
  69,
  -27,
  94,
  115,
  0,
  -93,
  88,
  -87,
  11,
  59,
  -48,
  115,
  57,
  6,
  -118,
  103,
  113,
  28,
  6,
  -43,
  -24,
  36,
  23,
  106,
  -35,
  18,
  18,
  -46,
  46,
  -7,
  71,
  -9,
  67,
  -64,
  18,
  82,
  95,
  41,
  -90,
  -9,
  -117,
  91,
  3,
  -123,
  30,
  -93,
  59,
  -62,
  -37,
  106,
  -79,
  -8,
  -17,
  -104,
  -127,
  12,
  81,
  2,
  -35,
  18,
  -63,
  -78,
  73,
  -114,
  -122,
  -55,
  99,
  -28,
  -97,
  -35,
  -97,
  99,
  37,
  -72,
  106,
  -85,
  -90,
  109,
  118,
  -74,
  -122,
  117,
  84,
  -10,
  90,
  -7,
  -62,
  -27,
  35,
  101,
  -83,
  111,
  -43,
  78,
  31,
  -16,
  -96,
  -32,
  72,
  -3,
  -104,
  61,
  71,
  36,
  109,
  77,
  -12,
  -86,
  42,
  -77,
  -85,
  112,
  10,
  65,
  -101,
  -15,
  -95,
  -28,
  -92,
  54,
  -47,
  -12,
  99,
  8,
  34,
  5,
  9,
  118,
  77,
  115,
  -47,
  122,
  -13,
  59,
  40,
  115,
  -119,
  86,
  -19,
  68,
  -14,
  -47,
  18,
  -100,
  100,
  -14,
  126,
  -106,
  -4,
  -99,
  41,
  -116,
  75,
  50,
  118,
  -46,
  53,
  3,
  9,
  -67,
  -108,
  -10,
  55,
  61,
  -25,
  -93,
  85,
  -16,
  -106,
  -61,
  -119,
  -68,
  -11,
  45,
  108,
  33,
  70,
  -80,
  -114,
  31,
  -114,
  109,
  -4,
  35,
  38,
  39,
  68,
  127,
  18,
  -117,
  -46,
  -2,
  69,
  -15,
  89,
  14,
  68,
  -6,
  -104,
  -90,
  94,
  125,
  56,
  120,
  -33,
  23,
  -83,
  -12,
  -72,
  82,
  -65,
  109,
  -50,
  26,
  104,
  -5,
  -75,
  90,
  -111,
  -71,
  -85,
  -80,
  106,
  78,
  4,
  18,
  -14,
  61,
  -105,
  72,
  113,
  -1,
  -9,
  1,
  28,
  32,
  -94,
  -104,
  -97,
  -69,
  52,
  -11,
  -12,
  75,
  99,
  -38,
  -19,
  49,
  -30,
  -86,
  -45,
  -107,
  -16,
  -27,
  0,
  58,
  -77,
  -124,
  20,
  88,
  -126,
  24,
  28,
  -61,
  71,
  -68,
  77,
  -83,
  -58,
  -104,
  95,
  -50,
  64,
  -87,
  48,
  78,
  48,
  84,
  65,
  127,
  -57,
  -39,
  4,
  87,
  78,
  96,
  30,
  -66,
  96,
  -52,
  -95,
  73,
  -33,
  -71,
  120,
  -91,
  -112,
  73,
  121,
  92,
  -32,
  -59,
  57,
  35,
  -126,
  8,
  68,
  124,
  42,
  -92,
  26,
  -72,
  23,
  -75,
  29,
  28,
  94,
  48,
  -110,
  -20,
  -68,
  104,
  31,
  -94,
  -117,
  -124,
  96,
  58,
  53,
  39,
  88,
  -87,
  -40,
  37,
  -65,
  -105,
  116,
  29,
  106,
  117,
  69,
  -19,
  -110,
  94,
  6,
  -93,
  26,
  -43,
  -63,
  125,
  11,
  118,
  25,
  78,
  120,
  118,
  103,
  87,
  76,
  -30,
  126,
  54,
  -45,
  -19,
  -36,
  -45,
  -100,
  37,
  -120,
  25,
  -44,
  -61,
  -44,
  20,
  59,
  -39,
  29,
  -114,
  112,
  7,
  -84,
  119,
  -118,
  93,
  -100,
  -61,
  123,
  127,
  -97,
  109,
  39,
  113,
  50,
  77,
  -124,
  -90,
  -8,
  78,
  -8,
  12,
  76,
  64,
  -83,
  40,
  -113,
  -65,
  -26,
  44,
  120,
  -4,
  21,
  -21,
  83,
  77,
  91,
  18,
  -22,
  -123,
  26,
  -36,
  90,
  -64,
  -114,
  -59,
  -62,
  15,
  82,
  -69,
  -125,
  28,
  48,
  103,
  -120,
  73,
  5,
  109,
  -71,
  61,
  -107,
  11,
  86,
  38,
  106,
  54,
  -49,
  86,
  -15,
  -8,
  -1,
  -14,
  -49,
  -78,
  -70,
  -110,
  -50,
  89,
  19,
  106,
  27,
  -96,
  -69,
  -61,
  40,
  32,
  -79,
  -1,
  106,
  3,
  -124,
  -43,
  -16,
  -33,
  -44,
  66,
  71,
  60,
  -62,
  -8,
  -35,
  -101,
  -49,
  72,
  -97,
  19,
  -73,
  9,
  80,
  106,
  -36,
  15,
  -53,
  -26,
  -9,
  -31,
  105,
  -30,
  56,
  -26,
  -94,
  93,
  13,
  80,
  -51,
  98,
  7,
  15,
  111,
  32,
  74,
  104,
  -3,
  101,
  2,
  -124,
  -104,
  80,
  -51,
  60,
  -89,
  127,
  119,
  -51,
  84,
  -85,
  119,
  127,
  29,
  -109,
  -51,
  39,
  1,
  -11,
  38,
  -27,
  -17,
  30,
  33,
  -32,
  23,
  113,
  99,
  63,
  -5,
  18,
  -64,
  -112,
  35,
  9,
  3,
  19,
  -25,
  52,
  76,
  -20,
  -40,
  -44,
  -58,
  -16,
  104,
  -99,
  -37,
  126,
  29,
  73,
  -64,
  82,
  61,
  2,
  63,
  -55,
  101,
  -52,
  -65,
  -114,
  37,
  73,
  -25,
  64,
  119,
  -108,
  104,
  80,
  38,
  43,
  -72,
  55,
  -98,
  13,
  53,
  -122,
  49,
  -47,
  -48,
  46,
  -61,
  -68,
  102,
  3,
  -68,
  -111,
  48,
  68,
  -87,
  94,
  -37,
  -87,
  -116,
  -115,
  -102,
  109,
  12,
  -91,
  -80,
  7,
  25,
  99,
  54,
  -103,
  -113,
  -97,
  -47,
  -43,
  -21,
  -28,
  16,
  9,
  122,
  -50,
  119,
  -110,
  -77,
  -58,
  93,
  -36,
  -78,
  -29,
  -101,
  -3,
  -39,
  27,
  59,
  -21,
  3,
  50,
  -38,
  1,
  97,
  -4,
  -36,
  20,
  65,
  -1,
  -125,
  -88,
  77,
  8,
  -98,
  27,
  -61,
  -28,
  -122,
  -15,
  119,
  -6,
  -27,
  -30,
  -37,
  82,
  68,
  -87,
  78,
  -105,
  -35,
  107,
  -38,
  -33,
  -21,
  -51,
  87,
  -102,
  -120,
  15,
  -110,
  -107,
  -17,
  3,
  -35,
  -53,
  -50,
  110,
  121,
  19,
  116,
  42,
  76,
  36,
  -78,
  121,
  108,
  108,
  104,
  0,
  -39,
  76,
  -63,
  100,
  73,
  116,
  -1,
  -4,
  3,
  -19,
  -77,
  -31,
  78,
  111,
  -12,
  61,
  115,
  -88,
  -97,
  -125,
  112,
  -94,
  -3,
  77,
  -17,
  51,
  9,
  -118,
  83,
  -24,
  97,
  -126,
  56,
  23,
  -67,
  103,
  87,
  92,
  122,
  9,
  -77,
  127,
  69,
  -48,
  -33,
  9,
  -21,
  -59,
  -52,
  -123,
  -119,
  102,
  72,
  -17,
  -51,
  4,
  97,
  125,
  -33,
  -119,
  -78,
  121,
  58,
  -72,
  71,
  -52,
  55,
  57,
  -113,
  -90,
  88,
  71,
  -53,
  27,
  58,
  -65,
  -125,
  16,
  17,
  122,
  91,
  -69,
  -57,
  40,
  67,
  -16,
  -114,
  107,
  -16,
  101,
  18,
  103,
  -13,
  81,
  -98,
  101,
  -69,
  -27,
  -9,
  -54,
  91,
  57,
  -64,
  -9,
  73,
  77,
  -34,
  34,
  -10,
  -91,
  -59,
  11,
  22,
  6,
  -66,
  -47,
  22,
  -10,
  -41,
  78,
  -111,
  2,
  24,
  115,
  1,
  -113,
  -27,
  -73,
  23,
  37,
  47,
  -40,
  67,
  1,
  99,
  -79,
  92,
  27,
  -49,
  7,
  44,
  -125,
  121,
  -82,
  3,
  -36,
  -110,
  -38,
  -13,
  23,
  87,
  90,
  -96,
  26,
  34,
  -41,
  -125,
  92,
  -64,
  -99,
  -121,
  -126,
  38,
  116,
  124,
  -4,
  -77,
  13,
  33,
  8,
  98,
  82,
  122,
  49,
  -49,
  78,
  -44,
  -116,
  15,
  82,
  -72,
  44,
  117,
  -95,
  -66,
  18,
  30,
  -107,
  15,
  59,
  95,
  49,
  0,
  78,
  23,
  28,
  -52,
  47,
  -104,
  -34,
  -66,
  59,
  -33,
  -113,
  90,
  35,
  56,
  60,
  -76,
  116,
  -87,
  -109,
  -55,
  -22,
  -92,
  2,
  97,
  105,
  -122,
  -72,
  -23,
  -18,
  71,
  113,
  -101,
  -84,
  24,
  -43,
  82,
  -4,
  -19,
  28,
  103,
  66,
  104,
  91,
  37,
  -72,
  37,
  -85,
  -121,
  -88,
  120,
  -84,
  -53,
  111,
  -105,
  91,
  -37,
  -92,
  4,
  125,
  59,
  127,
  -24,
  -18,
  7,
  35,
  22,
  -108,
  -9,
  109,
  -24,
  92,
  -20,
  65,
  -32,
  -124,
  43,
  -53,
  25,
  -97,
  59,
  -99,
  -114,
  59,
  18,
  72,
  69,
  101,
  -125,
  -57,
  38,
  -18,
  33,
  -90,
  39,
  83,
  -25,
  -104,
  54,
  -54,
  91,
  -22,
  66,
  7,
  73,
  -45,
  110,
  52,
  101,
  30,
  -83,
  17,
  -109,
  -42,
  -23,
  -69,
  -21,
  -10,
  -4,
  70,
  28,
  48,
  6,
  102,
  -124,
  -33,
  -112,
  117,
  57,
  93,
  -118,
  101,
  -118,
  -55,
  -92,
  -15,
  116,
  56,
  -25,
  -15,
  25,
  -49,
  -10,
  -14,
  5,
  62,
  7,
  -37,
  104,
  78,
  113,
  1,
  -114,
  45,
  -9,
  14,
  -83,
  -11,
  96,
  73,
  31,
  -88,
  110,
  -83,
  62,
  -80,
  -79,
  30,
  68,
  63,
  112,
  47,
  68,
  -30,
  12,
  91,
  42,
  -97,
  -34,
  14,
  4,
  -85,
  17,
  0,
  43,
  107,
  -38,
  41,
  -78,
  -76,
  18,
  102,
  93,
  -118,
  -83,
  -72,
  96,
  39,
  9,
  40,
  46,
  13,
  -53,
  57,
  82,
  -50,
  102,
  -110,
  -99,
  -94,
  21,
  81,
  119,
  14,
  -112,
  -36,
  -14,
  -11,
  -46,
  -99,
  -92,
  74,
  73,
  43,
  -67,
  -11,
  -18,
  -88,
  104,
  57,
  -38,
  -84,
  -6,
  77,
  126,
  -126,
  105,
  -111,
  -96,
  0,
  42,
  124,
  20,
  83,
  28,
  98,
  21,
  102,
  -92,
  -74,
  -89,
  -29,
  58,
  12,
  -46,
  75,
  -110,
  -112,
  117,
  -21,
  44,
  121,
  -93,
  107,
  44,
  126,
  -120,
  119,
  -98,
  78,
  53,
  107,
  117,
  -116,
  -11,
  66,
  42,
  51,
  114,
  4,
  128,
  128,
  3,
  -104,
  -46,
  -72,
  9,
  -47,
  123,
  37,
  21,
  -3,
  45,
  -125,
  13,
  -19,
  -42,
  -103,
  114,
  25,
  -113,
  -75,
  -1,
  -109,
  36,
  73,
  -35,
  -44,
  38,
  54,
  80,
  4,
  90,
  16,
  9,
  -24,
  105,
  47,
  83,
  117,
  -72,
  10,
  6,
  21,
  81,
  45,
  76,
  41,
  100,
  -75,
  40,
  -100,
  -21,
  -51,
  106,
  29,
  -126,
  -39,
  31,
  5,
  -15,
  -89,
  14,
  -94,
  77,
  -58,
  -91,
  -79,
  -61,
  -63,
  -47,
  -91,
  28,
  -95,
  55,
  -21,
  -80,
  119,
  -50,
  125,
  -27,
  -70,
  -11,
  22,
  -111,
  -66,
  67,
  -78,
  -25,
  2,
  -105,
  34,
  40,
  -28,
  -119,
  -36,
  -98,
  23,
  -54,
  125,
  6,
  70,
  -6,
  67,
  -34,
  -52,
  77,
  -2,
  -100,
  51,
  -89,
  -80,
  -27,
  -83,
  32,
  -100,
  -60,
  -49,
  -126,
  -74,
  -5,
  -125,
  -2,
  100,
  104,
  -28,
  -81,
  56,
  124,
  53,
  -88,
  59,
  83,
  -1,
  118,
  39,
  50,
  -33,
  107,
  -80,
  100,
  -116,
  -79,
  97,
  92,
  28,
  55,
  -28,
  73,
  101,
  -46,
  -12,
  -118,
  -90,
  32,
  -98,
  10,
  114,
  121,
  -88,
  82,
  34,
  -118,
  42,
  58,
  59,
  -9,
  49,
  65,
  -93,
  -11,
  -62,
  71,
  25,
  -44,
  111,
  89,
  22,
  62,
  29,
  69,
  -26,
  114,
  -107,
  -69,
  -86,
  -97,
  -125,
  -29,
  -112,
  43,
  52,
  27,
  -12,
  -104,
  -20,
  40,
  -49,
  98,
  87,
  127,
  -89,
  2,
  -93,
  67,
  95,
  74,
  85,
  -44,
  -41,
  2,
  34,
  88,
  85,
  34,
  25,
  -108,
  92,
  83,
  95,
  2,
  89,
  -100,
  74,
  -87,
  -35,
  -121,
  64,
  -83,
  80,
  -124,
  -42,
  46,
  -100,
  86,
  57,
  -99,
  26,
  -16,
  103,
  108,
  -32,
  82,
  70,
  -114,
  -61,
  -113,
  61,
  -98,
  13,
  -62,
  6,
  5,
  19,
  -82,
  -48,
  -14,
  20,
  -19,
  93,
  -14,
  -97,
  16,
  66,
  87,
  63,
  29,
  -45,
  -39,
  -106,
  -12,
  93,
  128,
  -118,
  -113,
  120,
  32,
  -6,
  14,
  -120,
  50,
  92,
  9,
  106,
  -76,
  49,
  -93,
  106,
  -113,
  -32,
  -53,
  15,
  -5,
  -127,
  -82,
  28,
  -6,
  -52,
  82,
  123,
  83,
  -64,
  -81,
  -67,
  -75,
  -116,
  59,
  106,
  -73,
  -26,
  -71,
  -25,
  5,
  -23,
  -117,
  -41,
  -53,
  71,
  -59,
  117,
  13,
  35,
  34,
  65,
  -95,
  108,
  98,
  75,
  42,
  -55,
  8,
  -71,
  -103,
  -113,
  70,
  -15,
  -69,
  11,
  104,
  -89,
  -3,
  -1,
  52,
  88,
  34,
  -99,
  114,
  57,
  96,
  -3,
  -18,
  32,
  -42,
  97,
  6,
  -31,
  9,
  -69,
  -116,
  -107,
  96,
  117,
  -90,
  92,
  -112,
  -95,
  9,
  54,
  47,
  52,
  126,
  125,
  -27,
  -118,
  -85,
  16,
  -99,
  -109,
  126,
  78,
  -78,
  47,
  106,
  -10,
  127,
  -127,
  37,
  -34,
  12,
  6,
  123,
  -30,
  -85,
  -90,
  -71,
  90,
  -66,
  -91,
  61,
  106,
  32,
  -109,
  -63,
  47,
  -113,
  -50,
  34,
  -80,
  -101,
  69,
  -18,
  -127,
  -33,
  -8,
  -84,
  -120,
  -18,
  -36,
  -51,
  -108,
  44,
  95,
  -94,
  56,
  39,
  -22,
  -61,
  -52,
  95,
  121,
  86,
  26,
  65,
  122,
  85,
  -76,
  -21,
  79,
  41,
  -7,
  7,
  -35,
  12,
  -103,
  56,
  -111,
  29,
  51,
  97,
  112,
  6,
  37,
  66,
  99,
  12,
  -5,
  27,
  -79,
  35,
  82,
  -5,
  70,
  104,
  18,
  -61,
  78,
  -25,
  -11,
  -124,
  78,
  -57,
  66,
  44,
  104,
  115,
  108,
  36,
  -27,
  -38,
  -113,
  33,
  55,
  32,
  -85,
  -28,
  -103,
  -70,
  -12,
  -83,
  42,
  -101,
  -38,
  83,
  -51,
  -50,
  35,
  -65,
  -125,
  -49,
  -24,
  19,
  -114,
  83,
  91,
  108,
  41,
  61,
  -45,
  120,
  75,
  -18,
  48,
  -81,
  44,
  -53,
  -37,
  70,
  82,
  -118,
  -7,
  -84,
  124,
  -17,
  -125,
  79,
  -6,
  123,
  28,
  -99,
  -81,
  -31,
  51,
  -44,
  -70,
  -98,
  123,
  14,
  -26,
  -59,
  25,
  -8,
  -88,
  -45,
  -24,
  -55,
  -56,
  -22,
  110,
  -85,
  72,
  -23,
  35,
  -67,
  38,
  -42,
  8,
  -46,
  -46,
  -96,
  -31,
  85,
  19,
  -100,
  25,
  77,
  0,
  -80,
  27,
  88,
  -64,
  -25,
  -103,
  120,
  26,
  -34,
  122,
  -23,
  -1,
  -81,
  91,
  -79,
  -36,
  109,
  -59,
  -76,
  -100,
  -29,
  -111,
  37,
  75,
  -70,
  -94,
  -34,
  126,
  94,
  -52,
  82,
  -113,
  113,
  96,
  -10,
  -12,
  -79,
  25,
  -97,
  -35,
  -119,
  -105,
  52,
  -22,
  -110,
  -15,
  -105,
  46,
  -11,
  -115,
  -5,
  102,
  93,
  8,
  8,
  -24,
  8,
  -55,
  51,
  -113,
  84,
  86,
  17,
  -121,
  -74,
  -63,
  -107,
  -98,
  72,
  -65,
  -52,
  31,
  -47,
  -34,
  -5,
  -20,
  2,
  -42,
  13,
  -70,
  -113,
  -23,
  -45,
  70,
  11,
  -74,
  -4,
  82,
  -9,
  2,
  21,
  -77,
  -93,
  -55,
  -124,
  -25,
  112,
  126,
  89,
  -79,
  124,
  -35,
  14,
  12,
  -57,
  -15,
  -54,
  -22,
  119,
  -17,
  -123,
  -90,
  -89,
  -83,
  28,
  -42,
  6,
  -10,
  82,
  -48,
  119,
  67,
  86,
  65,
  -65,
  -39,
  -54,
  -127,
  -64,
  110,
  -75,
  -121,
  10,
  17,
  0,
  -89,
  -87,
  -44,
  88,
  -57,
  114,
  -68,
  -39,
  105,
  44,
  -90,
  -95,
  -108,
  121,
  86,
  -54,
  -34,
  -53,
  36,
  67,
  -7,
  -90,
  38,
  -71,
  103,
  -22,
  55,
  -20,
  -106,
  -95,
  -42,
  -91,
  -66,
  94,
  -101,
  -21,
  46,
  33,
  105,
  -18,
  83,
  -90,
  -116,
  70,
  79,
  26,
  106,
  63,
  -61,
  97,
  106,
  58,
  -43,
  20,
  88,
  -116,
  100,
  19,
  104,
  -109,
  -55,
  75,
  -110,
  -57,
  -90,
  118,
  75,
  97,
  96,
  4,
  69,
  -106,
  -78,
  -45,
  33,
  -33,
  99,
  95,
  -45,
  20,
  104,
  115,
  -103,
  -107,
  99,
  36,
  -26,
  -125,
  60,
  56,
  -121,
  -36,
  11,
  -92,
  111,
  -3
}; // weak
_BYTE _firmware_update_e[13936] =
{
  -48,
  100,
  89,
  33,
  99,
  -18,
  -75,
  99,
  73,
  -64,
  -16,
  -125,
  55,
  -10,
  -123,
  -51,
  57,
  97,
  64,
  72,
  -113,
  -127,
  -80,
  78,
  72,
  -24,
  -44,
  20,
  87,
  69,
  72,
  14,
  120,
  -32,
  -13,
  -11,
  11,
  97,
  -111,
  -9,
  -29,
  76,
  -108,
  94,
  -115,
  -50,
  -50,
  48,
  -112,
  41,
  -40,
  -77,
  93,
  -9,
  26,
  45,
  9,
  -11,
  -61,
  56,
  22,
  -109,
  -37,
  114,
  -52,
  47,
  -49,
  20,
  -111,
  -9,
  -77,
  81,
  -60,
  13,
  116,
  -95,
  67,
  -42,
  65,
  89,
  -112,
  -121,
  -98,
  -109,
  -32,
  -123,
  -12,
  -85,
  -53,
  -16,
  -38,
  -56,
  85,
  -61,
  20,
  40,
  75,
  -50,
  89,
  20,
  4,
  127,
  65,
  21,
  79,
  68,
  5,
  100,
  -41,
  82,
  23,
  46,
  118,
  -5,
  -16,
  92,
  49,
  72,
  -66,
  -95,
  48,
  -85,
  -121,
  24,
  64,
  8,
  17,
  -109,
  -86,
  -10,
  -16,
  -124,
  34,
  91,
  92,
  57,
  78,
  29,
  90,
  59,
  113,
  111,
  -3,
  -56,
  -49,
  22,
  25,
  -81,
  -125,
  -97,
  -57,
  -103,
  -27,
  46,
  -42,
  83,
  -123,
  -84,
  -77,
  87,
  56,
  -16,
  -3,
  -76,
  -61,
  122,
  99,
  -82,
  20,
  -67,
  22,
  68,
  -57,
  -88,
  -69,
  110,
  -35,
  -63,
  7,
  -75,
  -98,
  61,
  -37,
  -23,
  54,
  -7,
  -31,
  42,
  3,
  -40,
  -58,
  -66,
  110,
  -20,
  42,
  -44,
  22,
  82,
  -107,
  -115,
  40,
  -29,
  -80,
  -92,
  -68,
  112,
  118,
  73,
  -73,
  -78,
  124,
  -20,
  -102,
  -38,
  70,
  -67,
  -111,
  -10,
  -91,
  95,
  -64,
  92,
  45,
  107,
  -125,
  104,
  83,
  -94,
  -31,
  -9,
  -63,
  -48,
  10,
  -28,
  91,
  -3,
  -74,
  67,
  -126,
  -87,
  2,
  17,
  43,
  -65,
  -47,
  25,
  -15,
  -92,
  -67,
  -44,
  -72,
  97,
  53,
  77,
  52,
  -20,
  106,
  8,
  57,
  44,
  105,
  -42,
  124,
  99,
  11,
  30,
  -56,
  125,
  19,
  41,
  56,
  8,
  40,
  -114,
  3,
  -29,
  -51,
  -36,
  60,
  79,
  -63,
  -13,
  20,
  120,
  -29,
  80,
  64,
  45,
  -27,
  -82,
  -50,
  -96,
  78,
  27,
  -30,
  -15,
  89,
  9,
  -87,
  31,
  7,
  -53,
  -69,
  35,
  54,
  -97,
  -27,
  128,
  -121,
  -15,
  11,
  -1,
  93,
  -7,
  25,
  -58,
  -117,
  -116,
  -31,
  -72,
  -5,
  77,
  12,
  -84,
  18,
  -90,
  70,
  76,
  10,
  86,
  -110,
  79,
  9,
  -62,
  111,
  28,
  -79,
  -87,
  -65,
  -105,
  23,
  49,
  63,
  -120,
  4,
  39,
  30,
  28,
  24,
  16,
  51,
  -16,
  125,
  -77,
  -84,
  -57,
  75,
  84,
  -67,
  24,
  66,
  122,
  -76,
  -125,
  15,
  39,
  47,
  70,
  58,
  64,
  113,
  -24,
  32,
  63,
  -35,
  -61,
  -80,
  -112,
  -82,
  95,
  102,
  -34,
  -121,
  -106,
  -48,
  1,
  -21,
  -47,
  5,
  -6,
  23,
  76,
  -89,
  -82,
  115,
  -119,
  75,
  -25,
  60,
  -102,
  4,
  12,
  95,
  -69,
  21,
  -63,
  -76,
  -4,
  22,
  -119,
  33,
  -54,
  97,
  -127,
  66,
  9,
  -73,
  89,
  79,
  66,
  7,
  38,
  -29,
  67,
  49,
  66,
  65,
  4,
  1,
  -63,
  -12,
  91,
  -73,
  -57,
  -105,
  105,
  -73,
  29,
  65,
  -92,
  84,
  90,
  93,
  -56,
  96,
  37,
  90,
  77,
  -125,
  -106,
  81,
  3,
  -34,
  -50,
  -7,
  1,
  -5,
  -104,
  91,
  106,
  -20,
  -8,
  -110,
  -73,
  -123,
  96,
  -125,
  12,
  3,
  -115,
  58,
  -75,
  -21,
  7,
  121,
  -37,
  -119,
  -116,
  64,
  107,
  -24,
  20,
  82,
  -125,
  -26,
  -50,
  -113,
  -38,
  -45,
  -99,
  67,
  -108,
  102,
  74,
  66,
  14,
  -90,
  83,
  -52,
  44,
  11,
  110,
  -83,
  26,
  118,
  43,
  22,
  -104,
  -30,
  100,
  -126,
  -115,
  121,
  -19,
  0,
  -4,
  -90,
  43,
  -13,
  -27,
  -9,
  4,
  67,
  -32,
  127,
  122,
  -20,
  110,
  -45,
  24,
  99,
  -46,
  72,
  127,
  97,
  -29,
  -101,
  -114,
  98,
  -99,
  65,
  -48,
  93,
  -43,
  -113,
  -3,
  106,
  -49,
  32,
  67,
  28,
  -1,
  4,
  117,
  66,
  7,
  -50,
  -56,
  87,
  -89,
  51,
  81,
  -5,
  -48,
  79,
  99,
  72,
  22,
  109,
  109,
  4,
  124,
  124,
  -52,
  7,
  -85,
  -120,
  -4,
  -93,
  110,
  118,
  71,
  -38,
  99,
  77,
  -82,
  -13,
  72,
  -38,
  122,
  -43,
  -27,
  42,
  77,
  96,
  113,
  94,
  -4,
  51,
  -126,
  -47,
  59,
  59,
  -39,
  25,
  -126,
  57,
  -100,
  59,
  14,
  -36,
  -55,
  95,
  -94,
  13,
  91,
  -46,
  -40,
  -48,
  18,
  20,
  13,
  -44,
  -110,
  -28,
  93,
  18,
  36,
  -68,
  57,
  -83,
  -26,
  22,
  -10,
  -107,
  -8,
  24,
  -123,
  -65,
  -110,
  34,
  -59,
  -52,
  -30,
  30,
  -125,
  46,
  92,
  69,
  -71,
  -10,
  53,
  90,
  -126,
  -107,
  55,
  -51,
  -53,
  -74,
  125,
  71,
  128,
  111,
  118,
  41,
  9,
  128,
  -81,
  -81,
  6,
  89,
  -46,
  -45,
  -99,
  32,
  43,
  -81,
  126,
  14,
  -13,
  -61,
  -88,
  7,
  -26,
  -25,
  108,
  -24,
  112,
  -96,
  80,
  -48,
  33,
  -63,
  70,
  4,
  -3,
  40,
  -108,
  -117,
  55,
  121,
  -53,
  65,
  60,
  -64,
  29,
  -106,
  55,
  97,
  -95,
  62,
  44,
  -99,
  -62,
  49,
  34,
  -48,
  116,
  -4,
  98,
  -109,
  128,
  126,
  -14,
  -52,
  -126,
  60,
  40,
  -10,
  -48,
  17,
  -102,
  -95,
  -86,
  121,
  -32,
  24,
  7,
  -52,
  88,
  -105,
  -100,
  -104,
  84,
  -5,
  123,
  -37,
  31,
  -55,
  -123,
  -84,
  -31,
  -74,
  -126,
  -12,
  62,
  44,
  26,
  65,
  8,
  -68,
  -65,
  9,
  41,
  -108,
  32,
  -116,
  29,
  -98,
  -6,
  -73,
  -29,
  -97,
  -76,
  118,
  45,
  -93,
  10,
  30,
  -50,
  -117,
  -122,
  84,
  45,
  40,
  -126,
  -18,
  2,
  68,
  29,
  -13,
  -39,
  106,
  -32,
  115,
  5,
  54,
  -111,
  -116,
  -117,
  -92,
  -46,
  -32,
  123,
  -110,
  -62,
  98,
  -31,
  79,
  27,
  50,
  100,
  -36,
  -27,
  82,
  64,
  121,
  -3,
  16,
  -25,
  -3,
  -127,
  -46,
  83,
  -115,
  -49,
  117,
  102,
  -3,
  -65,
  67,
  79,
  -91,
  -122,
  -108,
  -94,
  -34,
  113,
  82,
  -107,
  39,
  5,
  -117,
  -22,
  -52,
  -82,
  -57,
  -4,
  -98,
  96,
  53,
  53,
  71,
  -52,
  -10,
  103,
  -29,
  -124,
  -97,
  -36,
  22,
  -104,
  -99,
  110,
  26,
  -7,
  -6,
  -102,
  -96,
  -110,
  9,
  32,
  -21,
  -12,
  -67,
  12,
  26,
  74,
  -30,
  53,
  33,
  -51,
  -97,
  115,
  83,
  -47,
  35,
  -30,
  43,
  -48,
  -14,
  10,
  72,
  -97,
  -103,
  -94,
  40,
  -111,
  71,
  114,
  116,
  74,
  44,
  -113,
  -85,
  -112,
  112,
  -107,
  77,
  7,
  8,
  -2,
  55,
  109,
  40,
  -95,
  -80,
  -4,
  -46,
  20,
  -39,
  51,
  -34,
  -19,
  75,
  -62,
  -43,
  107,
  32,
  -86,
  57,
  28,
  -29,
  -101,
  40,
  -15,
  -24,
  -69,
  61,
  90,
  124,
  -73,
  -123,
  -17,
  -21,
  -83,
  79,
  -35,
  -99,
  53,
  79,
  18,
  110,
  -122,
  105,
  -6,
  -96,
  -126,
  -82,
  -31,
  79,
  -116,
  55,
  -71,
  -97,
  -73,
  55,
  94,
  81,
  -11,
  -107,
  -7,
  -82,
  -70,
  -74,
  99,
  -102,
  -37,
  -95,
  -24,
  24,
  45,
  57,
  -67,
  107,
  -112,
  6,
  117,
  43,
  -112,
  -119,
  -33,
  -78,
  -54,
  52,
  74,
  34,
  -99,
  -38,
  91,
  27,
  11,
  -40,
  -127,
  -38,
  72,
  -118,
  65,
  13,
  76,
  92,
  8,
  -114,
  25,
  -62,
  -45,
  38,
  20,
  -18,
  -122,
  -69,
  -125,
  -6,
  -87,
  -108,
  24,
  34,
  -15,
  112,
  71,
  -103,
  80,
  58,
  107,
  58,
  62,
  24,
  -98,
  103,
  47,
  108,
  -32,
  -123,
  -62,
  -37,
  -107,
  -115,
  -38,
  97,
  -62,
  44,
  6,
  -58,
  121,
  -78,
  -57,
  -60,
  49,
  -77,
  25,
  -100,
  112,
  96,
  11,
  13,
  7,
  65,
  -105,
  -117,
  -24,
  109,
  1,
  -37,
  -88,
  -90,
  1,
  95,
  -3,
  -20,
  61,
  -18,
  -53,
  88,
  -62,
  -52,
  82,
  55,
  80,
  -57,
  119,
  58,
  22,
  48,
  2,
  -94,
  86,
  -33,
  -50,
  -73,
  102,
  -17,
  88,
  -65,
  -30,
  -2,
  -123,
  -96,
  108,
  18,
  115,
  92,
  -54,
  123,
  -111,
  11,
  105,
  -99,
  -63,
  -34,
  49,
  -60,
  2,
  95,
  -89,
  56,
  117,
  35,
  9,
  -19,
  -111,
  81,
  -65,
  -24,
  125,
  -53,
  -4,
  -38,
  -43,
  47,
  -103,
  -94,
  16,
  54,
  -8,
  29,
  85,
  -64,
  -70,
  97,
  -17,
  -107,
  -86,
  41,
  -23,
  121,
  58,
  -13,
  -16,
  62,
  120,
  12,
  -80,
  53,
  -109,
  -80,
  -4,
  -79,
  24,
  123,
  -72,
  -54,
  -27,
  -3,
  102,
  -74,
  40,
  45,
  -81,
  -56,
  -122,
  -87,
  85,
  45,
  -54,
  58,
  82,
  24,
  -88,
  -21,
  -79,
  87,
  -73,
  -58,
  -53,
  -43,
  -23,
  -66,
  82,
  116,
  -109,
  -40,
  -115,
  -57,
  -121,
  -46,
  -42,
  -5,
  1,
  10,
  117,
  -99,
  82,
  116,
  -109,
  -25,
  40,
  -106,
  85,
  -13,
  24,
  47,
  -19,
  9,
  26,
  -53,
  -31,
  46,
  109,
  101,
  -17,
  49,
  86,
  -60,
  -70,
  128,
  -69,
  -8,
  -69,
  59,
  27,
  -45,
  36,
  -9,
  -47,
  118,
  -18,
  22,
  -86,
  -52,
  -91,
  111,
  53,
  58,
  -74,
  -121,
  76,
  -70,
  121,
  -6,
  25,
  23,
  114,
  36,
  40,
  56,
  -32,
  -76,
  14,
  101,
  14,
  16,
  98,
  48,
  114,
  -120,
  54,
  -66,
  87,
  75,
  18,
  50,
  -2,
  -120,
  -98,
  1,
  -49,
  92,
  -75,
  -126,
  -74,
  51,
  -95,
  89,
  -43,
  118,
  -86,
  48,
  22,
  -111,
  101,
  -66,
  68,
  118,
  -94,
  -66,
  -14,
  -11,
  -126,
  55,
  42,
  106,
  -21,
  57,
  -62,
  -92,
  127,
  128,
  107,
  -36,
  -25,
  -114,
  -25,
  76,
  62,
  -31,
  -2,
  19,
  -46,
  -13,
  -40,
  72,
  -84,
  -63,
  101,
  -47,
  -75,
  -22,
  15,
  -84,
  8,
  13,
  77,
  93,
  97,
  -108,
  72,
  76,
  -24,
  116,
  -101,
  -72,
  30,
  -18,
  97,
  92,
  122,
  39,
  113,
  94,
  -75,
  0,
  54,
  63,
  -34,
  23,
  31,
  -86,
  -70,
  13,
  -21,
  -31,
  -52,
  14,
  65,
  93,
  -66,
  -9,
  46,
  -78,
  -121,
  -8,
  98,
  116,
  -31,
  93,
  -14,
  39,
  113,
  -13,
  -12,
  -1,
  -109,
  -20,
  -118,
  68,
  83,
  100,
  -127,
  61,
  -2,
  104,
  -39,
  -37,
  -12,
  -115,
  122,
  46,
  77,
  -45,
  97,
  128,
  -94,
  47,
  69,
  111,
  -27,
  77,
  37,
  86,
  98,
  41,
  36,
  72,
  59,
  -72,
  -21,
  -104,
  -2,
  -119,
  -29,
  -93,
  -98,
  119,
  111,
  -102,
  -75,
  -32,
  106,
  -11,
  -69,
  -71,
  -58,
  -120,
  -33,
  -83,
  -62,
  -125,
  -116,
  -85,
  22,
  81,
  -97,
  77,
  -73,
  3,
  95,
  -68,
  -62,
  -52,
  -26,
  -115,
  -37,
  61,
  62,
  14,
  -61,
  3,
  119,
  -26,
  -52,
  113,
  79,
  -52,
  82,
  49,
  -46,
  38,
  43,
  54,
  59,
  16,
  83,
  7,
  -77,
  60,
  87,
  -97,
  8,
  127,
  71,
  -11,
  -93,
  -29,
  96,
  128,
  -56,
  -114,
  -98,
  82,
  -77,
  -123,
  -83,
  -111,
  -43,
  -3,
  119,
  101,
  30,
  -2,
  56,
  -82,
  39,
  9,
  30,
  86,
  109,
  115,
  51,
  -54,
  14,
  -78,
  2,
  39,
  44,
  -16,
  -83,
  -44,
  98,
  64,
  69,
  14,
  124,
  -86,
  -4,
  37,
  100,
  23,
  103,
  83,
  -92,
  112,
  38,
  66,
  -36,
  -127,
  -55,
  -36,
  -92,
  -76,
  82,
  13,
  -76,
  102,
  9,
  107,
  43,
  -54,
  -87,
  50,
  -114,
  14,
  6,
  127,
  -12,
  -28,
  -120,
  97,
  2,
  47,
  96,
  -101,
  111,
  56,
  -25,
  -13,
  -32,
  106,
  59,
  54,
  -4,
  41,
  -31,
  -102,
  -107,
  82,
  -59,
  -88,
  110,
  17,
  -44,
  5,
  73,
  -97,
  -36,
  -27,
  107,
  -4,
  -40,
  80,
  51,
  30,
  -13,
  118,
  79,
  2,
  111,
  99,
  56,
  -11,
  -122,
  -27,
  -111,
  -55,
  -46,
  -18,
  53,
  -28,
  76,
  -94,
  95,
  100,
  -125,
  -3,
  86,
  -71,
  -11,
  -53,
  -27,
  54,
  65,
  -33,
  -59,
  42,
  -18,
  -81,
  72,
  20,
  -107,
  91,
  102,
  -108,
  9,
  -80,
  -99,
  99,
  -50,
  -78,
  -50,
  -107,
  -101,
  42,
  -108,
  67,
  60,
  8,
  15,
  66,
  124,
  18,
  -52,
  -36,
  99,
  -5,
  13,
  -80,
  65,
  118,
  -25,
  -32,
  115,
  36,
  44,
  1,
  35,
  -110,
  -9,
  32,
  -124,
  85,
  42,
  -52,
  41,
  6,
  -16,
  5,
  -83,
  -5,
  0,
  -2,
  12,
  -91,
  -73,
  2,
  -70,
  109,
  -90,
  -93,
  -121,
  19,
  -96,
  -49,
  3,
  -59,
  110,
  -62,
  -51,
  -13,
  98,
  47,
  51,
  110,
  -61,
  126,
  3,
  7,
  27,
  -24,
  -31,
  73,
  122,
  70,
  -67,
  -36,
  12,
  -5,
  25,
  92,
  -108,
  50,
  -80,
  32,
  -45,
  86,
  -37,
  33,
  -116,
  116,
  -15,
  37,
  -18,
  -25,
  -99,
  47,
  -83,
  103,
  -69,
  -72,
  -8,
  -26,
  78,
  119,
  -65,
  19,
  121,
  -92,
  117,
  -62,
  86,
  109,
  -8,
  92,
  99,
  22,
  85,
  102,
  15,
  78,
  9,
  -104,
  32,
  -113,
  -104,
  72,
  -114,
  -117,
  -73,
  76,
  122,
  -62,
  -85,
  120,
  -84,
  -119,
  -89,
  0,
  58,
  86,
  -35,
  -56,
  51,
  64,
  56,
  84,
  71,
  45,
  -30,
  -86,
  28,
  92,
  41,
  109,
  53,
  114,
  121,
  -36,
  -56,
  81,
  -83,
  -6,
  -1,
  -80,
  7,
  41,
  -76,
  -99,
  -68,
  -54,
  109,
  -59,
  -25,
  67,
  94,
  -33,
  -27,
  -55,
  102,
  67,
  -41,
  8,
  -95,
  65,
  85,
  109,
  -8,
  87,
  21,
  -118,
  37,
  -79,
  118,
  1,
  -26,
  -101,
  -121,
  8,
  -71,
  98,
  -80,
  -92,
  -107,
  -42,
  101,
  -53,
  72,
  17,
  -74,
  84,
  -28,
  -109,
  -82,
  18,
  87,
  31,
  125,
  2,
  -17,
  -125,
  87,
  10,
  -107,
  76,
  -8,
  16,
  15,
  -17,
  105,
  -30,
  -124,
  -105,
  -76,
  -127,
  -49,
  -101,
  66,
  -28,
  -86,
  -55,
  -93,
  -53,
  -16,
  100,
  -77,
  29,
  22,
  -10,
  -62,
  95,
  -14,
  105,
  -114,
  -87,
  -70,
  -59,
  -86,
  25,
  -15,
  -35,
  41,
  105,
  -10,
  -84,
  -122,
  -45,
  -85,
  12,
  102,
  44,
  124,
  -24,
  21,
  -77,
  119,
  -21,
  -65,
  -34,
  -112,
  106,
  18,
  -22,
  -38,
  -9,
  96,
  34,
  52,
  34,
  -18,
  38,
  -40,
  63,
  -119,
  81,
  37,
  50,
  72,
  -121,
  -24,
  -60,
  12,
  61,
  -25,
  123,
  13,
  -58,
  35,
  -63,
  61,
  36,
  -28,
  -32,
  -92,
  60,
  118,
  -22,
  -106,
  77,
  56,
  89,
  72,
  -85,
  -40,
  -103,
  55,
  -93,
  -19,
  -121,
  96,
  32,
  115,
  -35,
  121,
  128,
  93,
  -65,
  -38,
  64,
  -47,
  -27,
  -81,
  -34,
  121,
  -62,
  -87,
  -1,
  15,
  52,
  116,
  -8,
  -44,
  -17,
  27,
  32,
  -45,
  -79,
  116,
  91,
  -15,
  -85,
  -98,
  11,
  -108,
  -94,
  -124,
  88,
  -43,
  -42,
  62,
  70,
  122,
  -51,
  96,
  -113,
  76,
  4,
  8,
  34,
  73,
  -20,
  98,
  -63,
  -78,
  20,
  118,
  -47,
  -50,
  5,
  -54,
  -121,
  49,
  113,
  57,
  37,
  45,
  71,
  -41,
  -23,
  6,
  -90,
  -50,
  -60,
  -97,
  -105,
  -77,
  66,
  -98,
  115,
  33,
  -111,
  -116,
  22,
  40,
  98,
  53,
  -110,
  -41,
  -78,
  96,
  -71,
  -40,
  114,
  -110,
  3,
  -96,
  -13,
  95,
  39,
  88,
  -95,
  81,
  93,
  34,
  16,
  57,
  98,
  49,
  -112,
  63,
  -90,
  -1,
  -57,
  48,
  -105,
  124,
  119,
  114,
  80,
  -93,
  -21,
  -82,
  1,
  21,
  -28,
  35,
  126,
  -95,
  95,
  -2,
  121,
  -108,
  -78,
  16,
  -95,
  -72,
  39,
  35,
  -17,
  -116,
  -50,
  33,
  -75,
  -91,
  111,
  -3,
  52,
  65,
  106,
  2,
  87,
  -124,
  -36,
  -121,
  57,
  14,
  95,
  -122,
  82,
  49,
  76,
  50,
  118,
  65,
  -121,
  124,
  42,
  58,
  82,
  -120,
  -47,
  90,
  48,
  -87,
  65,
  50,
  23,
  98,
  98,
  -123,
  -50,
  39,
  -76,
  -23,
  -71,
  -93,
  -102,
  -59,
  67,
  -11,
  68,
  -109,
  8,
  16,
  -124,
  -37,
  28,
  1,
  -53,
  -109,
  38,
  20,
  100,
  -116,
  -121,
  117,
  90,
  61,
  -112,
  96,
  46,
  117,
  26,
  -124,
  -61,
  82,
  -125,
  -20,
  108,
  -76,
  38,
  54,
  -75,
  101,
  -7,
  65,
  124,
  -47,
  -124,
  -96,
  128,
  103,
  83,
  -70,
  15,
  -80,
  24,
  112,
  0,
  82,
  -31,
  72,
  -92,
  51,
  -78,
  -103,
  52,
  123,
  7,
  123,
  -84,
  -12,
  -64,
  17,
  37,
  15,
  -42,
  -30,
  123,
  -96,
  -82,
  -75,
  -73,
  -40,
  -12,
  -39,
  95,
  -76,
  122,
  -96,
  -124,
  9,
  61,
  116,
  93,
  -2,
  -10,
  5,
  -82,
  -126,
  -30,
  66,
  83,
  12,
  -28,
  95,
  -28,
  -55,
  30,
  71,
  88,
  28,
  -5,
  -47,
  -120,
  -124,
  110,
  -121,
  -75,
  9,
  7,
  -119,
  96,
  -95,
  108,
  97,
  75,
  80,
  -27,
  42,
  -97,
  76,
  75,
  55,
  22,
  -9,
  -83,
  86,
  -91,
  50,
  -18,
  40,
  -99,
  -38,
  -112,
  -31,
  -63,
  86,
  16,
  77,
  46,
  -14,
  -16,
  60,
  -93,
  -126,
  -34,
  55,
  122,
  51,
  -50,
  -21,
  76,
  127,
  69,
  94,
  46,
  107,
  100,
  -50,
  -106,
  39,
  26,
  -99,
  -25,
  85,
  -117,
  73,
  96,
  79,
  -19,
  21,
  -9,
  -74,
  -25,
  -105,
  22,
  -116,
  -16,
  -64,
  -85,
  -107,
  88,
  -3,
  -62,
  -28,
  121,
  -72,
  21,
  -96,
  -121,
  -12,
  -117,
  -30,
  68,
  -118,
  48,
  11,
  -5,
  -73,
  12,
  94,
  101,
  2,
  -119,
  114,
  48,
  103,
  -119,
  -20,
  -58,
  -13,
  -36,
  -73,
  -96,
  -106,
  69,
  7,
  28,
  -111,
  108,
  -7,
  -119,
  -6,
  31,
  -44,
  -87,
  -112,
  27,
  110,
  -29,
  -39,
  19,
  78,
  90,
  70,
  25,
  111,
  -4,
  14,
  -22,
  -77,
  68,
  -65,
  94,
  -12,
  -89,
  -58,
  -86,
  -34,
  91,
  71,
  42,
  117,
  84,
  -127,
  -36,
  119,
  -96,
  126,
  -107,
  94,
  67,
  -112,
  89,
  107,
  13,
  -66,
  111,
  -104,
  -107,
  1,
  118,
  56,
  -53,
  -34,
  -37,
  117,
  -72,
  -49,
  -90,
  71,
  28,
  70,
  -63,
  -63,
  -65,
  127,
  -51,
  58,
  99,
  -113,
  -39,
  -48,
  -126,
  103,
  -52,
  -102,
  57,
  106,
  -78,
  89,
  20,
  -98,
  -13,
  8,
  -41,
  -54,
  116,
  -8,
  87,
  -34,
  80,
  34,
  -17,
  -21,
  -106,
  -66,
  25,
  -45,
  -87,
  36,
  -122,
  -69,
  -27,
  3,
  -121,
  27,
  84,
  -11,
  -46,
  -125,
  77,
  -53,
  72,
  55,
  -100,
  90,
  -103,
  115,
  -102,
  115,
  98,
  26,
  -46,
  -11,
  -25,
  -111,
  -30,
  119,
  34,
  66,
  85,
  103,
  15,
  -94,
  -14,
  17,
  79,
  77,
  123,
  -56,
  -49,
  -51,
  -32,
  101,
  -47,
  -45,
  9,
  21,
  58,
  -30,
  -34,
  12,
  -41,
  25,
  30,
  -65,
  -87,
  89,
  -103,
  -1,
  58,
  -2,
  -119,
  -67,
  35,
  14,
  21,
  11,
  -103,
  62,
  -72,
  -121,
  98,
  101,
  124,
  24,
  -52,
  12,
  66,
  -47,
  -27,
  11,
  91,
  41,
  87,
  24,
  101,
  4,
  3,
  50,
  -33,
  19,
  117,
  -81,
  -7,
  80,
  60,
  -105,
  106,
  85,
  74,
  -115,
  23,
  49,
  94,
  -12,
  -122,
  26,
  -39,
  -58,
  48,
  54,
  -28,
  -104,
  81,
  11,
  -75,
  -22,
  101,
  -40,
  6,
  -76,
  51,
  29,
  -96,
  -99,
  57,
  88,
  21,
  -110,
  47,
  120,
  -32,
  -118,
  79,
  -1,
  38,
  -38,
  -80,
  50,
  79,
  121,
  2,
  -73,
  -86,
  40,
  -56,
  17,
  85,
  -76,
  -35,
  -60,
  55,
  12,
  -74,
  89,
  -109,
  27,
  -93,
  86,
  122,
  68,
  12,
  -95,
  72,
  -28,
  68,
  -99,
  -14,
  -19,
  17,
  78,
  49,
  -92,
  -75,
  50,
  8,
  -109,
  -27,
  -26,
  114,
  51,
  91,
  -113,
  -62,
  -27,
  85,
  -26,
  -4,
  -35,
  62,
  -107,
  37,
  -121,
  -96,
  -72,
  -17,
  -79,
  14,
  -40,
  116,
  118,
  110,
  -48,
  110,
  5,
  61,
  -19,
  46,
  -9,
  -111,
  95,
  -25,
  88,
  9,
  119,
  -19,
  80,
  4,
  -10,
  80,
  -127,
  121,
  89,
  101,
  77,
  83,
  36,
  90,
  64,
  9,
  54,
  -46,
  -75,
  -13,
  -59,
  -106,
  -124,
  98,
  -9,
  -108,
  -8,
  127,
  80,
  -116,
  -58,
  64,
  -80,
  100,
  -109,
  -13,
  -108,
  73,
  85,
  -31,
  -7,
  72,
  -37,
  -39,
  -74,
  26,
  -23,
  126,
  75,
  29,
  -96,
  -28,
  -30,
  -16,
  -91,
  -32,
  -40,
  -7,
  69,
  48,
  -20,
  -14,
  76,
  27,
  66,
  -94,
  -95,
  80,
  -25,
  124,
  -68,
  126,
  -65,
  47,
  -83,
  102,
  120,
  -113,
  80,
  37,
  109,
  54,
  35,
  -118,
  37,
  96,
  -2,
  125,
  -8,
  -75,
  110,
  -75,
  -107,
  77,
  78,
  -24,
  117,
  19,
  18,
  -92,
  -9,
  -113,
  -118,
  49,
  -74,
  29,
  108,
  -18,
  -45,
  -28,
  77,
  107,
  -102,
  -18,
  -82,
  2,
  -30,
  74,
  -121,
  -32,
  41,
  -121,
  -110,
  128,
  88,
  -13,
  -91,
  8,
  -39,
  -85,
  -95,
  96,
  -14,
  15,
  -51,
  -21,
  -70,
  108,
  -3,
  23,
  92,
  83,
  60,
  21,
  87,
  124,
  113,
  33,
  -86,
  75,
  123,
  -114,
  8,
  -114,
  103,
  -49,
  -126,
  47,
  32,
  75,
  -48,
  128,
  -100,
  -51,
  22,
  -70,
  -14,
  75,
  94,
  -11,
  12,
  -91,
  -73,
  90,
  7,
  -16,
  -55,
  -102,
  -106,
  16,
  -84,
  -39,
  -54,
  -86,
  -6,
  -27,
  58,
  59,
  84,
  90,
  49,
  70,
  -56,
  -6,
  107,
  -74,
  -117,
  -2,
  -125,
  -54,
  83,
  -24,
  123,
  -9,
  -75,
  -34,
  124,
  74,
  13,
  55,
  61,
  56,
  54,
  42,
  -98,
  28,
  24,
  96,
  -105,
  -85,
  60,
  72,
  -121,
  117,
  -25,
  -3,
  -10,
  1,
  -82,
  -108,
  29,
  82,
  75,
  -83,
  16,
  121,
  -102,
  60,
  -127,
  102,
  68,
  121,
  48,
  -11,
  123,
  119,
  -96,
  23,
  -120,
  -25,
  -106,
  -49,
  105,
  101,
  125,
  20,
  -110,
  114,
  -97,
  -45,
  94,
  -77,
  76,
  -74,
  -69,
  124,
  -89,
  -90,
  -54,
  -61,
  -17,
  28,
  -25,
  -58,
  119,
  -122,
  -40,
  27,
  51,
  13,
  22,
  42,
  57,
  10,
  -95,
  -109,
  -118,
  104,
  -118,
  59,
  112,
  -87,
  -17,
  75,
  -11,
  100,
  -36,
  -28,
  -17,
  -50,
  12,
  105,
  -117,
  6,
  -20,
  127,
  -116,
  83,
  110,
  1,
  -65,
  -7,
  14,
  -97,
  94,
  103,
  25,
  122,
  -69,
  7,
  12,
  127,
  -11,
  -114,
  65,
  -40,
  -11,
  103,
  66,
  -84,
  111,
  27,
  -106,
  -56,
  -72,
  -2,
  -98,
  -81,
  122,
  97,
  -98,
  -19,
  -4,
  125,
  114,
  61,
  -74,
  73,
  115,
  -115,
  97,
  28,
  21,
  -37,
  15,
  -2,
  -9,
  -57,
  -123,
  -40,
  93,
  -120,
  23,
  20,
  -59,
  -40,
  19,
  104,
  -41,
  -37,
  -84,
  105,
  -14,
  -102,
  -51,
  77,
  -70,
  -64,
  26,
  -83,
  -82,
  -32,
  125,
  60,
  100,
  -82,
  -123,
  90,
  18,
  -3,
  -46,
  -55,
  -8,
  83,
  -36,
  -53,
  -23,
  66,
  -24,
  -125,
  13,
  9,
  11,
  114,
  60,
  -109,
  17,
  29,
  38,
  -100,
  -115,
  78,
  36,
  93,
  74,
  -50,
  111,
  96,
  -79,
  -3,
  -10,
  -81,
  128,
  -41,
  105,
  88,
  116,
  -34,
  -124,
  -125,
  -66,
  1,
  38,
  -96,
  -70,
  -30,
  -47,
  -73,
  -60,
  99,
  111,
  23,
  -4,
  98,
  79,
  12,
  -71,
  37,
  44,
  -124,
  -126,
  -61,
  56,
  -21,
  127,
  97,
  -35,
  57,
  29,
  7,
  14,
  -66,
  15,
  -26,
  -51,
  111,
  -60,
  -2,
  66,
  -18,
  81,
  -51,
  -115,
  -13,
  -122,
  -88,
  30,
  91,
  -77,
  2,
  -51,
  -84,
  -24,
  -5,
  -9,
  16,
  -90,
  -31,
  65,
  52,
  2,
  13,
  -1,
  -118,
  -85,
  32,
  94,
  111,
  111,
  -92,
  127,
  -49,
  -67,
  27,
  -109,
  105,
  14,
  -13,
  1,
  71,
  77,
  -61,
  -7,
  75,
  -81,
  -1,
  80,
  -78,
  -14,
  83,
  79,
  117,
  -95,
  89,
  2,
  -92,
  15,
  47,
  11,
  20,
  82,
  96,
  -7,
  -7,
  33,
  37,
  -74,
  -90,
  39,
  79,
  41,
  115,
  -24,
  30,
  -71,
  -102,
  25,
  -34,
  -37,
  79,
  -70,
  -67,
  116,
  63,
  70,
  -2,
  33,
  -56,
  -64,
  23,
  -122,
  28,
  14,
  30,
  52,
  88,
  -84,
  103,
  116,
  -38,
  18,
  -12,
  -125,
  99,
  -103,
  103,
  -23,
  -94,
  -51,
  105,
  -2,
  -51,
  42,
  -44,
  -40,
  63,
  -5,
  -75,
  -73,
  50,
  -56,
  -70,
  126,
  -125,
  -16,
  -93,
  107,
  15,
  56,
  -87,
  22,
  98,
  -117,
  51,
  -54,
  -38,
  -92,
  125,
  -110,
  65,
  20,
  85,
  69,
  -108,
  -52,
  98,
  88,
  43,
  -43,
  68,
  6,
  -2,
  -43,
  78,
  81,
  18,
  -19,
  13,
  25,
  28,
  -37,
  72,
  -116,
  -102,
  -59,
  -49,
  -49,
  125,
  -11,
  78,
  72,
  -67,
  -124,
  -120,
  6,
  32,
  115,
  -127,
  74,
  12,
  -90,
  73,
  47,
  33,
  127,
  13,
  93,
  85,
  123,
  102,
  54,
  -2,
  -4,
  -14,
  -119,
  55,
  -99,
  61,
  114,
  21,
  35,
  -73,
  74,
  1,
  117,
  -75,
  58,
  44,
  12,
  -43,
  1,
  -108,
  13,
  23,
  -22,
  123,
  87,
  -82,
  -91,
  90,
  102,
  -5,
  -84,
  -43,
  63,
  -127,
  4,
  -30,
  -47,
  98,
  -27,
  4,
  55,
  -55,
  -9,
  -114,
  -63,
  32,
  -60,
  -68,
  121,
  124,
  -53,
  1,
  -21,
  -3,
  -79,
  -57,
  107,
  113,
  5,
  43,
  109,
  47,
  31,
  -32,
  107,
  117,
  -2,
  119,
  -52,
  121,
  124,
  79,
  -56,
  -68,
  92,
  -75,
  54,
  112,
  -57,
  98,
  -119,
  128,
  -64,
  66,
  23,
  96,
  12,
  100,
  46,
  -29,
  84,
  -85,
  -72,
  -27,
  -118,
  -103,
  104,
  81,
  93,
  -74,
  -75,
  38,
  67,
  66,
  -2,
  13,
  125,
  10,
  30,
  128,
  -94,
  122,
  112,
  52,
  7,
  -94,
  -58,
  11,
  -96,
  28,
  -79,
  56,
  -106,
  -125,
  -64,
  34,
  -49,
  -101,
  118,
  24,
  -37,
  -15,
  85,
  -33,
  94,
  -9,
  104,
  -34,
  -32,
  -14,
  -123,
  -120,
  -120,
  -16,
  37,
  -81,
  48,
  126,
  43,
  -77,
  -109,
  -113,
  -126,
  -32,
  -109,
  28,
  49,
  35,
  65,
  -67,
  -92,
  25,
  -64,
  40,
  -10,
  10,
  110,
  95,
  -80,
  -99,
  21,
  -35,
  -72,
  -126,
  -69,
  -86,
  46,
  33,
  5,
  -90,
  -120,
  -30,
  -65,
  -50,
  -73,
  54,
  -40,
  -17,
  90,
  -123,
  10,
  -96,
  -90,
  -39,
  6,
  127,
  105,
  103,
  125,
  23,
  -65,
  105,
  -31,
  107,
  101,
  13,
  -112,
  -43,
  64,
  -58,
  17,
  78,
  127,
  -76,
  94,
  101,
  -75,
  122,
  83,
  117,
  -60,
  -55,
  86,
  53,
  -111,
  -29,
  16,
  111,
  -114,
  22,
  -21,
  29,
  97,
  46,
  48,
  117,
  30,
  64,
  -122,
  -117,
  105,
  113,
  -120,
  -11,
  36,
  29,
  36,
  -92,
  -5,
  -100,
  57,
  60,
  21,
  -96,
  -76,
  -34,
  83,
  -106,
  -110,
  -119,
  -25,
  47,
  -108,
  120,
  89,
  -29,
  9,
  3,
  -30,
  111,
  -111,
  -40,
  44,
  -119,
  19,
  82,
  -31,
  53,
  104,
  112,
  109,
  32,
  0,
  62,
  28,
  88,
  111,
  32,
  49,
  114,
  -32,
  -114,
  36,
  56,
  -70,
  -28,
  22,
  -72,
  118,
  0,
  97,
  105,
  -70,
  -113,
  27,
  -60,
  -75,
  34,
  113,
  126,
  46,
  2,
  -48,
  -62,
  59,
  -124,
  -79,
  73,
  74,
  11,
  -106,
  57,
  17,
  -107,
  -5,
  124,
  41,
  -122,
  15,
  -114,
  71,
  -100,
  -8,
  121,
  76,
  -15,
  -7,
  107,
  -78,
  49,
  -119,
  79,
  -84,
  3,
  94,
  128,
  17,
  38,
  83,
  -24,
  -9,
  60,
  30,
  -109,
  49,
  -4,
  0,
  -64,
  34,
  -26,
  94,
  43,
  123,
  -69,
  -78,
  -51,
  -100,
  11,
  60,
  28,
  -95,
  113,
  54,
  3,
  -117,
  65,
  -39,
  48,
  -98,
  14,
  -18,
  25,
  113,
  107,
  -43,
  -84,
  -32,
  113,
  46,
  117,
  119,
  105,
  71,
  56,
  -61,
  -63,
  -127,
  -45,
  -70,
  110,
  -86,
  31,
  -1,
  -15,
  -100,
  -27,
  -32,
  80,
  9,
  82,
  -45,
  106,
  91,
  -104,
  -5,
  -20,
  -51,
  94,
  97,
  -86,
  -53,
  12,
  18,
  25,
  -48,
  85,
  -76,
  -36,
  120,
  83,
  -10,
  -123,
  39,
  60,
  -10,
  46,
  -77,
  98,
  -22,
  -84,
  -114,
  27,
  -18,
  119,
  100,
  -4,
  5,
  -83,
  -12,
  98,
  -6,
  23,
  19,
  -58,
  -108,
  -57,
  86,
  -76,
  118,
  47,
  -51,
  -82,
  96,
  43,
  -57,
  63,
  -37,
  37,
  92,
  -121,
  70,
  4,
  -109,
  84,
  0,
  81,
  41,
  67,
  -33,
  -33,
  81,
  -57,
  31,
  27,
  7,
  80,
  -20,
  -28,
  28,
  -86,
  123,
  -69,
  74,
  80,
  -124,
  124,
  96,
  -107,
  127,
  -54,
  121,
  21,
  85,
  -17,
  69,
  -119,
  -114,
  114,
  33,
  35,
  -30,
  26,
  96,
  21,
  -12,
  -62,
  -22,
  -112,
  110,
  -58,
  14,
  -105,
  -20,
  27,
  119,
  -116,
  -111,
  -20,
  15,
  -61,
  104,
  21,
  -33,
  68,
  11,
  93,
  -11,
  -29,
  -22,
  -24,
  -39,
  -103,
  17,
  -28,
  -84,
  -9,
  66,
  -59,
  -107,
  -90,
  10,
  96,
  -39,
  -109,
  118,
  -37,
  100,
  -61,
  55,
  -57,
  39,
  11,
  67,
  18,
  5,
  44,
  107,
  87,
  -60,
  -114,
  72,
  -60,
  23,
  -121,
  67,
  86,
  -99,
  -89,
  -86,
  94,
  -107,
  -59,
  92,
  -39,
  50,
  -78,
  -77,
  -116,
  39,
  121,
  58,
  112,
  20,
  74,
  -70,
  19,
  62,
  -69,
  -60,
  -92,
  -28,
  102,
  17,
  -12,
  30,
  -35,
  -24,
  -71,
  -108,
  -118,
  56,
  -54,
  64,
  66,
  -4,
  -18,
  -29,
  -86,
  12,
  127,
  89,
  9,
  -97,
  -56,
  -84,
  39,
  -55,
  -29,
  -2,
  59,
  70,
  67,
  80,
  -90,
  -59,
  123,
  -120,
  103,
  5,
  4,
  -103,
  -40,
  44,
  -33,
  -29,
  93,
  2,
  53,
  19,
  115,
  67,
  60,
  -3,
  127,
  79,
  19,
  49,
  -21,
  -70,
  75,
  78,
  -52,
  38,
  -89,
  -119,
  92,
  114,
  -101,
  67,
  109,
  -85,
  -88,
  -55,
  60,
  -118,
  31,
  -119,
  47,
  -81,
  -101,
  120,
  13,
  -82,
  -96,
  -83,
  112,
  -114,
  -64,
  27,
  -87,
  -28,
  91,
  -19,
  77,
  97,
  -35,
  -125,
  66,
  -24,
  -66,
  44,
  -104,
  -89,
  -102,
  85,
  -24,
  93,
  -9,
  50,
  104,
  114,
  -124,
  -22,
  -75,
  80,
  -85,
  -125,
  -56,
  14,
  -66,
  -56,
  84,
  -53,
  -116,
  -125,
  -123,
  104,
  -23,
  -125,
  94,
  -111,
  48,
  -33,
  -4,
  -6,
  -100,
  -117,
  -27,
  -114,
  -71,
  -122,
  -113,
  67,
  -90,
  84,
  109,
  74,
  111,
  -56,
  -104,
  92,
  -43,
  -119,
  56,
  14,
  -14,
  39,
  8,
  5,
  -13,
  -124,
  -101,
  -30,
  68,
  -8,
  20,
  12,
  -54,
  4,
  -9,
  -115,
  -74,
  -8,
  -80,
  -101,
  -119,
  -126,
  -4,
  86,
  -104,
  -31,
  47,
  9,
  -28,
  46,
  -118,
  78,
  116,
  29,
  -15,
  66,
  -127,
  115,
  -49,
  -81,
  -56,
  36,
  126,
  -16,
  -79,
  -43,
  -18,
  -87,
  -37,
  38,
  -118,
  19,
  -40,
  59,
  -51,
  104,
  11,
  8,
  81,
  29,
  127,
  99,
  -106,
  -33,
  89,
  -17,
  92,
  -40,
  59,
  -105,
  120,
  47,
  120,
  64,
  -98,
  51,
  69,
  -2,
  -79,
  -14,
  80,
  0,
  101,
  -36,
  -111,
  -8,
  -103,
  4,
  -25,
  2,
  101,
  118,
  -34,
  -29,
  -50,
  126,
  -93,
  -18,
  96,
  111,
  43,
  31,
  -56,
  -43,
  -125,
  -120,
  -94,
  127,
  112,
  27,
  -25,
  -90,
  -76,
  2,
  -13,
  124,
  -46,
  -13,
  -26,
  -85,
  -18,
  37,
  -32,
  -114,
  44,
  117,
  24,
  -93,
  -19,
  -60,
  66,
  18,
  -40,
  98,
  119,
  31,
  -44,
  -34,
  45,
  103,
  -50,
  -43,
  -60,
  -79,
  -56,
  -117,
  60,
  104,
  10,
  78,
  87,
  -56,
  -107,
  -85,
  95,
  68,
  36,
  -102,
  93,
  -115,
  89,
  24,
  -72,
  -36,
  -53,
  -71,
  16,
  1,
  -86,
  120,
  116,
  117,
  -99,
  81,
  -93,
  -55,
  -111,
  -108,
  -85,
  -52,
  123,
  -70,
  15,
  -110,
  92,
  44,
  42,
  5,
  3,
  105,
  82,
  71,
  -118,
  119,
  -91,
  56,
  60,
  82,
  122,
  64,
  -31,
  -97,
  -27,
  -70,
  -22,
  100,
  42,
  61,
  14,
  69,
  -90,
  78,
  109,
  -106,
  -66,
  -124,
  -124,
  -101,
  39,
  105,
  -29,
  81,
  -55,
  -96,
  -112,
  82,
  -65,
  69,
  123,
  -45,
  -110,
  -127,
  -40,
  -107,
  85,
  -2,
  17,
  -55,
  2,
  68,
  22,
  -23,
  21,
  5,
  -94,
  56,
  -50,
  49,
  47,
  -6,
  -121,
  50,
  108,
  -124,
  56,
  27,
  -28,
  38,
  -64,
  -103,
  -73,
  -101,
  -119,
  33,
  21,
  83,
  3,
  -121,
  -102,
  86,
  25,
  -55,
  126,
  -73,
  -69,
  5,
  99,
  70,
  -122,
  -45,
  86,
  -49,
  95,
  -106,
  34,
  128,
  75,
  88,
  -95,
  116,
  -84,
  -68,
  -1,
  -26,
  -43,
  39,
  50,
  -41,
  -75,
  74,
  -51,
  122,
  -118,
  111,
  16,
  111,
  -7,
  101,
  -65,
  -74,
  3,
  93,
  41,
  -110,
  37,
  -33,
  85,
  -47,
  50,
  -14,
  -122,
  -113,
  -77,
  -1,
  35,
  -75,
  -104,
  47,
  -23,
  -53,
  111,
  -14,
  85,
  -39,
  96,
  96,
  -65,
  -63,
  24,
  96,
  50,
  -74,
  -61,
  15,
  -5,
  -127,
  -73,
  40,
  104,
  -34,
  3,
  -42,
  -80,
  -125,
  -14,
  101,
  -5,
  102,
  96,
  75,
  54,
  -42,
  -27,
  74,
  59,
  10,
  103,
  -111,
  4,
  108,
  -69,
  97,
  -108,
  55,
  -115,
  -99,
  -103,
  -68,
  -18,
  -70,
  -76,
  114,
  -64,
  114,
  82,
  100,
  -29,
  50,
  -65,
  -94,
  -52,
  118,
  11,
  -90,
  -44,
  94,
  125,
  7,
  51,
  91,
  98,
  24,
  -73,
  -40,
  -10,
  18,
  27,
  89,
  40,
  -108,
  13,
  20,
  -108,
  91,
  16,
  -98,
  29,
  119,
  -13,
  -88,
  -44,
  119,
  108,
  95,
  -47,
  -75,
  99,
  -88,
  43,
  24,
  -112,
  -19,
  116,
  90,
  -35,
  31,
  109,
  39,
  104,
  -98,
  -95,
  73,
  70,
  78,
  -97,
  124,
  -89,
  118,
  -97,
  -106,
  -97,
  32,
  -108,
  5,
  1,
  56,
  59,
  14,
  -111,
  55,
  19,
  37,
  127,
  76,
  -27,
  -87,
  -102,
  -83,
  11,
  -124,
  58,
  25,
  -69,
  119,
  -113,
  -123,
  -15,
  107,
  -82,
  -83,
  -86,
  -97,
  -69,
  -52,
  -34,
  103,
  -109,
  113,
  4,
  -86,
  -117,
  -30,
  -121,
  26,
  -107,
  74,
  19,
  -40,
  -77,
  53,
  -56,
  71,
  116,
  -33,
  105,
  95,
  1,
  -9,
  57,
  -68,
  126,
  -32,
  83,
  -66,
  -21,
  85,
  47,
  41,
  -32,
  97,
  -96,
  106,
  -123,
  103,
  -120,
  91,
  -29,
  5,
  34,
  124,
  10,
  49,
  -93,
  122,
  -124,
  -59,
  -81,
  -71,
  -51,
  -97,
  84,
  -87,
  -2,
  21,
  25,
  15,
  -34,
  6,
  117,
  -66,
  16,
  111,
  60,
  -57,
  -72,
  33,
  14,
  126,
  120,
  -77,
  112,
  82,
  -66,
  53,
  -107,
  -38,
  81,
  -126,
  87,
  32,
  0,
  -49,
  56,
  -90,
  -116,
  127,
  -100,
  -112,
  56,
  -66,
  69,
  -24,
  -88,
  -28,
  116,
  -123,
  122,
  117,
  -57,
  50,
  -3,
  1,
  88,
  33,
  -79,
  41,
  37,
  -50,
  71,
  61,
  -45,
  99,
  17,
  -71,
  76,
  -112,
  123,
  53,
  -27,
  -121,
  12,
  40,
  52,
  75,
  92,
  122,
  14,
  40,
  -34,
  13,
  54,
  -75,
  50,
  52,
  -13,
  82,
  87,
  31,
  110,
  0,
  107,
  90,
  77,
  40,
  81,
  -99,
  -75,
  -66,
  68,
  101,
  -105,
  113,
  -55,
  -86,
  -14,
  38,
  102,
  123,
  -120,
  -68,
  -83,
  -111,
  -98,
  -63,
  -66,
  -14,
  -76,
  -4,
  -123,
  -65,
  -51,
  128,
  35,
  122,
  64,
  24,
  -30,
  -126,
  62,
  42,
  -77,
  36,
  -32,
  -48,
  -111,
  53,
  -58,
  -111,
  -86,
  -7,
  -4,
  -71,
  15,
  -7,
  121,
  16,
  29,
  -62,
  121,
  -25,
  96,
  -116,
  67,
  17,
  -73,
  -10,
  42,
  125,
  -8,
  64,
  -53,
  28,
  -45,
  -72,
  -13,
  31,
  75,
  -105,
  94,
  56,
  36,
  -104,
  -98,
  92,
  76,
  98,
  15,
  112,
  -107,
  -124,
  -88,
  -119,
  5,
  36,
  -116,
  48,
  -120,
  -80,
  -63,
  86,
  -54,
  47,
  -52,
  17,
  -89,
  -36,
  70,
  -97,
  -1,
  -45,
  62,
  -72,
  -74,
  -20,
  84,
  -22,
  -61,
  -87,
  87,
  -104,
  -53,
  -17,
  -27,
  2,
  -70,
  -127,
  -47,
  124,
  -41,
  -64,
  114,
  -56,
  47,
  72,
  3,
  -89,
  25,
  -101,
  -103,
  17,
  63,
  77,
  -56,
  -89,
  119,
  68,
  92,
  -105,
  94,
  -80,
  -101,
  39,
  68,
  123,
  79,
  22,
  89,
  -9,
  -21,
  83,
  -33,
  2,
  -26,
  -96,
  42,
  -42,
  57,
  -2,
  11,
  87,
  -28,
  -25,
  -23,
  -94,
  80,
  -82,
  -78,
  -62,
  -23,
  72,
  8,
  -23,
  -31,
  14,
  -76,
  7,
  83,
  -101,
  27,
  27,
  -109,
  73,
  85,
  -38,
  -34,
  -20,
  -110,
  5,
  -63,
  117,
  101,
  84,
  -107,
  21,
  34,
  -9,
  -115,
  4,
  -21,
  27,
  -97,
  -49,
  -121,
  36,
  77,
  76,
  32,
  -106,
  49,
  -71,
  65,
  -4,
  -107,
  -100,
  -102,
  32,
  -25,
  -35,
  107,
  75,
  -105,
  27,
  85,
  -71,
  -68,
  -22,
  -121,
  -17,
  -2,
  -94,
  125,
  -83,
  -108,
  -79,
  55,
  105,
  44,
  78,
  -30,
  -52,
  126,
  -68,
  1,
  70,
  -98,
  23,
  46,
  -58,
  -112,
  -51,
  -17,
  -48,
  27,
  82,
  -124,
  -32,
  27,
  83,
  -41,
  114,
  -107,
  121,
  -12,
  9,
  108,
  48,
  -37,
  -40,
  87,
  127,
  41,
  -33,
  -78,
  -89,
  46,
  -111,
  -126,
  83,
  107,
  -58,
  16,
  -118,
  68,
  -40,
  -35,
  -111,
  74,
  -23,
  120,
  -74,
  -1,
  12,
  -10,
  -86,
  121,
  0,
  90,
  -66,
  49,
  -119,
  34,
  125,
  112,
  -18,
  27,
  102,
  -3,
  18,
  -83,
  94,
  -109,
  -97,
  92,
  45,
  65,
  98,
  -49,
  5,
  9,
  -125,
  3,
  -60,
  17,
  40,
  -20,
  -29,
  24,
  4,
  -84,
  -35,
  7,
  -122,
  -14,
  123,
  -125,
  -27,
  42,
  -71,
  -25,
  78,
  -10,
  42,
  -48,
  57,
  29,
  87,
  38,
  10,
  22,
  82,
  -123,
  -29,
  -17,
  -63,
  -97,
  5,
  2,
  -18,
  -65,
  47,
  -62,
  -109,
  2,
  26,
  12,
  -52,
  -7,
  3,
  87,
  -77,
  32,
  31,
  -127,
  -71,
  -107,
  24,
  2,
  105,
  43,
  104,
  -27,
  -103,
  -111,
  -127,
  -127,
  -34,
  91,
  -102,
  69,
  -33,
  32,
  32,
  82,
  31,
  -65,
  21,
  -113,
  -115,
  -37,
  53,
  45,
  -112,
  -100,
  24,
  41,
  103,
  -4,
  -97,
  -15,
  25,
  -58,
  -20,
  -24,
  97,
  -77,
  46,
  -82,
  -98,
  -37,
  -19,
  61,
  41,
  -108,
  -36,
  -93,
  -93,
  5,
  -121,
  103,
  -91,
  97,
  91,
  -104,
  -53,
  -5,
  31,
  11,
  -3,
  -8,
  76,
  -96,
  117,
  119,
  -21,
  128,
  38,
  -66,
  -27,
  -67,
  -98,
  -20,
  -28,
  0,
  -40,
  96,
  45,
  118,
  -74,
  29,
  8,
  1,
  10,
  115,
  24,
  3,
  24,
  -76,
  85,
  -2,
  -50,
  -28,
  -93,
  -46,
  -57,
  73,
  119,
  10,
  -6,
  26,
  -5,
  98,
  -45,
  87,
  46,
  -25,
  -26,
  4,
  114,
  -100,
  -17,
  -115,
  -4,
  -89,
  -20,
  -63,
  64,
  -3,
  112,
  66,
  -19,
  -47,
  -6,
  10,
  26,
  -17,
  100,
  6,
  -66,
  -79,
  14,
  36,
  -122,
  128,
  108,
  -122,
  69,
  -71,
  103,
  17,
  50,
  -84,
  -113,
  107,
  28,
  -82,
  -39,
  27,
  102,
  23,
  -87,
  -34,
  119,
  56,
  -80,
  75,
  39,
  97,
  -95,
  100,
  92,
  78,
  43,
  2,
  -40,
  -29,
  -110,
  -56,
  37,
  -14,
  -68,
  82,
  -69,
  38,
  127,
  31,
  -122,
  -84,
  -87,
  -84,
  18,
  86,
  -62,
  20,
  -14,
  104,
  -67,
  -44,
  -68,
  -34,
  -21,
  -57,
  -110,
  -20,
  -13,
  98,
  -49,
  80,
  44,
  56,
  -122,
  17,
  78,
  -38,
  49,
  92,
  -97,
  103,
  79,
  -111,
  42,
  -127,
  -121,
  7,
  100,
  39,
  -23,
  -72,
  108,
  40,
  43,
  -95,
  91,
  -81,
  89,
  -93,
  89,
  -107,
  127,
  -70,
  94,
  1,
  -31,
  -30,
  92,
  -48,
  -43,
  114,
  -97,
  81,
  53,
  118,
  17,
  9,
  -18,
  -40,
  9,
  -89,
  45,
  122,
  -58,
  54,
  1,
  -79,
  121,
  26,
  -39,
  -14,
  -106,
  -116,
  -53,
  -19,
  33,
  40,
  105,
  89,
  -106,
  -113,
  -108,
  -89,
  88,
  -25,
  -63,
  31,
  99,
  -101,
  -62,
  4,
  -103,
  107,
  64,
  -108,
  26,
  67,
  45,
  79,
  110,
  -104,
  11,
  51,
  116,
  -70,
  -3,
  52,
  111,
  -89,
  87,
  63,
  -17,
  29,
  87,
  4,
  -54,
  -76,
  -25,
  101,
  -69,
  49,
  53,
  54,
  -11,
  -95,
  20,
  -46,
  78,
  -85,
  -6,
  -122,
  -57,
  55,
  112,
  -89,
  51,
  88,
  -16,
  27,
  -103,
  93,
  40,
  41,
  -86,
  61,
  100,
  -40,
  -66,
  120,
  49,
  -92,
  -13,
  102,
  -111,
  -70,
  -58,
  48,
  107,
  -57,
  20,
  102,
  -18,
  64,
  45,
  111,
  -40,
  17,
  6,
  27,
  -125,
  9,
  87,
  124,
  30,
  10,
  108,
  -15,
  88,
  64,
  -94,
  -76,
  109,
  1,
  42,
  96,
  58,
  -124,
  -120,
  93,
  79,
  23,
  -49,
  -63,
  -117,
  124,
  5,
  63,
  67,
  -37,
  31,
  120,
  -5,
  86,
  -59,
  -98,
  -15,
  -27,
  56,
  88,
  -10,
  68,
  -54,
  7,
  113,
  97,
  26,
  -20,
  -15,
  -92,
  97,
  -1,
  -80,
  -110,
  107,
  53,
  -107,
  124,
  -42,
  -31,
  -91,
  -79,
  -11,
  23,
  -22,
  68,
  90,
  64,
  -34,
  -16,
  -112,
  -108,
  81,
  -86,
  46,
  64,
  -1,
  -34,
  128,
  122,
  -91,
  17,
  99,
  -86,
  58,
  17,
  86,
  -58,
  120,
  -19,
  -68,
  -67,
  -122,
  23,
  -108,
  -50,
  73,
  -30,
  -99,
  -58,
  90,
  5,
  5,
  112,
  -97,
  -5,
  31,
  31,
  116,
  -45,
  3,
  -103,
  -3,
  -88,
  52,
  -58,
  0,
  -93,
  -118,
  -102,
  -32,
  -13,
  8,
  -3,
  -90,
  71,
  33,
  -68,
  -70,
  0,
  103,
  -74,
  93,
  24,
  -104,
  -40,
  -59,
  103,
  128,
  90,
  17,
  -91,
  -48,
  124,
  -88,
  105,
  -114,
  -113,
  107,
  85,
  -64,
  -125,
  82,
  58,
  -122,
  92,
  56,
  -37,
  81,
  122,
  18,
  -2,
  111,
  13,
  -88,
  46,
  -15,
  -22,
  44,
  42,
  119,
  -1,
  -40,
  -75,
  54,
  61,
  -79,
  119,
  121,
  121,
  -66,
  -58,
  89,
  20,
  64,
  -24,
  -95,
  74,
  -31,
  -33,
  6,
  80,
  124,
  -34,
  -27,
  48,
  -125,
  32,
  124,
  -105,
  23,
  27,
  73,
  15,
  105,
  -112,
  117,
  -76,
  -121,
  -53,
  -5,
  -125,
  -22,
  -116,
  -125,
  27,
  -83,
  115,
  52,
  84,
  -51,
  -118,
  -107,
  93,
  92,
  -18,
  82,
  -4,
  112,
  -62,
  -112,
  -126,
  -55,
  -14,
  58,
  43,
  -88,
  -20,
  -44,
  82,
  -5,
  17,
  -112,
  95,
  -83,
  128,
  4,
  -65,
  55,
  -37,
  34,
  -13,
  -2,
  -39,
  96,
  99,
  14,
  -35,
  108,
  -65,
  -11,
  15,
  52,
  107,
  119,
  -83,
  -47,
  -54,
  -76,
  -125,
  -78,
  128,
  37,
  -51,
  108,
  -84,
  -77,
  0,
  77,
  -92,
  88,
  -110,
  14,
  54,
  99,
  -78,
  -10,
  -19,
  95,
  52,
  108,
  115,
  15,
  -89,
  -69,
  -33,
  -120,
  74,
  -38,
  63,
  55,
  107,
  -14,
  -108,
  -3,
  101,
  -46,
  -90,
  106,
  60,
  -52,
  20,
  68,
  113,
  6,
  101,
  -25,
  -120,
  57,
  34,
  104,
  110,
  9,
  80,
  73,
  22,
  -36,
  82,
  77,
  120,
  28,
  89,
  101,
  -127,
  108,
  52,
  -84,
  -108,
  -34,
  63,
  -81,
  -10,
  112,
  -115,
  42,
  -38,
  100,
  -32,
  118,
  -124,
  51,
  -1,
  -119,
  -42,
  19,
  -29,
  -77,
  -32,
  67,
  46,
  -107,
  -118,
  52,
  -10,
  10,
  -84,
  96,
  -125,
  -11,
  123,
  -33,
  -99,
  -31,
  62,
  63,
  66,
  65,
  -113,
  58,
  26,
  98,
  32,
  18,
  87,
  89,
  16,
  52,
  -23,
  12,
  -3,
  -53,
  -96,
  -82,
  -49,
  63,
  52,
  99,
  77,
  14,
  15,
  -105,
  72,
  78,
  -110,
  -99,
  -57,
  15,
  127,
  -13,
  100,
  49,
  -89,
  -110,
  6,
  -8,
  80,
  113,
  22,
  -18,
  -115,
  -65,
  82,
  -57,
  57,
  -85,
  -73,
  -41,
  42,
  -95,
  -98,
  68,
  96,
  74,
  -58,
  -23,
  -29,
  85,
  122,
  -46,
  14,
  -18,
  -125,
  -110,
  120,
  -59,
  -24,
  105,
  118,
  67,
  70,
  -79,
  -39,
  -14,
  83,
  17,
  -74,
  28,
  -98,
  -72,
  3,
  -87,
  57,
  -16,
  -32,
  120,
  23,
  115,
  72,
  -53,
  -98,
  117,
  25,
  -14,
  29,
  114,
  -77,
  1,
  -98,
  115,
  -21,
  85,
  -51,
  -104,
  -58,
  87,
  -94,
  63,
  -35,
  8,
  25,
  67,
  -114,
  25,
  8,
  -41,
  27,
  -78,
  -65,
  -42,
  61,
  28,
  22,
  -13,
  -25,
  70,
  -59,
  -86,
  -115,
  32,
  -121,
  92,
  101,
  -64,
  -63,
  -13,
  76,
  107,
  75,
  -116,
  9,
  84,
  -36,
  -106,
  44,
  71,
  -101,
  126,
  27,
  -118,
  85,
  123,
  113,
  -37,
  -56,
  99,
  116,
  92,
  31,
  -75,
  28,
  -109,
  114,
  -55,
  -51,
  118,
  97,
  -41,
  -84,
  47,
  -127,
  -30,
  -67,
  -126,
  -43,
  104,
  24,
  -66,
  107,
  -14,
  -93,
  -107,
  -76,
  7,
  67,
  -38,
  -123,
  -118,
  -38,
  15,
  91,
  70,
  33,
  66,
  52,
  28,
  2,
  -44,
  13,
  14,
  18,
  108,
  42,
  -19,
  -75,
  15,
  122,
  -84,
  82,
  17,
  -29,
  51,
  -9,
  -114,
  80,
  -115,
  -103,
  37,
  -111,
  -70,
  -93,
  -17,
  -89,
  30,
  -83,
  32,
  -77,
  -93,
  80,
  85,
  -91,
  -113,
  -5,
  62,
  -17,
  -96,
  -105,
  -4,
  124,
  -39,
  -69,
  88,
  29,
  -112,
  -107,
  -83,
  18,
  45,
  -106,
  -107,
  128,
  -45,
  -47,
  -96,
  -37,
  -54,
  40,
  -19,
  119,
  -23,
  -88,
  -42,
  35,
  98,
  55,
  24,
  10,
  128,
  40,
  56,
  -53,
  -47,
  112,
  -105,
  -66,
  21,
  20,
  70,
  111,
  8,
  84,
  -58,
  -23,
  28,
  -6,
  100,
  82,
  -22,
  76,
  117,
  -48,
  34,
  93,
  91,
  -78,
  -96,
  -117,
  -28,
  -94,
  -89,
  50,
  12,
  -87,
  21,
  -87,
  54,
  56,
  -40,
  -50,
  -121,
  -124,
  126,
  67,
  12,
  112,
  28,
  79,
  -35,
  112,
  -90,
  100,
  -64,
  -82,
  -114,
  89,
  -37,
  100,
  -5,
  -110,
  -32,
  116,
  -101,
  -50,
  127,
  26,
  -94,
  -121,
  85,
  54,
  96,
  119,
  -54,
  52,
  101,
  -104,
  63,
  -17,
  32,
  88,
  44,
  126,
  -51,
  -53,
  -61,
  -87,
  -125,
  -41,
  128,
  -116,
  113,
  -80,
  -14,
  -57,
  97,
  -60,
  -126,
  61,
  76,
  -125,
  -126,
  67,
  126,
  -26,
  -119,
  29,
  -102,
  -4,
  -19,
  86,
  -85,
  -76,
  -81,
  -24,
  104,
  -26,
  49,
  63,
  2,
  11,
  -3,
  -116,
  -86,
  84,
  -57,
  -98,
  71,
  19,
  12,
  75,
  -75,
  33,
  54,
  39,
  -110,
  -79,
  -83,
  20,
  -45,
  94,
  78,
  -82,
  -54,
  -57,
  -81,
  76,
  27,
  -110,
  -93,
  8,
  -65,
  -35,
  -68,
  -69,
  -106,
  108,
  -44,
  114,
  -47,
  1,
  84,
  -5,
  -87,
  50,
  35,
  92,
  -99,
  103,
  -58,
  67,
  37,
  -24,
  -19,
  -14,
  84,
  43,
  63,
  -24,
  -66,
  -25,
  -122,
  -59,
  110,
  -63,
  -41,
  -64,
  -10,
  -73,
  127,
  -74,
  -44,
  -126,
  87,
  112,
  31,
  -84,
  28,
  -61,
  107,
  120,
  118,
  27,
  68,
  -40,
  -107,
  0,
  119,
  -77,
  107,
  124,
  -45,
  -53,
  103,
  5,
  -127,
  -65,
  -75,
  -127,
  -104,
  69,
  33,
  -107,
  126,
  -85,
  -31,
  125,
  -113,
  38,
  21,
  -82,
  -27,
  -34,
  98,
  85,
  -62,
  -35,
  -122,
  -80,
  -73,
  82,
  110,
  96,
  -94,
  -118,
  -91,
  10,
  29,
  55,
  -87,
  -98,
  91,
  64,
  -66,
  36,
  -78,
  -74,
  -74,
  25,
  91,
  -31,
  98,
  -72,
  47,
  67,
  23,
  128,
  59,
  78,
  -29,
  -31,
  -63,
  -28,
  118,
  -54,
  21,
  105,
  68,
  -98,
  43,
  57,
  125,
  115,
  63,
  123,
  -124,
  12,
  100,
  41,
  23,
  -84,
  72,
  -1,
  123,
  118,
  125,
  112,
  -81,
  -124,
  82,
  -83,
  116,
  37,
  -39,
  110,
  -9,
  -64,
  63,
  105,
  -1,
  43,
  -82,
  -115,
  -22,
  65,
  34,
  -113,
  -55,
  58,
  -34,
  -104,
  54,
  -49,
  -103,
  76,
  -74,
  86,
  -25,
  -38,
  -48,
  97,
  -111,
  -113,
  62,
  -33,
  -88,
  113,
  -49,
  23,
  58,
  -111,
  -24,
  -75,
  17,
  75,
  89,
  40,
  80,
  80,
  120,
  127,
  111,
  95,
  128,
  1,
  -48,
  -66,
  -98,
  -83,
  -59,
  13,
  -48,
  70,
  -33,
  65,
  82,
  -85,
  87,
  -20,
  26,
  114,
  -85,
  -54,
  97,
  31,
  -64,
  120,
  51,
  -22,
  113,
  -69,
  3,
  -79,
  69,
  68,
  -92,
  12,
  -47,
  101,
  37,
  81,
  48,
  -79,
  67,
  -122,
  -108,
  49,
  111,
  36,
  -107,
  6,
  0,
  -121,
  69,
  -30,
  81,
  54,
  23,
  -33,
  98,
  -44,
  22,
  125,
  -117,
  34,
  -55,
  -21,
  -100,
  -95,
  96,
  -46,
  49,
  46,
  49,
  -27,
  61,
  107,
  -35,
  -57,
  -29,
  -25,
  44,
  -59,
  58,
  -21,
  110,
  -108,
  -111,
  126,
  113,
  -13,
  18,
  25,
  115,
  126,
  48,
  -79,
  42,
  94,
  84,
  -94,
  36,
  -93,
  -124,
  67,
  57,
  68,
  -124,
  -86,
  56,
  11,
  107,
  9,
  -68,
  6,
  120,
  101,
  -34,
  -47,
  13,
  17,
  35,
  16,
  -109,
  -2,
  -95,
  -4,
  -27,
  13,
  -112,
  -21,
  32,
  -70,
  -76,
  -48,
  116,
  9,
  66,
  -19,
  44,
  127,
  89,
  -15,
  94,
  77,
  75,
  112,
  52,
  5,
  -1,
  84,
  -91,
  -2,
  -110,
  99,
  -96,
  -111,
  75,
  102,
  27,
  -79,
  -27,
  35,
  38,
  -18,
  -64,
  -111,
  114,
  -39,
  45,
  -126,
  50,
  35,
  124,
  17,
  -82,
  24,
  62,
  -67,
  26,
  -115,
  -33,
  16,
  86,
  -6,
  100,
  -16,
  88,
  -99,
  -102,
  -60,
  108,
  39,
  25,
  -90,
  -58,
  -17,
  -45,
  -117,
  68,
  54,
  20,
  100,
  110,
  -69,
  97,
  101,
  113,
  23,
  -17,
  -107,
  94,
  59,
  115,
  -42,
  -16,
  70,
  -111,
  30,
  -78,
  -127,
  -109,
  0,
  115,
  -26,
  -43,
  17,
  -38,
  43,
  17,
  116,
  -40,
  -76,
  -63,
  28,
  -21,
  -86,
  118,
  -49,
  34,
  43,
  9,
  -86,
  -92,
  113,
  -100,
  -125,
  71,
  31,
  46,
  -32,
  -114,
  67,
  -39,
  17,
  119,
  -27,
  -124,
  27,
  57,
  68,
  84,
  30,
  -18,
  43,
  101,
  -25,
  -118,
  -62,
  -8,
  -80,
  -123,
  -40,
  8,
  -49,
  -88,
  -107,
  111,
  19,
  -101,
  113,
  5,
  -38,
  -72,
  -115,
  127,
  61,
  -94,
  118,
  118,
  -93,
  -57,
  -115,
  -32,
  -100,
  112,
  120,
  124,
  -80,
  -69,
  53,
  -27,
  -72,
  -102,
  -125,
  94,
  91,
  93,
  108,
  -44,
  116,
  63,
  -73,
  98,
  94,
  27,
  -43,
  116,
  -108,
  98,
  -122,
  102,
  69,
  113,
  116,
  -90,
  23,
  34,
  -49,
  -112,
  15,
  42,
  -62,
  -21,
  -80,
  -33,
  -58,
  123,
  25,
  47,
  58,
  -87,
  -100,
  49,
  62,
  38,
  -13,
  -99,
  -113,
  -54,
  -54,
  -45,
  -24,
  -11,
  -99,
  -19,
  29,
  -2,
  33,
  62,
  -81,
  21,
  -57,
  70,
  50,
  -113,
  86,
  22,
  -99,
  97,
  -10,
  10,
  84,
  116,
  105,
  112,
  -84,
  -79,
  6,
  -95,
  -111,
  -115,
  -3,
  -66,
  72,
  21,
  66,
  -110,
  -86,
  102,
  -4,
  -76,
  107,
  -28,
  -96,
  92,
  -77,
  115,
  110,
  -38,
  58,
  124,
  87,
  -67,
  104,
  -102,
  47,
  4,
  -74,
  -37,
  60,
  -34,
  -72,
  79,
  -19,
  28,
  108,
  43,
  81,
  -27,
  -83,
  -127,
  91,
  -30,
  -39,
  109,
  -110,
  25,
  62,
  25,
  65,
  -56,
  -56,
  12,
  70,
  93,
  -18,
  55,
  42,
  -56,
  -55,
  -112,
  -81,
  29,
  -73,
  -118,
  -110,
  1,
  40,
  27,
  70,
  107,
  -46,
  -78,
  71,
  -114,
  37,
  8,
  51,
  128,
  -94,
  -32,
  -29,
  10,
  -25,
  -60,
  -84,
  14,
  -85,
  3,
  52,
  49,
  99,
  97,
  116,
  -116,
  22,
  86,
  91,
  -69,
  53,
  -74,
  -68,
  -13,
  13,
  27,
  -69,
  123,
  38,
  124,
  128,
  -101,
  -5,
  26,
  98,
  -26,
  20,
  -63,
  36,
  10,
  -16,
  80,
  7,
  72,
  48,
  96,
  -29,
  31,
  39,
  -123,
  -89,
  -75,
  76,
  2,
  27,
  7,
  107,
  -57,
  -41,
  -111,
  -112,
  99,
  18,
  12,
  1,
  -14,
  -21,
  4,
  11,
  77,
  95,
  40,
  80,
  -82,
  -89,
  -11,
  -104,
  70,
  -127,
  60,
  27,
  91,
  76,
  -34,
  81,
  -6,
  37,
  -10,
  -127,
  98,
  -28,
  84,
  70,
  49,
  96,
  49,
  42,
  -67,
  110,
  -80,
  -82,
  48,
  126,
  -1,
  -54,
  78,
  -116,
  -4,
  -61,
  -45,
  101,
  -23,
  89,
  -59,
  -2,
  -9,
  50,
  -63,
  -41,
  -45,
  43,
  -55,
  73,
  74,
  -12,
  18,
  -15,
  66,
  -124,
  113,
  24,
  72,
  48,
  -44,
  36,
  -15,
  53,
  92,
  3,
  41,
  108,
  -74,
  56,
  100,
  14,
  39,
  65,
  -70,
  -69,
  92,
  -37,
  50,
  -71,
  9,
  -31,
  -87,
  105,
  71,
  12,
  122,
  75,
  47,
  112,
  29,
  -27,
  -81,
  98,
  -31,
  -112,
  -16,
  6,
  103,
  -39,
  112,
  -8,
  -4,
  79,
  -99,
  58,
  7,
  -89,
  82,
  3,
  -17,
  126,
  45,
  124,
  77,
  85,
  -51,
  101,
  -35,
  62,
  97,
  82,
  -55,
  -114,
  117,
  32,
  52,
  97,
  29,
  1,
  -98,
  -50,
  -122,
  -97,
  -91,
  -61,
  -13,
  35,
  -115,
  110,
  37,
  -125,
  -41,
  80,
  -39,
  -39,
  33,
  68,
  -47,
  33,
  -122,
  22,
  -47,
  -114,
  -91,
  22,
  51,
  13,
  -6,
  110,
  -44,
  -5,
  -104,
  -77,
  -14,
  104,
  101,
  -93,
  105,
  70,
  66,
  110,
  27,
  121,
  121,
  -72,
  124,
  -22,
  24,
  -58,
  -41,
  -96,
  -35,
  43,
  12,
  -117,
  -119,
  78,
  113,
  -10,
  104,
  128,
  75,
  47,
  -21,
  -124,
  -12,
  -27,
  -91,
  -47,
  -15,
  -3,
  -61,
  -126,
  101,
  41,
  -54,
  89,
  -11,
  -33,
  -86,
  77,
  122,
  -93,
  123,
  40,
  -112,
  -12,
  109,
  81,
  -126,
  111,
  111,
  69,
  11,
  78,
  95,
  -15,
  10,
  68,
  38,
  127,
  100,
  18,
  -78,
  71,
  -21,
  -7,
  96,
  -75,
  40,
  -15,
  32,
  122,
  -47,
  -64,
  -94,
  16,
  -78,
  -92,
  -55,
  37,
  98,
  -45,
  -24,
  73,
  63,
  -7,
  59,
  80,
  2,
  -19,
  87,
  -51,
  -66,
  -62,
  -103,
  42,
  -88,
  72,
  -68,
  76,
  -66,
  -50,
  -37,
  -49,
  -87,
  -84,
  47,
  -52,
  77,
  -48,
  -65,
  22,
  -106,
  -23,
  17,
  40,
  22,
  82,
  24,
  87,
  35,
  114,
  23,
  106,
  -24,
  -127,
  -63,
  80,
  -14,
  -87,
  121,
  -56,
  112,
  -58,
  -60,
  23,
  -103,
  -98,
  54,
  73,
  10,
  -31,
  -8,
  63,
  -87,
  -47,
  -94,
  -97,
  83,
  29,
  93,
  50,
  14,
  60,
  61,
  -103,
  -42,
  60,
  38,
  -15,
  12,
  126,
  80,
  -75,
  90,
  -27,
  53,
  34,
  28,
  -84,
  16,
  -22,
  78,
  -71,
  99,
  -29,
  17,
  -15,
  -59,
  100,
  -21,
  -12,
  -66,
  -87,
  -102,
  110,
  93,
  121,
  -78,
  -17,
  60,
  29,
  27,
  -10,
  48,
  105,
  -43,
  72,
  116,
  -94,
  107,
  72,
  -79,
  40,
  38,
  97,
  -91,
  104,
  -27,
  17,
  -38,
  -87,
  85,
  46,
  114,
  -65,
  -55,
  111,
  -105,
  -55,
  -26,
  -21,
  6,
  13,
  49,
  82,
  -117,
  -49,
  -33,
  -100,
  -15,
  29,
  101,
  -86,
  -48,
  117,
  -6,
  -1,
  -44,
  -108,
  40,
  94,
  103,
  -108,
  123,
  25,
  106,
  37,
  15,
  42,
  -65,
  82,
  -17,
  26,
  29,
  -60,
  -74,
  32,
  76,
  32,
  17,
  21,
  112,
  -108,
  43,
  65,
  -106,
  -103,
  -8,
  93,
  -124,
  -116,
  56,
  65,
  26,
  -11,
  17,
  -55,
  56,
  -66,
  108,
  23,
  -76,
  23,
  32,
  -81,
  12,
  33,
  -103,
  110,
  64,
  101,
  -41,
  123,
  3,
  -78,
  114,
  52,
  -33,
  -116,
  -71,
  -79,
  10,
  -73,
  111,
  -19,
  -125,
  38,
  99,
  53,
  83,
  -119,
  -31,
  87,
  27,
  -57,
  41,
  102,
  28,
  63,
  -14,
  -74,
  -45,
  71,
  -46,
  -24,
  -84,
  7,
  28,
  -15,
  -25,
  -29,
  -43,
  128,
  47,
  -81,
  -23,
  -1,
  60,
  126,
  -92,
  107,
  -79,
  76,
  4,
  4,
  -77,
  -5,
  -58,
  100,
  -21,
  -119,
  -70,
  60,
  -111,
  121,
  -113,
  -3,
  -87,
  40,
  84,
  16,
  87,
  -92,
  90,
  72,
  -83,
  2,
  49,
  0,
  -112,
  127,
  -22,
  -95,
  46,
  -118,
  125,
  -43,
  128,
  80,
  -17,
  -28,
  58,
  -108,
  -41,
  -81,
  -57,
  18,
  7,
  18,
  90,
  -75,
  -86,
  -21,
  4,
  92,
  32,
  54,
  -83,
  97,
  53,
  -58,
  -52,
  -71,
  -25,
  -77,
  81,
  -103,
  -107,
  25,
  -124,
  80,
  61,
  -78,
  -119,
  -1,
  -51,
  -21,
  2,
  6,
  -126,
  93,
  12,
  -44,
  -84,
  -126,
  50,
  -74,
  -9,
  -11,
  81,
  -108,
  -110,
  42,
  45,
  57,
  9,
  -33,
  -19,
  34,
  -110,
  -80,
  -18,
  -71,
  -107,
  2,
  120,
  119,
  108,
  -22,
  95,
  -18,
  89,
  -101,
  40,
  -43,
  -94,
  -52,
  -19,
  -110,
  122,
  75,
  28,
  55,
  -23,
  -41,
  -125,
  100,
  -102,
  44,
  -108,
  -56,
  37,
  100,
  41,
  -72,
  -55,
  -31,
  -124,
  -18,
  -108,
  85,
  78,
  -73,
  -60,
  93,
  33,
  -1,
  -48,
  43,
  -76,
  -115,
  116,
  -53,
  41,
  -40,
  -48,
  69,
  12,
  68,
  -32,
  -88,
  103,
  -7,
  124,
  0,
  43,
  -89,
  -105,
  60,
  3,
  83,
  -102,
  29,
  2,
  50,
  24,
  -74,
  -50,
  -80,
  128,
  -47,
  123,
  94,
  -47,
  128,
  14,
  38,
  2,
  -66,
  52,
  -17,
  -38,
  103,
  -50,
  -16,
  -65,
  -31,
  -41,
  -41,
  -61,
  -100,
  46,
  34,
  -46,
  127,
  -55,
  -78,
  27,
  32,
  -75,
  33,
  58,
  -105,
  43,
  -76,
  59,
  -29,
  4,
  -15,
  91,
  90,
  -113,
  -39,
  10,
  -53,
  -104,
  -67,
  -89,
  -70,
  -81,
  -17,
  88,
  -127,
  107,
  39,
  -36,
  -7,
  10,
  73,
  -40,
  -120,
  -84,
  68,
  79,
  62,
  0,
  110,
  13,
  -20,
  90,
  89,
  105,
  -94,
  -26,
  76,
  -110,
  46,
  -14,
  14,
  89,
  31,
  85,
  -98,
  -78,
  49,
  67,
  125,
  -111,
  48,
  -69,
  56,
  -60,
  -12,
  -109,
  -121,
  99,
  -34,
  103,
  -113,
  -42,
  -94,
  -52,
  -89,
  -113,
  25,
  16,
  -1,
  -25,
  122,
  84,
  38,
  -42,
  107,
  43,
  19,
  -55,
  -103,
  -31,
  -34,
  -38,
  -109,
  -39,
  89,
  -47,
  10,
  34,
  -120,
  80,
  9,
  -67,
  114,
  -28,
  -33,
  35,
  58,
  -122,
  76,
  38,
  89,
  100,
  85,
  -124,
  -79,
  18,
  89,
  -36,
  128,
  -62,
  67,
  7,
  -78,
  -55,
  -83,
  -51,
  -49,
  -8,
  -108,
  -118,
  78,
  -24,
  -15,
  105,
  112,
  41,
  -3,
  54,
  7,
  105,
  56,
  -54,
  121,
  73,
  92,
  -119,
  -64,
  -117,
  47,
  43,
  -57,
  -86,
  -26,
  113,
  -112,
  66,
  -34,
  21,
  -27,
  71,
  -90,
  58,
  -13,
  -24,
  -7,
  71,
  112,
  -25,
  -115,
  77,
  -100,
  89,
  69,
  90,
  -124,
  -91,
  -41,
  9,
  53,
  75,
  122,
  26,
  -51,
  -28,
  103,
  -18,
  -104,
  -56,
  -67,
  -100,
  -19,
  78,
  -90,
  -22,
  98,
  -44,
  105,
  87,
  -37,
  -51,
  -31,
  35,
  72,
  91,
  8,
  53,
  124,
  -18,
  88,
  -75,
  -66,
  -31,
  2,
  28,
  55,
  -80,
  -36,
  86,
  58,
  -59,
  -123,
  -99,
  -98,
  -16,
  -8,
  -113,
  -45,
  62,
  32,
  48,
  -26,
  5,
  -3,
  -115,
  -63,
  -48,
  62,
  -109,
  -67,
  -10,
  13,
  83,
  -24,
  -121,
  4,
  99,
  -45,
  -87,
  -50,
  -30,
  -107,
  -92,
  60,
  21,
  2,
  -18,
  63,
  -20,
  -31,
  52,
  56,
  -67,
  -101,
  -118,
  -66,
  58,
  -30,
  -19,
  -36,
  -5,
  35,
  -102,
  -30,
  -73,
  -11,
  86,
  -49,
  72,
  59,
  93,
  98,
  13,
  -40,
  49,
  108,
  116,
  -46,
  81,
  78,
  76,
  -33,
  -45,
  61,
  -25,
  -40,
  -27,
  79,
  -96,
  -126,
  60,
  112,
  -113,
  -107,
  -111,
  124,
  44,
  5,
  127,
  120,
  -104,
  -53,
  -3,
  -5,
  -40,
  -122,
  -59,
  -15,
  -12,
  -110,
  84,
  105,
  38,
  85,
  -89,
  104,
  -59,
  -48,
  73,
  42,
  -115,
  114,
  -119,
  -64,
  -54,
  106,
  -64,
  13,
  112,
  -10,
  69,
  83,
  -122,
  -16,
  -56,
  26,
  -92,
  82,
  20,
  62,
  -127,
  38,
  107,
  -83,
  -98,
  -34,
  -23,
  -62,
  68,
  51,
  93,
  -47,
  -123,
  27,
  -124,
  -52,
  113,
  -52,
  -74,
  -9,
  -66,
  55,
  98,
  119,
  -12,
  -31,
  128,
  118,
  -59,
  -120,
  77,
  84,
  -102,
  65,
  59,
  -72,
  -2,
  50,
  96,
  116,
  65,
  87,
  -29,
  37,
  -52,
  15,
  -25,
  -80,
  16,
  88,
  -87,
  100,
  36,
  -82,
  -95,
  19,
  -56,
  26,
  109,
  33,
  13,
  -114,
  39,
  -78,
  -87,
  -45,
  -2,
  44,
  58,
  118,
  26,
  102,
  9,
  -63,
  -65,
  -22,
  107,
  66,
  -83,
  -104,
  2,
  -91,
  85,
  26,
  -105,
  56,
  -26,
  7,
  57,
  -23,
  84,
  -80,
  100,
  101,
  -34,
  -80,
  -101,
  -43,
  39,
  -29,
  -75,
  -102,
  58,
  -28,
  -8,
  112,
  79,
  -57,
  79,
  -114,
  -100,
  59,
  39,
  101,
  124,
  -72,
  -21,
  -86,
  90,
  89,
  36,
  -27,
  -113,
  -27,
  59,
  87,
  14,
  53,
  127,
  -122,
  123,
  0,
  19,
  -72,
  -79,
  -103,
  32,
  43,
  -42,
  -80,
  -2,
  56,
  16,
  -89,
  18,
  50,
  91,
  -123,
  98,
  -118,
  -64,
  33,
  124,
  -35,
  -42,
  104,
  122,
  -18,
  90,
  81,
  -67,
  -109,
  100,
  -121,
  -20,
  -64,
  -48,
  79,
  40,
  71,
  17,
  9,
  -58,
  111,
  27,
  85,
  1,
  -29,
  -123,
  117,
  -122,
  -13,
  -18,
  71,
  82,
  14,
  -107,
  -127,
  43,
  -125,
  117,
  -22,
  -3,
  -36,
  -48,
  -7,
  27,
  66,
  107,
  60,
  -90,
  -27,
  32,
  -17,
  -73,
  -67,
  -34,
  -72,
  -89,
  -29,
  -118,
  102,
  111,
  -90,
  -85,
  -97,
  -11,
  38,
  97,
  -85,
  -28,
  49,
  -46,
  -28,
  126,
  -62,
  70,
  -104,
  18,
  -10,
  35,
  -52,
  -86,
  55,
  49,
  -116,
  38,
  -44,
  75,
  49,
  -109,
  41,
  -71,
  -70,
  12,
  26,
  -47,
  -90,
  26,
  111,
  -61,
  -34,
  46,
  21,
  -102,
  42,
  89,
  36,
  111,
  122,
  7,
  71,
  58,
  68,
  11,
  81,
  5,
  53,
  103,
  -93,
  6,
  46,
  53,
  83,
  -33,
  -62,
  47,
  83,
  -82,
  -42,
  -113,
  -51,
  -14,
  -58,
  -81,
  -18,
  87,
  97,
  -88,
  -39,
  -18,
  111,
  -30,
  -21,
  24,
  -37,
  72,
  77,
  124,
  -100,
  23,
  -73,
  -106,
  99,
  69,
  106,
  58,
  7,
  -8,
  105,
  -70,
  97,
  -91,
  14,
  -76,
  -22,
  -123,
  -55,
  51,
  -116,
  28,
  3,
  -86,
  48,
  69,
  -14,
  1,
  -29,
  -100,
  -78,
  123,
  -39,
  -50,
  -48,
  -114,
  -48,
  74,
  -104,
  -97,
  24,
  -48,
  -99,
  -109,
  4,
  66,
  36,
  126,
  127,
  -8,
  16,
  93,
  5,
  128,
  75,
  24,
  -87,
  -85,
  -27,
  -6,
  -81,
  -63,
  113,
  101,
  -47,
  -76,
  -79,
  -63,
  55,
  126,
  52,
  -80,
  -78,
  -45,
  108,
  108,
  81,
  -73,
  -67,
  -38,
  36,
  105,
  30,
  -59,
  -120,
  116,
  -26,
  77,
  -84,
  -116,
  -34,
  -67,
  -34,
  14,
  -3,
  -97,
  112,
  -65,
  29,
  -91,
  -7,
  -30,
  -37,
  88,
  109,
  -67,
  7,
  -103,
  85,
  -85,
  -88,
  41,
  46,
  85,
  -41,
  122,
  37,
  -24,
  107,
  111,
  -15,
  57,
  -41,
  -6,
  -117,
  92,
  -102,
  -20,
  -46,
  88,
  -109,
  -122,
  13,
  99,
  -6,
  51,
  52,
  -84,
  37,
  -72,
  53,
  -66,
  -55,
  125,
  28,
  -119,
  -66,
  -89,
  -62,
  -98,
  76,
  17,
  -46,
  87,
  76,
  91,
  48,
  13,
  -88,
  -88,
  -66,
  -119,
  -4,
  -51,
  -86,
  -12,
  55,
  -91,
  110,
  -55,
  108,
  31,
  125,
  -18,
  107,
  69,
  104,
  -18,
  -76,
  120,
  -38,
  35,
  -41,
  100,
  22,
  -86,
  -65,
  32,
  58,
  -13,
  -88,
  -15,
  -28,
  71,
  60,
  -107,
  -107,
  5,
  -86,
  -89,
  92,
  0,
  -60,
  -90,
  -92,
  -125,
  67,
  -46,
  61,
  -6,
  111,
  -64,
  118,
  104,
  83,
  45,
  -46,
  55,
  -115,
  110,
  91,
  76,
  -74,
  30,
  82,
  81,
  9,
  -117,
  -28,
  -52,
  -14,
  -100,
  62,
  119,
  -117,
  50,
  115,
  128,
  9,
  -4,
  55,
  -91,
  -16,
  -91,
  5,
  -37,
  -65,
  -12,
  72,
  54,
  25,
  121,
  -29,
  -74,
  114,
  -71,
  -33,
  9,
  -110,
  -92,
  -8,
  32,
  31,
  31,
  -122,
  92,
  44,
  10,
  -99,
  101,
  88,
  -110,
  -15,
  64,
  82,
  1,
  118,
  16,
  7,
  34,
  -78,
  -45,
  -28,
  -33,
  -72,
  -68,
  -115,
  -38,
  81,
  106,
  58,
  6,
  -14,
  -105,
  -37,
  -98,
  70,
  -90,
  76,
  68,
  -76,
  -85,
  117,
  12,
  53,
  67,
  -62,
  118,
  5,
  -2,
  86,
  57,
  -117,
  -61,
  45,
  116,
  29,
  97,
  -42,
  -108,
  47,
  -97,
  -36,
  13,
  83,
  121,
  -86,
  -85,
  127,
  45,
  -5,
  -50,
  -22,
  63,
  -77,
  -2,
  54,
  -9,
  -6,
  -2,
  56,
  -101,
  -52,
  -36,
  -7,
  74,
  2,
  -30,
  -117,
  75,
  79,
  -27,
  65,
  61,
  -111,
  12,
  -88,
  22,
  -41,
  -8,
  -30,
  -81,
  -81,
  -110,
  -120,
  52,
  25,
  115,
  -42,
  11,
  -87,
  81,
  118,
  81,
  -35,
  -71,
  42,
  -123,
  74,
  -123,
  10,
  -9,
  42,
  103,
  -99,
  -105,
  35,
  46,
  -47,
  18,
  -107,
  -13,
  53,
  13,
  -51,
  -93,
  -83,
  -36,
  125,
  50,
  -78,
  64,
  117,
  -33,
  91,
  -96,
  36,
  -116,
  -67,
  -55,
  -32,
  -27,
  -21,
  -66,
  -77,
  2,
  -57,
  -40,
  54,
  -112,
  -110,
  95,
  104,
  98,
  25,
  -122,
  78,
  43,
  74,
  -108,
  -1,
  -89,
  -18,
  3,
  88,
  -116,
  103,
  -67,
  2,
  91,
  4,
  43,
  -98,
  65,
  -117,
  25,
  -112,
  -49,
  55,
  -127,
  -20,
  30,
  55,
  -1,
  -99,
  115,
  31,
  -124,
  103,
  26,
  -16,
  31,
  125,
  -106,
  113,
  -115,
  -29,
  124,
  16,
  17,
  86,
  74,
  99,
  -2,
  -107,
  128,
  124,
  113,
  47,
  25,
  84,
  24,
  -93,
  101,
  -111,
  -42,
  75,
  -56,
  4,
  1,
  85,
  -105,
  64,
  23,
  -79,
  -98,
  19,
  -56,
  -36,
  19,
  18,
  -24,
  51,
  -88,
  -4,
  -53,
  102,
  -44,
  -48,
  -89,
  -67,
  -12,
  -28,
  112,
  14,
  67,
  -82,
  82,
  -99,
  13,
  117,
  -83,
  69,
  105,
  14,
  -19,
  120,
  68,
  116,
  -126,
  -65,
  -76,
  65,
  95,
  -80,
  6,
  -115,
  -37,
  22,
  35,
  108,
  -13,
  -50,
  110,
  -117,
  -109,
  21,
  -22,
  -83,
  -7,
  13,
  84,
  65,
  66,
  -76,
  -64,
  -65,
  -95,
  -48,
  -119,
  96,
  63,
  20,
  -78,
  66,
  -79,
  -113,
  -15,
  -24,
  -113,
  41,
  15,
  23,
  -121,
  109,
  2,
  -36,
  23,
  55,
  7,
  -30,
  -114,
  112,
  -24,
  -28,
  72,
  -127,
  -1,
  -28,
  -47,
  -120,
  113,
  -35,
  -89,
  -6,
  -36,
  -126,
  -29,
  -118,
  65,
  -109,
  127,
  -45,
  59,
  -94,
  18,
  17,
  63,
  12,
  52,
  81,
  76,
  103,
  -123,
  -27,
  -1,
  117,
  -108,
  -73,
  54,
  12,
  117,
  11,
  -102,
  -83,
  -90,
  86,
  -38,
  112,
  -122,
  58,
  102,
  62,
  -18,
  -7,
  -19,
  -85,
  95,
  -3,
  -124,
  -64,
  75,
  -47,
  -3,
  -52,
  -67,
  -42,
  -114,
  53,
  70,
  -16,
  -113,
  5,
  -34,
  -13,
  108,
  -51,
  12,
  -1,
  128,
  -120,
  -121,
  38,
  -35,
  96,
  74,
  -25,
  77,
  -99,
  17,
  -96,
  6,
  100,
  18,
  -33,
  104,
  35,
  -97,
  30,
  127,
  -114,
  -6,
  1,
  122,
  -46,
  -102,
  97,
  64,
  -75,
  88,
  -86,
  -41,
  -16,
  -1,
  -77,
  80,
  -96,
  -73,
  -92,
  21,
  -108,
  -79,
  119,
  124,
  30,
  105,
  16,
  81,
  -103,
  25,
  -59,
  -63,
  65,
  -63,
  -11,
  -32,
  -26,
  -55,
  -3,
  69,
  -49,
  -113,
  -106,
  -11,
  9,
  14,
  -98,
  -67,
  80,
  58,
  48,
  -122,
  91,
  -25,
  21,
  -46,
  109,
  105,
  -36,
  -102,
  -101,
  70,
  110,
  -4,
  92,
  -1,
  -127,
  -36,
  -115,
  -91,
  -64,
  91,
  -71,
  -7,
  114,
  -117,
  -46,
  -81,
  -67,
  -23,
  -82,
  27,
  64,
  -111,
  17,
  102,
  49,
  77,
  35,
  34,
  47,
  87,
  128,
  65,
  2,
  13,
  128,
  99,
  12,
  49,
  33,
  -25,
  34,
  -50,
  -1,
  -15,
  117,
  -127,
  -62,
  -118,
  -103,
  -47,
  -13,
  96,
  -111,
  -124,
  -20,
  -1,
  125,
  -124,
  116,
  54,
  -85,
  -113,
  50,
  -103,
  -23,
  70,
  62,
  74,
  -44,
  14,
  -34,
  4,
  4,
  -26,
  71,
  107,
  -113,
  -76,
  -9,
  -12,
  51,
  83,
  -99,
  118,
  108,
  -71,
  -55,
  105,
  85,
  40,
  -65,
  -10,
  36,
  112,
  37,
  59,
  -4,
  -33,
  25,
  -111,
  -25,
  93,
  0,
  -72,
  80,
  1,
  -64,
  57,
  -7,
  -68,
  38,
  22,
  -114,
  -101,
  -7,
  -28,
  -46,
  -85,
  72,
  -22,
  120,
  94,
  19,
  15,
  -42,
  123,
  46,
  29,
  -87,
  84,
  31,
  101,
  -63,
  -103,
  -122,
  -68,
  6,
  -52,
  20,
  -105,
  -3,
  4,
  -102,
  -7,
  121,
  -113,
  -89,
  79,
  -34,
  125,
  32,
  48,
  76,
  -124,
  97,
  -101,
  -62,
  67,
  -101,
  -125,
  98,
  88,
  -62,
  -120,
  -89,
  -75,
  -66,
  45,
  -54,
  -115,
  11,
  127,
  -23,
  119,
  71,
  5,
  -87,
  99,
  113,
  -59,
  119,
  -121,
  -114,
  118,
  100,
  3,
  -14,
  -98,
  -48,
  37,
  121,
  41,
  -50,
  79,
  -3,
  -29,
  55,
  110,
  69,
  122,
  3,
  -102,
  34,
  97,
  25,
  79,
  28,
  4,
  5,
  70,
  63,
  30,
  -81,
  4,
  49,
  66,
  -105,
  -63,
  -23,
  46,
  -48,
  27,
  119,
  -44,
  107,
  -63,
  -74,
  61,
  19,
  -21,
  -121,
  -101,
  48,
  12,
  67,
  -94,
  -79,
  -90,
  23,
  -5,
  -115,
  -89,
  -114,
  42,
  -89,
  111,
  28,
  14,
  94,
  45,
  -75,
  -117,
  5,
  -72,
  25,
  -124,
  111,
  -62,
  23,
  20,
  91,
  78,
  -66,
  -80,
  -56,
  84,
  -64,
  -64,
  -67,
  -28,
  -43,
  -127,
  -66,
  -1,
  109,
  -102,
  -64,
  -93,
  -94,
  45,
  6,
  -55,
  58,
  -101,
  38,
  -84,
  53,
  -110,
  -119,
  -14,
  -116,
  -51,
  56,
  -70,
  3,
  41,
  -94,
  79,
  47,
  28,
  63,
  -27,
  16,
  -58,
  -12,
  -62,
  -102,
  -86,
  17,
  61,
  74,
  118,
  122,
  -7,
  -91,
  95,
  -98,
  96,
  -100,
  52,
  110,
  -70,
  -115,
  -100,
  92,
  -54,
  -32,
  -119,
  -96,
  -53,
  -123,
  -9,
  20,
  -11,
  -36,
  86,
  107,
  -99,
  117,
  95,
  -118,
  107,
  -55,
  -102,
  21,
  22,
  2,
  -92,
  32,
  -74,
  -100,
  -92,
  11,
  39,
  52,
  104,
  -79,
  -30,
  -94,
  63,
  26,
  76,
  -88,
  -121,
  -63,
  122,
  -109,
  -82,
  -67,
  115,
  77,
  -63,
  -16,
  -67,
  -48,
  -127,
  -97,
  -32,
  -121,
  -83,
  -74,
  39,
  115,
  -122,
  -104,
  -53,
  -48,
  94,
  44,
  18,
  -91,
  43,
  19,
  72,
  -69,
  19,
  -15,
  77,
  -114,
  56,
  -114,
  -81,
  -33,
  111,
  -124,
  10,
  27,
  24,
  -80,
  -78,
  -112,
  -119,
  -36,
  -59,
  75,
  -83,
  99,
  -125,
  8,
  6,
  -28,
  -90,
  67,
  -94,
  -62,
  30,
  127,
  124,
  68,
  23,
  58,
  -64,
  96,
  36,
  -64,
  3,
  -90,
  111,
  -39,
  81,
  -12,
  82,
  -110,
  -99,
  -34,
  84,
  -31,
  48,
  71,
  -124,
  -90,
  -23,
  13,
  119,
  53,
  -84,
  106,
  -27,
  -93,
  -109,
  -92,
  -127,
  -99,
  101,
  104,
  76,
  -105,
  87,
  7,
  0,
  -115,
  -53,
  -74,
  47,
  -19,
  -34,
  -85,
  -54,
  65,
  -107,
  -62,
  -60,
  -30,
  -6,
  47,
  76,
  68,
  -40,
  -103,
  100,
  -94,
  -69,
  84,
  -63,
  -92,
  80,
  -10,
  -68,
  -63,
  61,
  98,
  80,
  -34,
  42,
  -6,
  -46,
  100,
  59,
  -20,
  96,
  -45,
  79,
  85,
  -111,
  109,
  -122,
  48,
  -40,
  -33,
  72,
  3,
  -106,
  126,
  -107,
  -110,
  -64,
  118,
  -127,
  71,
  -94,
  98,
  -8,
  -25,
  -113,
  96,
  -88,
  59,
  54,
  -122,
  -20,
  114,
  63,
  -84,
  -8,
  94,
  127,
  -44,
  -100,
  9,
  50,
  -108,
  -99,
  -100,
  -31,
  92,
  23,
  -76,
  -97,
  101,
  73,
  79,
  -67,
  -126,
  55,
  -89,
  55,
  -96,
  -111,
  -107,
  -91,
  54,
  -39,
  76,
  -70,
  -9,
  20,
  64,
  -104,
  39,
  -49,
  -20,
  22,
  -91,
  -42,
  104,
  -87,
  30,
  70,
  23,
  25,
  87,
  -54,
  -33,
  117,
  -61,
  -80,
  116,
  73,
  113,
  -59,
  -122,
  -114,
  73,
  -78,
  -86,
  76,
  -69,
  -36,
  -23,
  98,
  -54,
  -63,
  -46,
  -68,
  49,
  42,
  -98,
  -89,
  94,
  -9,
  26,
  73,
  29,
  -64,
  26,
  122,
  -29,
  -30,
  85,
  97,
  -99,
  83,
  -5,
  -126,
  -101,
  -113,
  81,
  -76,
  115,
  78,
  94,
  86,
  106,
  1,
  118,
  -50,
  -44,
  -97,
  109,
  -62,
  -5,
  -57,
  26,
  1,
  -66,
  -106,
  -79,
  -77,
  2,
  89,
  -87,
  -108,
  -44,
  -108,
  88,
  30,
  -68,
  -8,
  10,
  4,
  -63,
  -69,
  81,
  -124,
  31,
  13,
  -3,
  -15,
  29,
  -10,
  44,
  -43,
  120,
  -88,
  -56,
  77,
  -99,
  78,
  -63,
  62,
  1,
  0,
  26,
  -22,
  -78,
  102,
  -39,
  64,
  46,
  52,
  128,
  125,
  -57,
  126,
  117,
  -60,
  74,
  -86,
  -87,
  -125,
  61,
  56,
  -10,
  9,
  -49,
  109,
  -28,
  2,
  36,
  -11,
  100,
  -75,
  36,
  -126,
  -79,
  -88,
  -102,
  9,
  56,
  25,
  76,
  -88,
  -108,
  87,
  -123,
  -65,
  -111,
  5,
  117,
  -7,
  127,
  -18,
  -104,
  -34,
  -100,
  70,
  98,
  36,
  81,
  128,
  -1,
  -57,
  109,
  -54,
  -10,
  -70,
  -78,
  -7,
  60,
  -65,
  57,
  -117,
  -29,
  -29,
  12,
  -77,
  34,
  92,
  41,
  79,
  42,
  -57,
  -47,
  66,
  -22,
  -50,
  -90,
  105,
  18,
  -115,
  -103,
  -105,
  -97,
  89,
  -127,
  37,
  45,
  46,
  98,
  33,
  38,
  -93,
  -117,
  57,
  105,
  -66,
  -50,
  -36,
  75,
  117,
  -100,
  -1,
  2,
  -61,
  -3,
  -13,
  -112,
  -38,
  104,
  -92,
  83,
  62,
  -15,
  74,
  94,
  -122,
  26,
  -92,
  13,
  -121,
  -103,
  -100,
  -50,
  93,
  108,
  55,
  39,
  -15,
  -69,
  25,
  -45,
  -120,
  -93,
  -97,
  16,
  -60,
  56,
  -5,
  -119,
  -76,
  -124,
  106,
  -10,
  -13,
  -96,
  11,
  -87,
  -84,
  14,
  -63,
  -8,
  52,
  62,
  -32,
  -70,
  -66,
  5,
  -73,
  53,
  -76,
  -55,
  -9,
  93,
  41,
  -43,
  21,
  51,
  39,
  126,
  -7,
  -66,
  122,
  -106,
  17,
  -21,
  43,
  -123,
  123,
  125,
  -13,
  -23,
  31,
  -10,
  85,
  16,
  -121,
  -19,
  77,
  -28,
  47,
  -107,
  -81,
  81,
  -8,
  116,
  -89,
  -91,
  -45,
  35,
  89,
  16,
  -64,
  23,
  88,
  -37,
  47,
  -58,
  8,
  -42,
  49,
  5,
  -70,
  -95,
  -25,
  7,
  -113,
  123,
  -50,
  -100,
  -75,
  92,
  58,
  120,
  -125,
  80,
  99,
  -68,
  -76,
  13,
  -18,
  -88,
  -124,
  24,
  -46,
  -3,
  -96,
  86,
  59,
  100,
  -92,
  -77,
  -101,
  -82,
  -95,
  80,
  69,
  47,
  1,
  122,
  -85,
  -51,
  -72,
  112,
  27,
  -66,
  -85,
  -118,
  -26,
  70,
  -91,
  43,
  -116,
  -20,
  -63,
  -81,
  36,
  4,
  -62,
  108,
  33,
  -82,
  -10,
  22,
  78,
  -29,
  -64,
  -105,
  -12,
  10,
  -10,
  94,
  -62,
  52,
  -35,
  -94,
  -74,
  -50,
  -94,
  20,
  86,
  -122,
  -24,
  -115,
  -54,
  -103,
  -35,
  52,
  47,
  -19,
  -39,
  -18,
  -73,
  89,
  -50,
  -108,
  -122,
  -111,
  -123,
  -80,
  97,
  -92,
  54,
  109,
  56,
  -103,
  24,
  50,
  -81,
  -67,
  75,
  79,
  -66,
  20,
  -74,
  -71,
  -81,
  15,
  -54,
  -37,
  81,
  83,
  -77,
  -22,
  95,
  58,
  -42,
  49,
  -112,
  -28,
  18,
  -62,
  -80,
  -36,
  7,
  -94,
  -52,
  -108,
  68,
  -41,
  -107,
  -83,
  -69,
  -13,
  20,
  63,
  67,
  63,
  -111,
  118,
  -10,
  -91,
  -31,
  119,
  -66,
  84,
  89,
  -25,
  -20,
  16,
  100,
  79,
  -73,
  113,
  104,
  128,
  75,
  114,
  59,
  36,
  82,
  -13,
  -119,
  38,
  73,
  70,
  -1,
  111,
  5,
  55,
  -91,
  -72,
  -87,
  57,
  -88,
  93,
  -65,
  75,
  -104,
  89,
  106,
  76,
  -63,
  15,
  -66,
  123,
  113,
  -98,
  -83,
  -88,
  108,
  -104,
  78,
  100,
  -103,
  -23,
  11,
  -124,
  12,
  124,
  -34,
  71,
  -42,
  56,
  10,
  13,
  -112,
  -27,
  97,
  37,
  -78,
  -86,
  -5,
  2,
  102,
  -106,
  -50,
  11,
  21,
  -89,
  -28,
  119,
  46,
  -60,
  -83,
  -7,
  8,
  42,
  59,
  -113,
  -2,
  86,
  39,
  68,
  -101,
  -70,
  74,
  61,
  -83,
  -96,
  -56,
  -21,
  -44,
  -93,
  -35,
  -28,
  67,
  31,
  99,
  -10,
  -31,
  3,
  16,
  -107,
  29,
  66,
  -75,
  -24,
  72,
  85,
  -69,
  -37,
  -63,
  102,
  69,
  24,
  128,
  -30,
  -110,
  -52,
  -65,
  108,
  -74,
  97,
  49,
  -70,
  98,
  -110,
  -102,
  -33,
  -97,
  -114,
  -67,
  -35,
  -103,
  -84,
  37,
  -66,
  82,
  124,
  -85,
  110,
  -59,
  43,
  82,
  49,
  123,
  -100,
  77,
  -2,
  126,
  -50,
  -70,
  -43,
  76,
  102,
  43,
  63,
  9,
  57,
  -118,
  -13,
  -58,
  -127,
  -16,
  -22,
  67,
  43,
  43,
  -36,
  32,
  127,
  -78,
  -54,
  57,
  -2,
  77,
  -28,
  70,
  -11,
  63,
  -78,
  81,
  -87,
  92,
  96,
  -84,
  57,
  63,
  -23,
  39,
  37,
  113,
  108,
  -76,
  -21,
  -28,
  -39,
  -30,
  20,
  -5,
  -14,
  52,
  -45,
  -120,
  -18,
  -105,
  -99,
  -60,
  35,
  -65,
  -93,
  -76,
  -32,
  20,
  -120,
  86,
  -83,
  -4,
  -105,
  -68,
  44,
  -22,
  81,
  32,
  53,
  80,
  -88,
  44,
  112,
  119,
  117,
  -52,
  -118,
  109,
  69,
  -36,
  51,
  -39,
  6,
  92,
  -12,
  29,
  -3,
  63,
  120,
  -20,
  106,
  -39,
  66,
  -42,
  13,
  56,
  99,
  124,
  108,
  70,
  55,
  -60,
  -36,
  -64,
  -78,
  126,
  -14,
  65,
  -99,
  -83,
  7,
  114,
  -48,
  61,
  -32,
  -127,
  -72,
  -33,
  49,
  5,
  -41,
  -77,
  52,
  31,
  -125,
  -33,
  -71,
  -42,
  -43,
  98,
  62,
  -55,
  76,
  -7,
  27,
  -75,
  119,
  -42,
  -32,
  -70,
  50,
  -58,
  66,
  -88,
  70,
  80,
  8,
  79,
  69,
  28,
  17,
  79,
  -64,
  -94,
  -85,
  76,
  110,
  124,
  23,
  -70,
  127,
  50,
  128,
  120,
  -50,
  81,
  -63,
  -101,
  -25,
  -42,
  -77,
  68,
  -82,
  -58,
  -125,
  -38,
  -1,
  18,
  -53,
  -106,
  -84,
  -38,
  -62,
  -87,
  51,
  125,
  -64,
  -18,
  -117,
  114,
  6,
  111,
  99,
  78,
  106,
  128,
  33,
  23,
  52,
  127,
  32,
  -65,
  -124,
  -99,
  -16,
  -56,
  120,
  -17,
  -111,
  94,
  -68,
  -117,
  55,
  22,
  61,
  -26,
  -6,
  -14,
  123,
  14,
  -120,
  -35,
  58,
  -29,
  35,
  -55,
  49,
  39,
  25,
  53,
  57,
  19,
  -24,
  -25,
  -62,
  67,
  -109,
  101,
  -51,
  74,
  125,
  26,
  -82,
  127,
  43,
  -33,
  124,
  28,
  91,
  -31,
  92,
  -71,
  92,
  20,
  -61,
  91,
  -112,
  -97,
  66,
  -69,
  -127,
  -62,
  105,
  -97,
  -93,
  -17,
  -12,
  -26,
  -50,
  -20,
  110,
  -72,
  -43,
  48,
  42,
  57,
  23,
  -17,
  -28,
  67,
  -4,
  37,
  -62,
  47,
  115,
  -125,
  74,
  -27,
  -30,
  -53,
  -49,
  22,
  116,
  99,
  -90,
  -49,
  -43,
  63,
  27,
  -42,
  99,
  18,
  93,
  -44,
  84,
  -11,
  108,
  -123,
  14,
  -115,
  87,
  -41,
  91,
  -95,
  -78,
  98,
  -46,
  -119,
  88,
  -114,
  -111,
  -55,
  -91,
  82,
  67,
  -124,
  -69,
  35,
  -46,
  55,
  -64,
  -2,
  -126,
  -125,
  8,
  -107,
  -53,
  40,
  -33,
  77,
  -123,
  -1,
  74,
  -18,
  -67,
  -50,
  -23,
  -57,
  -11,
  45,
  81,
  -38,
  -98,
  -83,
  -10,
  -47,
  -88,
  -6,
  35,
  84,
  91,
  -99,
  -44,
  -65,
  -13,
  -71,
  -83,
  -71,
  -95,
  -93,
  96,
  127,
  -69,
  63,
  113,
  -102,
  -71,
  -24,
  128,
  -73,
  -94,
  -53,
  -101,
  111,
  62,
  47,
  121,
  116,
  -54,
  43,
  -79,
  -76,
  65,
  87,
  50,
  82,
  89,
  104,
  79,
  126,
  52,
  -46,
  -114,
  -117,
  35,
  93,
  43,
  -48,
  -53,
  15,
  -25,
  -11,
  -88,
  -85,
  -25,
  -90,
  84,
  88,
  -57,
  70,
  35,
  -94,
  113,
  -100,
  -68,
  -90,
  96,
  120,
  -71,
  -88,
  48,
  114,
  -127,
  38,
  20,
  -2,
  -33,
  35,
  -113,
  -26,
  44,
  -125,
  -67,
  48,
  -95,
  14,
  -13,
  -117,
  -63,
  -116,
  41,
  65,
  25,
  74,
  86,
  -105,
  74,
  -118,
  -27,
  100,
  -77,
  -47,
  74,
  24,
  -66,
  -74,
  119,
  6,
  6,
  -22,
  47,
  98,
  -70,
  49,
  21,
  -81,
  -5,
  -12,
  -18,
  90,
  37,
  -99,
  -61,
  -30,
  127,
  15,
  -11,
  30,
  -4,
  74,
  -38,
  -77,
  49,
  108,
  55,
  -17,
  -17,
  -36,
  -117,
  95,
  -36,
  -7,
  -125,
  7,
  31,
  74,
  -90,
  -116,
  -89,
  128,
  118,
  80,
  -108,
  14,
  31,
  32,
  39,
  50,
  -58,
  71,
  41,
  -40,
  -38,
  -104,
  74,
  11,
  -74,
  45,
  -46,
  -33,
  83,
  5,
  28,
  -98,
  -84,
  -35,
  88,
  -89,
  -4,
  6,
  87,
  88,
  88,
  59,
  84,
  63,
  53,
  -40,
  -27,
  99,
  -119,
  115,
  100,
  72,
  3,
  -108,
  19,
  -80,
  -88,
  8,
  -13,
  36,
  12,
  104,
  -98,
  59,
  87,
  11,
  -120,
  8,
  117,
  -27,
  -72,
  65,
  103,
  102,
  -87,
  -2,
  -1,
  -107,
  124,
  -95,
  48,
  -72,
  -65,
  -20,
  -85,
  72,
  18,
  -52,
  125,
  78,
  121,
  -33,
  -28,
  -33,
  81,
  -98,
  79,
  -16,
  104,
  83,
  18,
  10,
  -97,
  -1,
  -89,
  32,
  112,
  24,
  22,
  104,
  57,
  88,
  88,
  -59,
  7,
  70,
  -38,
  -48,
  102,
  100,
  105,
  125,
  105,
  104,
  -121,
  -66,
  125,
  -115,
  -70,
  98,
  60,
  56,
  18,
  51,
  -83,
  -96,
  109,
  62,
  -16,
  112,
  0,
  -5,
  59,
  -90,
  34,
  -65,
  1,
  55,
  -62,
  -72,
  -61,
  -32,
  101,
  -99,
  -23,
  51,
  55,
  62,
  94,
  34,
  92,
  0,
  -93,
  -61,
  -78,
  83,
  -75,
  73,
  -122,
  -124,
  -58,
  -61,
  101,
  111,
  8,
  -25,
  73,
  90,
  -72,
  -7,
  93,
  -82,
  95,
  26,
  64,
  -63,
  81,
  50,
  -106,
  -4,
  -71,
  -124,
  56,
  111,
  -91,
  100,
  30,
  -12,
  -65,
  0,
  125,
  -109,
  -70,
  69,
  -51,
  88,
  -4,
  63,
  -25,
  -53,
  113,
  121,
  53,
  -32,
  -82,
  -30,
  -92,
  -36,
  -65,
  107,
  76,
  31,
  43,
  -92,
  32,
  -52,
  10,
  -101,
  -37,
  -29,
  -120,
  -79,
  115,
  78,
  -15,
  100,
  -24,
  -113,
  -61,
  90,
  -43,
  -68,
  14,
  -39,
  -48,
  36,
  54,
  98,
  11,
  112,
  6,
  -53,
  77,
  82,
  -52,
  -44,
  102,
  -5,
  -36,
  67,
  -15,
  29,
  32,
  85,
  -100,
  120,
  -82,
  34,
  11,
  -65,
  102,
  14,
  -124,
  -4,
  80,
  87,
  94,
  126,
  -102,
  64,
  80,
  102,
  59,
  -122,
  -104,
  -88,
  22,
  -68,
  23,
  -79,
  -114,
  67,
  72,
  -70,
  -46,
  -2,
  -28,
  -22,
  -18,
  -38,
  123,
  28,
  -37,
  95,
  83,
  77,
  -96,
  47,
  76,
  61,
  -47,
  -83,
  -24,
  -70,
  17,
  -115,
  -106,
  111,
  65,
  -125,
  56,
  -68,
  56,
  -27,
  -37,
  103,
  76,
  -70,
  123,
  -86,
  -82,
  -24,
  13,
  110,
  -63,
  7,
  -19,
  33,
  70,
  -88,
  -71,
  -62,
  36,
  105,
  -36,
  114,
  78,
  40,
  -76,
  -7,
  -96,
  -41,
  -80,
  105,
  -105,
  14,
  50,
  71,
  13,
  39,
  -50,
  5,
  73,
  -119,
  -45,
  -102,
  -115,
  8,
  -79,
  101,
  60,
  19,
  42,
  -52,
  -44,
  -2,
  -52,
  77,
  -53,
  -101,
  -127,
  -73,
  61,
  -67,
  -86,
  29,
  -27,
  126,
  48,
  69,
  8,
  93,
  86,
  68,
  55,
  5,
  -10,
  60,
  -25,
  46,
  -110,
  116,
  46,
  -63,
  74,
  -16,
  -117,
  -69,
  85,
  72,
  67,
  71,
  122,
  -64,
  -106,
  -26,
  122,
  71,
  -88,
  -117,
  -100,
  -126,
  54,
  114,
  36,
  -107,
  40,
  -29,
  63,
  110,
  -125,
  -96,
  125,
  35,
  -115,
  63,
  12,
  7,
  79,
  69,
  18,
  65,
  10,
  70,
  -41,
  87,
  -15,
  67,
  107,
  56,
  23,
  24,
  120,
  78,
  50,
  -73,
  -45,
  -2,
  19,
  19,
  -120,
  9,
  87,
  59,
  77,
  75,
  54,
  -75,
  -48,
  -111,
  33,
  40,
  1,
  -103,
  125,
  28,
  85,
  -10,
  -20,
  -74,
  -2,
  -58,
  -29,
  57,
  -122,
  -87,
  -88,
  11,
  14,
  22,
  11,
  55,
  112,
  74,
  -44,
  -78,
  -39,
  -103,
  -8,
  128,
  30,
  105,
  -24,
  -78,
  17,
  60,
  -73,
  -25,
  17,
  94,
  -4,
  -114,
  108,
  -67,
  64,
  103,
  61,
  67,
  -60,
  18,
  -28,
  -52,
  57,
  -61,
  -28,
  -79,
  -3,
  48,
  86,
  68,
  -110,
  -53,
  69,
  76,
  114,
  -9,
  109,
  -4,
  -70,
  107,
  -75,
  -60,
  41,
  -104,
  -60,
  76,
  99,
  -42,
  -94,
  -30,
  -43,
  41,
  -120,
  76,
  -97,
  -77,
  -123,
  30,
  42,
  -42,
  -69,
  -78,
  89,
  89,
  85,
  -8,
  80,
  58,
  -77,
  -42,
  25,
  -102,
  111,
  -12,
  -23,
  -104,
  -111,
  -35,
  58,
  15,
  -81,
  81,
  -56,
  -66,
  -85,
  -109,
  0,
  61,
  -23,
  -125,
  76,
  -87,
  -67,
  -48,
  115,
  -39,
  118,
  122,
  -118,
  0,
  115,
  19,
  71,
  -16,
  22,
  -99,
  21,
  -68,
  71,
  86,
  -97,
  93,
  66,
  -44,
  83,
  33,
  -63,
  -88,
  -79,
  97,
  66,
  -86,
  -22,
  6,
  -9,
  -4,
  86,
  34,
  -45,
  86,
  70,
  -20,
  92,
  56,
  -77,
  77,
  98,
  70,
  91,
  102,
  -80,
  69,
  -42,
  -4,
  82,
  -82,
  123,
  -28,
  88,
  9,
  15,
  31,
  22,
  33,
  -38,
  -46,
  17,
  -47,
  -89,
  -119,
  -46,
  67,
  48,
  -53,
  87,
  39,
  103,
  14,
  78,
  57,
  51,
  35,
  106,
  25,
  63,
  -19,
  -12,
  -109,
  -97,
  -112,
  -46,
  -87,
  62,
  46,
  6,
  37,
  -84,
  27,
  -111,
  -37,
  8,
  10,
  -116,
  -95,
  -31,
  -29,
  -117,
  -48,
  -113,
  -88,
  39,
  -85,
  -31,
  -7,
  31,
  119,
  89,
  -121,
  84,
  17,
  90,
  -79,
  90,
  57,
  -96,
  -43,
  -82,
  93,
  -100,
  -31,
  86,
  -54,
  -4,
  118,
  7,
  19,
  -49,
  3,
  80,
  -54,
  -92,
  -97,
  103,
  -103,
  47,
  1,
  -69,
  -88,
  -14,
  16,
  -27,
  -64,
  -107,
  -114,
  14,
  128,
  -115,
  107,
  60,
  25,
  -43,
  -79,
  -6,
  79,
  9,
  109,
  100,
  -107,
  116,
  5,
  -118,
  -108,
  -35,
  -23,
  -53,
  -60,
  31,
  -121,
  17,
  97,
  7,
  -90,
  -118,
  -66,
  40,
  97,
  47,
  -123,
  21,
  -22,
  -42,
  -110,
  52,
  -49,
  -12,
  -115,
  -52,
  -17,
  126,
  -76,
  115,
  96,
  45,
  -76,
  69,
  -10,
  36,
  29,
  81,
  -70,
  69,
  105,
  -58,
  120,
  25,
  35,
  -104,
  -48,
  39,
  25,
  55,
  -96,
  111,
  -31,
  -121,
  -94,
  -111,
  -22,
  -84,
  -75,
  102,
  -49,
  22,
  -21,
  96,
  49,
  47,
  -84,
  -69,
  -87,
  -82,
  128,
  15,
  -16,
  -88,
  -110,
  32,
  1,
  -118,
  -108,
  -125,
  125,
  -124,
  -124,
  -116,
  40,
  -16,
  33,
  -38,
  41,
  56,
  126,
  4,
  32,
  79,
  110,
  87,
  65,
  87,
  -26,
  -85,
  -92,
  122,
  -91,
  -57,
  -82,
  8,
  -40,
  104,
  -44,
  6,
  -48,
  -84,
  107,
  71,
  -83,
  -3,
  105,
  -105,
  -72,
  64,
  65,
  0,
  35,
  128,
  -95,
  97,
  50,
  -72,
  -49,
  -88,
  114,
  105,
  -74,
  -69,
  -124,
  70,
  -21,
  118,
  39,
  -115,
  49,
  70,
  64,
  86,
  -109,
  -124,
  58,
  23,
  79,
  -96,
  32,
  -61,
  8,
  -54,
  109,
  115,
  -85,
  -94,
  1,
  -34,
  19,
  -92,
  106,
  -61,
  -103,
  82,
  3,
  -22,
  -25,
  38,
  91,
  -31,
  85,
  -38,
  41,
  74,
  -106,
  -32,
  -72,
  -56,
  -30,
  52,
  -68,
  67,
  -40,
  53,
  -23,
  -62,
  117,
  -125,
  107,
  50,
  21,
  -40,
  51,
  74,
  71,
  11,
  99,
  -66,
  -124,
  -45,
  46,
  52,
  127,
  113,
  79,
  -100,
  -88,
  40,
  82,
  74,
  91,
  -51,
  66,
  87,
  -82,
  94,
  102,
  57,
  69,
  27,
  53,
  89,
  18,
  -82,
  126,
  -113,
  -5,
  -80,
  80,
  -23,
  67,
  13,
  125,
  128,
  127,
  22,
  86,
  123,
  86,
  113,
  59,
  -80,
  -84,
  73,
  -33,
  4,
  38,
  106,
  -110,
  -126,
  84,
  105,
  -53,
  81,
  4,
  105,
  126,
  51,
  9,
  -13,
  -98,
  -68,
  -47,
  -121,
  -81,
  60,
  -23,
  -16,
  -94,
  -88,
  -16,
  -3,
  -103,
  75,
  85,
  83,
  100,
  -64,
  -95,
  33,
  35,
  -79,
  76,
  -19,
  -13,
  -110,
  -27,
  -7,
  6,
  21,
  14,
  82,
  -83,
  -2,
  101,
  -91,
  0,
  -115,
  -94,
  57,
  91,
  44,
  -27,
  92,
  61,
  -83,
  -22,
  -84,
  75,
  -2,
  -58,
  59,
  -64,
  127,
  -120,
  -38,
  77,
  127,
  -59,
  12,
  123,
  118,
  -123,
  -34,
  -32,
  -104,
  110,
  73,
  -96,
  -11,
  77,
  -32,
  -29,
  108,
  -110,
  -58,
  -93,
  -4,
  127,
  127,
  49,
  -92,
  -48,
  117,
  -102,
  79,
  -111,
  37,
  -11,
  61,
  -66,
  59,
  -26,
  -122,
  103,
  75,
  73,
  -52,
  43,
  57,
  94,
  122,
  50,
  -122,
  62,
  120,
  -37,
  105,
  -23,
  -85,
  34,
  50,
  124,
  17,
  109,
  98,
  -50,
  73,
  102,
  -19,
  -78,
  51,
  -60,
  118,
  104,
  -52,
  -77,
  -127,
  -99,
  -81,
  49,
  -60,
  -49,
  -84,
  -1,
  103,
  -80,
  40,
  92,
  11,
  28,
  121,
  -74,
  7,
  -93,
  -122,
  -69,
  84,
  21,
  -127,
  -28,
  -95,
  -52,
  28,
  -124,
  24,
  93,
  52,
  -88,
  -19,
  -125,
  72,
  122,
  -84,
  -78,
  48,
  94,
  34,
  19,
  -68,
  68,
  103,
  -72,
  -106,
  -83,
  -59,
  -25,
  100,
  41,
  128,
  15,
  6,
  -41,
  68,
  -48,
  13,
  -48,
  85,
  66,
  8,
  41,
  -56,
  -65,
  -5,
  -114,
  -109,
  -54,
  -53,
  54,
  53,
  50,
  41,
  6,
  -31,
  124,
  -2,
  -16,
  7,
  -96,
  -105,
  -116,
  39,
  -117,
  12,
  -24,
  82,
  64,
  -29,
  -30,
  92,
  75,
  -29,
  109,
  42,
  15,
  -31,
  -57,
  -4,
  80,
  -10,
  10,
  -84,
  95,
  -122,
  -86,
  106,
  23,
  110,
  -90,
  -125,
  92,
  -79,
  -44,
  55,
  44,
  -110,
  -34,
  9,
  43,
  25,
  -94,
  -65,
  -94,
  118,
  -83,
  -50,
  122,
  -53,
  90,
  -77,
  73,
  49,
  -73,
  -105,
  -112,
  -97,
  -50,
  -74,
  29,
  12,
  47,
  58,
  92,
  98,
  -114,
  46,
  5,
  115,
  64,
  53,
  -67,
  85,
  22,
  -17,
  -70,
  -107,
  -97,
  119,
  -69,
  65,
  -83,
  -63,
  -68,
  -103,
  11,
  -43,
  -50,
  77,
  107,
  100,
  -111,
  99,
  64,
  -46,
  -70,
  102,
  105,
  -39,
  32,
  -61,
  -60,
  -75,
  -28,
  -91,
  -89,
  88,
  -36,
  -25,
  117,
  51,
  -68,
  -28,
  56,
  38,
  -34,
  -119,
  -106,
  -124,
  103,
  -71,
  24,
  122,
  53,
  -38,
  -10,
  -100,
  -32,
  2,
  30,
  120,
  67,
  -35,
  -18,
  -64,
  25,
  -106,
  17,
  9,
  5,
  -75,
  -11,
  -44,
  -2,
  78,
  -110,
  -3,
  -30,
  -121,
  -2,
  -113,
  -126,
  -25,
  -67,
  -10,
  28,
  105,
  49,
  -86,
  81,
  56,
  112,
  6,
  6,
  -46,
  -69,
  39,
  -102,
  47,
  29,
  -69,
  114,
  -97,
  70,
  56,
  -32,
  -12,
  37,
  -19,
  65,
  -79,
  78,
  84,
  108,
  -68,
  115,
  -92,
  -105,
  -68,
  -26,
  11,
  30,
  -69,
  -77,
  -7,
  111,
  0,
  -81,
  2,
  -48,
  -92,
  32,
  117,
  51,
  51,
  36,
  113,
  58,
  117,
  -104,
  -6,
  -43,
  128,
  61,
  -98,
  -81,
  -104,
  71,
  -25,
  -33,
  31,
  37,
  32,
  115,
  -70,
  -38,
  -17,
  -42,
  -50,
  -108,
  127,
  108,
  -94,
  -66,
  65,
  12,
  96,
  46,
  71,
  -89,
  25,
  86,
  51,
  -85,
  -19,
  -58,
  -88,
  10,
  -117,
  -100,
  -54,
  -10,
  -60,
  101,
  109,
  -44,
  -106,
  -33,
  81,
  -12,
  27,
  -51,
  55,
  -114,
  96,
  -58,
  -46,
  -106,
  -34,
  55,
  -25,
  -48,
  -48,
  -119,
  23,
  -69,
  96,
  101,
  -70,
  -40,
  -93,
  -107,
  64,
  -124,
  30,
  -124,
  79,
  -35,
  100,
  -104,
  16,
  -5,
  91,
  14,
  -48,
  -45,
  29,
  82,
  121,
  45,
  -55,
  39,
  -11,
  -68,
  -58,
  114,
  -109,
  61,
  -27,
  88,
  -43,
  121,
  37,
  100,
  100,
  8,
  99,
  -62,
  -57,
  -76,
  -72,
  3,
  63,
  0,
  -49,
  16,
  -69,
  -51,
  -112,
  64,
  -14,
  95,
  116,
  127,
  12,
  -122,
  93,
  49,
  -78,
  108,
  -116,
  11,
  123,
  -6,
  -17,
  -46,
  97,
  -30,
  28,
  41,
  -50,
  -8,
  -76,
  91,
  50,
  101,
  -105,
  84,
  106,
  5,
  89,
  37,
  14,
  -114,
  6,
  105,
  -29,
  -61,
  -75,
  96,
  45,
  114,
  21,
  -4,
  -42,
  56,
  64,
  46,
  -97,
  35,
  -54,
  78,
  -32,
  14,
  29,
  81,
  -81,
  -88,
  -108,
  49,
  40,
  -120,
  -56,
  28,
  -53,
  -126,
  25,
  -48,
  -48,
  0,
  33,
  -52,
  14,
  -67,
  -65,
  -23,
  81,
  42,
  94,
  73,
  -55,
  7,
  23,
  -85,
  -95,
  74,
  -26,
  -27,
  -115,
  26,
  -41,
  72,
  48,
  48,
  66,
  -30,
  -4,
  -114,
  -30,
  -39,
  35,
  92,
  -107,
  -27,
  -86,
  -3,
  77,
  -13,
  -47,
  -105,
  -113,
  -1,
  -24,
  57,
  105,
  -96,
  57,
  -121,
  45,
  -97,
  -64,
  18,
  73,
  -58,
  41,
  -64,
  51,
  4,
  127,
  -116,
  -85,
  -108,
  26,
  -71,
  -33,
  54,
  33,
  -69,
  14,
  68,
  126,
  -86,
  -14,
  -49,
  -63,
  -116,
  -56,
  -75,
  -21,
  -6,
  -1,
  56,
  46,
  104,
  -123,
  16,
  -127,
  47,
  -44,
  23,
  -97,
  37,
  55,
  39,
  90,
  74,
  -49,
  -108,
  -36,
  -93,
  -27,
  30,
  51,
  107,
  43,
  -87,
  -64,
  82,
  99,
  5,
  113,
  -59,
  60,
  37,
  -25,
  -49,
  39,
  118,
  115,
  1,
  -80,
  63,
  -9,
  64,
  63,
  -62,
  50,
  42,
  43,
  23,
  -24,
  -95,
  -5,
  19,
  12,
  79,
  -107,
  45,
  41,
  108,
  119,
  -121,
  -18,
  -24,
  58,
  -34,
  76,
  71,
  111,
  85,
  -46,
  111,
  64,
  3,
  30,
  -63,
  12,
  -68,
  -24,
  -39,
  -50,
  0,
  -20,
  90,
  -18,
  113,
  16,
  -11,
  74,
  -51,
  51,
  49,
  -44,
  40,
  -2,
  -16,
  93,
  51,
  -80,
  20,
  85,
  -101,
  -90,
  79,
  -40,
  72,
  -47,
  79,
  67,
  126,
  -67,
  72,
  -99,
  49,
  19,
  -50,
  -25,
  29,
  -100,
  -104,
  42,
  4,
  -31,
  -110,
  -36,
  100,
  -111,
  -43,
  65,
  -91,
  -48,
  55,
  114,
  74,
  -52,
  -32,
  -97,
  8,
  -17,
  -122,
  -15,
  -118,
  93,
  69,
  84,
  -53,
  0,
  -81,
  -36,
  91,
  -95,
  8,
  -73,
  106,
  -51,
  36,
  -48,
  -63,
  -64,
  -83,
  -123,
  109,
  80,
  -64,
  108,
  47,
  58,
  -15,
  -15,
  126,
  6,
  -42,
  -10,
  128,
  94,
  102,
  20,
  -39,
  -126,
  90,
  -118,
  -72,
  26,
  54,
  -101,
  -121,
  -5,
  -43,
  36,
  29,
  19,
  99,
  -42,
  83,
  49,
  -122,
  15,
  -35,
  18,
  -10,
  50,
  35,
  -46,
  30,
  -60,
  68,
  84,
  87,
  -125,
  87,
  8,
  80,
  -50,
  84,
  57,
  112,
  -115,
  -27,
  127,
  -17,
  111,
  119,
  60,
  114,
  -33,
  90,
  102,
  50,
  102,
  60,
  -108,
  108,
  -46,
  -108,
  81,
  -65,
  -30,
  -115,
  -82,
  -57,
  58,
  27,
  -11,
  93,
  -75,
  -18,
  -14,
  -106,
  -102,
  83,
  -62,
  108,
  -102,
  40,
  -97,
  35,
  105,
  -47,
  100,
  81,
  78,
  24,
  -110,
  85,
  125,
  -124,
  50,
  -52,
  -24,
  87,
  65,
  -50,
  42,
  -104,
  37,
  58,
  -81,
  -18,
  113,
  97,
  -73,
  -63,
  40,
  -21,
  81,
  -72,
  -6,
  106,
  -31,
  -88,
  54,
  49,
  126,
  92,
  -49,
  -35,
  125,
  124,
  -16,
  -90,
  -32,
  114,
  107,
  14,
  -12,
  -94,
  22,
  -82,
  74,
  -13,
  -35,
  54,
  45,
  125,
  69,
  -2,
  78,
  -101,
  -115,
  41,
  -26,
  -13,
  23,
  66,
  -7,
  111,
  70,
  118,
  -58,
  71,
  -19,
  110,
  -50,
  102,
  2,
  -122,
  -88,
  -52,
  -119,
  95,
  40,
  -70,
  119,
  -116,
  -39,
  124,
  -104,
  -38,
  48,
  -96,
  -107,
  -11,
  -36,
  -102,
  12,
  -86,
  -67,
  87,
  9,
  -113,
  69,
  3,
  -101,
  -47,
  126,
  115,
  -1,
  54,
  11,
  20,
  120,
  -23,
  25,
  61,
  48,
  -25,
  -6,
  38,
  -58,
  8,
  -116,
  89,
  -36,
  6,
  32,
  118,
  111,
  22,
  55,
  -71,
  -116,
  12,
  4,
  -102,
  4,
  89,
  103,
  58,
  21,
  -27,
  -44,
  95,
  -105,
  -21,
  -106,
  88,
  61,
  82,
  -87,
  -12,
  7,
  0,
  -91,
  103,
  112,
  29,
  -125,
  -66,
  82,
  85,
  -50,
  116,
  -61,
  -7,
  84,
  -110,
  30,
  64,
  70,
  -3,
  110,
  48,
  -40,
  -8,
  -105,
  89,
  114,
  113,
  47,
  109,
  100,
  124,
  52,
  80,
  -44,
  -122,
  -126,
  14,
  -81,
  53,
  -87,
  -7,
  -60,
  82,
  116,
  60,
  91,
  -103,
  67,
  11,
  -72,
  -64,
  -96,
  66,
  -74,
  -65,
  19,
  -43,
  53,
  56,
  -36,
  -42,
  -4,
  87,
  -22,
  22,
  48,
  -72,
  -4,
  -18,
  -56,
  116,
  -56,
  82,
  -85,
  100,
  -37,
  24,
  -61,
  -46,
  -76,
  40,
  123,
  -13,
  -127,
  38,
  37,
  -48,
  7,
  5,
  -25,
  -61,
  68,
  8,
  52,
  -65,
  117,
  -2,
  -49,
  -23,
  -55,
  -118,
  4,
  118,
  -30,
  -118,
  16,
  -120,
  122,
  55,
  127,
  27,
  110,
  121,
  -91,
  -21,
  121,
  -86,
  -59,
  53,
  -95,
  55,
  -45,
  48,
  -46,
  -101,
  -29,
  82,
  53,
  -64,
  102,
  121,
  123,
  89,
  41,
  -41,
  60,
  -104,
  -30,
  75,
  95,
  125,
  56,
  9,
  118,
  -68,
  119,
  -90,
  39,
  -125,
  86,
  74,
  -92,
  19,
  -54,
  113,
  41,
  85,
  -56,
  14,
  -30,
  66,
  38,
  35,
  80,
  30,
  -122,
  -120,
  -14,
  21,
  -73,
  64,
  -71,
  -13,
  -102,
  114,
  -15,
  -49,
  98,
  -84,
  21,
  -15,
  9,
  -82,
  -58,
  11,
  -63,
  92,
  -60,
  90,
  107,
  66,
  108,
  -36,
  48,
  -11,
  38,
  -93,
  -75,
  0,
  -90,
  73,
  -98,
  -29,
  -61,
  21,
  -101,
  45,
  -106,
  -111,
  -96,
  -105,
  -40,
  41,
  -68,
  54,
  -40,
  114,
  -53,
  110,
  120,
  -107,
  -103,
  76,
  114,
  -62,
  -124,
  -126,
  9,
  -88,
  24,
  76,
  30,
  123,
  -59,
  123,
  18,
  -98,
  -124,
  103,
  -16,
  -1,
  -95,
  -58,
  12,
  -44,
  86,
  39,
  -44,
  25,
  66,
  118,
  15,
  69,
  -82,
  -96,
  79,
  17,
  35,
  -25,
  -107,
  55,
  46,
  -108,
  68,
  3,
  54,
  66,
  -112,
  -127,
  108,
  -53,
  83,
  119,
  71,
  -35,
  -70,
  -33,
  128,
  12,
  -100,
  -43,
  51,
  -18,
  122,
  -22,
  -3,
  128,
  -38,
  -96,
  -98,
  73,
  16,
  -93,
  -78,
  -16,
  23,
  73,
  -104,
  31,
  80,
  -86,
  -8,
  -57,
  -120,
  -127,
  25,
  53,
  105,
  -58,
  98,
  66,
  -80,
  50,
  67,
  115,
  -114,
  -117,
  36,
  101,
  -16,
  -88,
  120,
  -13,
  69,
  40,
  -110,
  87,
  85,
  111,
  -32,
  111,
  64,
  -104,
  22,
  9,
  117,
  -30,
  -112,
  58,
  51,
  -30,
  -124,
  34,
  -104,
  16,
  116,
  -33,
  -25,
  50,
  32,
  -37,
  107,
  -66,
  -39,
  -15,
  17,
  -11,
  -60,
  83,
  31,
  -120,
  56,
  -41,
  -33,
  14,
  -69,
  87,
  -42,
  -31,
  111,
  -125,
  -28,
  -101,
  54,
  8,
  -104,
  -78,
  12,
  -16,
  25,
  -48,
  -62,
  7,
  109,
  85,
  106,
  3,
  -87,
  3,
  17,
  -79,
  -127,
  6,
  23,
  -110,
  -123,
  30,
  -14,
  -52,
  -119,
  94,
  109,
  75,
  8,
  30,
  -112,
  73,
  -6,
  115,
  32,
  -38,
  64,
  112,
  50,
  -24,
  -15,
  -96,
  -74,
  -21,
  22,
  112,
  69,
  33,
  -17,
  -74,
  76,
  -65,
  87,
  12,
  20,
  -13,
  77,
  94,
  -46,
  -72,
  106,
  -57,
  -95,
  -106,
  -12,
  -46,
  -97,
  121,
  97,
  24,
  -35,
  23,
  -104,
  80,
  -21,
  68,
  -60,
  -28,
  -50,
  -39,
  -92,
  -11,
  72,
  20,
  -116,
  -39,
  -57,
  75,
  81,
  35,
  98,
  120,
  -94,
  28,
  -45,
  -83,
  113,
  -9,
  -9,
  72,
  -91,
  16,
  -71,
  118,
  -49,
  -60,
  -94,
  -5,
  -105,
  14,
  93,
  71,
  -51,
  12,
  -49,
  -99,
  9,
  -90,
  -16,
  -12,
  -27,
  -9,
  46,
  -118,
  -107,
  15,
  98,
  33,
  66,
  -60,
  -15,
  -105,
  82,
  -90,
  27,
  -58,
  87,
  -118,
  -90,
  119,
  -23,
  125,
  -63,
  -9,
  -64,
  14,
  120,
  65,
  100,
  68,
  94,
  125,
  68,
  47,
  -98,
  58,
  68,
  118,
  37,
  98,
  -67,
  -27,
  -119,
  -58,
  -119,
  108,
  -106,
  -77,
  93,
  -80,
  -45,
  94,
  -70,
  46,
  -122,
  -49,
  50,
  109,
  -26,
  78,
  -104,
  -3,
  86,
  40,
  9,
  112,
  -58,
  -119,
  54,
  -58,
  95,
  -24,
  124,
  -51,
  -43,
  -20,
  53,
  59,
  -91,
  -94,
  121,
  41,
  -63,
  -34,
  -80,
  -64,
  6,
  -51,
  -6,
  37,
  117,
  -121,
  106,
  -33,
  -15,
  88,
  -45,
  -81,
  35,
  98,
  1,
  -1,
  -102,
  77,
  128,
  -20,
  -4,
  87,
  -116,
  56,
  87,
  -109,
  -64,
  55,
  36,
  105,
  98,
  27,
  35,
  70,
  77,
  38,
  45,
  31,
  -14,
  3,
  30,
  124,
  84,
  -115,
  -106,
  -112,
  4,
  -91,
  -125,
  114,
  79,
  -65,
  -11,
  -119,
  76,
  -103,
  -84,
  -41,
  -39,
  -68,
  -105,
  26,
  -88,
  113,
  47,
  116,
  52,
  -52,
  -16,
  -16,
  -21,
  95,
  -122,
  -40,
  40,
  -62,
  29,
  68,
  -45,
  -64,
  61,
  30,
  -24,
  52,
  60,
  -91,
  8,
  -100,
  68,
  -15,
  124,
  -30,
  116,
  -24,
  -73,
  -4,
  -81,
  23,
  -71,
  76,
  102,
  -3,
  25,
  18,
  -104,
  -18,
  89,
  74,
  110,
  64,
  -5,
  92,
  -33,
  -105,
  -41,
  79,
  41,
  -85,
  128,
  -124,
  46,
  123,
  13,
  -90,
  108,
  -81,
  -119,
  -1,
  29,
  -63,
  83,
  106,
  76,
  -40,
  97,
  -23,
  -32,
  40,
  -5,
  -109,
  89,
  128,
  43,
  -8,
  -53,
  -62,
  74,
  -44,
  -121,
  -38,
  -91,
  -96,
  -5,
  121,
  -47,
  30,
  -122,
  -19,
  -77,
  110,
  -17,
  -122,
  -108,
  -7,
  -66,
  -98,
  -100,
  4,
  0,
  68,
  10,
  21,
  62,
  -55,
  -34,
  24,
  -4,
  88,
  90,
  -115,
  -44,
  0,
  -44,
  -39,
  -111,
  -33,
  120,
  -84,
  -83,
  125,
  -118,
  91,
  -53,
  -12,
  -111,
  42,
  -91,
  -11,
  -45,
  -74,
  22,
  -119,
  -113,
  47,
  -119,
  -90,
  11,
  -99,
  30,
  -5,
  -110,
  -88,
  -4,
  -76,
  110,
  23,
  39,
  -54,
  -4,
  1,
  -80,
  -89,
  -58,
  117,
  -96,
  -67,
  91,
  -109,
  -24,
  -120,
  126,
  -42,
  -45,
  3,
  -30,
  -33,
  84,
  27,
  53,
  31,
  -102,
  -28,
  -16,
  9,
  29,
  126,
  110,
  -48,
  -97,
  87,
  4,
  -17,
  61,
  -114,
  118,
  46,
  47,
  -110,
  -23,
  -103,
  -37,
  -68,
  38,
  8,
  83,
  -68,
  1,
  -94,
  -104,
  -39,
  80,
  17,
  121,
  113,
  -91,
  75,
  90,
  -56,
  57,
  -107,
  96,
  -103,
  -114,
  -33,
  -31,
  58,
  -61,
  65,
  -39,
  -32,
  -93,
  -102,
  -24,
  50,
  -12,
  -52,
  94,
  -65,
  -96,
  -67,
  77,
  120,
  42,
  -117,
  -120,
  -34,
  128,
  59,
  -44,
  82,
  61,
  -92,
  1,
  78,
  0,
  95,
  55,
  -52,
  86,
  -100,
  6,
  -52,
  68,
  -24,
  -77,
  -61,
  -35,
  121,
  -105,
  -38,
  -39,
  -79,
  -3,
  14,
  59,
  119,
  38,
  -1,
  -17,
  28,
  -5,
  62,
  -29,
  -87,
  -84,
  -96,
  43,
  -81,
  85,
  -99,
  -31,
  70,
  -97,
  -104,
  20,
  -57,
  39,
  -46,
  -55,
  48,
  -103,
  19,
  -127,
  -6,
  -52,
  -55,
  -83,
  -65
}; // weak
int g_quietmode = 1; // weak
int downloadSlot = 1; // idb
char stopfile[5] = "stop"; // weak
int channelType = -1; // weak
int customIcon = -1; // weak
int log_count = 512; // weak
char autorunValue = '\x01'; // weak
char banner[16] = "vexcom utility "; // weak
char *long_options_6703 = "verbose"; // weak
char chars_6696[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
int nLogLevel = 2; // weak
char inifile[] = ";\n; VEX program ini file\n; Copyright (c) 2018-2021 VEX Robotics\n;\n[project]\nversion      = \"1\"\nide          = \"make\"\nfile         = \"none\"\n;\n[program]\nversion      = \"1\"\nname         = \"<programname>\"\nslot         = \"<slot>\"\nicon         = \"<icon>.bmp\"\ndescription  = \"<desc>\"\ndate         = \"<date>\"\ntimezone     = \"-08:00\"\n"; // idb
int _python_vm_version = 16777487; // weak
int _python_vm_crc = -492745757; // weak
_BYTE _python_vm[3543] =
{
  31,
  -117,
  8,
  8,
  127,
  -126,
  -59,
  99,
  0,
  3,
  112,
  121,
  116,
  104,
  111,
  110,
  95,
  118,
  109,
  46,
  98,
  105,
  110,
  0,
  -76,
  -67,
  11,
  120,
  29,
  85,
  -71,
  63,
  -68,
  102,
  -49,
  -34,
  -55,
  78,
  -70,
  -101,
  -52,
  78,
  -46,
  82,
  99,
  -107,
  73,
  26,
  -80,
  -106,
  42,
  -109,
  -74,
  64,
  45,
  32,
  -101,
  22,
  16,
  21,
  15,
  -69,
  87,
  -54,
  -27,
  64,
  90,
  16,
  80,
  -15,
  24,
  110,
  -54,
  57,
  -14,
  -105,
  -99,
  91,
  91,
  107,
  -117,
  -69,
  109,
  82,
  10,
  -57,
  -102,
  41,
  8,
  42,
  84,
  72,
  75,
  -63,
  -98,
  90,
  112,
  -9,
  2,
  114,
  -76,
  114,
  122,
  -29,
  42,
  -32,
  -98,
  25,
  -122,
  -108,
  68,
  15,
  69,
  110,
  -27,
  -102,
  -17,
  -9,
  91,
  107,
  77,
  118,
  64,
  -12,
  -7,
  -98,
  -1,
  -13,
  125,
  121,
  -98,
  60,
  51,
  -77,
  102,
  -51,
  90,
  -17,
  122,
  -41,
  -69,
  -34,
  -5,
  90,
  123,
  -31,
  -126,
  -123,
  39,
  8,
  -4,
  25,
  -30,
  -17,
  -1,
  -86,
  13,
  97,
  88,
  -103,
  -49,
  -67,
  -20,
  -118,
  -34,
  -48,
  -75,
  122,
  67,
  97,
  -69,
  -127,
  33,
  -78,
  94,
  -36,
  -50,
  109,
  121,
  111,
  104,
  104,
  91,
  30,
  -27,
  -7,
  -113,
  41,
  -65,
  -4,
  105,
  49,
  40,
  68,
  54,
  40,
  19,
  -94,
  -2,
  -63,
  16,
  -9,
  25,
  -41,
  -69,
  -104,
  101,
  -106,
  -21,
  -59,
  -123,
  -21,
  -35,
  -124,
  123,
  75,
  -120,
  -127,
  23,
  -117,
  -86,
  -98,
  33,
  90,
  107,
  89,
  39,
  41,
  68,
  -27,
  -53,
  40,
  -101,
  56,
  77,
  4,
  38,
  -37,
  -61,
  -9,
  -74,
  -125,
  -10,
  51,
  29,
  -95,
  112,
  -36,
  64,
  56,
  -99,
  -31,
  32,
  -34,
  63,
  -116,
  54,
  127,
  -6,
  -108,
  24,
  -68,
  -101,
  109,
  11,
  55,
  -80,
  114,
  15,
  29,
  106,
  -99,
  -41,
  101,
  62,
  -76,
  80,
  -3,
  23,
  -16,
  127,
  -28,
  -118,
  30,
  -13,
  99,
  -122,
  -12,
  119,
  127,
  -122,
  61,
  -37,
  -1,
  -12,
  -48,
  -15,
  -58,
  -119,
  66,
  -52,
  -32,
  24,
  26,
  -123,
  -72,
  45,
  38,
  -46,
  -34,
  4,
  -64,
  82,
  21,
  75,
  7,
  109,
  105,
  -41,
  72,
  58,
  -82,
  105,
  56,
  110,
  -83,
  17,
  -101,
  29,
  8,
  49,
  -69,
  -39,
  -88,
  113,
  -101,
  -51,
  41,
  110,
  -13,
  59,
  67,
  67,
  51,
  98,
  -122,
  42,
  107,
  -77,
  -36,
  -26,
  14,
  71,
  -107,
  69,
  -8,
  48,
  68,
  -58,
  54,
  -19,
  -10,
  -122,
  13,
  -72,
  -33,
  128,
  -5,
  59,
  112,
  -33,
  96,
  100,
  -67,
  6,
  35,
  99,
  79,
  104,
  64,
  57,
  -18,
  55,
  -32,
  -2,
  14,
  -36,
  19,
  15,
  19,
  -90,
  -12,
  -91,
  27,
  106,
  -36,
  -12,
  43,
  67,
  67,
  -11,
  49,
  -32,
  9,
  112,
  -95,
  13,
  23,
  -29,
  112,
  107,
  -27,
  125,
  114,
  118,
  -48,
  48,
  -50,
  109,
  -80,
  108,
  119,
  2,
  -6,
  -104,
  106,
  -92,
  -16,
  92,
  -25,
  54,
  36,
  -19,
  -10,
  70,
  75,
  -32,
  -66,
  -58,
  109,
  -120,
  -29,
  62,
  -114,
  123,
  -12,
  -37,
  -66,
  -63,
  110,
  -49,
  59,
  49,
  -43,
  14,
  -37,
  23,
  -94,
  88,
  123,
  62,
  -16,
  14,
  120,
  3,
  -64,
  89,
  105,
  98,
  110,
  31,
  30,
  26,
  26,
  44,
  -53,
  60,
  116,
  104,
  -75,
  48,
  -117,
  -90,
  117,
  122,
  81,
  -43,
  -99,
  29,
  -52,
  -62,
  -8,
  -115,
  -126,
  93,
  20,
  -42,
  -94,
  -103,
  -60,
  -47,
  103,
  -16,
  44,
  -100,
  62,
  79,
  56,
  45,
  51,
  13,
  49,
  -41,
  59,
  86,
  -29,
  105,
  -30,
  72,
  60,
  -39,
  -64,
  -109,
  -83,
  -16,
  100,
  106,
  60,
  -59,
  26,
  75,
  120,
  50,
  53,
  -98,
  -38,
  109,
  -115,
  39,
  65,
  60,
  -51,
  -11,
  12,
  103,
  -106,
  29,
  19,
  57,
  -32,
  105,
  -82,
  -73,
  1,
  -9,
  -73,
  -29,
  -66,
  -63,
  -104,
  -21,
  53,
  52,
  -49,
  -78,
  27,
  13,
  -108,
  -29,
  126,
  3,
  -18,
  111,
  -57,
  -67,
  16,
  115,
  -125,
  -58,
  -58,
  18,
  -98,
  -124,
  -72,
  8,
  -29,
  106,
  -103,
  -87,
  -32,
  62,
  -59,
  43,
  -35,
  -69,
  83,
  -9,
  84,
  -69,
  -122,
  33,
  114,
  -26,
  -1,
  45,
  -18,
  -40,
  -10,
  84,
  -32,
  -81,
  -44,
  102,
  54,
  -120,
  25,
  -59,
  93,
  49,
  -61,
  -67,
  -65,
  92,
  -29,
  -15,
  109,
  -115,
  -57,
  -5,
  63,
  6,
  -113,
  -4,
  -113,
  -91,
  27,
  124,
  -112,
  -39,
  64,
  -84,
  121,
  -126,
  -17,
  -96,
  94,
  27,
  -24,
  -68,
  35,
  -21,
  122,
  9,
  49,
  -51,
  -117,
  9,
  -57,
  16,
  -123,
  -18,
  116,
  -84,
  -48,
  -109,
  -34,
  -3,
  -5,
  -61,
  -23,
  71,
  -16,
  -65,
  2,
  -8,
  -4,
  -39,
  87,
  92,
  -17,
  -50,
  11,
  -82,
  43,
  -118,
  -20,
  -41,
  55,
  99,
  13,
  61,
  -101,
  -56,
  116,
  22,
  99,
  -74,
  93,
  52,
  -99,
  -122,
  -94,
  16,
  -115,
  69,
  -61,
  -102,
  48,
  -4,
  124,
  -94,
  -104,
  31,
  56,
  -103,
  -121,
  -106,
  -95,
  -81,
  -74,
  -104,
  -111,
  14,
  -116,
  -79,
  -82,
  103,
  60,
  -22,
  6,
  13,
  99,
  87,
  128,
  118,
  48,
  103,
  -94,
  -43,
  23,
  -106,
  -25,
  -57,
  -116,
  -38,
  -64,
  60,
  -47,
  -11,
  38,
  -100,
  -88,
  -53,
  -19,
  107,
  124,
  -31,
  4,
  62,
  -31,
  -8,
  6,
  -25,
  58,
  115,
  -122,
  111,
  23,
  -81,
  -57,
  -77,
  -40,
  86,
  -13,
  -72,
  -21,
  77,
  73,
  -28,
  49,
  -9,
  27,
  -4,
  -38,
  -86,
  124,
  113,
  -18,
  -104,
  77,
  69,
  -64,
  49,
  96,
  103,
  -49,
  68,
  -99,
  -101,
  125,
  67,
  -52,
  9,
  106,
  81,
  39,
  86,
  88,
  49,
  97,
  46,
  -22,
  -19,
  58,
  122,
  83,
  49,
  54,
  -37,
  -16,
  99,
  66,
  92,
  32,
  10,
  55,
  98,
  -68,
  -121,
  101,
  -97,
  70,
  -39,
  -20,
  -96,
  26,
  -21,
  42,
  -122,
  43,
  -66,
  -97,
  -79,
  -63,
  -22,
  -13,
  90,
  68,
  -97,
  119,
  85,
  1,
  48,
  102,
  58,
  -3,
  -50,
  73,
  -72,
  38,
  -82,
  9,
  -66,
  37,
  -60,
  -92,
  -104,
  113,
  81,
  -32,
  22,
  -6,
  0,
  90,
  -97,
  31,
  -81,
  -33,
  80,
  76,
  88,
  109,
  30,
  -58,
  117,
  -120,
  56,
  92,
  81,
  0,
  -35,
  -119,
  62,
  -116,
  123,
  67,
  -47,
  40,
  -61,
  24,
  1,
  -21,
  -33,
  -28,
  -36,
  55,
  7,
  117,
  88,
  -105,
  -45,
  -80,
  62,
  -63,
  91,
  -16,
  -83,
  -92,
  63,
  -52,
  -11,
  -100,
  -96,
  113,
  34,
  -26,
  -38,
  -103,
  -43,
  104,
  -92,
  112,
  -33,
  -124,
  121,
  -58,
  -67,
  5,
  -72,
  27,
  27,
  49,
  -49,
  -72,
  -113,
  -29,
  62,
  -122,
  -21,
  -19,
  -50,
  44,
  -25,
  -10,
  -26,
  89,
  69,
  -37,
  -98,
  -21,
  99,
  78,
  -17,
  78,
  -39,
  -85,
  125,
  -16,
  -99,
  103,
  -21,
  10,
  -19,
  126,
  -54,
  94,
  -20,
  -89,
  83,
  -82,
  -41,
  92,
  67,
  -66,
  37,
  6,
  -22,
  -20,
  118,
  -33,
  46,
  44,
  -34,
  -97,
  -58,
  -77,
  51,
  -66,
  109,
  -97,
  21,
  115,
  -9,
  -103,
  -103,
  121,
  -59,
  120,
  125,
  -101,
  11,
  120,
  55,
  0,
  -34,
  95,
  0,
  -34,
  13,
  -15,
  76,
  -47,
  59,
  58,
  51,
  -49,
  -81,
  102,
  123,
  -103,
  110,
  31,
  99,
  -1,
  125,
  29,
  -58,
  107,
  -37,
  -105,
  -7,
  78,
  -36,
  -11,
  -46,
  -79,
  -100,
  -41,
  92,
  -41,
  53,
  60,
  -66,
  84,
  -26,
  50,
  -11,
  14,
  -76,
  -106,
  -114,
  -25,
  -68,
  4,
  -8,
  100,
  -12,
  -82,
  25,
  -11,
  71,
  62,
  11,
  49,
  45,
  48,
  78,
  -100,
  -32,
  27,
  99,
  27,
  98,
  -64,
  97,
  -52,
  -56,
  -98,
  89,
  -13,
  -29,
  -95,
  -95,
  1,
  -48,
  -113,
  71,
  -6,
  -7,
  20,
  -26,
  50,
  -94,
  -83,
  56,
  -25,
  -71,
  -48,
  -19,
  -103,
  -64,
  13,
  -8,
  -119,
  17,
  -75,
  97,
  -118,
  102,
  15,
  -8,
  -86,
  37,
  95,
  65,
  -39,
  56,
  -108,
  -91,
  127,
  -10,
  -5,
  62,
  -55,
  111,
  115,
  -104,
  31,
  -61,
  -62,
  124,
  -90,
  -37,
  38,
  68,
  -11,
  -115,
  51,
  -69,
  -47,
  95,
  -37,
  20,
  60,
  79,
  -57,
  115,
  51,
  -25,
  -6,
  -90,
  -70,
  -82,
  -96,
  122,
  108,
  91,
  -64,
  53,
  28,
  -43,
  35,
  12,
  -24,
  43,
  -115,
  -66,
  72,
  -53,
  6,
  120,
  102,
  26,
  107,
  45,
  109,
  -100,
  -107,
  -9,
  -52,
  5,
  -85,
  13,
  -12,
  107,
  -60,
  -114,
  106,
  -85,
  45,
  -115,
  -59,
  9,
  0,
  7,
  -41,
  -89,
  -63,
  -75,
  97,
  124,
  -43,
  13,
  -90,
  0,
  79,
  34,
  -21,
  -78,
  60,
  88,
  -126,
  113,
  -3,
  -93,
  58,
  -79,
  -39,
  -106,
  -49,
  117,
  -55,
  122,
  55,
  -94,
  94,
  -50,
  -18,
  -13,
  118,
  -90,
  93,
  111,
  17,
  112,
  21,
  -85,
  114,
  -67,
  -95,
  105,
  53,
  53,
  67,
  -15,
  -87,
  -75,
  85,
  -75,
  13,
  53,
  28,
  -97,
  16,
  83,
  2,
  62,
  71,
  -19,
  84,
  125,
  -51,
  13,
  36,
  -51,
  -90,
  119,
  4,
  87,
  -31,
  123,
  -61,
  -50,
  123,
  -47,
  59,
  -10,
  79,
  122,
  31,
  89,
  22,
  -101,
  -99,
  6,
  -35,
  -125,
  -66,
  -11,
  122,
  -118,
  -32,
  104,
  -8,
  67,
  -97,
  119,
  6,
  121,
  0,
  120,
  -2,
  -58,
  29,
  125,
  30,
  120,
  71,
  -51,
  -16,
  -75,
  -95,
  -67,
  104,
  59,
  -117,
  125,
  107,
  23,
  -26,
  -113,
  115,
  107,
  -26,
  36,
  45,
  -59,
  -80,
  -98,
  79,
  66,
  -97,
  -83,
  104,
  119,
  -88,
  -32,
  6,
  -27,
  123,
  86,
  4,
  13,
  95,
  25,
  95,
  -100,
  112,
  -63,
  120,
  43,
  37,
  -90,
  -91,
  83,
  -30,
  -124,
  -12,
  -11,
  66,
  -116,
  -30,
  -70,
  55,
  91,
  26,
  -118,
  43,
  -22,
  119,
  120,
  43,
  102,
  -20,
  -14,
  -116,
  5,
  18,
  -113,
  105,
  -52,
  5,
  104,
  -96,
  35,
  -32,
  92,
  -25,
  119,
  -34,
  92,
  36,
  -68,
  -85,
  -4,
  59,
  -117,
  -79,
  -122,
  50,
  63,
  31,
  -36,
  89,
  20,
  45,
  120,
  -98,
  123,
  23,
  120,
  -59,
  41,
  -127,
  81,
  -68,
  -71,
  118,
  8,
  -21,
  37,
  -106,
  90,
  16,
  -104,
  -25,
  -20,
  -26,
  26,
  -99,
  116,
  115,
  -79,
  -49,
  75,
  100,
  31,
  40,
  -106,
  -75,
  -36,
  85,
  92,
  50,
  -90,
  -35,
  -69,
  -77,
  -66,
  -51,
  -21,
  74,
  -72,
  -34,
  -67,
  -107,
  57,
  -17,
  -26,
  -48,
  -11,
  -34,
  47,
  -52,
  -13,
  -53,
  83,
  23,
  117,
  0,
  105,
  -53,
  99,
  -58,
  -59,
  -127,
  91,
  44,
  -83,
  -53,
  86,
  61,
  119,
  -79,
  69,
  101,
  -66,
  97,
  45,
  1,
  -99,
  -27,
  48,
  -25,
  13,
  -59,
  -115,
  88,
  7,
  -87,
  -20,
  117,
  5,
  -84,
  -123,
  29,
  -88,
  -13,
  24,
  -22,
  -20,
  32,
  -100,
  -94,
  8,
  30,
  -113,
  -75,
  -16,
  -81,
  88,
  3,
  39,
  -118,
  -21,
  72,
  47,
  7,
  98,
  105,
  99,
  63,
  -22,
  60,
  -115,
  58,
  -5,
  4,
  105,
  31,
  -17,
  -21,
  -11,
  90,
  73,
  69,
  107,
  37,
  123,
  -103,
  111,
  -99,
  0,
  -68,
  113,
  -67,
  36,
  114,
  94,
  -84,
  65,
  -51,
  -43,
  29,
  -43,
  -7,
  98,
  115,
  -35,
  -19,
  -59,
  -114,
  -30,
  79,
  -67,
  59,
  -86,
  11,
  70,
  -21,
  -56,
  53,
  -60,
  111,
  -90,
  -31,
  -101,
  -124,
  90,
  71,
  -24,
  -57,
  103,
  125,
  -14,
  -79,
  -113,
  -42,
  -105,
  117,
  -61,
  -101,
  61,
  7,
  -11,
  -45,
  39,
  116,
  -56,
  117,
  -58,
  -6,
  -51,
  -15,
  2,
  -22,
  -27,
  -2,
  -82,
  125,
  -82,
  59,
  -24,
  39,
  -11,
  -79,
  69,
  -122,
  -81,
  -42,
  -56,
  48,
  47,
  -118,
  81,
  -106,
  -106,
  -127,
  95,
  9,
  113,
  66,
  64,
  90,
  -117,
  45,
  50,
  -3,
  118,
  -48,
  -93,
  -23,
  -36,
  -127,
  58,
  -75,
  1,
  -42,
  -88,
  -86,
  -29,
  116,
  72,
  -103,
  128,
  57,
  -10,
  38,
  92,
  -112,
  42,
  114,
  -98,
  -63,
  115,
  42,
  -37,
  90,
  -14,
  94,
  71,
  -53,
  -22,
  116,
  8,
  -98,
  70,
  92,
  18,
  14,
  -82,
  -85,
  -88,
  111,
  -66,
  -25,
  -6,
  -27,
  58,
  102,
  61,
  -24,
  78,
  -107,
  108,
  3,
  -109,
  82,
  111,
  92,
  -98,
  71,
  123,
  -94,
  30,
  109,
  97,
  93,
  -117,
  122,
  -13,
  -14,
  -43,
  -84,
  -101,
  -26,
  58,
  -92,
  -2,
  21,
  -75,
  119,
  83,
  93,
  -37,
  -16,
  122,
  -115,
  -38,
  101,
  -39,
  23,
  -113,
  106,
  27,
  126,
  -2,
  103,
  -12,
  120,
  -79,
  -92,
  -57,
  51,
  -118,
  102,
  -79,
  -95,
  8,
  26,
  -12,
  40,
  103,
  -50,
  1,
  28,
  -108,
  41,
  -58,
  28,
  23,
  -70,
  75,
  -105,
  -41,
  120,
  74,
  -121,
  23,
  107,
  114,
  -67,
  -122,
  57,
  93,
  -98,
  125,
  81,
  -105,
  39,
  46,
  35,
  78,
  -85,
  124,
  83,
  -52,
  7,
  76,
  11,
  -116,
  -9,
  51,
  63,
  -13,
  -51,
  115,
  58,
  -71,
  -114,
  38,
  -35,
  1,
  93,
  98,
  49,
  120,
  117,
  -84,
  101,
  65,
  -47,
  -52,
  62,
  82,
  -116,
  -98,
  -115,
  50,
  -84,
  -53,
  -33,
  -31,
  -65,
  -120,
  -14,
  -30,
  19,
  -59,
  88,
  -53,
  89,
  118,
  85,
  -42,
  109,
  72,
  65,
  39,
  24,
  -2,
  -26,
  35,
  -17,
  54,
  -2,
  -109,
  119,
  -109,
  -115,
  127,
  -14,
  29,
  -34,
  -107,
  21,
  123,
  -68,
  -47,
  -28,
  -103,
  115,
  92,
  -17,
  -40,
  -117,
  -69,
  -68,
  -78,
  -59,
  -112,
  -49,
  -51,
  -82,
  119,
  -5,
  23,
  59,
  -68,
  -10,
  6,
  -41,
  -101,
  -68,
  -77,
  -49,
  -5,
  19,
  -26,
  -123,
  115,
  77,
  124,
  10,
  57,
  -49,
  128,
  111,
  -121,
  27,
  60,
  65,
  -66,
  -127,
  114,
  -108,
  73,
  -39,
  19,
  -83,
  -101,
  89,
  67,
  67,
  -53,
  -51,
  -62,
  -4,
  98,
  -84,
  -80,
  64,
  -116,
  -108,
  105,
  -61,
  107,
  -57,
  -85,
  -14,
  27,
  -58,
  -34,
  -20,
  109,
  -52,
  116,
  -1,
  -45,
  53,
  -45,
  -116,
  -10,
  -53,
  -118,
  93,
  -34,
  -15,
  -72,
  42,
  122,
  -103,
  -122,
  -71,
  62,
  -63,
  -56,
  -125,
  -106,
  120,
  79,
  120,
  -56,
  91,
  87,
  0,
  62,
  -50,
  127,
  -121,
  -42,
  27,
  49,
  -9,
  -34,
  82,
  124,
  -61,
  50,
  -14,
  116,
  -50,
  -41,
  -107,
  -8,
  38,
  122,
  -105,
  -61,
  -69,
  -120,
  -26,
  -50,
  -58,
  55,
  109,
  -103,
  -68,
  119,
  29,
  -82,
  29,
  -39,
  -43,
  -34,
  -59,
  -72,
  -34,
  64,
  -66,
  91,
  40,
  6,
  49,
  -14,
  64,
  -48,
  -125,
  -48,
  -41,
  120,
  -31,
  115,
  97,
  27,
  100,
  -9,
  30,
  -16,
  -7,
  14,
  117,
  77,
  87,
  1,
  119,
  -15,
  -67,
  43,
  -3,
  -74,
  2,
  -38,
  43,
  72,
  30,
  -97,
  -106,
  122,
  -115,
  80,
  60,
  27,
  -4,
  50,
  -96,
  -68,
  -127,
  -18,
  55,
  59,
  38,
  -78,
  -58,
  -82,
  106,
  -73,
  97,
  87,
  117,
  -79,
  25,
  122,
  89,
  32,
  105,
  91,
  -73,
  39,
  105,
  -7,
  -47,
  -68,
  -124,
  87,
  -73,
  -19,
  29,
  -30,
  122,
  120,
  116,
  -75,
  -9,
  18,
  96,
  -113,
  -117,
  -11,
  47,
  -54,
  117,
  -120,
  119,
  28,
  71,
  -118,
  -76,
  82,
  80,
  -29,
  73,
  57,
  -32,
  -9,
  -100,
  11,
  -48,
  -17,
  65,
  -24,
  97,
  74,
  -41,
  109,
  -99,
  101,
  104,
  124,
  39,
  -117,
  -97,
  11,
  -33,
  66,
  121,
  -92,
  75,
  39,
  -117,
  -86,
  45,
  -106,
  -65,
  -86,
  -54,
  -89,
  -94,
  124,
  -62,
  -56,
  -14,
  65,
  85,
  -66,
  6,
  -27,
  29,
  35,
  -53,
  95,
  -8,
  7,
  -27,
  79,
  127,
  76,
  59,
  109,
  -92,
  -71,
  99,
  87,
  -109,
  -89,
  77,
  -86,
  128,
  -20,
  -8,
  -30,
  23,
  -117,
  -63,
  -50,
  73,
  115,
  -117,
  80,
  -54,
  110,
  107,
  3,
  111,
  -117,
  53,
  119,
  4,
  -18,
  12,
  -84,
  25,
  -24,
  109,
  90,
  -49,
  -84,
  -47,
  -70,
  -85,
  -60,
  -115,
  81,
  -58,
  117,
  15,
  -98,
  99,
  -92,
  -95,
  -65,
  21,
  -51,
  -111,
  -17,
  -38,
  -64,
  95,
  42,
  -87,
  55,
  -95,
  125,
  94,
  -53,
  71,
  -76,
  15,
  62,
  -11,
  -107,
  -111,
  -19,
  79,
  29,
  -74,
  1,
  74,
  -19,
  18,
  -33,
  -80,
  7,
  -126,
  15,
  -73,
  -23,
  122,
  -27,
  83,
  -26,
  -8,
  -79,
  71,
  -25,
  54,
  -34,
  -12,
  -56,
  -115,
  -115,
  101,
  -44,
  -15,
  119,
  128,
  -33,
  97,
  29,
  -72,
  85,
  43,
  0,
  -25,
  -100,
  -64,
  52,
  -36,
  34,
  -108,
  86,
  -91,
  83,
  3,
  110,
  -24,
  56,
  -11,
  -97,
  63,
  118,
  13,
  -32,
  51,
  54,
  -93,
  108,
  19,
  -23,
  -9,
  118,
  -24,
  117,
  -29,
  -96,
  59,
  65,
  87,
  -14,
  -83,
  83,
  -6,
  -92,
  -20,
  -61,
  124,
  -41,
  18,
  -90,
  59,
  -16,
  95,
  -101,
  -54,
  121,
  83,
  -89,
  96,
  -99,
  97,
  -34,
  48,
  -73,
  3,
  59,
  103,
  28,
  -106,
  -68,
  -53,
  56,
  49,
  -17,
  -35,
  20,
  119,
  107,
  -51,
  68,
  -82,
  86,
  -14,
  81,
  3,
  124,
  43,
  -98,
  11,
  98,
  9,
  69,
  43,
  49,
  -61,
  86,
  -70,
  52,
  116,
  106,
  -54,
  -5,
  54,
  -89,
  47,
  109,
  -118,
  41,
  -23,
  -103,
  123,
  14,
  -89,
  103,
  -31,
  -1,
  75,
  -96,
  -59,
  -58,
  -55,
  -48,
  113,
  79,
  -71,
  -90,
  8,
  -7,
  91,
  48,
  44,
  -69,
  32,
  68,
  -125,
  -70,
  58,
  -105,
  110,
  -2,
  4,
  108,
  7,
  -91,
  39,
  91,
  -78,
  -51,
  -95,
  120,
  -127,
  -74,
  67,
  13,
  -15,
  31,
  27,
  -45,
  22,
  12,
  -43,
  -19,
  -64,
  90,
  94,
  84,
  -125,
  54,
  -67,
  -49,
  83,
  39,
  -74,
  103,
  -6,
  -77,
  -51,
  60,
  100,
  -8,
  -91,
  126,
  -70,
  -106,
  -8,
  20,
  74,
  7,
  -80,
  -82,
  6,
  28,
  69,
  63,
  -106,
  -56,
  6,
  -93,
  104,
  55,
  -58,
  -77,
  1,
  -24,
  118,
  -122,
  11,
  -71,
  64,
  -3,
  -61,
  128,
  -98,
  -8,
  1,
  -12,
  -53,
  -23,
  82,
  -81,
  -99,
  29,
  -76,
  -113,
  82,
  56,
  51,
  33,
  43,
  37,
  -98,
  45,
  -22,
  -77,
  110,
  49,
  -106,
  -80,
  2,
  -10,
  -15,
  6,
  -24,
  -36,
  126,
  20,
  101,
  101,
  -82,
  -111,
  -78,
  103,
  -58,
  -122,
  -110,
  86,
  32,
  -30,
  -76,
  -89,
  102,
  -58,
  -86,
  -53,
  112,
  31,
  115,
  -115,
  56,
  -18,
  77,
  -44,
  23,
  6,
  116,
  57,
  -36,
  -77,
  -17,
  -100,
  112,
  -101,
  -123,
  -67,
  -33,
  111,
  31,
  -107,
  115,
  -123,
  -67,
  120,
  51,
  -38,
  -33,
  -32,
  -60,
  58,
  54,
  -87,
  57,
  -99,
  -126,
  49,
  53,
  0,
  70,
  27,
  104,
  107,
  -113,
  -63,
  -58,
  -86,
  -7,
  61,
  -41,
  61,
  112,
  14,
  124,
  121,
  -60,
  87,
  45,
  -7,
  55,
  -58,
  26,
  -109,
  118,
  -62,
  20,
  -40,
  98,
  -82,
  -95,
  108,
  78,
  -57,
  -45,
  54,
  103,
  122,
  40,
  94,
  67,
  62,
  32,
  -11,
  -62,
  -104,
  -111,
  -101,
  32,
  -25,
  -95,
  105,
  53,
  -38,
  -51,
  77,
  -111,
  -70,
  32,
  112,
  114,
  83,
  -68,
  99,
  120,
  -114,
  102,
  78,
  -26,
  90,
  118,
  -45,
  -77,
  78,
  57,
  108,
  64,
  55,
  75,
  -25,
  -102,
  48,
  79,
  -45,
  -6,
  96,
  -121,
  57,
  -122,
  -95,
  -26,
  -43,
  -93,
  45,
  111,
  72,
  -101,
  72,
  -21,
  112,
  -48,
  -17,
  -55,
  43,
  -66,
  58,
  -83,
  -125,
  -70,
  -98,
  -92,
  -57,
  -22,
  17,
  -6,
  23,
  -21,
  39,
  70,
  60,
  -57,
  -102,
  63,
  -94,
  -117,
  -47,
  62,
  40,
  -72,
  70,
  100,
  3,
  92,
  -120,
  118,
  -116,
  41,
  -77,
  98,
  -79,
  19,
  102,
  -7,
  71,
  -47,
  22,
  79,
  94,
  20,
  76,
  126,
  -116,
  -74,
  -33,
  76,
  -40,
  3,
  -72,
  -33,
  77,
  -69,
  111,
  38,
  -20,
  1,
  -36,
  -17,
  -92,
  -35,
  55,
  19,
  -10,
  -64,
  69,
  1,
  -16,
  -38,
  -72,
  -47,
  -98,
  -23,
  108,
  108,
  -104,
  83,
  108,
  63,
  121,
  22,
  109,
  -98,
  109,
  -23,
  41,
  29,
  69,
  107,
  -89,
  -21,
  -39,
  -96,
  103,
  -38,
  40,
  78,
  -20,
  -114,
  97,
  -6,
  -73,
  49,
  -49,
  105,
  -3,
  110,
  -123,
  -56,
  123,
  -51,
  120,
  -73,
  17,
  58,
  3,
  -33,
  81,
  -114,
  -70,
  -57,
  -115,
  47,
  110,
  56,
  -103,
  50,
  116,
  10,
  100,
  -24,
  -44,
  -12,
  23,
  -119,
  111,
  -69,
  -67,
  72,
  -69,
  58,
  23,
  7,
  94,
  -22,
  -6,
  -92,
  44,
  -113,
  77,
  69,
  -35,
  88,
  -121,
  -73,
  -95,
  -90,
  -61,
  -53,
  55,
  -73,
  21,
  99,
  70,
  10,
  -8,
  -99,
  29,
  -48,
  86,
  -66,
  -29,
  -24,
  54,
  -23,
  87,
  -64,
  -6,
  -15,
  110,
  -78,
  119,
  -6,
  -17,
  -125,
  -82,
  -86,
  -91,
  94,
  54,
  119,
  -104,
  -82,
  34,
  93,
  58,
  -74,
  35,
  -27,
  -73,
  -43,
  -71,
  -122,
  27,
  95,
  -31,
  109,
  -120,
  -77,
  -2,
  28,
  127,
  -56,
  -71,
  102,
  39,
  -24,
  99,
  7,
  101,
  11,
  -25,
  72,
  -30,
  30,
  -27,
  39,
  64,
  -49,
  -6,
  -124,
  -72,
  6,
  -10,
  -84,
  -40,
  47,
  -11,
  48,
  -116,
  33,
  7,
  -70,
  -92,
  126,
  -54,
  -15,
  112,
  -52,
  -117,
  -124,
  -92,
  83,
  127,
  -123,
  -77,
  -58,
  -117,
  -58,
  37,
  -23,
  106,
  -121,
  128,
  14,
  4,
  58,
  76,
  88,
  -80,
  -73,
  102,
  -58,
  -34,
  -107,
  -14,
  40,
  -121,
  119,
  83,
  3,
  -14,
  -117,
  54,
  -38,
  27,
  -119,
  -76,
  9,
  -102,
  83,
  -17,
  32,
  51,
  11,
  -96,
  -67,
  13,
  39,
  83,
  -122,
  77,
  -15,
  -120,
  -117,
  4,
  -57,
  -67,
  99,
  47,
  -22,
  -17,
  -85,
  125,
  -103,
  -14,
  85,
  -40,
  24,
  -73,
  -16,
  -121,
  -57,
  98,
  56,
  -75,
  -92,
  71,
  -40,
  120,
  -75,
  49,
  -93,
  -71,
  118,
  -76,
  -44,
  121,
  -90,
  72,
  -66,
  69,
  -102,
  -86,
  -112,
  58,
  -49,
  84,
  -55,
  31,
  65,
  95,
  -110,
  -26,
  40,
  59,
  -94,
  118,
  70,
  -14,
  13,
  -34,
  -101,
  -6,
  -2,
  -29,
  -26,
  101,
  -122,
  -100,
  -105,
  -103,
  114,
  94,
  48,
  39,
  94,
  14,
  -70,
  -32,
  120,
  -82,
  -1,
  41,
  -80,
  -93,
  49,
  39,
  -10,
  20,
  -14,
  -24,
  -108,
  79,
  95,
  5,
  -25,
  -30,
  -1,
  -40,
  -73,
  -5,
  -79,
  71,
  74,
  -66,
  -117,
  -44,
  8,
  -33,
  -59,
  -58,
  17,
  -66,
  -117,
  -55,
  35,
  124,
  23,
  -44,
  53,
  -52,
  41,
  125,
  -44,
  39,
  -46,
  -121,
  49,
  94,
  -50,
  -29,
  122,
  -24,
  9,
  108,
  99,
  -28,
  60,
  114,
  14,
  57,
  127,
  55,
  -63,
  14,
  -3,
  71,
  115,
  -9,
  99,
  105,
  23,
  -3,
  -33,
  -51,
  -61,
  -18,
  17,
  -13,
  -112,
  -48,
  -72,
  124,
  80,
  -22,
  15,
  83,
  -67,
  -5,
  -28,
  60,
  -72,
  -34,
  102,
  -87,
  59,
  76,
  -107,
  60,
  -103,
  -72,
  -67,
  5,
  -33,
  -78,
  124,
  35,
  -54,
  -93,
  57,
  123,
  -127,
  -70,
  70,
  -61,
  -34,
  -32,
  118,
  94,
  -101,
  -9,
  5,
  55,
  -29,
  -6,
  -77,
  127,
  -94,
  55,
  -28,
  32,
  91,
  70,
  -14,
  -98,
  114,
  -83,
  55,
  -36,
  81,
  88,
  77,
  126,
  3,
  62,
  62,
  39,
  -69,
  -93,
  -38,
  109,
  -37,
  -95,
  116,
  3,
  -55,
  39,
  88,
  87,
  -50,
  -9,
  -18,
  62,
  9,
  11,
  -66,
  -13,
  94,
  -91,
  -66,
  -126,
  -25,
  87,
  62,
  -94,
  19,
  16,
  -66,
  -108,
  -91,
  -12,
  128,
  106,
  -24,
  1,
  -59,
  17,
  122,
  64,
  -11,
  -1,
  15,
  122,
  128,
  -9,
  15,
  -54,
  -1,
  -12,
  49,
  -19,
  112,
  -20,
  55,
  -59,
  -25,
  -48,
  126,
  -104,
  -15,
  83,
  -52,
  97,
  -29,
  -28,
  -71,
  69,
  -116,
  -1,
  54,
  49,
  77,
  -55,
  104,
  -54,
  -93,
  -113,
  -109,
  -1,
  -117,
  -80,
  62,
  35,
  122,
  87,
  122,
  128,
  -11,
  119,
  122,
  0,
  -27,
  32,
  -38,
  -99,
  -60,
  -10,
  -53,
  70,
  -76,
  -113,
  -71,
  -3,
  74,
  -44,
  -2,
  71,
  -27,
  -1,
  -56,
  118,
  63,
  78,
  15,
  -120,
  99,
  28,
  67,
  -15,
  98,
  48,
  109,
  -17,
  -41,
  -4,
  -9,
  -97,
  81,
  62,
  -42,
  -8,
  -77,
  98,
  112,
  -1,
  -97,
  -60,
  -32,
  85,
  -94,
  55,
  124,
  6,
  -9,
  24,
  99,
  -112,
  128,
  -19,
  -3,
  -121,
  103,
  -43,
  -5,
  0,
  -9,
  127,
  110,
  16,
  -63,
  43,
  -24,
  -1,
  66,
  -3,
  -2,
  55,
  -72,
  -42,
  -119,
  -107,
  -2,
  -19,
  113,
  92,
  -99,
  -11,
  97,
  2,
  101,
  127,
  -75,
  72,
  -61,
  -12,
  -27,
  -82,
  12,
  -57,
  -93,
  44,
  46,
  -81,
  -67,
  -95,
  112,
  -42,
  -124,
  73,
  -36,
  -41,
  -31,
  -2,
  7,
  -8,
  -18,
  -99,
  106,
  55,
  104,
  58,
  32,
  6,
  -1,
  23,
  -13,
  -7,
  -26,
  -44,
  78,
  115,
  -49,
  5,
  93,
  -90,
  -104,
  -42,
  105,
  114,
  78,
  -91,
  76,
  -8,
  -109,
  24,
  56,
  60,
  11,
  -10,
  10,
  -32,
  -84,
  3,
  -100,
  34,
  -29,
  6,
  -5,
  1,
  107,
  37,
  -20,
  -121,
  103,
  112,
  109,
  50,
  122,
  -61,
  -5,
  52,
  108,
  -73,
  -30,
  74,
  88,
  9,
  83,
  47,
  -18,
  83,
  120,
  -9,
  -58,
  -3,
  120,
  -41,
  -22,
  122,
  113,
  -36,
  -1,
  -102,
  -11,
  114,
  -96,
  -97,
  -52,
  31,
  -61,
  -47,
  -8,
  -89,
  79,
  -31,
  78,
  -40,
  -44,
  -12
}; // weak
int _python_vm_iq2_version = 16777233; // weak
char _python_vm_iq2[5] = "XVQ2"; // weak
int _python_vm_iq2_internal_version = 16777233; // weak
int _python_vm_iq2_internal_crc = 1697284998; // weak
int _python_vm_exp_version = 16777225; // weak
char _python_vm_exp[5] = "XVXE"; // weak
int _python_vm_exp_internal_version = 16777225; // weak
int _python_vm_exp_internal_crc = 66918513; // weak
int (__cdecl *zalloc)(int, int, int) = &V5_ZipInflateAlloc; // weak
int (*zfree)() = &V5_ZipInflateFree; // weak
void *_error_descp = &unk_50F070; // weak
void *_logTypes = &unk_50F070; // weak
char *_devTypes[15] =
{
  "NXB",
  "NXA",
  "Motor",
  "Led",
  "Rotation",
  "Motor",
  "Inertial",
  "Distance",
  "Radio",
  "Controller",
  "Brain",
  "Vision",
  "ADI",
  "Partner",
  "Battery"
}; // weak
char *_vexProgTypes[4] = { "Drive", "ClawBot", "Sensor Demo", "Tutorial" }; // weak
void *(__cdecl *global_hooks)(size_t Size) = &malloc; // weak
void (__cdecl *off_4E9D44)(void *Block) = &free; // weak
void *(__cdecl *off_4E9D48)(void *Block, size_t Size) = &realloc; // weak
const DEVPROPKEY DEVPKEY_NAME =
{
  {
    3072717104u,
    18415u,
    4122u,
    { 165u, 241u, 2u, 96u, 140u, 158u, 235u, 172u }
  },
  10u
};
const DEVPROPKEY DEVPKEY_Device_InstanceId =
{
  { 2026065864u, 4170u, 19146u, { 158u, 164u, 82u, 77u, 82u, 153u, 110u, 87u } },
  256u
};
const DEVPROPKEY DEVPKEY_Device_HardwareIds =
{
  {
    2757502286u,
    57116u,
    20221u,
    { 128u, 32u, 103u, 209u, 70u, 168u, 80u, 224u }
  },
  3u
};
const DEVPROPKEY DEVPKEY_Device_CompatibleIds =
{
  {
    2757502286u,
    57116u,
    20221u,
    { 128u, 32u, 103u, 209u, 70u, 168u, 80u, 224u }
  },
  4u
};
const DEVPROPKEY DEVPKEY_Device_ContainerId =
{
  {
    2357121542u,
    16266u,
    18471u,
    { 179u, 171u, 174u, 158u, 31u, 174u, 252u, 108u }
  },
  2u
};
const PROPERTYKEY PKEY_DeviceInterface_Bluetooth_DeviceAddress =
{
  { 735477131u, 35819u, 18645u, { 135u, 224u, 108u, 218u, 52u, 40u, 4u, 10u } },
  1u
};
const PROPERTYKEY PKEY_DeviceInterface_Bluetooth_Manufacturer =
{
  { 735477131u, 35819u, 18645u, { 135u, 224u, 108u, 218u, 52u, 40u, 4u, 10u } },
  4u
};
_UNKNOWN api_version; // weak
_UNKNOWN _EXP_boot_ram; // weak
_UNKNOWN _IQ2_boot_ram; // weak
int dfu_timeout = 5000; // weak
__int32 data_1 = -1; // weak
signed __int32 mtx_pthr_locked = -3; // weak
int *_pthread_key_lock = (int *)0xFFFFFFFF; // weak
DWORD _pthread_tls = 4294967295u; // idb
__int32 cond_locked = -1; // weak
__int32 rwl_global = -1; // weak
__int32 cond_locked_0 = -1; // weak
int (*data_2)[120] = &dword_445420; // weak
int _dowildcard = -1; // weak
int _CRT_MT = 2; // weak
int fpi_3876[6] = { 53, -1074, 971, 1, 0, 14 }; // weak
int posixly_correct_67427 = -1; // weak
int nonopt_end = -1; // weak
int nonopt_start = -1; // weak
char *place = &unk_511775; // idb
int optopt = 63; // weak
int optind = 1; // weak
int opterr = 1; // weak
int _MINGW_INSTALL_DEBUG_MATHERR = -1; // weak
void *pmem_next = &private_mem; // weak
errno_t (__cdecl *__sopen_s)(int *FileHandle, const char *FileName, int OpenFlag, int ShareFlag, int PermissionMode) = &_stub;
uintptr_t __security_cookie = 3141592654u;
int __security_cookie_complement = 1153374641; // weak
const GUID GUID_DEVCLASS_PORTS = { 1295444344u, 58149u, 4558u, { 191u, 193u, 8u, 0u, 43u, 225u, 3u, 24u } };
_UNKNOWN unk_50DF91; // weak
_UNKNOWN unk_50F070; // weak
const char byte_50FC1A = '\xEF'; // idb
int default_buffer_size_5552 = 256; // weak
const wchar_t aB[] = L"B"; // idb
const wchar_t aW[] = L"W"; // idb
_UNKNOWN unk_5109FC; // weak
const struct _EXCEPTION_POINTERS GS_ExceptionPointers = { &GS_ExceptionRecord, &GS_ContextRecord }; // idb
char *CSWTCH_5[6] =
{
  "Argument domain error (DOMAIN)",
  "Argument singularity (SIGN)",
  "Overflow range error (OVERFLOW)",
  "The result is too small to be represented (UNDERFLOW)",
  "Total loss of significance (TLOSS)",
  "Partial loss of significance (PLOSS)"
}; // weak
const char Locale[2] = { '\0', '\0' }; // idb
const wchar_t Source[] = L"."; // idb
_UNKNOWN unk_511775; // weak
int fivesbits[23] =
{
  0,
  3,
  5,
  7,
  10,
  12,
  14,
  17,
  19,
  21,
  24,
  26,
  28,
  31,
  33,
  35,
  38,
  40,
  42,
  45,
  47,
  49,
  52
}; // weak
double dbl_5119F8[] = { 0.0 }; // weak
char byte_511A00[] = { 'A' }; // weak
char byte_511A07[] = { 'a' }; // weak
char byte_511A0E[] = { '0' }; // weak
int dword_511A1C[] = { 0 }; // weak
double __tens_D2A[24] =
{
  1.0,
  10.0,
  100.0,
  1000.0,
  10000.0,
  100000.0,
  1000000.0,
  1.0e7,
  1.0e8,
  1.0e9,
  1.0e10,
  1.0e11,
  1.0e12,
  1.0e13,
  1.0e14,
  1.0e15,
  1.0e16,
  1.0e17,
  1.0e18,
  1.0e19,
  1.0e20,
  1.0e21,
  1.0e22,
  0.0
}; // weak
double __tinytens_D2A[4] = { 1.0e-16, 1.0e-32, 1.0e-64, 1.0e-128 }; // weak
double __bigtens_D2A[4] = { 1.0e16, 1.0e32, 1.0e64, 1.0e128 }; // weak
char byte_511B9F[] = { '\0' }; // weak
char _dist_code[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F'
}; // weak
char byte_511CA0[] = { '\0' }; // weak
char _length_code[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\b',
  '\t',
  '\t',
  '\n',
  '\n',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1C'
}; // weak
int base_dist[] = { 0 }; // weak
int base_length[] = { 0 }; // weak
char bl_order[32] =
{
  '\x10',
  '\x11',
  '\x12',
  '\0',
  '\b',
  '\a',
  '\t',
  '\x06',
  '\n',
  '\x05',
  '\v',
  '\x04',
  '\f',
  '\x03',
  '\r',
  '\x02',
  '\x0E',
  '\x01',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
__int16 configuration_table[] = { 0 }; // weak
__int16 word_511FC2[] = { 0 }; // weak
int (__cdecl *funcs_427A76[3])(int, int) =
{
  &deflate_stored,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008
}; // weak
int crc_table[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // weak
int dword_512440[256] =
{
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  -925267448,
  -775767223,
  -84940662,
  -470492725,
  -1397403892,
  -1246855603,
  -1635570290,
  -2020074289,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  -2112120743,
  -1694455528,
  -1339163941,
  -1456026726,
  -428384931,
  -9671652,
  -733921313,
  -849736034,
  -1786501982,
  -1935731229,
  -1481488864,
  -1096190111,
  -236396122,
  -386674457,
  -1008827612,
  -624577947,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  -549046541,
  -966981710,
  -311405455,
  -194288336,
  -1154812937,
  -1573797194,
  -1994616459,
  -1878548428,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  -260485371,
  -379421116,
  -1034998393,
  -615244602,
  -1810527743,
  -1928414400,
  -1507596157,
  -1086793278,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  -1162125996,
  -1549767659,
  -2004009002,
  -1852436841,
  -556296112,
  -942888687,
  -320734510,
  -168113261,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  -1390091857,
  -1270886162,
  -1626176723,
  -2046184852,
  -918018901,
  -799861270,
  -75610583,
  -496666776,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  -404294658,
  -16923969,
  -707751556,
  -859070403,
  -2088093958,
  -1701771333,
  -1313057672,
  -1465424583,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  -212200893,
  -364829950,
  -1049857855,
  -663273088,
  -1758013625,
  -1909594618,
  -1526680123,
  -1139047292,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  -1181220846,
  -1602014893,
  -1951505776,
  -1833610287,
  -571161322,
  -990907305,
  -272455788,
  -153512235,
  -1375224599,
  -1222865496,
  -1674453397,
  -2060783830,
  -898926099,
  -747616084,
  -128115857,
  -515495378,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  -456806728,
  -35741703,
  -688665542,
  -806814341,
  -2136380484,
  -1716364547,
  -1298200258,
  -1417398145,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  -872753330,
  -756947441,
  -104024628,
  -522746739,
  -1349119414,
  -1232264437,
  -1650429752,
  -2068102775,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  -2126985953,
  -1742474146,
  -1290885219,
  -1441425700,
  -447479781,
  -61918886,
  -681418087,
  -830909480,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  -1767409180,
  -1883486043,
  -1533994138,
  -1115018713,
  -221528864,
  -338653791,
  -1057104286,
  -639176925,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  -597333067,
  -981574924,
  -296548041,
  -146261898,
  -1207325007,
  -1592614928,
  -1975530445,
  -1826292366
}; // weak
int dword_512840[256] =
{
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  -516613248,
  -520654409,
  -491663378,
  -478960167,
  -432229540,
  -402728597,
  -440899790,
  -461763323,
  -282703304,
  -287039473,
  -324886954,
  -312413087,
  -399514908,
  -370308909,
  -341100918,
  -362193731,
  -49039120,
  -53357881,
  -23630690,
  -11204951,
  -98955220,
  -69699045,
  -107035582,
  -128143755,
  -218044088,
  -222133377,
  -259769050,
  -247048431,
  -200719980,
  -171234397,
  -141715974,
  -162529331,
  -646423200,
  -658884777,
  -620984050,
  -616635591,
  -562956868,
  -541876341,
  -571137582,
  -600355867,
  -680850216,
  -693541137,
  -722478922,
  -718425471,
  -798841852,
  -777990605,
  -739872662,
  -769385891,
  -983630320,
  -996371417,
  -958780802,
  -954711991,
  -1034463540,
  -1013629701,
  -1043103070,
  -1072568171,
  -884101208,
  -896547425,
  -926319674,
  -922021391,
  -867956876,
  -846828221,
  -809446630,
  -838682323,
  -1850763712,
  -1871840137,
  -1842658770,
  -1813436391,
  -1767489892,
  -1755032405,
  -1792873742,
  -1797226299,
  -1615017992,
  -1635865137,
  -1674046570,
  -1644529247,
  -1732939996,
  -1720253165,
  -1691239606,
  -1695297155,
  -1920387792,
  -1941217529,
  -1911692962,
  -1882223767,
  -1971282452,
  -1958545445,
  -1996207742,
  -2000280651,
  -2087033720,
  -2108158273,
  -2145472282,
  -2116232495,
  -2070688684,
  -2058246557,
  -2028529606,
  -2032831987,
  -1444753248,
  -1474250089,
  -1436154674,
  -1415287047,
  -1360299908,
  -1356262837,
  -1385190382,
  -1397897691,
  -1477345000,
  -1506546897,
  -1535814282,
  -1514717375,
  -1594349116,
  -1590017037,
  -1552089686,
  -1564567651,
  -1245416496,
  -1274668569,
  -1237276738,
  -1216164471,
  -1295131892,
  -1290817221,
  -1320611998,
  -1333041835,
  -1143528856,
  -1173010337,
  -1202457082,
  -1181639631,
  -1126266188,
  -1122180989,
  -1084596518,
  -1097321235
}; // weak
int dword_512C40[1280] =
{
  0,
  -1195612315,
  -1442199413,
  313896942,
  -1889364137,
  937357362,
  627793884,
  -1646839623,
  -978048785,
  2097696650,
  1874714724,
  -687765759,
  1255587768,
  -227878691,
  -522225869,
  1482887254,
  1343838111,
  -391827206,
  -99573996,
  1118632049,
  -545537848,
  1741137837,
  1970407491,
  -842109146,
  -1783791760,
  756094997,
  1067759611,
  -2028416866,
  449832999,
  -1569484990,
  -1329192788,
  142231497,
  -1607291074,
  412010587,
  171665333,
  -1299775280,
  793786473,
  -1746116852,
  -2057703198,
  1038456711,
  1703315409,
  -583343948,
  -812691622,
  1999841343,
  -354152314,
  1381529571,
  1089329165,
  -128860312,
  -265553759,
  1217896388,
  1512189994,
  -492939441,
  2135519222,
  -940242797,
  -717183107,
  1845280792,
  899665998,
  -1927039189,
  -1617553211,
  657096608,
  -1157806311,
  37822588,
  284462994,
  -1471616777,
  -1693165507,
  598228824,
  824021174,
  -1985873965,
  343330666,
  -1396004849,
  -1098971167,
  113467524,
  1587572946,
  -434366537,
  -190203815,
  1276501820,
  -775755899,
  1769898208,
  2076913422,
  -1015592853,
  -888336478,
  1941006535,
  1627703081,
  -642211764,
  1148164341,
  -53215344,
  -295284610,
  1457141531,
  247015245,
  -1241169880,
  -1531908154,
  470583459,
  -2116308966,
  963106687,
  735213713,
  -1821499404,
  992409347,
  -2087022490,
  -1859174520,
  697522413,
  -1270587308,
  217581361,
  508405983,
  -1494102086,
  -23928852,
  1177467017,
  1419450215,
  -332959742,
  1911572667,
  -917753890,
  -604405712,
  1665525589,
  1799331996,
  -746338311,
  -1053399017,
  2039091058,
  -463652917,
  1558270126,
  1314193216,
  -152528859,
  -1366587277,
  372764438,
  75645176,
  -1136777315,
  568925988,
  -1722451903,
  -1948198993,
  861712586,
  -312887749,
  1441124702,
  1196457648,
  -1304107,
  1648042348,
  -628668919,
  -936187417,
  1888390786,
  686661332,
  -1873675855,
  -2098964897,
  978858298,
  -1483798141,
  523464422,
  226935048,
  -1254447507,
  -1119821404,
  100435649,
  390670639,
  -1342878134,
  841119475,
  -1969352298,
  -1741963656,
  546822429,
  2029308235,
  -1068978642,
  -755170880,
  1782671013,
  -141140452,
  1328167289,
  1570739863,
  -450629134,
  1298864389,
  -170426784,
  -412954226,
  1608431339,
  -1039561134,
  2058742071,
  1744848601,
  -792976964,
  -1998638614,
  811816591,
  584513889,
  -1704288764,
  129869501,
  -1090403880,
  -1380684234,
  352848211,
  494030490,
  -1513215489,
  -1216641519,
  264757620,
  -1844389427,
  715964072,
  941166918,
  -2136639965,
  -658086283,
  1618608400,
  1926213374,
  -898381413,
  1470427426,
  -283601337,
  -38979159,
  1158766284,
  1984818694,
  -823031453,
  -599513459,
  1693991400,
  -114329263,
  1100160564,
  1395044826,
  -342174017,
  -1275476247,
  189112716,
  435162722,
  -1588827897,
  1016811966,
  -2077804837,
  -1768777419,
  774831696,
  643086745,
  -1628905732,
  -1940033262,
  887166583,
  -1456066866,
  294275499,
  54519365,
  -1149009632,
  -471821962,
  1532818963,
  1240029693,
  -246071656,
  1820460577,
  -734109372,
  -963916118,
  2117577167,
  -696303304,
  1858283101,
  2088143283,
  -993333546,
  1495127663,
  -509497078,
  -216785180,
  1269332353,
  332098007,
  -1418260814,
  -1178427044,
  25085497,
  -1666580864,
  605395429,
  916469259,
  -1910746770,
  -2040129881,
  1054503362,
  745528876,
  -1798063799,
  151290352,
  -1313282411,
  -1559410309,
  464596510,
  1137851976,
  -76654291,
  -371460413,
  1365741990,
  -860837601,
  1946996346,
  1723425172,
  -570095887,
  0,
  -1775237257,
  744558318,
  -1169094247,
  432303367,
  -1879807376,
  900031465,
  -1550490466,
  847829774,
  -1531388807,
  518641120,
  -1998990697,
  726447625,
  -1115901570,
  120436967,
  -1860321392,
  1678817053,
  -232738710,
  1215412723,
  -566116732,
  2111101466,
  -337322643,
  1370871028,
  -947530877,
  1452829715,
  -1062704284,
  2063164157,
  -322345590,
  1331429652,
  -647231901,
  1664946170,
  -183695219,
  -937398725,
  1578133836,
  -465477419,
  1920034722,
  -773586116,
  1205077067,
  -41611822,
  1807026853,
  -89606859,
  1821946434,
  -691422245,
  1090108588,
  -479406030,
  1969020741,
  -821176612,
  1497223595,
  -1406084826,
  973135441,
  -2142119992,
  375509183,
  -1242254303,
  600093526,
  -1718240561,
  262520248,
  -1632107992,
  143131999,
  -1294398266,
  619252657,
  -2021888209,
  290220120,
  -1424137791,
  1026385590,
  -1874731914,
  108124929,
  -1138699624,
  705746415,
  -1987726991,
  532002310,
  -1511735393,
  869578984,
  -1563883656,
  888733711,
  -1901590122,
  412618465,
  -1156748673,
  759000328,
  -1754504047,
  22832102,
  -195990677,
  1650551836,
  -667916923,
  1308648178,
  -309000596,
  2074411291,
  -1040971646,
  1472466933,
  -958812059,
  1357494034,
  -356991349,
  2089335292,
  -551690910,
  1227741717,
  -209923188,
  1699534075,
  1482797645,
  -833505990,
  1946205347,
  -500122668,
  1101389642,
  -678045635,
  1841615268,
  -67840301,
  1793681731,
  -52859340,
  1183344557,
  -793222950,
  1932330052,
  -451083469,
  1598818986,
  -914616867,
  1014039888,
  -1438580185,
  269487038,
  -2044719927,
  632645719,
  -1283100896,
  164914873,
  -1612422706,
  251256414,
  -1731602135,
  580440240,
  -1264003129,
  389919577,
  -2129808338,
  995933623,
  -1385383232,
  545503469,
  -1229733990,
  216184323,
  -1697468044,
  961009130,
  -1351101795,
  354867972,
  -2095653773,
  302736355,
  -2076482412,
  1047162125,
  -1470469510,
  198119140,
  -1644230253,
  665714698,
  -1315043459,
  1150488560,
  -761067385,
  1760690462,
  -20838807,
  1566008055,
  -882416256,
  1899392025,
  -419009682,
  1981535486,
  -533998711,
  1518000656,
  -867508889,
  1876933113,
  -101728626,
  1136572183,
  -712069024,
  -391915818,
  2123616673,
  -993863624,
  1391648591,
  -244859951,
  1733803174,
  -586762945,
  1261875784,
  -634712616,
  1276840623,
  -162921674,
  1618609217,
  -1007722273,
  1440704424,
  -275878351,
  2042521926,
  -1934401077,
  444819132,
  -1596821723,
  920807506,
  -1787360052,
  54987707,
  -1189739998,
  791020885,
  -1103381819,
  671858098,
  -1839549397,
  74101596,
  -1476405310,
  835702965,
  -1952523988,
  497999451,
  -1329437541,
  653419500,
  -1667011979,
  177433858,
  -1459222116,
  1060507371,
  -2056845454,
  324468741,
  -2109030507,
  343587042,
  -1372868229,
  941340172,
  -1685138798,
  230610405,
  -1209017220,
  568318731,
  -724380794,
  1122161905,
  -122430104,
  1854134815,
  -854147455,
  1529264630,
  -512249745,
  2001188632,
  -430307192,
  1885999103,
  -902101402,
  1544225041,
  -6396529,
  1773036280,
  -738235551,
  1171221526,
  2028079776,
  -288223785,
  1417872462,
  -1028455623,
  1629906855,
  -149528368,
  1296525641,
  -612929986,
  1248514478,
  -598026535,
  1712054080,
  -264513481,
  1403960489,
  -979452962,
  2144318023,
  -369117904,
  485670333,
  -1966949686,
  814986067,
  -1499220956,
  87478458,
  -1828268083,
  693624404,
  -1083713245,
  779773619,
  -1203084860,
  35350621,
  -1809092822,
  935201716,
  -1584526141,
  467600730,
  -1913716179,
  0,
  1093737241,
  -2107492814,
  -1017959125,
  80047204,
  1173649277,
  -2035852714,
  -946454193,
  143317448,
  1237041873,
  -1964445702,
  -874908445,
  206550444,
  1300147893,
  -1909619810,
  -820209529,
  1360183882,
  270784851,
  -747572104,
  -1841172639,
  1440198190,
  350663991,
  -675964900,
  -1769700603,
  1503140738,
  413728923,
  -604361296,
  -1697958231,
  1566406630,
  476867839,
  -549502508,
  -1643226419,
  -1574665067,
  -485122164,
  541504167,
  1635232190,
  -1495144207,
  -405736472,
  612622019,
  1706214874,
  -1431413411,
  -341883324,
  684485487,
  1778217078,
  -1368706759,
  -279303648,
  738789131,
  1832393746,
  -214546721,
  -1308140090,
  1901359341,
  811953140,
  -135058757,
  -1228787294,
  1972444297,
  882902928,
  -71524585,
  -1165130738,
  2044635429,
  955232828,
  -8785037,
  -1102518166,
  2098971969,
  1009442392,
  89094640,
  1149133545,
  -2027073598,
  -971221797,
  25826708,
  1086000781,
  -2081938522,
  -1025951553,
  231055416,
  1291107105,
  -1884842486,
  -828994285,
  151047260,
  1211225925,
  -1956447634,
  -900472457,
  1415429050,
  359440547,
  -700478072,
  -1760651631,
  1352194014,
  296340679,
  -755310100,
  -1815348491,
  1557619314,
  501643627,
  -558541760,
  -1618718887,
  1477578262,
  421729551,
  -630179804,
  -1690229955,
  -1486095003,
  -430250372,
  621398871,
  1681444942,
  -1548840703,
  -492860904,
  567060275,
  1627241514,
  -1344199507,
  -288342092,
  763564703,
  1823607174,
  -1423685431,
  -367701040,
  692485883,
  1752655330,
  -159826129,
  -1220008906,
  1947928861,
  891949572,
  -222538933,
  -1282586542,
  1893623161,
  837779040,
  -17570073,
  -1077740034,
  2089930965,
  1033948108,
  -97088893,
  -1157131878,
  2018819249,
  962963368,
  1268286267,
  178886690,
  -906316535,
  -1999917552,
  1331556191,
  242021446,
  -851453587,
  -1945189772,
  1125276403,
  35865066,
  -1049596735,
  -2143193128,
  1205286551,
  115748238,
  -977993563,
  -2071716932,
  445268337,
  1539005032,
  -1729595581,
  -640062374,
  508505365,
  1602106892,
  -1674765529,
  -585367490,
  302028985,
  1395753888,
  -1872580981,
  -783043182,
  382072029,
  1475669956,
  -1800944913,
  -711534090,
  -373553234,
  -1467147081,
  1809723804,
  720317061,
  -310809654,
  -1404538669,
  1864064504,
  774522593,
  -516497818,
  -1610103425,
  1666508884,
  577106765,
  -437014014,
  -1530746597,
  1737589808,
  648060713,
  -1196505628,
  -106963203,
  986510294,
  2080237775,
  -1133794944,
  -44387687,
  1040818098,
  2134410411,
  -1339810772,
  -250280139,
  843459102,
  1937191175,
  -1260294072,
  -170890415,
  914572922,
  2008178019,
  1322777291,
  266789330,
  -860500743,
  -1920673824,
  1242732207,
  186879414,
  -932142947,
  -1992180860,
  1180508931,
  124532762,
  -1002498767,
  -2062676440,
  1117278055,
  61428862,
  -1057326763,
  -2117377460,
  533018753,
  1593058200,
  -1649996109,
  -594143830,
  453006565,
  1513181180,
  -1721605417,
  -665617970,
  391110985,
  1451162192,
  -1792157829,
  -736310174,
  327847213,
  1388025396,
  -1847018721,
  -791044090,
  -319586722,
  -1379769017,
  1855015020,
  799036277,
  -399109574,
  -1459156701,
  1783899144,
  728055569,
  -461789290,
  -1521959793,
  1713082788,
  657099453,
  -524497934,
  -1584541461,
  1658781120,
  602924761,
  -1109279724,
  -53434611,
  1065585190,
  2125631807,
  -1188769680,
  -132789399,
  994502210,
  2054683995,
  -1251252772,
  -195395899,
  923358190,
  1983400183,
  -1313994312,
  -258010463,
  869023626,
  1929192595,
  0,
  929743361,
  1859421187,
  1505641986,
  -592967417,
  -339555578,
  -1300460284,
  -2062135547,
  -1202646258,
  -1891905265,
  -695888115,
  -504408820,
  1694046729,
  1402198024,
  170761738,
  1028086795,
  1889740316,
  1204413469,
  511156767,
  689791006,
  -1408553189,
  -1688081126,
  -1025529064,
  -172660455,
  -923650798,
  -6752493,
  -1507413743,
  -1857260784,
  341457941,
  590413332,
  2056173590,
  1306819095,
  -532263624,
  -684945607,
  -1902982853,
  -1174926534,
  1022247999,
  193234494,
  1379582012,
  1699742269,
  1477926454,
  1870502967,
  918805045,
  27858996,
  -2067835087,
  -1277848272,
  -362032334,
  -587132621,
  -1864013020,
  -1483757275,
  -30281945,
  -916771546,
  1280139811,
  2066194466,
  580511264,
  368256033,
  682915882,
  534690347,
  1180761129,
  1896496680,
  -199462611,
  -1015631060,
  -1698106066,
  -1381877969,
  -1064461712,
  -135833487,
  -1369891213,
  -1724654478,
  472224631,
  726618486,
  1928402804,
  1167840629,
  2027719038,
  1337346943,
  369626493,
  560123772,
  -1535868807,
  -1826733448,
  -895482758,
  -37042565,
  -1339114388,
  -2025554323,
  -554026897,
  -376374674,
  1820767595,
  1542223722,
  38941032,
  892924777,
  142585698,
  1058368867,
  1722493793,
  1371662688,
  -724064667,
  -474127260,
  -1174199706,
  -1922441113,
  550229832,
  396432713,
  1310675787,
  2037748042,
  -60563889,
  -888595378,
  -1833477556,
  -1512204211,
  -1734687674,
  -1343224249,
  -162643899,
  -1054571964,
  1144180033,
  1935150912,
  719735106,
  495749955,
  1349054804,
  1728197461,
  1052538199,
  165066582,
  -1933510573,
  -1146471854,
  -501973936,
  -713114031,
  -398859686,
  -548200357,
  -2031262119,
  -1316510632,
  881978205,
  66791772,
  1514499934,
  1831841119,
  -2145700383,
  -1217267744,
  -288378398,
  -643468317,
  1555250406,
  1809448679,
  845658341,
  84769508,
  944383727,
  253813998,
  1453236972,
  1643405549,
  -454938648,
  -746000919,
  -1976128533,
  -1118017046,
  -256371715,
  -942484996,
  -1637050370,
  -1459202561,
  739252986,
  461035771,
  1120182009,
  1974361336,
  1223229683,
  2139341554,
  641565936,
  290932465,
  -1807676940,
  -1557410827,
  -90862089,
  -838905866,
  1616738521,
  1463270104,
  243924186,
  971194075,
  -1124765218,
  -1952468001,
  -769526307,
  -448055332,
  -670274601,
  -278484522,
  -1227296812,
  -2119029291,
  77882064,
  869179601,
  1785784019,
  1561994450,
  285105861,
  664050884,
  2116737734,
  1228937415,
  -866756670,
  -79915581,
  -1568484415,
  -1779953216,
  -1464906293,
  -1614442550,
  -964965944,
  -250541111,
  1946633420,
  1131251405,
  450085071,
  767099598,
  1083617169,
  2013031824,
  776088466,
  422111635,
  -1673615722,
  -1420532585,
  -219536747,
  -981409644,
  -121127777,
  -810713442,
  -1777125220,
  -1585841507,
  611300760,
  319125401,
  1253781915,
  2110911386,
  808814989,
  123685772,
  1591807374,
  1770770319,
  -325222262,
  -604552565,
  -2109143927,
  -1255946616,
  -2006672765,
  -1089578878,
  -424665472,
  -774185855,
  1422693252,
  1671844229,
  974657415,
  225629574,
  -1596923223,
  -1749409624,
  -838572374,
  -110189397,
  2088299438,
  1259481519,
  313290669,
  633777580,
  411169191,
  803943334,
  1985312164,
  1094694821,
  -1003882336,
  -213697887,
  -1426228061,
  -1650999646,
  -797719371,
  -417790284,
  -1096335178,
  -1983020361,
  215731634,
  1001459635,
  1645169073,
  1432718256,
  1747113915,
  1598559674,
  116806584,
  832344505,
  -1265967428,
  -2082464579,
  -631350593,
  -315320130,
  0,
  1701297336,
  -1949824598,
  -290474734,
  1469538959,
  854646327,
  -597726427,
  -1187457123,
  -282544955,
  -1974531971,
  1692450159,
  25625047,
  -1195387318,
  -573019406,
  863494112,
  1443914584,
  -1621681840,
  -97475096,
  345968890,
  1912122434,
  -926909473,
  -1381513369,
  1124627061,
  644861645,
  1887415701,
  353898797,
  -71850945,
  -1630529401,
  669568794,
  1116697506,
  -1407138128,
  -918062584,
  1051669152,
  1539870232,
  -1251525878,
  -805271630,
  1765298223,
  207613079,
  -487564923,
  -2020088515,
  -779647387,
  -1260373283,
  1515163599,
  1059599223,
  -2045713174,
  -478717870,
  232320320,
  1757368824,
  -1577571344,
  -996174008,
  707797594,
  1331142370,
  -160478849,
  -1828129337,
  2108113109,
  415300717,
  1322295093,
  733422477,
  -988244321,
  -1602278873,
  424148410,
  2082488578,
  -1836059632,
  -135771992,
  1029182619,
  1480566819,
  -1232069327,
  -738745975,
  1791981076,
  262720172,
  -519602242,
  -2074033402,
  -764370850,
  -1223222042,
  1505274356,
  1021252940,
  -2048408879,
  -528449943,
  238013307,
  1799911363,
  -1576071733,
  -949440141,
  700908641,
  1285601497,
  -174559420,
  -1862282244,
  2119198446,
  456645206,
  1294448910,
  675284406,
  -957370204,
  -1551365092,
  447798145,
  2144823097,
  -1854352853,
  -199266669,
  66528827,
  1720752771,
  -2009124975,
  -312962263,
  1415595188,
  822605836,
  -542618338,
  -1160777306,
  -320892162,
  -1984418234,
  1729600340,
  40904684,
  -1152847759,
  -567325495,
  813758939,
  1441219939,
  -1667219605,
  -104365101,
  392705729,
  1913621113,
  -885563932,
  -1370431140,
  1090475086,
  630778102,
  1938328494,
  384775958,
  -129990140,
  -1658372420,
  606071073,
  1098405273,
  -1344806773,
  -894411725,
  1001806317,
  1590814037,
  -1333899193,
  -719721217,
  1814117218,
  155617242,
  -404147512,
  -2104586640,
  -727782104,
  -1309060720,
  1599530114,
  976312378,
  -2096525401,
  -428985569,
  146900493,
  1839610549,
  -1528741699,
  -1048118267,
  791234839,
  1246688687,
  -210361806,
  -1777230198,
  2025728920,
  500799264,
  1271526520,
  783173824,
  -1073611310,
  -1520025238,
  475961079,
  2033789519,
  -1751736483,
  -219077659,
  85551949,
  1618925557,
  -1898880281,
  -340337057,
  1385040322,
  938063226,
  -649723800,
  -1138639664,
  -365830264,
  -1890163920,
  1643763234,
  77490842,
  -1113146105,
  -658439745,
  913224877,
  1393100821,
  -1706135011,
  -14037339,
  294026167,
  1960953615,
  -841412462,
  -1463899094,
  1175525688,
  594978176,
  1969669848,
  268532320,
  -22098062,
  -1681296438,
  586261591,
  1201019119,
  -1455837699,
  -866250427,
  116280694,
  1669984718,
  -1926871844,
  -398329756,
  1366896633,
  874419009,
  -625924525,
  -1076454677,
  -372835917,
  -1935588085,
  1645146137,
  124341409,
  -1101948100,
  -617207932,
  899256982,
  1358835246,
  -1715907546,
  -52500322,
  309419404,
  1997988148,
  -835832151,
  -1421243887,
  1172717315,
  545358779,
  1989271779,
  334912603,
  -44439223,
  -1740745231,
  554074732,
  1147223764,
  -1429304378,
  -810993794,
  943816662,
  1562821486,
  -1282836868,
  -688993596,
  1876303193,
  179413473,
  -467790605,
  -2122733493,
  -680932589,
  -1307674709,
  1554105017,
  969309697,
  -2130794084,
  -442952412,
  188129334,
  1850809486,
  -1491704186,
  -1032725954,
  752774956,
  1236915092,
  -259980279,
  -1780041551,
  2068385187,
  506376475,
  1212076611,
  760835835,
  -1007232023,
  -1500420271,
  531214540,
  2060323956,
  -1805534874,
  -251263522
}; // weak
_UNKNOWN dbase_3510; // weak
_UNKNOWN dext_3511; // weak
int display_mask_63785[24] =
{
  -252645136,
  -858993460,
  -1431655766,
  -16711936,
  -252645136,
  -858993460,
  -65536,
  -16711936,
  -252645136,
  252645135,
  858993459,
  1431655765,
  -16711936,
  252645135,
  858993459,
  -65536,
  -16711936,
  252645135,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN distfix_3604; // weak
int extra_dbits[] = { 0 }; // weak
int extra_lbits[] = { 0 }; // weak
_UNKNOWN lbase_3508; // weak
_UNKNOWN lenfix_3603; // weak
int dword_514AA0[80] =
{
  526096,
  6096896,
  1902592,
  10160384,
  5441300,
  8194048,
  3999744,
  14354688,
  1509138,
  7145472,
  2951168,
  12257536,
  854016,
  9242624,
  5048320,
  16451840,
  198416,
  5441536,
  1247232,
  12781589,
  2295571,
  7538688,
  3344384,
  13043968,
  722705,
  6490112,
  2295808,
  10946816,
  198656,
  8587264,
  4392960,
  15141120,
  460560,
  5965824,
  1771520,
  9898240,
  4392724,
  8062976,
  3868672,
  14092544,
  1246994,
  7014400,
  2820096,
  11995392,
  722944,
  9111552,
  4917248,
  16189696,
  329488,
  5703680,
  1509376,
  2112,
  3344147,
  7800832,
  3606528,
  13568256,
  984849,
  6752256,
  2557952,
  11471104,
  460800,
  8849408,
  4655104,
  15665408,
  591632,
  6227968,
  2033664,
  10422528,
  6489876,
  8325120,
  4130816,
  14616832,
  1771282,
  7276544,
  3082240,
  12519680,
  985088,
  9373696,
  5179392,
  16713984
}; // weak
_UNKNOWN lext_3509; // weak
__int16 word_514C1E[] = { 0 }; // weak
_UNKNOWN order_3632; // weak
_UNKNOWN unk_514C46; // weak
int png_32bit_exp[16] =
{
  -1,
  -182092523,
  -356464920,
  -523444500,
  -683344693,
  -836465643,
  -983094767,
  -1123507297,
  -1257966796,
  -1386725654,
  -1510025558,
  -1628097951,
  -1741164462,
  -1849437324,
  -1953119772,
  -2052406424
}; // weak
int png_pass_inc_63829[7] = { 8, 8, 4, 4, 2, 2, 1 }; // weak
char png_pass_inc_64022[8] = { '\b', '\b', '\x04', '\x04', '\x02', '\x02', '\x01', '\0' }; // weak
char png_pass_start_64021[8] = { '\0', '\x04', '\0', '\x02', '\0', '\x01', '\0', '\0' }; // weak
char png_pass_yinc_64015[8] = { '\b', '\b', '\b', '\x04', '\x04', '\x02', '\x02', '\0' }; // weak
char png_pass_ystart_64014[] = { '\0' }; // weak
__int16 png_sRGB_base[512] =
{
  128,
  1782,
  3383,
  4644,
  5675,
  6564,
  7357,
  8074,
  8732,
  9346,
  9921,
  10463,
  10977,
  11466,
  11935,
  12384,
  12816,
  13233,
  13634,
  14024,
  14402,
  14769,
  15125,
  15473,
  15812,
  16142,
  16466,
  16781,
  17090,
  17393,
  17690,
  17981,
  18266,
  18546,
  18822,
  19093,
  19359,
  19621,
  19879,
  20133,
  20383,
  20630,
  20873,
  21113,
  21349,
  21583,
  21813,
  22041,
  22265,
  22487,
  22707,
  22923,
  23138,
  23350,
  23559,
  23767,
  23972,
  24175,
  24376,
  24575,
  24772,
  24967,
  25160,
  25352,
  25542,
  25730,
  25916,
  26101,
  26284,
  26465,
  26645,
  26823,
  27000,
  27176,
  27350,
  27523,
  27695,
  27865,
  28034,
  28201,
  28368,
  28533,
  28697,
  28860,
  29021,
  29182,
  29341,
  29500,
  29657,
  29813,
  29969,
  30123,
  30276,
  30429,
  30580,
  30730,
  30880,
  31028,
  31176,
  31323,
  31469,
  31614,
  31758,
  31902,
  32045,
  32186,
  32327,
  32468,
  32607,
  32746,
  -32652,
  -32515,
  -32378,
  -32242,
  -32107,
  -31972,
  -31839,
  -31705,
  -31573,
  -31441,
  -31310,
  -31179,
  -31050,
  -30920,
  -30792,
  -30663,
  -30536,
  -30409,
  -30283,
  -30157,
  -30032,
  -29907,
  -29783,
  -29660,
  -29537,
  -29414,
  -29292,
  -29171,
  -29050,
  -28930,
  -28810,
  -28691,
  -28572,
  -28453,
  -28335,
  -28218,
  -28101,
  -27985,
  -27868,
  -27753,
  -27638,
  -27523,
  -27409,
  -27295,
  -27182,
  -27069,
  -26956,
  -26844,
  -26733,
  -26621,
  -26510,
  -26400,
  -26290,
  -26180,
  -26071,
  -25962,
  -25854,
  -25746,
  -25638,
  -25531,
  -25424,
  -25317,
  -25211,
  -25105,
  -24999,
  -24894,
  -24789,
  -24685,
  -24581,
  -24477,
  -24373,
  -24270,
  -24167,
  -24065,
  -23963,
  -23861,
  -23759,
  -23658,
  -23557,
  -23457,
  -23357,
  -23257,
  -23157,
  -23058,
  -22959,
  -22860,
  -22761,
  -22663,
  -22565,
  -22468,
  -22371,
  -22274,
  -22177,
  -22080,
  -21984,
  -21888,
  -21793,
  -21697,
  -21602,
  -21508,
  -21413,
  -21319,
  -21225,
  -21131,
  -21037,
  -20944,
  -20851,
  -20758,
  -20666,
  -20574,
  -20482,
  -20390,
  -20298,
  -20207,
  -20116,
  -20025,
  -19935,
  -19844,
  -19754,
  -19664,
  -19575,
  -19485,
  -19396,
  -19307,
  -19218,
  -19130,
  -19042,
  -18953,
  -18866,
  -18778,
  -18690,
  -18603,
  -18516,
  -18429,
  -18343,
  -18256,
  -18170,
  -18084,
  -17998,
  -17913,
  -17827,
  -17742,
  -17657,
  -17572,
  -17488,
  -17403,
  -17319,
  -17235,
  -17151,
  -17068,
  -16984,
  -16901,
  -16818,
  -16735,
  -16652,
  -16570,
  -16488,
  -16405,
  -16323,
  -16242,
  -16160,
  -16078,
  -15997,
  -15916,
  -15835,
  -15754,
  -15674,
  -15593,
  -15513,
  -15433,
  -15353,
  -15273,
  -15194,
  -15114,
  -15035,
  -14956,
  -14877,
  -14798,
  -14720,
  -14641,
  -14563,
  -14485,
  -14407,
  -14329,
  -14251,
  -14174,
  -14097,
  -14019,
  -13942,
  -13865,
  -13789,
  -13712,
  -13636,
  -13559,
  -13483,
  -13407,
  -13331,
  -13256,
  -13180,
  -13104,
  -13029,
  -12954,
  -12879,
  -12804,
  -12729,
  -12655,
  -12580,
  -12506,
  -12432,
  -12358,
  -12284,
  -12210,
  -12136,
  -12063,
  -11990,
  -11916,
  -11843,
  -11770,
  -11697,
  -11625,
  -11552,
  -11480,
  -11407,
  -11335,
  -11263,
  -11191,
  -11119,
  -11047,
  -10976,
  -10904,
  -10833,
  -10762,
  -10691,
  -10620,
  -10549,
  -10478,
  -10407,
  -10337,
  -10267,
  -10196,
  -10126,
  -10056,
  -9986,
  -9916,
  -9847,
  -9777,
  -9708,
  -9638,
  -9569,
  -9500,
  -9431,
  -9362,
  -9293,
  -9225,
  -9156,
  -9088,
  -9019,
  -8951,
  -8883,
  -8815,
  -8747,
  -8679,
  -8612,
  -8544,
  -8477,
  -8409,
  -8342,
  -8275,
  -8208,
  -8141,
  -8074,
  -8007,
  -7941,
  -7874,
  -7808,
  -7741,
  -7675,
  -7609,
  -7543,
  -7477,
  -7411,
  -7345,
  -7280,
  -7214,
  -7149,
  -7083,
  -7018,
  -6953,
  -6888,
  -6823,
  -6758,
  -6693,
  -6628,
  -6564,
  -6499,
  -6435,
  -6371,
  -6306,
  -6242,
  -6178,
  -6114,
  -6050,
  -5987,
  -5923,
  -5859,
  -5796,
  -5732,
  -5669,
  -5606,
  -5543,
  -5480,
  -5417,
  -5354,
  -5291,
  -5228,
  -5166,
  -5103,
  -5041,
  -4978,
  -4916,
  -4854,
  -4792,
  -4730,
  -4668,
  -4606,
  -4544,
  -4482,
  -4421,
  -4359,
  -4298,
  -4236,
  -4175,
  -4114,
  -4053,
  -3992,
  -3931,
  -3870,
  -3809,
  -3748,
  -3688,
  -3627,
  -3567,
  -3506,
  -3446,
  -3386,
  -3325,
  -3265,
  -3205,
  -3145,
  -3086,
  -3026,
  -2966,
  -2906,
  -2847,
  -2787,
  -2728,
  -2669,
  -2609,
  -2550,
  -2491,
  -2432,
  -2373,
  -2314,
  -2255,
  -2196,
  -2138,
  -2079,
  -2021,
  -1962,
  -1904,
  -1845,
  -1787,
  -1729,
  -1671,
  -1613,
  -1555,
  -1497,
  -1439,
  -1381,
  -1324,
  -1266,
  -1208,
  -1151,
  -1093,
  -1036,
  -979,
  -922,
  -864,
  -807,
  -750,
  -693,
  -636,
  -580,
  -523,
  -466,
  -410,
  -353,
  -297,
  -240,
  -184,
  -127,
  -71
}; // weak
char png_sRGB_delta[512] =
{
  '\xCF',
  '\xC9',
  '\x9E',
  '\x81',
  'q',
  'd',
  'Z',
  'R',
  'M',
  'H',
  'D',
  '@',
  '=',
  ';',
  '8',
  '6',
  '4',
  '2',
  '1',
  '/',
  '.',
  '-',
  '+',
  '*',
  ')',
  '(',
  '\'',
  '\'',
  '&',
  '%',
  '$',
  '$',
  '#',
  '\"',
  '\"',
  '!',
  '!',
  ' ',
  ' ',
  '\x1F',
  '\x1F',
  '\x1E',
  '\x1E',
  '\x1E',
  '\x1D',
  '\x1D',
  '\x1C',
  '\x1C',
  '\x1C',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a'
}; // weak
__int16 png_sRGB_table[256] =
{
  0,
  20,
  40,
  60,
  80,
  99,
  119,
  139,
  159,
  179,
  199,
  219,
  241,
  264,
  288,
  313,
  340,
  367,
  396,
  427,
  458,
  491,
  526,
  562,
  599,
  637,
  677,
  718,
  761,
  805,
  851,
  898,
  947,
  997,
  1048,
  1101,
  1156,
  1212,
  1270,
  1330,
  1391,
  1453,
  1517,
  1583,
  1651,
  1720,
  1790,
  1863,
  1937,
  2013,
  2090,
  2170,
  2250,
  2333,
  2418,
  2504,
  2592,
  2681,
  2773,
  2866,
  2961,
  3058,
  3157,
  3258,
  3360,
  3464,
  3570,
  3678,
  3788,
  3900,
  4014,
  4129,
  4247,
  4366,
  4488,
  4611,
  4736,
  4864,
  4993,
  5124,
  5257,
  5392,
  5530,
  5669,
  5810,
  5953,
  6099,
  6246,
  6395,
  6547,
  6700,
  6856,
  7014,
  7174,
  7335,
  7500,
  7666,
  7834,
  8004,
  8177,
  8352,
  8528,
  8708,
  8889,
  9072,
  9258,
  9445,
  9635,
  9828,
  10022,
  10219,
  10417,
  10619,
  10822,
  11028,
  11235,
  11446,
  11658,
  11873,
  12090,
  12309,
  12530,
  12754,
  12980,
  13209,
  13440,
  13673,
  13909,
  14146,
  14387,
  14629,
  14874,
  15122,
  15371,
  15623,
  15878,
  16135,
  16394,
  16656,
  16920,
  17187,
  17456,
  17727,
  18001,
  18277,
  18556,
  18837,
  19121,
  19407,
  19696,
  19987,
  20281,
  20577,
  20876,
  21177,
  21481,
  21787,
  22096,
  22407,
  22721,
  23038,
  23357,
  23678,
  24002,
  24329,
  24658,
  24990,
  25325,
  25662,
  26001,
  26344,
  26688,
  27036,
  27386,
  27739,
  28094,
  28452,
  28813,
  29176,
  29542,
  29911,
  30282,
  30656,
  31033,
  31412,
  31794,
  32179,
  32567,
  -32579,
  -32186,
  -31791,
  -31393,
  -30992,
  -30588,
  -30181,
  -29772,
  -29360,
  -28945,
  -28528,
  -28107,
  -27684,
  -27258,
  -26830,
  -26398,
  -25964,
  -25527,
  -25087,
  -24645,
  -24199,
  -23751,
  -23300,
  -22846,
  -22389,
  -21930,
  -21467,
  -21002,
  -20534,
  -20063,
  -19589,
  -19113,
  -18633,
  -18151,
  -17665,
  -17177,
  -16686,
  -16192,
  -15695,
  -15195,
  -14692,
  -14187,
  -13678,
  -13167,
  -12652,
  -12135,
  -11615,
  -11091,
  -10565,
  -10036,
  -9504,
  -8969,
  -8431,
  -7890,
  -7346,
  -6799,
  -6249,
  -5696,
  -5140,
  -4581,
  -4019,
  -3454,
  -2886,
  -2315,
  -1741,
  -1164,
  -584,
  -1
}; // weak
int row_mask_63784[25] =
{
  16843009,
  269488144,
  286331153,
  1145324612,
  1431655765,
  -1431655766,
  196611,
  50332416,
  50529027,
  808464432,
  858993459,
  -858993460,
  15,
  983040,
  983055,
  251662080,
  252645135,
  -252645136,
  -2139062144,
  134744072,
  -2004318072,
  572662306,
  -1431655766,
  1431655765,
  12583104
}; // weak
_UNKNOWN unk_515744; // weak
_DWORD sRGB_xy[8] = { 64000, 33000, 30000, 60000, 15000, 6000, 31270, 32900 }; // weak
_UNKNOWN static_bl_desc; // weak
void *static_d_desc = &static_dtree; // weak
_UNKNOWN static_dtree; // weak
void *static_l_desc = &static_ltree; // weak
_UNKNOWN static_ltree; // weak
char *z_errmsg[2] = { "need dictionary", "stream end" }; // weak
_UNKNOWN __EH_FRAME_BEGIN__; // weak
int _bss_start__; // weak
int managedapp; // weak
char **envp; // idb
char **argv; // idb
int argc; // idb
_UNKNOWN obj; // weak
void *g_serial; // idb
int g_jsonmode; // weak
int operation; // weak
int button_data; // weak
char *device; // idb
char device_admin[128]; // idb
char device_user[128]; // idb
int updatemode; // weak
char *filename; // idb
int program_name; // weak
int runafterdownload; // weak
int stopProgram; // weak
int downloadSlotSet; // weak
int runSysinfoJson; // weak
int runMedic; // weak
int runFirmwareUp; // weak
int runPython; // weak
int runDfu; // weak
int runUsb; // weak
char *dfuTarget; // idb
int timershow; // weak
int progressshow; // weak
int isSecure; // weak
int userProgCtlData; // weak
int disableCompress; // weak
char *new_teamnumber; // idb
char *new_robotname; // idb
char program_description; // idb
char byte_52023F; // weak
HANDLE parentProcessHandle; // idb
int globalStatus[]; // weak
int dword_520264; // weak
int dword_520268; // weak
int dword_52026C; // weak
int dword_520270; // weak
int dword_520274; // weak
int dword_520278; // weak
int dword_52027C; // weak
int dword_520280; // weak
int dword_520284; // weak
int dword_520288; // weak
int dword_52028C; // weak
int dword_520290; // weak
int dword_520294; // weak
int dword_520298; // weak
__int16 word_52029C; // weak
int dword_5202A0; // weak
char byte_5202A4; // weak
char byte_5202A5; // weak
char byte_5202A6; // weak
char byte_5202A7; // weak
char byte_5202A8; // weak
_UNKNOWN unk_5202AC; // weak
_UNKNOWN unk_5202AD; // weak
_UNKNOWN unk_5202AE; // weak
_UNKNOWN unk_5202B0; // weak
_DWORD dword_5202B4[103]; // weak
_UNKNOWN unk_520450; // weak
_UNKNOWN unk_520474; // weak
_DWORD dword_520478[277]; // weak
_UNKNOWN unk_5208CC; // weak
_UNKNOWN unk_5208D0; // weak
_UNKNOWN unk_5208D4; // weak
_DWORD dword_5208D8[213]; // weak
char byte_520C2C[32]; // weak
char byte_520C4C[52]; // weak
char str1_6662[32]; // idb
char str2_6663[32]; // weak
char str1_6667[32]; // idb
int timestart_6678; // weak
int dword_520CE4; // weak
int timeend_6679; // weak
int dword_520CEC; // weak
char lookup_6695[]; // weak
char transfer_action[64]; // idb
char transfer_phase[64]; // idb
int dot_6640; // weak
int last_pct_6641; // weak
int last_pct_6649; // weak
char buffer_6630[4096]; // weak
char final_6639[4096]; // idb
char transferParams; // weak
char byte_522EA1; // weak
char byte_522EA2; // weak
int dword_522EA4; // weak
char bVerboseComms; // weak
int cdc2Target; // weak
int cdc2ExtCmd; // weak
int cdc2ExtCmdLast; // weak
int str_6644; // weak
char byte_522EBC; // weak
FILE *fp; // idb
_UNKNOWN buf; // weak
int nLeft; // weak
_UNKNOWN inflateHeap; // weak
int heapPtr; // weak
_DWORD buffer[512]; // weak
char str_6656[32]; // idb
char dl_curl; // weak
int (__cdecl *curl_global_init)(_DWORD); // weak
int (*curl_global_cleanup)(void); // weak
int (*curl_easy_init)(void); // weak
int (__cdecl *curl_easy_setopt)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *curl_easy_perform)(_DWORD); // weak
int (__cdecl *curl_easy_cleanup)(_DWORD); // weak
int (__cdecl *curl_easy_strerror)(_DWORD); // weak
int _crc32_table[256]; // weak
char _table32Generated; // weak
__int16 _crc16_table[256]; // weak
char _table16Generated; // weak
char _bitrev_table[256]; // weak
int radio_dfu; // weak
int dword_535EB0; // weak
int dword_535ED0; // weak
char dword_535ED4[]; // idb
unsigned __int8 byte_535EFD[259]; // weak
int dword_536000; // weak
char bFullRadioProgram; // weak
char header[156]; // idb
char byte_53613C; // weak
char byte_5361A1[255]; // idb
char str1_6646[16]; // idb
char str1_6651[16]; // idb
char dscbufr_6671[512]; // idb
char str_6713[32]; // idb
_DWORD zipdata[3]; // weak
int dword_5364EC; // weak
char *FileName; // idb
size_t Size; // idb
size_t dword_536504; // idb
_DWORD zipdata_0[3]; // weak
int dword_53652C; // weak
int dword_536530; // idb
size_t dword_536540; // idb
size_t dword_536544; // idb
int global_error; // weak
int dword_536564; // weak
char version_5279[16]; // idb
int (__stdcall *HidD_GetHidGuid)(_DWORD); // weak
int (__stdcall *HidD_GetAttributes)(_DWORD, _DWORD); // weak
int (__stdcall *HidD_GetSerialNumberString)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *HidD_GetManufacturerString)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *HidD_GetProductString)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *HidD_SetFeature)(_DWORD, _DWORD, _DWORD); // weak
int HidD_GetFeature; // weak
int HidD_GetInputReport; // weak
int (__stdcall *HidD_GetIndexedString)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *HidD_GetPreparsedData)(_DWORD, _DWORD); // weak
int (__stdcall *HidD_FreePreparsedData)(_DWORD); // weak
int (__stdcall *HidP_GetCaps)(_DWORD, _DWORD); // weak
int (__stdcall *HidD_SetNumInputBuffers)(_DWORD, _DWORD); // weak
int (__stdcall *CM_Locate_DevNodeW)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *CM_Get_Parent)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *CM_Get_DevNode_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *CM_Get_Device_Interface_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *CM_Get_Device_Interface_List_SizeW)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *CM_Get_Device_Interface_ListW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
HMODULE hid_lib_handle; // idb
HMODULE cfgmgr32_lib_handle; // idb
char hidapi_initialized; // weak
int handle; // idb
char dfuTransferSize[]; // idb
char cmd_7145; // weak
char byte_536601; // weak
__int16 word_536602; // weak
_UNKNOWN unk_536604; // weak
int (__stdcall *usb)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *libusb_exit)(_DWORD, _DWORD); // weak
int (__stdcall *libusb_open_device_with_vid_pid)(_DWORD); // weak
int (__stdcall *libusb_get_device)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *libusb_get_config_descriptor)(_DWORD); // weak
int (__stdcall *libusb_set_configuration)(_DWORD, _DWORD); // weak
int (__stdcall *libusb_claim_interface)(_DWORD, _DWORD); // weak
int (__stdcall *libusb_close)(_DWORD); // weak
int (__cdecl *libusb_control_transfer)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int libusb_set_option; // weak
int (__stdcall *libusb_get_device_list)(_DWORD, _DWORD); // weak
int (__stdcall *libusb_free_device_list)(_DWORD); // weak
int (__stdcall *libusb_get_device_descriptor)(_DWORD, _DWORD); // weak
void *_pthread_key_dest; // idb
int dummy_concurrency_level; // weak
int once_obj; // weak
int print_state; // weak
PVOID SetThreadName_VEH_handle; // idb
int idListNextId; // weak
int idListMax; // weak
int idListCnt; // weak
void *idList; // idb
int pthr_last; // weak
int pthr_root; // weak
int _pthread_key_sch; // weak
int _pthread_key_max; // weak
int _pthread_tls_once; // weak
int _pthread_concur; // weak
int _pthread_cancelling; // weak
int print_state_0; // weak
FILE *fo; // idb
int print_state_1; // weak
int bss_1; // weak
int mingw_initcharmax; // weak
int dword_536B4C; // weak
int dword_536B58; // weak
int dword_536B64; // weak
int GS_ExceptionRecord; // weak
int dword_536D84; // weak
int dword_536D8C; // weak
int _newmode; // weak
int mingw_initltssuo_force; // weak
int mingw_initltsdyn_force; // weak
int mingw_initltsdrot_force; // weak
int (__cdecl *stUserMathErr)(_DWORD); // weak
int mingw_app_type; // weak
int was_init_67496; // weak
int maxSections; // weak
int the_secs; // weak
int _fmode;
int (__stdcall *__mingw_oldexcpt_handler)(_DWORD); // weak
void *key_dtor_list; // idb
int __mingwthr_cs_init; // weak
struct _RTL_CRITICAL_SECTION __mingwthr_cs; // idb
void *retfail_4182; // idb
int p5s; // weak
_UNKNOWN private_mem; // weak
int freelist[10]; // weak
int dtoa_CS_init; // weak
struct _RTL_CRITICAL_SECTION dtoa_CritSec; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int bss_2; // weak
HMODULE hmod_libgcc; // idb
__int64 factory_data; // weak
_UNKNOWN PartitionHeader; // weak
_UNKNOWN unk_53780C; // weak
_UNKNOWN unk_537814; // weak
_UNKNOWN unk_537818; // weak
_DWORD dword_537820[216]; // weak
void *zipdata_1; // idb
int dword_537B84; // idb
char dword_537B94[]; // idb
char dword_537B98[]; // idb
char *optarg; // idb
int __mingw_optreset; // weak
char __hexdig_D2A[48]; // weak
char byte_537BF0; // weak
// extern BOOL (__stdcall *CancelIo)(HANDLE hFile);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateSemaphoreA)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern DWORD (__stdcall *FormatMessageW)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern BOOL (__stdcall *GetCommState)(HANDLE hFile, LPDCB lpDCB);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *GetHandleInformation)(HANDLE hObject, LPDWORD lpdwFlags);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *GetOverlappedResult)(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *GetProcessAffinityMask)(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// extern BOOL (__stdcall *GetProcessTimes)(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern BOOL (__stdcall *GetSystemTimeAdjustment)(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern UINT (__stdcall *GetTempFileNameA)(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
// extern DWORD (__stdcall *GetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *GetThreadContext)(HANDLE hThread, LPCONTEXT lpContext);
// extern int (__stdcall *GetThreadPriority)(HANDLE hThread);
// extern BOOL (__stdcall *GetThreadTimes)(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern void (__stdcall *OutputDebugStringA)(LPCSTR lpOutputString);
// extern BOOL (__stdcall *PurgeComm)(HANDLE hFile, DWORD dwFlags);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOL (__stdcall *QueryPerformanceFrequency)(LARGE_INTEGER *lpFrequency);
// extern void (__stdcall *RaiseException)(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern ULONG (__stdcall *RemoveVectoredExceptionHandler)(PVOID Handle);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern DWORD (__stdcall *ResumeThread)(HANDLE hThread);
// extern BOOL (__stdcall *SetCommMask)(HANDLE hFile, DWORD dwEvtMask);
// extern BOOL (__stdcall *SetCommState)(HANDLE hFile, LPDCB lpDCB);
// extern BOOL (__stdcall *SetCommTimeouts)(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
// extern BOOL (__stdcall *SetConsoleMode)(HANDLE hConsoleHandle, DWORD dwMode);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern BOOL (__stdcall *SetNamedPipeHandleState)(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);
// extern BOOL (__stdcall *SetProcessAffinityMask)(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask);
// extern BOOL (__stdcall *SetSystemTime)(const SYSTEMTIME *lpSystemTime);
// extern BOOL (__stdcall *SetThreadContext)(HANDLE hThread, const CONTEXT *lpContext);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *SetupComm)(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *SuspendThread)(HANDLE hThread);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern DWORD (__stdcall *TlsAlloc)();
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern BOOL (__stdcall *TryEnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern uintptr_t (__cdecl *__beginthreadex)(void *Security, unsigned int StackSize, _beginthreadex_proc_type StartAddress, void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// extern int (__cdecl *__close)(int FileHandle);
// extern void (__cdecl *__endthreadex)(unsigned int ReturnCode);
// extern int *(__cdecl *__errno)();
// extern FILE *(__cdecl *__fdopen)(int FileHandle, const char *Mode);
// extern int (__cdecl *__getch)();
// extern FILE __iob[];
// extern int (__cdecl *__kbhit)();
// extern char *(__cdecl *__ultoa)(unsigned int Value, char *Buffer, int Radix);
// extern int (__cdecl *__vsnwprintf)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args);
// extern wchar_t *(__cdecl *__wcsdup)(const wchar_t *String);
// extern int (__cdecl *_isupper)(int C);
// extern int (__cdecl *_tolower)(int C);
// extern BOOL (__stdcall *SetupDiEnumDeviceInfo)(HDEVINFO DeviceInfoSet, DWORD MemberIndex, PSP_DEVINFO_DATA DeviceInfoData);
// extern HDEVINFO (__stdcall *SetupDiGetClassDevsA)(const GUID *ClassGuid, PCSTR Enumerator, HWND hwndParent, DWORD Flags);
// extern BOOL (__stdcall *SetupDiGetDeviceRegistryPropertyA)(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, PBYTE PropertyBuffer, DWORD PropertyBufferSize, PDWORD RequiredSize);
int (__stdcall *__xl_f)(int, int, int) = &__dyn_tls_pthread; // weak


//----- (00401010) --------------------------------------------------------
int pre_c_init()
{
  BOOL v0; // eax
  __int16 v2; // dx

  v0 = 0;
  mingw_initltsdrot_force = 1;
  mingw_initltsdyn_force = 1;
  mingw_initltssuo_force = 1;
  mingw_initcharmax = 1;
  if ( MEMORY[0x400000] == 23117 && *(_DWORD *)(MEMORY[0x40003C] + 0x400000) == 17744 )
  {
    v2 = *(_WORD *)(MEMORY[0x40003C] + 4194328);
    if ( v2 == 267 )
    {
      if ( *(_DWORD *)(MEMORY[0x40003C] + 4194420) > 0xEu )
        v0 = *(_DWORD *)(MEMORY[0x40003C] + 4194536) != 0;
    }
    else if ( v2 == 523 && *(_DWORD *)(MEMORY[0x40003C] + 4194436) > 0xEu )
    {
      v0 = *(_DWORD *)(MEMORY[0x40003C] + 4194552) != 0;
    }
  }
  managedapp = v0;
  if ( mingw_app_type )
    __set_app_type(_crt_gui_app);
  else
    __set_app_type(_crt_console_app);
  *__p__fmode() = _fmode;
  _setargv();
  if ( _MINGW_INSTALL_DEBUG_MATHERR == 1 )
    __mingw_setusermatherr(_matherr);
  return 0;
}
// 50CF88: using guessed type int _MINGW_INSTALL_DEBUG_MATHERR;
// 520008: using guessed type int managedapp;
// 536A90: using guessed type int mingw_initcharmax;
// 536DE4: using guessed type int mingw_initltssuo_force;
// 536DE8: using guessed type int mingw_initltsdyn_force;
// 536DEC: using guessed type int mingw_initltsdrot_force;
// 536DF8: using guessed type int mingw_app_type;

//----- (00401110) --------------------------------------------------------
int pre_cpp_init()
{
  _bss_start__ = _newmode;
  return __getmainargs(&argc, &argv, &envp, _dowildcard, &_bss_start__);
}
// 424ED0: using guessed type int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 50CF48: using guessed type int _dowildcard;
// 520000: using guessed type int _bss_start__;
// 536DE0: using guessed type int _newmode;

//----- (00401480) --------------------------------------------------------
int __cdecl WinMainCRTStartup(char a1)
{
  mingw_app_type = 1;
  __security_init_cookie();
  return __tmainCRTStartup(a1);
}
// 401150: using guessed type _DWORD __cdecl __tmainCRTStartup(char);
// 536DF8: using guessed type int mingw_app_type;

//----- (004014C0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *Func)())
{
  return -(_onexit((_onexit_t)Func) == 0);
}

//----- (004014E0) --------------------------------------------------------
int __gcc_register_frame()
{
  HMODULE ModuleHandleA; // eax
  HMODULE v1; // ebx
  FARPROC __register_frame_info; // esi

  ModuleHandleA = GetModuleHandleA("libgcc_s_dw2-1.dll");
  if ( ModuleHandleA )
  {
    v1 = ModuleHandleA;
    hmod_libgcc = LoadLibraryA("libgcc_s_dw2-1.dll");
    __register_frame_info = GetProcAddress(v1, "__register_frame_info");
    deregister_frame_fn = (int (__cdecl *)(_DWORD))GetProcAddress(v1, "__deregister_frame_info");
  }
  else
  {
    deregister_frame_fn = 0;
    __register_frame_info = 0;
  }
  if ( __register_frame_info )
    ((void (__cdecl *)(void *, void *))__register_frame_info)(&__EH_FRAME_BEGIN__, &obj);
  return atexit(__gcc_deregister_frame);
}
// 446004: using guessed type int (__cdecl *deregister_frame_fn)(_DWORD);

//----- (00401590) --------------------------------------------------------
void __cdecl __gcc_deregister_frame()
{
  if ( deregister_frame_fn )
    deregister_frame_fn(&__EH_FRAME_BEGIN__);
  if ( hmod_libgcc )
    FreeLibrary(hmod_libgcc);
}
// 446004: using guessed type int (__cdecl *deregister_frame_fn)(_DWORD);

//----- (004015C0) --------------------------------------------------------
int __cdecl show_help(const char *a1)
{
  int v1; // edi
  int v2; // esi
  int v3; // ebx
  char *v4; // eax

  v1 = _python_vm_exp_version;
  v2 = _python_vm_iq2_version;
  v3 = _python_vm_version;
  v4 = systemVersionString();
  return vexerr(
           255,
           "%sV%s\n"
           "usage: %s [option(s)] [serial_port]\n"
           "       -v --verbose       verbose mode\n"
           "          --quiet         disable all program stdio output\n"
           "       -d --directory     show user directory\n"
           "       -p --programs      show programs\n"
           "       -w --write file    Write file to brain\n"
           "       -r --read file     Read file from brain into file\n"
           "       -g --run           Run program after download\n"
           "       -x --stop          Stop program\n"
           "       -s --slot n        slot number (1-8)\n"
           "       -l --load          Load and Run program\n"
           "       -e --erase file    Erase file on brain\n"
           "       -e --erase n       Erase program in slot n on brain\n"
           "          --python        Upload python vm to brain\n"
           "                          V5  python vm version (0x%08X)\n"
           "                          IQ2 python vm version (0x%08X)\n"
           "                          EXP python vm version (0x%08X)\n"
           "          --json          system info in json format\n"
           "          --screen file   screen capture\n"
           "          --eventlog      read event log from brain\n"
           "          --timer         show transfer timer\n"
           "          --progress      show transfer progress\n"
           "          --chan n        set radio channel 0=pit, 1=download\n"
           "          --icon n        set program icon number\n"
           "          --medic         run battery medic\n"
           "          --vexos file    update brain using vexos file\n"
           "          --vexos latest  update brain using latest from server\n"
           "          --team id       set team number\n"
           "          --robot id      set robot name\n"
           "          --ctrl-fw file  update iq2/exp controller using vexos file\n"
           "          --atmel-fw file update iq2/exp controller Atmel using vexos file\n"
           "          --dfu=iq2       load IQ2 RAM bootloader when in dfu mode\n"
           "          --dfu=exp       load EXP RAM bootloader when in dfu mode\n"
           "          --nocompress    disable program compression for V5/EXP\n"
           "          --vexos-full    full vexos update, allow reinstallation\n"
           "\n"
           "Examples: (serial_port is optional, %s will try and auto detect the port)\n"
           "\n"
           "  Write file to slot 2 in brain\n"
           "  %s --slot 2 --write filename COM7\n"
           "\n"
           "  Show directory\n"
           "  %s --directory COM7\n"
           "\n",
           banner,
           v4,
           a1,
           v3,
           v2,
           v1,
           a1,
           a1,
           a1);
}
// 44C420: using guessed type int _python_vm_version;
// 478390: using guessed type int _python_vm_iq2_version;
// 4ACF80: using guessed type int _python_vm_exp_version;

//----- (00401633) --------------------------------------------------------
void __cdecl __noreturn show_version(const char *a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( g_jsonmode )
  {
    v2 = systemVersionString();
    appVersionJson(a1, v2, "Mar  6 2023", "10:40:25");
  }
  else
  {
    v1 = systemVersionString();
    vexlog(2, "%s: version %s [%s %s]\n", a1, v1, "Mar  6 2023", "10:40:25");
  }
  exit(0);
}
// 520044: using guessed type int g_jsonmode;

//----- (004016A8) --------------------------------------------------------
int __cdecl parse_options(int a1, char **a2)
{
  char *v2; // eax
  int v3; // eax
  bool v4; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  bool v13; // al
  int v14; // eax
  int v15; // eax
  bool v16; // al
  int v17; // eax
  bool v18; // al
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  int v23; // [esp+2Ch] [ebp-1Ch] BYREF
  size_t v24; // [esp+30h] [ebp-18h]
  char *Source; // [esp+34h] [ebp-14h]
  char v26; // [esp+3Bh] [ebp-Dh]
  int i; // [esp+3Ch] [ebp-Ch]

  v23 = 0;
  v26 = 0;
  if ( a1 <= 1 )
  {
    v2 = basename(*a2);
    show_help(v2);
    exit(0);
  }
  while ( 1 )
  {
    i = getopt_long(a1, (int)a2, "hvdpgxw:r:n:e::s:l:c:i:", (const char **)&long_options_6703, &v23);
    if ( i == -1 )
      break;
    if ( i == 700 )
    {
      v5 = updatemode;
      BYTE1(v5) = BYTE1(updatemode) | 1;
      updatemode = v5;
      progressshow = 1;
    }
    else if ( i > 700 )
    {
      if ( i == 708 )
      {
        operation |= 0x80000u;
        if ( filename )
          goto LABEL_74;
        filename = optarg;
      }
      else if ( i > 708 )
      {
        if ( i == 712 )
        {
          runUsb = 1;
          if ( optarg || a1 <= optind || *a2[optind] == 45 )
          {
            v13 = optarg != 0;
          }
          else
          {
            v12 = optind++;
            optarg = a2[v12];
            v13 = optarg != 0;
          }
          if ( v13 && !strcmp(optarg, "dfu") )
            runUsb = 2;
        }
        else if ( i > 712 )
        {
          if ( i == 714 )
          {
            disableCompress = 1;
          }
          else if ( i < 714 )
          {
            if ( strchr(optarg, 32) || (strlen(optarg) & 3) != 0 || (Source = (char *)decodeBase64(optarg)) == 0 )
            {
              strncpy(&program_description, optarg, 0x80u);
              byte_52023F = 0;
            }
            else
            {
              strncpy(&program_description, Source, 0x80u);
              free(Source);
            }
          }
          else if ( i == 715 )
          {
            v14 = operation;
            BYTE1(v14) = BYTE1(operation) | 1;
            operation = v14;
          }
          else if ( i == 716 )
          {
            operation |= 0x800000u;
            if ( optarg || a1 <= optind || *a2[optind] == 45 )
            {
              v16 = optarg != 0;
            }
            else
            {
              v15 = optind++;
              optarg = a2[v15];
              v16 = optarg != 0;
            }
            if ( v16 )
            {
              log_count = strtol(optarg, 0, 0);
              v24 = strlen(optarg);
              if ( v24 )
              {
                if ( (optarg[v24 - 1] == 114 || optarg[v24 - 1] == 45) && log_count > 0 )
                  log_count = -log_count;
              }
            }
          }
        }
        else if ( i == 710 )
        {
          operation = 128;
          if ( filename )
            vexerr(255, "Error: Screen capture and other options are not supported simultaneously\n");
          else
            filename = optarg;
        }
        else if ( i > 710 )
        {
          v11 = operation;
          BYTE1(v11) = BYTE1(operation) | 0x10;
          operation = v11;
          runSysinfoJson = 1;
        }
        else
        {
          runDfu = 1;
          dfuTarget = optarg;
        }
      }
      else if ( i == 704 )
      {
        v9 = operation;
        BYTE1(v9) = BYTE1(operation) | 0x40;
        operation = v9;
        new_robotname = optarg;
      }
      else if ( i > 704 )
      {
        if ( i == 706 )
        {
          v26 = 1;
        }
        else if ( i > 706 )
        {
          operation |= 0x40000u;
          if ( filename )
LABEL_74:
            vexerr(255, "Error: Firmware update and other options are not supported simultaneously\n");
          else
            filename = optarg;
        }
        else
        {
          v10 = strtol(optarg, 0, 0);
          vexlogLevel(v10);
        }
      }
      else if ( i == 702 )
      {
        updatemode |= 1u;
      }
      else if ( i > 702 )
      {
        v8 = operation;
        BYTE1(v8) = BYTE1(operation) | 0x20;
        operation = v8;
        new_teamnumber = optarg;
      }
      else
      {
        if ( !optarg )
          goto LABEL_62;
        if ( !strcmp(optarg, "latest") )
        {
          v6 = operation;
          BYTE1(v6) = BYTE1(operation) | 8;
          operation = v6;
        }
        else if ( !strcmp(optarg, "catalog") )
        {
          operation |= 0x100000u;
        }
        else
        {
LABEL_62:
          v7 = operation;
          BYTE1(v7) = BYTE1(operation) | 4;
          operation = v7;
          if ( filename )
            goto LABEL_74;
          filename = optarg;
        }
      }
    }
    else if ( i == 108 )
    {
      operation |= 0x40u;
      if ( !filename )
        filename = optarg;
    }
    else if ( i > 108 )
    {
      if ( i == 115 )
      {
        downloadSlot = strtol(optarg, 0, 0);
        downloadSlotSet = 1;
      }
      else if ( i > 115 )
      {
        if ( i == 119 )
        {
          operation |= 1u;
          if ( filename )
            vexerr(255, "Error: File write and other options are not supported simultaneously\n");
          else
            filename = optarg;
        }
        else if ( i > 119 )
        {
          if ( i == 120 )
          {
            operation |= 0x40u;
            if ( !filename )
              filename = stopfile;
            stopProgram = 1;
          }
          else if ( i == 600 )
          {
            runPython = 1;
            if ( optarg || a1 <= optind || *a2[optind] == 45 )
            {
              v4 = optarg != 0;
            }
            else
            {
              v3 = optind++;
              optarg = a2[v3];
              v4 = optarg != 0;
            }
            if ( v4 )
              filename = optarg;
          }
        }
        else if ( i == 118 )
        {
          g_quietmode = 0;
        }
      }
      else
      {
        switch ( i )
        {
          case 'p':
            operation |= 0x200000u;
            break;
          case 'r':
            operation |= 8u;
            if ( filename )
              vexerr(255, "File read and write not supported simultaneously\n");
            else
              filename = optarg;
            break;
          case 'n':
            program_name = (int)optarg;
            break;
        }
      }
    }
    else if ( i == 101 )
    {
      operation |= 0x10u;
      if ( optarg || a1 <= optind || *a2[optind] == 45 )
      {
        v18 = optarg != 0;
      }
      else
      {
        v17 = optind++;
        optarg = a2[v17];
        v18 = optarg != 0;
      }
      if ( v18 && !filename )
        filename = optarg;
    }
    else if ( i > 101 )
    {
      switch ( i )
      {
        case 'h':
          v19 = basename(*a2);
          show_help(v19);
          exit(0);
        case 'i':
          customIcon = strtol(optarg, 0, 0);
          break;
        case 'g':
          operation |= 0x40u;
          runafterdownload = 1;
          break;
      }
    }
    else if ( i == 99 )
    {
      if ( !strcmp(optarg, "download") )
      {
        channelType = 1;
      }
      else if ( !strcmp(optarg, "pit") )
      {
        channelType = 0;
      }
      else
      {
        channelType = strtol(optarg, 0, 0);
      }
    }
    else if ( i > 99 )
    {
      operation |= 2u;
    }
  }
  if ( runSysinfoJson && (operation || runPython || v26) )
  {
    runSysinfoJson = 0;
    g_jsonmode = 1;
  }
  if ( v26 )
  {
    v20 = basename(*a2);
    show_version(v20);
  }
  if ( runDfu )
  {
    if ( !strcmp(dfuTarget, "iq2") )
    {
      iq2_ram_bootloader(0, 0);
    }
    else if ( !strcmp(dfuTarget, "exp") )
    {
      exp_ram_bootloader(0, 0);
    }
    exit(0);
  }
  if ( runUsb )
  {
    usb_detect(runUsb == 2);
    exit(0);
  }
  for ( i = optind; i < a1; ++i )
  {
    if ( device )
    {
      vexerr(255, "Error: Invalid parameter specified\n");
      v21 = basename(*a2);
      show_help(v21);
      return 7;
    }
    device = a2[i];
  }
  if ( !device )
  {
    memset(device_admin, 0, sizeof(device_admin));
    memset(device_user, 0, sizeof(device_user));
    if ( serialFindPorts(device_admin, device_user) > 0 )
    {
      if ( !g_jsonmode && !runSysinfoJson && g_quietmode <= 1 )
        vexlog(2, "Device: %s\n", device_admin);
      device = device_admin;
    }
  }
  if ( device || (operation & 0x88000) != 0 )
    return 0;
  vexerr(255, "Error: Device not specified or not found\n");
  return 5;
}
// 44BF70: using guessed type int g_quietmode;
// 44BF80: using guessed type int channelType;
// 44BF84: using guessed type int customIcon;
// 44BF88: using guessed type int log_count;
// 44BFA0: using guessed type char *long_options_6703;
// 50CF80: using guessed type int optind;
// 520044: using guessed type int g_jsonmode;
// 520048: using guessed type int operation;
// 520160: using guessed type int updatemode;
// 520168: using guessed type int program_name;
// 52016C: using guessed type int runafterdownload;
// 520170: using guessed type int stopProgram;
// 520174: using guessed type int downloadSlotSet;
// 520178: using guessed type int runSysinfoJson;
// 520184: using guessed type int runPython;
// 52018C: using guessed type int runDfu;
// 520190: using guessed type int runUsb;
// 52019C: using guessed type int progressshow;
// 5201AC: using guessed type int disableCompress;
// 52023F: using guessed type char byte_52023F;

//----- (004022C6) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  const char *v13; // esi
  int v14; // ebx
  char *v15; // eax
  unsigned __int8 v16; // cl
  bool v17; // bl
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  int v21; // ebx
  char *v22; // eax
  char Buffer[133]; // [esp+3Bh] [ebp-10Dh] BYREF
  int v24; // [esp+C0h] [ebp-88h] BYREF
  int v25; // [esp+C4h] [ebp-84h] BYREF
  char Str[2]; // [esp+CAh] [ebp-7Eh] BYREF
  int v27; // [esp+CCh] [ebp-7Ch] BYREF
  int v28; // [esp+D0h] [ebp-78h] BYREF
  char *v29; // [esp+D4h] [ebp-74h] BYREF
  _BYTE v30[15]; // [esp+D9h] [ebp-6Fh] BYREF
  int v31[3]; // [esp+E8h] [ebp-60h] BYREF
  int Version; // [esp+F4h] [ebp-54h]
  int Catalog; // [esp+F8h] [ebp-50h]
  FILE *v34; // [esp+FCh] [ebp-4Ch]
  int v35; // [esp+100h] [ebp-48h]
  int v36; // [esp+104h] [ebp-44h]
  int v37; // [esp+108h] [ebp-40h]
  char *ini_file; // [esp+10Ch] [ebp-3Ch]
  char *v39; // [esp+110h] [ebp-38h]
  __int16 v40; // [esp+115h] [ebp-33h]
  char v41; // [esp+117h] [ebp-31h]
  int v42; // [esp+118h] [ebp-30h]
  void (__cdecl *v43)(int, int); // [esp+11Ch] [ebp-2Ch]
  void (__cdecl *v44)(size_t, int); // [esp+120h] [ebp-28h]
  int v45; // [esp+124h] [ebp-24h]
  char v46; // [esp+12Ah] [ebp-1Eh]
  char v47; // [esp+12Bh] [ebp-1Dh]
  int file; // [esp+12Ch] [ebp-1Ch]
  const char *v49; // [esp+130h] [ebp-18h]
  const char *v50; // [esp+134h] [ebp-14h]
  int i; // [esp+138h] [ebp-10h]
  int v52; // [esp+13Ch] [ebp-Ch]

  __main();
  vexLoggerInit();
  v52 = parse_options(argc, (char **)argv);
  if ( v52 )
    return v52;
  if ( g_quietmode == 2 )
    vexlogLevel(-1);
  if ( !g_jsonmode && !runSysinfoJson )
  {
    v4 = systemVersionString();
    vexlog(2, "%sV%s\n", banner, v4);
  }
  v5_TransferParameterSet(0, isSecure != 0, timershow != 0, 0);
  g_serial = serialOpen(device);
  if ( !g_serial && (operation & 0x88000) == 0 )
  {
    perror(device);
    return 6;
  }
  if ( g_serial )
  {
    if ( serialConfig((int)g_serial, 8, 3, 0, 0) )
    {
      perror(device);
      serialClose((char *)g_serial);
      return 6;
    }
    serialSleep(0x14u);
  }
  if ( !v5_SystemAlive(0) && (operation & 0xC8000) == 0 && !runSysinfoJson )
    return 2;
  if ( (operation & 0x80000) != 0 )
  {
    iq2_controller_atmel_update(filename);
    return 0;
  }
  if ( channelType != -1 && channelType <= 1 )
  {
    if ( !channelType )
      vexlog(4, "Channel: change to drive channel\n");
    if ( channelType == 1 )
      vexlog(4, "Channel: change to download channel\n");
    if ( v5_SetRadioChannel(channelType) )
      vexlog(4, "Change channel error\n");
  }
  if ( runSysinfoJson )
  {
    v5_GetSystemInfoJson(device_admin, device_user);
    return 0;
  }
  if ( (operation & 0x8000) != 0 )
    return 0;
  if ( (operation & 0x40000) != 0 )
  {
    result = iq2_controller_update(filename, progressshow != 0);
    v52 = result;
    return result;
  }
  if ( (operation & 0x20000000) != 0 )
  {
    v5_FactorySpecial((unsigned __int8)button_data, 90, button_data, 1, 0, 0);
    serialSleep(0xFAu);
    return 0;
  }
  if ( (operation & 0x40000000) != 0 )
  {
    for ( i = 0; i <= 4 && !BYTE4(factory_data); ++i )
      factory_data <<= 8;
    v42 = *(_DWORD *)((char *)&factory_data + 1);
    v41 = factory_data;
    vexlog(
      3,
      "Special: %02X %02X %02X %02X %02X\n",
      BYTE4(factory_data),
      BYTE3(factory_data),
      BYTE2(factory_data),
      BYTE1(factory_data),
      (unsigned __int8)factory_data);
    v5_FactorySpecial(HIBYTE(v42), SHIBYTE(v42), SBYTE2(v42), SBYTE1(v42), v42, v41);
    serialSleep(0xFAu);
    return 0;
  }
  else
  {
    if ( !v5_SystemVersion(v31) )
      return 3;
    if ( (operation & 0x800000) != 0 )
    {
      result = read_log(log_count, g_jsonmode != 0, progressshow != 0);
      v52 = result;
      return result;
    }
    if ( (operation & 0x1000000) != 0 )
    {
      sprintf(Buffer, "slot_%d.ini", downloadSlot);
      result = v5_AutorunFlagSet((int)Buffer, 1u, Buffer, autorunValue);
      v52 = result;
      return result;
    }
    if ( (operation & 0x1000) != 0 )
    {
      if ( g_jsonmode )
      {
        v5_SystemStatusJson((int)v31, device_admin, device_user);
        return 0;
      }
      v5_SystemStatus((int)v30, (int)v30);
    }
    if ( (operation & 0x800) != 0 || (operation & 0x100000) != 0 )
    {
      v50 = 0;
      v49 = 0;
      if ( isV5ProductId((int)v31) )
      {
        v50 = "https://content.vexrobotics.com/vexos/public/V5/";
        v49 = "VEXOS_V5";
      }
      else if ( isIq2ProductId((int)v31) )
      {
        v50 = "https://content.vexrobotics.com/vexos/public/IQ2/";
        v49 = "VEXOS_IQ2";
      }
      else if ( isExpProductId((int)v31) )
      {
        v50 = "https://content.vexrobotics.com/vexos/public/EXP/";
        v49 = "VEXOS_EXP";
      }
      Catalog = v5_firmwareGetCatalog(v50);
      if ( (operation & 0x800) == 0 || Catalog == -1 )
      {
        if ( g_jsonmode )
        {
          v5_showCatalogJson((int)v31, Catalog);
        }
        else
        {
          v6 = vexosVersionToString(Catalog);
          vexlog(2, "catalog: %s\n", v6);
        }
        return 8;
      }
      else
      {
        v5 = vexosVersionToString(Catalog);
        vexlog(3, "vexos  : %s\n", v5);
        v29 = 0;
        Version = v5_firmwareGetVersion(v50, v49, Catalog, (void **)&v29);
        if ( Version && v29 )
        {
          v52 = v5_firmwareUpdate(
                  v29,
                  Version,
                  (unsigned __int8)updatemode,
                  (updatemode & 0x100) != 0,
                  (updatemode & 0x200) != 0);
          free(v29);
        }
        return v52;
      }
    }
    else if ( (operation & 0x400) != 0 )
    {
      v5_LoadAndRun(1u, "stop", 1);
      serialSleep(0x1F4u);
      v52 = v5_firmwareUpdate(
              filename,
              0,
              (unsigned __int8)updatemode,
              (updatemode & 0x100) != 0,
              (updatemode & 0x200) != 0);
      if ( isV5ProductId((int)v31) && (operation & 0x20000) != 0 )
      {
        v5_FactorySpecial(operation & 0x20000, 10, 1, 1, 0, 0);
        serialSleep(0x32u);
        v5_FactoryResetBrain(v7);
      }
      return v52;
    }
    else if ( (operation & 0x20000) != 0 )
    {
      v8 = v5_FactoryEnable(operation & 0x20000);
      if ( v8 )
      {
        v5_FactorySpecial(v8, 10, 1, 1, 0, 0);
        serialSleep(0x32u);
        v5_FactoryResetBrain(v9);
        return 0;
      }
      else
      {
        return 4;
      }
    }
    else if ( runMedic )
    {
      if ( isV5ProductId((int)v31) )
      {
        v5_LoadAndRun(1u, "stop", 1);
        serialSleep(0x1F4u);
        return v5_Download(1, "medic.bin", _medic_0_e, 10400, 1u, 5, 0);
      }
      return v52;
    }
    else if ( runFirmwareUp )
    {
      if ( isV5ProductId((int)v31) )
      {
        v5_LoadAndRun(1u, "stop", 1);
        serialSleep(0x1F4u);
        return v5_Download(1, "V5_Update.bin", _firmware_update_e, 13936, 1u, 5, 0);
      }
      return v52;
    }
    else
    {
      if ( runPython )
      {
        result = v5_DownloadPythonVm((int)v31, filename, timershow != 0, progressshow != 0);
        v52 = result;
        return result;
      }
      if ( (operation & 0x2000) != 0
        && new_teamnumber
        && v5_KVSave((int)new_teamnumber, "teamnumber", new_teamnumber) != 118 )
      {
        return 4;
      }
      if ( (operation & 0x4000) != 0
        && new_robotname
        && v5_KVSave((int)new_robotname, "robotname", new_robotname) != 118 )
      {
        return 4;
      }
      if ( (operation & 0x200) != 0 )
      {
        v40 = userProgCtlData;
        v5_UserProgramControl(BYTE1(userProgCtlData), SBYTE1(userProgCtlData), userProgCtlData, Buffer);
      }
      if ( (operation & 1) != 0 )
      {
        file = read_file(filename, (void **)&v28);
        vexlog(3, "Download: %s is %d bytes\n", filename, file);
        v47 = 0;
        v46 = 0;
        v39 = strrchr(filename, 46);
        if ( v39 && !strcmp(v39, ".py") )
        {
          v47 = 1;
          vexlog(3, "found python file\n");
        }
        if ( file > 0 )
        {
          v45 = -1;
          if ( customIcon <= 0 )
          {
            if ( isV5ProductId((int)v31) )
            {
              if ( v47 )
                v10 = 925;
              else
                v10 = 926;
              v45 = v10;
              v46 = 1;
            }
            else if ( isIq2ProductId((int)v31) )
            {
              if ( v47 )
                v11 = 932;
              else
                v11 = 930;
              v45 = v11;
            }
            else if ( isExpProductId((int)v31) )
            {
              if ( v47 )
                v12 = 925;
              else
                v12 = 926;
              v45 = v12;
              v46 = 1;
            }
          }
          else
          {
            v45 = customIcon;
          }
          if ( stopProgram )
          {
            v5_LoadAndRun(1u, "stop", 1);
            stopProgram = 0;
          }
          if ( program_description )
            v13 = &program_description;
          else
            v13 = 0;
          v14 = downloadSlot;
          if ( program_name )
            v15 = (char *)program_name;
          else
            v15 = basename(filename);
          ini_file = create_ini_file(v15, v14, v45, v13);
          v37 = strlen(ini_file);
          sprintf(Buffer, "slot_%d.ini", downloadSlot);
          v5_Download(1, Buffer, ini_file, v37, 0, 1, 0);
          sprintf(Buffer, "slot_%d.bin", downloadSlot);
          v5_TransferParameterSet(v47, isSecure != 0, timershow != 0, 1);
          v44 = 0;
          if ( progressshow )
          {
            v44 = (void (__cdecl *)(size_t, int))v5_FileTransferProgress;
            v5_FileTransferMetadata("download", "program", (char *)(progressshow != 0));
          }
          if ( disableCompress || isSecure )
            v46 = 0;
          if ( v46 )
          {
            v36 = v28;
            if ( *(_BYTE *)v28 != 31 && *(_BYTE *)(v36 + 1) != 0x8B )
            {
              v35 = gzip_compress_binary(v28, file, (void **)&v27);
              if ( v35 > 0 )
              {
                file = v35;
                v28 = v27;
              }
            }
          }
          if ( runafterdownload )
            v16 = 1;
          else
            v16 = 3;
          v5_Download(1, Buffer, (_BYTE *)v28, file, v16, 1, v44);
        }
      }
      else if ( (operation & 0x40) != 0 )
      {
        if ( filename )
        {
          v17 = stopProgram != 0;
          v18 = basename(filename);
          v5_LoadAndRun(1u, v18, v17);
        }
        else
        {
          v5_LoadAndRunSlot(1u, downloadSlot, stopProgram != 0);
        }
      }
      else if ( (operation & 0x80) != 0 )
      {
        if ( filename )
          v5_ScreenCapture(filename);
      }
      else if ( (operation & 0x100) != 0 )
      {
        if ( isV5ProductId((int)v31) )
          v5_ReadUserData();
        else
          vexerr(255, "Error: Only supported on V5\n");
      }
      else if ( (operation & 0x10) != 0 )
      {
        if ( filename )
        {
          v19 = basename(filename);
          v5_Erase(1u, v19);
        }
        else if ( downloadSlotSet )
        {
          Str[0] = downloadSlot + 48;
          Str[1] = 0;
          v5_Erase(1u, Str);
        }
      }
      else if ( (operation & 8) != 0 )
      {
        v25 = 0;
        v43 = 0;
        if ( progressshow )
        {
          v43 = (void (__cdecl *)(int, int))v5_FileTransferProgress;
          v5_FileTransferMetadata("upload", "file", (char *)(progressshow != 0));
        }
        v20 = basename(filename);
        v52 = v5_Upload(1, v20, (void **)&v25, &v24, 0, 1, v43);
        if ( v52 || v24 <= 0 )
          return v52;
        v21 = v24;
        v22 = basename(filename);
        vexlog(3, "File %s is %d bytes\n", v22, v21);
        v34 = fopen(filename, "wb");
        if ( v34 )
        {
          fwrite((const void *)v25, v24, 1u, v34);
          fclose(v34);
        }
        if ( v25 )
          free((void *)v25);
      }
      if ( (operation & 2) != 0 )
      {
        if ( g_jsonmode )
          v5_GetDirJson(1u);
        else
          v5_GetDir(1u);
      }
      if ( (operation & 0x200000) != 0 )
      {
        if ( g_jsonmode )
          v5_GetProgramsJson();
        else
          v5_GetPrograms();
      }
      serialClose((char *)g_serial);
      return 0;
    }
  }
}
// 402BDD: variable 'v7' is possibly undefined
// 402C47: variable 'v9' is possibly undefined
// 446040: using guessed type _BYTE _medic_0_e[10400];
// 448900: using guessed type _BYTE _firmware_update_e[13936];
// 44BF70: using guessed type int g_quietmode;
// 44BF80: using guessed type int channelType;
// 44BF84: using guessed type int customIcon;
// 44BF88: using guessed type int log_count;
// 44BF8C: using guessed type char autorunValue;
// 520044: using guessed type int g_jsonmode;
// 520048: using guessed type int operation;
// 52004C: using guessed type int button_data;
// 520160: using guessed type int updatemode;
// 520168: using guessed type int program_name;
// 52016C: using guessed type int runafterdownload;
// 520170: using guessed type int stopProgram;
// 520174: using guessed type int downloadSlotSet;
// 520178: using guessed type int runSysinfoJson;
// 52017C: using guessed type int runMedic;
// 520180: using guessed type int runFirmwareUp;
// 520184: using guessed type int runPython;
// 520198: using guessed type int timershow;
// 52019C: using guessed type int progressshow;
// 5201A0: using guessed type int isSecure;
// 5201A4: using guessed type int userProgCtlData;
// 5201AC: using guessed type int disableCompress;
// 5377F0: using guessed type __int64 factory_data;
// 4022C6: using guessed type char Str[2];

//----- (00403624) --------------------------------------------------------
int __cdecl getComPort(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v3; // edx
  _BYTE *v4; // eax
  int v5; // [esp+4h] [ebp-Ch]
  _BYTE *v8; // [esp+Ch] [ebp-4h]

  v5 = 0;
  while ( *a1 && *a1 != 40 )
    ++a1;
  if ( !*a1 )
    return 0;
  v8 = a1 + 1;
  while ( *v8 && *v8 != 41 )
  {
    v3 = v8++;
    v4 = a2++;
    *v4 = *v3;
    ++v5;
  }
  if ( !*v8 )
    return 0;
  *a2 = 0;
  return v5;
}

//----- (004036B9) --------------------------------------------------------
int __cdecl enumerateSerialPortsFriendlyNames(_BYTE *a1, char a2)
{
  unsigned int i; // eax
  int result; // eax
  DWORD v4; // ecx
  int v5; // eax
  void *v6; // esp
  void *v7; // esp
  DWORD v8; // ecx
  int v9; // eax
  void *v10; // esp
  void *v11; // esp
  DWORD v12; // edx
  DWORD v13; // eax
  BYTE v14[16]; // [esp+1Ch] [ebp-8Ch] BYREF
  char v15; // [esp+2Ch] [ebp-7Ch]
  DWORD RequiredSize; // [esp+38h] [ebp-70h] BYREF
  DWORD PropertyRegDataType; // [esp+3Ch] [ebp-6Ch] BYREF
  struct _SP_DEVINFO_DATA DeviceInfoData; // [esp+40h] [ebp-68h] BYREF
  int v19; // [esp+5Ch] [ebp-4Ch]
  int v20; // [esp+60h] [ebp-48h]
  int v21; // [esp+64h] [ebp-44h]
  int v22; // [esp+68h] [ebp-40h]
  int v23; // [esp+6Ch] [ebp-3Ch]
  int v24; // [esp+70h] [ebp-38h]
  int v25; // [esp+74h] [ebp-34h]
  PBYTE v26; // [esp+78h] [ebp-30h]
  DWORD v27; // [esp+7Ch] [ebp-2Ch]
  PBYTE PropertyBuffer; // [esp+80h] [ebp-28h]
  DWORD v29; // [esp+84h] [ebp-24h]
  HDEVINFO DeviceInfoSet; // [esp+88h] [ebp-20h]
  DWORD MemberIndex; // [esp+8Ch] [ebp-1Ch]

  v15 = a2;
  for ( i = 0; i < 0x1C; i += 4 )
    *(DWORD *)((char *)&DeviceInfoData.cbSize + i) = 0;
  DeviceInfoData.cbSize = 28;
  DeviceInfoSet = SetupDiGetClassDevsA(&GUID_DEVCLASS_PORTS, 0, 0, 2u);
  if ( DeviceInfoSet == (HDEVINFO)-1 )
    return -1;
  MemberIndex = 0;
  while ( 1 )
  {
    v13 = MemberIndex++;
    if ( !SetupDiEnumDeviceInfo(DeviceInfoSet, v13, &DeviceInfoData) )
      break;
    RequiredSize = 0;
    SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, &DeviceInfoData, 1u, 0, 0, 0, &RequiredSize);
    v4 = 1;
    if ( RequiredSize )
      v4 = RequiredSize;
    v29 = v4 - 1;
    v5 = 16 * ((v4 + 15) / 0x10);
    v6 = alloca(v5);
    v7 = alloca(v5);
    PropertyBuffer = v14;
    if ( SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, &DeviceInfoData, 1u, &PropertyRegDataType, v14, v4, 0) )
    {
      RequiredSize = 0;
      SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, &DeviceInfoData, 0xCu, 0, 0, 0, &RequiredSize);
      v8 = 1;
      if ( RequiredSize )
        v8 = RequiredSize;
      v27 = v8 - 1;
      v9 = 16 * ((v8 + 15) / 0x10);
      v10 = alloca(v9);
      v11 = alloca(v9);
      v26 = v14;
      if ( !SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, &DeviceInfoData, 0xCu, 0, v14, v8, 0) )
      {
        v12 = 1;
        if ( RequiredSize )
          v12 = RequiredSize;
        memset(v26, 0, v12);
      }
      if ( v15 != 1 && !strncmp("VEX V5 Communications Port", (const char *)v26, 0x1Au) )
      {
        result = getComPort(v26, a1);
        v25 = result;
        return result;
      }
      if ( v15 != 1 && !strncmp("VEX V5 Controller Port", (const char *)v26, 0x16u) )
      {
        result = getComPort(v26, a1);
        v24 = result;
        return result;
      }
      if ( v15 != 1 && !strncmp("VEX IQ Communications Port", (const char *)v26, 0x1Au) )
      {
        result = getComPort(v26, a1);
        v23 = result;
        return result;
      }
      if ( v15 && !strncmp("VEX V5 User Port", (const char *)v26, 0x10u) )
      {
        result = getComPort(v26, a1);
        v22 = result;
        return result;
      }
      if ( v15 && !strncmp("VEX IQ User Port", (const char *)v26, 0x10u) )
      {
        result = getComPort(v26, a1);
        v21 = result;
        return result;
      }
      if ( v15 != 1 && !strncmp("VEX V5 CR Communications Port", (const char *)v26, 0x1Du) )
      {
        result = getComPort(v26, a1);
        v20 = result;
        return result;
      }
      if ( v15 != 1 && !strncmp("VEX EXP Communications Port", (const char *)v26, 0x1Bu) )
      {
        result = getComPort(v26, a1);
        v19 = result;
        return result;
      }
    }
  }
  return 0;
}

//----- (00403B18) --------------------------------------------------------
int __cdecl serialFindPorts(char *a1, char *Destination)
{
  char Source[32]; // [esp+1Ch] [ebp-2Ch] BYREF
  int v4; // [esp+3Ch] [ebp-Ch]

  v4 = enumerateSerialPortsFriendlyNames(Source, 1);
  if ( v4 > 0 )
    strcpy(Destination, Source);
  v4 = enumerateSerialPortsFriendlyNames(Source, 0);
  if ( v4 <= 0 )
    return 0;
  strcpy(a1, Source);
  return v4;
}

//----- (00403B86) --------------------------------------------------------
void __cdecl serialSleep(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (00403B9F) --------------------------------------------------------
char *__cdecl serialOpen(char *Str)
{
  size_t v2; // eax
  struct _COMMTIMEOUTS CommTimeouts; // [esp+24h] [ebp-24h] BYREF
  char *v4; // [esp+38h] [ebp-10h]
  char *Buffer; // [esp+3Ch] [ebp-Ch]

  if ( !Str )
    return 0;
  v4 = (char *)malloc(0x3Cu);
  CommTimeouts.ReadIntervalTimeout = -1;
  CommTimeouts.ReadTotalTimeoutMultiplier = -1;
  CommTimeouts.ReadTotalTimeoutConstant = 500;
  CommTimeouts.WriteTotalTimeoutMultiplier = 0;
  CommTimeouts.WriteTotalTimeoutConstant = 0;
  if ( strlen(Str) <= 4 || *Str == 92 )
  {
    Buffer = Str;
  }
  else
  {
    v2 = strlen(Str);
    Buffer = (char *)calloc(1u, v2 + 5);
    sprintf(Buffer, "\\\\.\\%s", Str);
  }
  *(_DWORD *)v4 = CreateFileA(Buffer, 0xC0000000, 0, 0, 3u, 0, 0);
  if ( Buffer != Str )
    free(Buffer);
  if ( *(_DWORD *)v4 == -1 )
    return 0;
  SetupComm(*(HANDLE *)v4, 0x1000u, 0x1000u);
  SetCommTimeouts(*(HANDLE *)v4, &CommTimeouts);
  SetCommMask(*(HANDLE *)v4, 0x80u);
  GetCommState(*(HANDLE *)v4, (LPDCB)(v4 + 4));
  GetCommState(*(HANDLE *)v4, (LPDCB)(v4 + 32));
  PurgeComm(*(HANDLE *)v4, 0xFu);
  return v4;
}

//----- (00403D5E) --------------------------------------------------------
int __cdecl serialConfig(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  if ( !a1 )
    return 1;
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(a1 + 36) = 1200;
      goto LABEL_13;
    case 2:
      *(_DWORD *)(a1 + 36) = 2400;
      goto LABEL_13;
    case 3:
      *(_DWORD *)(a1 + 36) = 4800;
      goto LABEL_13;
    case 4:
      *(_DWORD *)(a1 + 36) = 9600;
      goto LABEL_13;
    case 5:
      *(_DWORD *)(a1 + 36) = 19200;
      goto LABEL_13;
    case 6:
      *(_DWORD *)(a1 + 36) = 38400;
      goto LABEL_13;
    case 7:
      *(_DWORD *)(a1 + 36) = 57600;
      goto LABEL_13;
    case 8:
      *(_DWORD *)(a1 + 36) = 115200;
LABEL_13:
      if ( a3 == 1 )
      {
        *(_BYTE *)(a1 + 50) = 6;
      }
      else if ( a3 )
      {
        if ( a3 == 2 )
        {
          *(_BYTE *)(a1 + 50) = 7;
        }
        else
        {
          if ( a3 != 3 )
            return 4;
          *(_BYTE *)(a1 + 50) = 8;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 50) = 5;
      }
      if ( a4 == 1 )
      {
        *(_BYTE *)(a1 + 51) = 2;
      }
      else if ( a4 )
      {
        if ( a4 != 2 )
          return 5;
        *(_BYTE *)(a1 + 51) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 51) = 0;
      }
      if ( a5 )
      {
        if ( a5 != 1 )
          return 6;
        *(_BYTE *)(a1 + 52) = 2;
      }
      else
      {
        *(_BYTE *)(a1 + 52) = 0;
      }
      *(_BYTE *)(a1 + 40) &= ~4u;
      *(_BYTE *)(a1 + 40) &= ~8u;
      *(_BYTE *)(a1 + 41) &= ~1u;
      *(_BYTE *)(a1 + 41) &= ~2u;
      *(_BYTE *)(a1 + 41) &= ~8u;
      *(_BYTE *)(a1 + 41) &= ~0x40u;
      *(_BYTE *)(a1 + 40) = *(_BYTE *)(a1 + 40) & 0xCF | 0x10;
      serialFlush((HANDLE *)a1);
      result = !SetCommState(*(HANDLE *)a1, (LPDCB)(a1 + 32));
      break;
    default:
      return 3;
  }
  return result;
}

//----- (00403F35) --------------------------------------------------------
int __cdecl serialSetTimeout(HANDLE *a1, signed int a2)
{
  struct _COMMTIMEOUTS CommTimeouts; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( !a1 )
    return 1;
  CommTimeouts.ReadIntervalTimeout = -1;
  CommTimeouts.ReadTotalTimeoutMultiplier = -1;
  CommTimeouts.ReadTotalTimeoutConstant = 500;
  CommTimeouts.WriteTotalTimeoutMultiplier = 0;
  CommTimeouts.WriteTotalTimeoutConstant = 0;
  if ( a2 > 0 )
    CommTimeouts.ReadTotalTimeoutConstant = a2;
  SetCommTimeouts(*a1, &CommTimeouts);
  return 0;
}

//----- (00403F97) --------------------------------------------------------
void __cdecl serialClose(char *Block)
{
  if ( Block )
  {
    serialFlush((HANDLE *)Block);
    SetCommState(*(HANDLE *)Block, (LPDCB)(Block + 4));
    CloseHandle(*(HANDLE *)Block);
    free(Block);
  }
}

//----- (00403FEC) --------------------------------------------------------
BOOL __cdecl serialFlush(HANDLE *a1)
{
  BOOL result; // eax

  if ( a1 )
    return PurgeComm(*a1, 0xFu);
  return result;
}

//----- (00404017) --------------------------------------------------------
int __cdecl serialWrite(HANDLE *a1, const void *a2, DWORD nNumberOfBytesToWrite)
{
  DWORD NumberOfBytesWritten; // [esp+28h] [ebp-10h] BYREF
  LPCVOID lpBuffer; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 1;
  for ( lpBuffer = a2; ; lpBuffer = (char *)lpBuffer + NumberOfBytesWritten )
  {
    if ( !nNumberOfBytesToWrite )
      return 0;
    if ( !WriteFile(*a1, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
      break;
    if ( !NumberOfBytesWritten )
      return 1;
    nNumberOfBytesToWrite -= NumberOfBytesWritten;
  }
  if ( GetLastError() == 2 )
    exit(1);
  return 1;
}

//----- (004040AB) --------------------------------------------------------
int __cdecl serialRead(HANDLE *a1, void *a2, DWORD nNumberOfBytesToRead)
{
  DWORD NumberOfBytesRead; // [esp+28h] [ebp-10h] BYREF
  LPVOID lpBuffer; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    return 1;
  lpBuffer = a2;
  while ( nNumberOfBytesToRead )
  {
    ReadFile(*a1, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
    if ( !NumberOfBytesRead )
      return 7;
    nNumberOfBytesToRead -= NumberOfBytesRead;
    lpBuffer = (char *)lpBuffer + NumberOfBytesRead;
  }
  return 0;
}

//----- (0040411C) --------------------------------------------------------
DWORD getppid()
{
  PROCESSENTRY32 pe; // [esp+1Ch] [ebp-13Ch] BYREF
  HANDLE hSnapshot; // [esp+144h] [ebp-14h]
  DWORD CurrentProcessId; // [esp+148h] [ebp-10h]
  DWORD dwProcessId; // [esp+14Ch] [ebp-Ch]

  dwProcessId = 0;
  CurrentProcessId = GetCurrentProcessId();
  hSnapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( hSnapshot == (HANDLE)-1 )
    return 0;
  memset(&pe, 0, sizeof(pe));
  pe.dwSize = 296;
  if ( !Process32First(hSnapshot, &pe) )
    return 0;
  while ( CurrentProcessId != pe.th32ProcessID )
  {
    if ( !Process32Next(hSnapshot, &pe) )
      goto LABEL_8;
  }
  dwProcessId = pe.th32ParentProcessID;
LABEL_8:
  if ( hSnapshot != (HANDLE)-1 )
    CloseHandle(hSnapshot);
  if ( dwProcessId )
    parentProcessHandle = OpenProcess(0x400u, 0, dwProcessId);
  return dwProcessId;
}

//----- (00404223) --------------------------------------------------------
BOOL verifyppid()
{
  DWORD ExitCode[3]; // [esp+1Ch] [ebp-Ch] BYREF

  return parentProcessHandle && GetExitCodeProcess(parentProcessHandle, ExitCode) && ExitCode[0] == 259;
}
// 404223: using guessed type DWORD ExitCode[3];

//----- (00404267) --------------------------------------------------------
int __cdecl getNextStdioChar(HANDLE hFile, char a2)
{
  DWORD NumberOfBytesRead; // [esp+38h] [ebp-10h] BYREF
  char Buffer[9]; // [esp+3Fh] [ebp-9h] BYREF

  if ( a2 != 1 )
  {
    if ( __kbhit() )
      return (unsigned __int8)__getch();
  }
  else
  {
    NumberOfBytesRead = 0;
    ReadFile(hFile, Buffer, 1u, &NumberOfBytesRead, 0);
    if ( NumberOfBytesRead )
      return (unsigned __int8)Buffer[0];
  }
  return 0;
}
// 404267: using guessed type char Buffer[9];

//----- (004042E8) --------------------------------------------------------
void __cdecl __noreturn serialReadUserData(int (__cdecl *a1)(char *, int, char *), char a2)
{
  FILE *v2; // eax
  int v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  char v6; // al
  DWORD v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  DWORD Mode; // [esp+2Ch] [ebp-42Ch] BYREF
  char Buffer[512]; // [esp+33h] [ebp-425h] BYREF
  char v13[512]; // [esp+233h] [ebp-225h] BYREF
  char NextStdioChar; // [esp+433h] [ebp-25h]
  size_t ElementCount; // [esp+434h] [ebp-24h]
  DWORD dwMode; // [esp+438h] [ebp-20h]
  HANDLE hConsoleHandle; // [esp+43Ch] [ebp-1Ch]
  DWORD v18; // [esp+440h] [ebp-18h]
  int v19; // [esp+444h] [ebp-14h]
  char v20; // [esp+44Bh] [ebp-Dh]
  int v21; // [esp+44Ch] [ebp-Ch]

  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = getppid();
  hConsoleHandle = GetStdHandle(0xFFFFFFF6);
  dwMode = 0;
  if ( !SetConsoleMode(hConsoleHandle, 0) && GetFileType(hConsoleHandle) == 3 )
  {
    Mode = 1;
    SetNamedPipeHandleState(hConsoleHandle, &Mode, 0, 0);
    v20 = 1;
  }
  v2 = ___acrt_iob_func(1u);
  v3 = fileno(v2);
  setmode(v3, 0x8000);
  while ( 1 )
  {
    ElementCount = a1(v13, v21, Buffer);
    if ( (int)ElementCount > 0 )
    {
      v4 = ___acrt_iob_func(1u);
      fwrite(Buffer, 1u, ElementCount, v4);
      v5 = ___acrt_iob_func(1u);
      fflush(v5);
    }
    v6 = v19++;
    if ( (v6 & 0xF) == 0 && !verifyppid() )
      exit(0);
    if ( a2 )
      v7 = 50;
    else
      v7 = 20;
    serialSleep(v7);
    v21 = 0;
    while ( 1 )
    {
      NextStdioChar = getNextStdioChar(hConsoleHandle, v20);
      if ( !NextStdioChar )
        goto LABEL_20;
      if ( NextStdioChar == 13 )
        break;
      if ( NextStdioChar == 3 )
        exit(0);
      v10 = v21++;
      v13[v10] = NextStdioChar;
    }
    v8 = v21++;
    v13[v8] = 13;
    v9 = v21++;
    v13[v9] = 10;
LABEL_20:
    v13[v21] = 0;
  }
}
// 4042E8: using guessed type char var_225[512];

//----- (00404500) --------------------------------------------------------
int __cdecl v5_ExitStatusJson(int a1, int a2, const char *a3)
{
  puts("{");
  printf("  \"status\":%d,\n", a1);
  printf("  \"error\":%d,\n", a2);
  printf("  \"message\":\"%s\"\n", a3);
  return puts("}");
}

//----- (0040455A) --------------------------------------------------------
int __cdecl v5_SetBrainStatus(int a1)
{
  int result; // eax

  globalStatus[0] = (*(unsigned __int8 *)(a1 + 9) << 8)
                  + (*(unsigned __int8 *)(a1 + 8) << 16)
                  + (*(unsigned __int8 *)(a1 + 7) << 24)
                  + *(unsigned __int8 *)(a1 + 10);
  dword_520264 = (*(unsigned __int8 *)(a1 + 13) << 8)
               + (*(unsigned __int8 *)(a1 + 12) << 16)
               + (*(unsigned __int8 *)(a1 + 11) << 24)
               + *(unsigned __int8 *)(a1 + 14);
  dword_520268 = (*(unsigned __int8 *)(a1 + 17) << 8)
               + (*(unsigned __int8 *)(a1 + 16) << 16)
               + (*(unsigned __int8 *)(a1 + 15) << 24)
               + *(unsigned __int8 *)(a1 + 18);
  dword_52026C = (*(unsigned __int8 *)(a1 + 21) << 8)
               + (*(unsigned __int8 *)(a1 + 20) << 16)
               + (*(unsigned __int8 *)(a1 + 19) << 24)
               + *(unsigned __int8 *)(a1 + 22);
  dword_520270 = (*(_BYTE *)(a1 + 38) & 0xC0)
               + (*(unsigned __int8 *)(a1 + 36) << 16)
               + (*(unsigned __int8 *)(a1 + 35) << 24)
               + *(unsigned __int8 *)(a1 + 37);
  dword_520274 = *(_DWORD *)(a1 + 23);
  dword_520278 = (*(unsigned __int8 *)(a1 + 41) << 8)
               + (*(unsigned __int8 *)(a1 + 40) << 16)
               + (*(unsigned __int8 *)(a1 + 39) << 24)
               + *(unsigned __int8 *)(a1 + 42);
  dword_52027C = *(_DWORD *)(a1 + 27);
  result = *(_DWORD *)(a1 + 31);
  dword_520280 = result;
  return result;
}
// 520260: using guessed type int globalStatus[];
// 520264: using guessed type int dword_520264;
// 520268: using guessed type int dword_520268;
// 52026C: using guessed type int dword_52026C;
// 520270: using guessed type int dword_520270;
// 520274: using guessed type int dword_520274;
// 520278: using guessed type int dword_520278;
// 52027C: using guessed type int dword_52027C;
// 520280: using guessed type int dword_520280;

//----- (004046F7) --------------------------------------------------------
int __cdecl v5_SetSystemStatus(unsigned __int8 *a1)
{
  int result; // eax

  dword_5202A0 = (a1[7] << 8) + (a1[8] << 16) + a1[6];
  byte_5202A4 = a1[9];
  byte_5202A5 = (8 * a1[10]) & 0x78;
  if ( byte_5202A5 > 100 )
    byte_5202A5 = 100;
  byte_5202A6 = ((int)a1[10] >> 1) & 0x78;
  if ( byte_5202A6 > 100 )
    byte_5202A6 = 100;
  byte_5202A8 = (8 * a1[11]) & 0x78;
  if ( byte_5202A8 > 100 )
    byte_5202A8 = 100;
  byte_5202A7 = ((int)a1[11] >> 1) & 0x78;
  result = (unsigned __int8)byte_5202A7;
  if ( byte_5202A7 > 100 )
    byte_5202A7 = 100;
  return result;
}
// 5202A0: using guessed type int dword_5202A0;
// 5202A4: using guessed type char byte_5202A4;
// 5202A5: using guessed type char byte_5202A5;
// 5202A6: using guessed type char byte_5202A6;
// 5202A7: using guessed type char byte_5202A7;
// 5202A8: using guessed type char byte_5202A8;

//----- (004047D2) --------------------------------------------------------
int v5_SetDeviceStatus()
{
  int result; // eax
  char v1[6]; // [esp+13h] [ebp-125h] BYREF
  char v2[255]; // [esp+19h] [ebp-11Fh]
  int v3; // [esp+118h] [ebp-20h]
  int v4; // [esp+11Ch] [ebp-1Ch]
  int v5; // [esp+120h] [ebp-18h]
  unsigned __int16 v6; // [esp+126h] [ebp-12h]
  unsigned int v7; // [esp+128h] [ebp-10h]
  unsigned int i; // [esp+12Ch] [ebp-Ch]

  result = v5_DeviceStatus((int)v1, v1);
  if ( result == 118 )
  {
    dword_52028C = v2[0] & 0x1F;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( dword_52028C <= i )
        break;
      v7 = 8 * i + 1;
      *((_BYTE *)&unk_5202AC + 12 * i) = v2[v7];
      *((_BYTE *)&unk_5202AD + 12 * i) = v2[v7 + 1];
      *((_BYTE *)&unk_5202AE + 12 * i) = v2[v7 + 2];
      v6 = ((unsigned __int8)v2[v7 + 5] << 8) + (unsigned __int8)v2[v7 + 4];
      v5 = (v6 >> 14) & 3;
      v4 = HIBYTE(v6) & 0x3F;
      v3 = (unsigned __int8)v6;
      *((_DWORD *)&unk_5202B0 + 3 * i) = ((unsigned __int8)v6 << 8)
                                       + (v4 << 16)
                                       + (v5 << 24)
                                       + (unsigned __int8)v2[v7 + 3];
      v6 = ((unsigned __int8)v2[v7 + 7] << 8) + (unsigned __int8)v2[v7 + 6];
      v5 = (v6 >> 14) & 3;
      v4 = HIBYTE(v6) & 0x3F;
      v3 = (unsigned __int8)v6;
      dword_5202B4[3 * i] = (v4 << 16) + (v5 << 24) + ((unsigned __int8)v6 << 8);
    }
  }
  return result;
}
// 52028C: using guessed type int dword_52028C;
// 5202B4: using guessed type _DWORD dword_5202B4[103];
// 4047D2: using guessed type char var_11F[255];

//----- (004049C0) --------------------------------------------------------
int v5_SetProgramStatus()
{
  int result; // eax
  __time32_t v1; // [esp+18h] [ebp-1A0h] BYREF
  __time32_t Time; // [esp+1Ch] [ebp-19Ch] BYREF
  char v3[7]; // [esp+21h] [ebp-197h] BYREF
  int v4; // [esp+28h] [ebp-190h]
  int v5; // [esp+30h] [ebp-188h]
  int v6; // [esp+34h] [ebp-184h]
  __time32_t v7; // [esp+38h] [ebp-180h]
  int v8; // [esp+3Ch] [ebp-17Ch]
  char v9[34]; // [esp+40h] [ebp-178h] BYREF
  char v10[6]; // [esp+62h] [ebp-156h] BYREF
  unsigned __int16 v11; // [esp+68h] [ebp-150h]
  int v12; // [esp+6Ch] [ebp-14Ch] BYREF
  unsigned __int8 v13; // [esp+72h] [ebp-146h]
  char v14[133]; // [esp+76h] [ebp-142h] BYREF
  char v15[6]; // [esp+FBh] [ebp-BDh] BYREF
  char v16[127]; // [esp+101h] [ebp-B7h]
  char *v17; // [esp+180h] [ebp-38h]
  char *Source; // [esp+184h] [ebp-34h]
  size_t v19; // [esp+188h] [ebp-30h]
  size_t Count; // [esp+18Ch] [ebp-2Ch]
  int j; // [esp+190h] [ebp-28h]
  int i; // [esp+194h] [ebp-24h]
  int v23; // [esp+198h] [ebp-20h]
  int v24; // [esp+19Ch] [ebp-1Ch]
  int v25; // [esp+1A0h] [ebp-18h]
  int v26; // [esp+1A4h] [ebp-14h]
  int v27; // [esp+1A8h] [ebp-10h]
  int v28; // [esp+1ACh] [ebp-Ch]

  result = v5_ProgramSlotInfo_14((int)v15, v15);
  if ( result == 118 )
  {
    if ( (v16[0] & 0xF0) == 0 || (result = v5_ProgramSlotInfo_58((int)v14, v14), result == 118) )
    {
      v28 = 1;
      v27 = 0;
      v26 = 0;
      v25 = 1;
      while ( v26 <= 3 )
      {
        if ( ((unsigned __int8)v28 & v16[0]) != 0 )
        {
          *((_DWORD *)&unk_520450 + 36 * v26) = (unsigned __int8)v16[v25] + ((unsigned __int8)v16[v25 + 1] << 8);
          Count = (unsigned __int8)v16[v25 + 2];
          if ( Count && (int)Count <= 32 )
            strncpy((char *)&globalStatus[36 * v26 + 115], &v15[v25 + 9], Count);
          ++v27;
          v25 += Count + 3;
        }
        v28 *= 2;
        ++v26;
      }
      v24 = 4;
      v23 = 1;
      while ( v24 <= 7 )
      {
        if ( ((unsigned __int8)v28 & v16[0]) != 0 )
        {
          *((_DWORD *)&unk_520450 + 36 * v24) = (unsigned __int8)v14[v23 + 6] + ((unsigned __int8)v14[v23 + 7] << 8);
          v19 = (unsigned __int8)v14[v23 + 8];
          if ( v19 && (int)v19 <= 32 )
            strncpy((char *)&globalStatus[36 * v24 + 115], &v14[v23 + 9], v19);
          ++v27;
          v23 += v19 + 3;
        }
        v28 *= 2;
        ++v24;
      }
      dword_520284 = v27;
      if ( v5_FileGetDirCount((int)v10, 1, 0, (int)v10) == 118 )
      {
        for ( i = 0; i < v11; ++i )
        {
          if ( v5_FileGetDirEntry((unsigned __int8)i, i, 0, v3) == 118 )
          {
            Time = v7;
            Source = (char *)v5GetTime(&Time);
            if ( (v6 & 0xFFFFFF) == 7235938 && v5_ProgramStatus((int)v9, 1, 0, v9, (int)&v12) == 118 && v13 <= 7u )
            {
              strcpy((char *)&globalStatus[36 * v13 + 125], v9);
              strcpy((char *)&globalStatus[36 * v13 + 135], Source);
              *((_DWORD *)&unk_520474 + 36 * v13) = v4;
              dword_520478[36 * v13] = v6;
            }
          }
        }
      }
      result = v5_FileGetDirCount((int)v10, 64, 0, (int)v10);
      if ( result == 118 )
      {
        for ( j = 0; ; ++j )
        {
          result = v11;
          if ( j >= v11 )
            break;
          if ( v5_FileGetDirEntry((unsigned __int8)j, j, 0, v3) == 118 )
          {
            v1 = v7;
            v17 = (char *)v5GetTime(&v1);
            if ( j <= 7 )
            {
              ++dword_520288;
              strcpy((char *)&globalStatus[28 * j + 403], v9);
              strcpy((char *)&globalStatus[28 * j + 415], v17);
              *((_DWORD *)&unk_5208CC + 28 * j) = v4;
              *((_DWORD *)&unk_5208D0 + 28 * j) = v6;
              *((_DWORD *)&unk_5208D4 + 28 * j) = v5;
              dword_5208D8[28 * j] = v8;
            }
          }
        }
      }
    }
  }
  return result;
}
// 520260: using guessed type int globalStatus[];
// 520284: using guessed type int dword_520284;
// 520288: using guessed type int dword_520288;
// 520478: using guessed type _DWORD dword_520478[277];
// 5208D8: using guessed type _DWORD dword_5208D8[213];
// 4049C0: using guessed type char var_B7[127];

//----- (00404EC8) --------------------------------------------------------
int __cdecl v5_GetSystemInfoJson(const char *a1, const char *a2)
{
  int result; // eax
  int v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // esi
  int *v9; // eax
  int v10; // esi
  int v11; // ebx
  const char *v12; // edi
  int *v13; // eax
  char v14[15]; // [esp+29h] [ebp-AFh] BYREF
  unsigned __int16 v15; // [esp+38h] [ebp-A0h]
  unsigned __int8 v16; // [esp+3Ch] [ebp-9Ch]
  int v17; // [esp+40h] [ebp-98h] BYREF
  int v18; // [esp+44h] [ebp-94h] BYREF
  int v19; // [esp+48h] [ebp-90h] BYREF
  char v20; // [esp+4Fh] [ebp-89h] BYREF
  char v21[31]; // [esp+50h] [ebp-88h] BYREF
  int v22; // [esp+6Fh] [ebp-69h]
  unsigned __int8 v23[15]; // [esp+7Dh] [ebp-5Bh] BYREF
  _DWORD v24[5]; // [esp+8Ch] [ebp-4Ch] BYREF
  int v25; // [esp+A0h] [ebp-38h]
  int v26; // [esp+A4h] [ebp-34h]
  unsigned int k; // [esp+A8h] [ebp-30h]
  int j; // [esp+ACh] [ebp-2Ch]
  int i; // [esp+B0h] [ebp-28h]
  int v30; // [esp+B4h] [ebp-24h]
  char v31; // [esp+B8h] [ebp-20h]
  char v32; // [esp+B9h] [ebp-1Fh]
  bool v33; // [esp+BAh] [ebp-1Eh]
  char v34; // [esp+BBh] [ebp-1Dh]
  char v35; // [esp+BCh] [ebp-1Ch]
  char v36; // [esp+BDh] [ebp-1Bh]
  char v37; // [esp+BEh] [ebp-1Ah]
  char v38; // [esp+BFh] [ebp-19h]

  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  memset(globalStatus, 0, 0xA0Cu);
  memset(v24, 0, 0xCu);
  if ( !v5_SystemVersion(v24) )
  {
    v20 = 0;
    v19 = 0;
    result = iq2_ControllerAtmelStatus(&v20, &v19);
    if ( result == 1 )
      return result;
    LOBYTE(word_52029C) = v20;
    dword_520294 = v19;
    v35 = 1;
    v34 = 1;
  }
  if ( isIq2ProductId((int)v24) )
    v38 = 1;
  if ( isExpProductId((int)v24) )
    v37 = 1;
  if ( isControllerProductId((int)v24) )
  {
    v36 = 1;
    dword_520290 = (BYTE2(v24[1]) << 8) + (BYTE1(v24[1]) << 16) + (LOBYTE(v24[1]) << 24) + LOBYTE(v24[2]);
    word_52029C = HIWORD(v24[2]);
    if ( v38 || v37 )
    {
      iq2_GetControllerVersions(&v18, &v17);
      dword_520294 = v18;
    }
    else if ( !v5_ControllerVersionsGet(v14) )
    {
      v26 = (v15 >> 14) & 3;
      v25 = HIBYTE(v15) & 0x3F;
      v24[4] = (unsigned __int8)v15;
      v24[3] = v16;
      dword_520298 = ((unsigned __int8)v15 << 8) + (v25 << 16) + (v26 << 24) + v16;
    }
  }
  if ( v38 || v37 )
  {
    if ( v5_BrainStatus((int)v21, (int)v21) == 118 )
    {
      if ( (v22 & 0x20000) != 0 )
      {
        v32 = 1;
      }
      else if ( (v22 & 0x40000) != 0 )
      {
        v31 = 1;
      }
    }
    v33 = (unsigned __int8)(v31 | v32) != 0;
  }
  if ( !v33 && v34 != 1 )
  {
    result = v5_SystemStatus((int)v23, (int)v23);
    if ( result != 118 )
    {
      if ( !v36 )
        return result;
      v35 = 1;
    }
  }
  if ( v33 )
  {
    v5_SetBrainStatus((int)v21);
  }
  else if ( v35 != 1 )
  {
    result = v5_BrainStatus((int)v21, (int)v21);
    if ( result != 118 )
      return result;
    v3 = v5_KVLoad(118, "teamnumber", byte_520C2C, 32);
    v5_KVLoad(v3, "robotname", byte_520C4C, 32);
    v5_SetBrainStatus((int)v21);
    v5_SetSystemStatus(v23);
    v5_SetDeviceStatus();
    v5_SetProgramStatus();
  }
  if ( v34 )
  {
    if ( !usb_detect_device_iq2_ctrl(0) )
      v38 = 1;
    if ( v38 != 1 && !usb_detect_device_exp_ctrl(0) )
      v37 = 1;
  }
  puts("{\n  \"device\": {");
  printf("    \"admin\":\"%s\",\n", a1);
  printf("    \"user\":\"%s\",\n", a2);
  if ( v36 || v34 )
    v4 = "controller";
  else
    v4 = "brain";
  printf("    \"connection\":\"%s\"\n", v4);
  puts("  },");
  puts("  \"files\": {");
  puts("    \"python_vm\": {");
  if ( v38 )
  {
    printf("      \"version\":\"0x%08X\",\n", _python_vm_iq2_internal_version);
    printf("      \"crc\":\"0x%08X\"\n", _python_vm_iq2_internal_crc);
  }
  else if ( v37 )
  {
    printf("      \"version\":\"0x%08X\",\n", _python_vm_exp_internal_version);
    printf("      \"crc\":\"0x%08X\"\n", _python_vm_exp_internal_crc);
  }
  else
  {
    printf("      \"version\":\"0x%08X\",\n", _python_vm_version);
    printf("      \"crc\":\"0x%08X\"\n", _python_vm_crc);
  }
  puts("    }");
  puts("  },");
  if ( v38 )
  {
    puts("  \"iq2\": {");
  }
  else if ( v37 )
  {
    puts("  \"exp\": {");
  }
  else if ( v34 )
  {
    puts("  \"unknown\": {");
  }
  else
  {
    puts("  \"v5\": {");
  }
  if ( v34 )
  {
    puts("    \"controller_boot\": {");
    printf("      \"atmel\":\"0x%08X\",\n", dword_520294);
    printf("      \"status\":\"0x%02X\"\n", (unsigned __int8)word_52029C);
    if ( v35 )
      v5 = (const char *)&unk_50DF91;
    else
      v5 = ",";
    printf("    }%s\n", v5);
  }
  if ( v36 )
  {
    puts("    \"controller\": {");
    printf("      \"version\":\"0x%08X\",\n", dword_520290);
    if ( v38 || v37 || v34 )
      printf("      \"atmel\":\"0x%08X\",\n", dword_520294);
    else
      printf("      \"radio\":\"0x%08X\",\n", dword_520298);
    printf("      \"flags\":\"0x%02X\",\n", (unsigned __int8)word_52029C);
    printf("      \"radio_bits\":\"0x%02X\"\n", HIBYTE(word_52029C));
    if ( v35 )
      v6 = (const char *)&unk_50DF91;
    else
      v6 = ",";
    printf("    }%s\n", v6);
  }
  if ( v33 )
  {
    puts("    \"brain\": {");
    if ( v32 )
      v7 = "rom";
    else
      v7 = "ram";
    printf("      \"bootloader\":\"%s\",\n", v7);
    printf("      \"version\":\"0x%08X\"\n", globalStatus[0]);
    puts("    }");
  }
  else if ( v35 != 1 )
  {
    puts("    \"brain\": {");
    printf("      \"vexos\":\"0x%08X\",\n", globalStatus[0]);
    printf("      \"cpu0\":\"0x%08X\",\n", dword_520264);
    if ( v38 != 1 && v37 != 1 )
      printf("      \"cpu1\":\"0x%08X\",\n", dword_520268);
    if ( v38 != 1 && v37 != 1 )
      printf("      \"golden\":\"0x%08X\",\n", dword_520270);
    printf("      \"ssn\":\"0x%08X\",\n", dword_520274);
    if ( v38 != 1 && v37 != 1 )
      printf("      \"nxp\":\"0x%08X\",\n", dword_520278);
    printf("      \"flags\":\"0x%08X\",\n", dword_52027C);
    printf("      \"flags2\":\"0x%08X\",\n", dword_520280);
    if ( v38 != 1 && v37 != 1 )
      printf("      \"eventBrain\":%d,\n", HIWORD(dword_520280) & 1);
    printf("      \"programCount\":%d,\n", dword_520284);
    printf("      \"deviceCount\":%d,\n", dword_52028C);
    printf("      \"name\":\"%s\",\n", byte_520C4C);
    printf("      \"team\":\"%s\"\n", byte_520C2C);
    puts("    },");
    puts("    \"system\": {");
    printf("      \"device_dirty\":\"%d\",\n", dword_5202A0 & 1);
    printf("      \"files_dirty\":\"%d\",\n", ((unsigned int)dword_5202A0 >> 1) & 1);
    printf("      \"ui_dirty\":\"%d\",\n", ((unsigned int)dword_5202A0 >> 2) & 1);
    printf("      \"error_dirty\":\"%d\",\n", ((unsigned int)dword_5202A0 >> 3) & 1);
    printf("      \"flags\":\"0x%08X\",\n", dword_5202A0);
    printf("      \"screen_id\":\"%d\",\n", (unsigned __int8)byte_5202A4);
    printf("      \"battery\":%d,\n", byte_5202A5);
    printf("      \"controller_battery\":%0d,\n", byte_5202A6);
    printf("      \"partner_battery\":%d,\n", byte_5202A7);
    printf("      \"radio_quality\":%d,\n", byte_5202A8);
    printf("      \"radio_present\":%d,\n", ((unsigned int)dword_5202A0 >> 9) & 1);
    printf("      \"radio_linked\":%d,\n", ((unsigned int)dword_5202A0 >> 10) & 1);
    printf("      \"battery_charging\":%d,\n", ((unsigned int)dword_5202A0 >> 17) & 1);
    printf("      \"low_battery\":%d,\n", ((unsigned int)dword_5202A0 >> 19) & 1);
    printf("      \"controller_tethered\":%d\n", ((unsigned int)dword_5202A0 >> 8) & 1);
    puts("    },");
    puts("    \"programs\": {");
    printf("      \"count\":%d,\n", dword_520284);
    puts("      \"items\": [");
    v30 = 0;
    for ( i = 0; i <= 7; ++i )
    {
      if ( dword_520478[36 * i] )
      {
        if ( v30 )
          puts(",");
        v8 = (const char *)&globalStatus[36 * i + 135];
        v9 = v5_TypeToString(dword_520478[36 * i]);
        printf(
          "        { \"slot\": %d, \"file\": \"%s\", \"binfile\": \"%s\", \"size\": %d, \"type\": \"%s\", \"time\": \"%s\" }",
          i,
          (const char *)&globalStatus[36 * i + 115],
          (const char *)&globalStatus[36 * i + 125],
          *((_DWORD *)&unk_520474 + 36 * i),
          (const char *)v9,
          v8);
        v30 = 1;
      }
    }
    putchar(10);
    puts("      ]");
    puts("    },");
    puts("    \"vms\": {");
    printf("      \"count\":%d,\n", dword_520288);
    puts("      \"items\": [");
    v30 = 0;
    for ( j = 0; j <= 7; ++j )
    {
      if ( *((_DWORD *)&unk_5208D0 + 28 * j) )
      {
        if ( v30 )
          puts(",");
        v10 = dword_5208D8[28 * j];
        v11 = *((_DWORD *)&unk_5208D4 + 28 * j);
        v12 = (const char *)&globalStatus[28 * j + 415];
        v13 = v5_TypeToString(*((_DWORD *)&unk_5208D0 + 28 * j));
        printf(
          "        { \"binfile\": \"%s\", \"size\": %d, \"type\": \"%s\", \"time\": \"%s\", \"crc32\": \"0x%08X\", \"vers"
          "ion\": \"0x%08X\" }",
          (const char *)&globalStatus[28 * j + 403],
          *((_DWORD *)&unk_5208CC + 28 * j),
          (const char *)v13,
          v12,
          v11,
          v10);
        v30 = 1;
      }
    }
    putchar(10);
    puts("      ]");
    puts("    },");
    puts("    \"devices\": {");
    printf("      \"count\":%d,\n", dword_52028C);
    puts("      \"items\": [");
    v30 = 0;
    for ( k = 0; dword_52028C > k; ++k )
    {
      if ( v30 )
        puts(",");
      printf(
        "        { \"port\": %d, \"type\": %d, \"status\": %d, \"version\": \"0x%08X\", \"boot\": \"0x%08X\" }",
        *((char *)&unk_5202AC + 12 * k),
        *((char *)&unk_5202AD + 12 * k),
        *((char *)&unk_5202AE + 12 * k),
        *((_DWORD *)&unk_5202B0 + 3 * k),
        dword_5202B4[3 * k]);
      v30 = 1;
    }
    putchar(10);
    puts("      ]");
    puts("    }");
  }
  puts("  }");
  return puts("}");
}
// 44C420: using guessed type int _python_vm_version;
// 44C424: using guessed type int _python_vm_crc;
// 4ACF28: using guessed type int _python_vm_iq2_internal_version;
// 4ACF2C: using guessed type int _python_vm_iq2_internal_crc;
// 4E9B70: using guessed type int _python_vm_exp_internal_version;
// 4E9B74: using guessed type int _python_vm_exp_internal_crc;
// 520260: using guessed type int globalStatus[];
// 520264: using guessed type int dword_520264;
// 520268: using guessed type int dword_520268;
// 520270: using guessed type int dword_520270;
// 520274: using guessed type int dword_520274;
// 520278: using guessed type int dword_520278;
// 52027C: using guessed type int dword_52027C;
// 520280: using guessed type int dword_520280;
// 520284: using guessed type int dword_520284;
// 520288: using guessed type int dword_520288;
// 52028C: using guessed type int dword_52028C;
// 520290: using guessed type int dword_520290;
// 520294: using guessed type int dword_520294;
// 520298: using guessed type int dword_520298;
// 52029C: using guessed type __int16 word_52029C;
// 5202A0: using guessed type int dword_5202A0;
// 5202A4: using guessed type char byte_5202A4;
// 5202A5: using guessed type char byte_5202A5;
// 5202A6: using guessed type char byte_5202A6;
// 5202A7: using guessed type char byte_5202A7;
// 5202A8: using guessed type char byte_5202A8;
// 5202B4: using guessed type _DWORD dword_5202B4[103];
// 520478: using guessed type _DWORD dword_520478[277];
// 5208D8: using guessed type _DWORD dword_5208D8[213];
// 404EC8: using guessed type int var_90;
// 404EC8: using guessed type char var_AF[15];

//----- (00405BE6) --------------------------------------------------------
int __cdecl v5_GetDirJson(unsigned __int8 a1)
{
  int result; // eax
  int *v2; // eax
  __time32_t Time; // [esp+38h] [ebp-70h] BYREF
  _DWORD v4[3]; // [esp+3Dh] [ebp-6Bh] BYREF
  char v5[7]; // [esp+49h] [ebp-5Fh] BYREF
  int v6; // [esp+50h] [ebp-58h]
  int v7; // [esp+5Ch] [ebp-4Ch]
  __time32_t v8; // [esp+60h] [ebp-48h]
  char v9[34]; // [esp+68h] [ebp-40h] BYREF
  char v10[6]; // [esp+8Ah] [ebp-1Eh] BYREF
  unsigned __int16 v11; // [esp+90h] [ebp-18h]
  const char *v12; // [esp+94h] [ebp-14h]
  int i; // [esp+98h] [ebp-10h]
  char v14; // [esp+9Eh] [ebp-Ah]
  char v15; // [esp+9Fh] [ebp-9h]

  v15 = 0;
  v14 = 0;
  result = v5_SystemVersion(v4);
  if ( result )
  {
    if ( isIq2ProductId((int)v4) )
      v15 = 1;
    if ( isExpProductId((int)v4) )
      v14 = 1;
    result = v5_FileGetDirCount(a1, a1, 0, (int)v10);
    if ( result == 118 )
    {
      puts("{");
      if ( v15 )
      {
        puts("  \"iq2\": {");
      }
      else if ( v14 )
      {
        puts("  \"exp\": {");
      }
      else
      {
        puts("  \"v5\": {");
      }
      printf("    \"directory\": {\n      \"count\": %d,\n      \"items\": [\n", v11);
      for ( i = 0; i < v11; ++i )
      {
        if ( v5_FileGetDirEntry((unsigned __int8)i, i, 0, v5) == 118 )
        {
          Time = v8;
          v12 = v5GetTime(&Time);
          v2 = v5_TypeToString(v7);
          printf(
            "        { \"file\": \"%s\", \"size\": \"%d\", \"type\": \"%s\", \"time\": \"%s\" }",
            v9,
            v6,
            (const char *)v2,
            v12);
          if ( i != v11 - 1 )
            puts(",");
        }
      }
      return puts("\n      ]\n    }\n  }\n}");
    }
  }
  return result;
}
// 405BE6: using guessed type _DWORD var_6B[3];
// 405BE6: using guessed type char var_1E[6];
// 405BE6: using guessed type char var_5F[7];
// 405BE6: using guessed type char anonymous_0[34];

//----- (00405D68) --------------------------------------------------------
int __cdecl v5_showCatalogJson(int a1, int a2)
{
  bool v3; // [esp+1Eh] [ebp-Ah]
  bool v4; // [esp+1Fh] [ebp-9h]

  v4 = isIq2ProductId(a1);
  v3 = isExpProductId(a1);
  puts("{");
  if ( v4 )
  {
    puts("  \"iq2\": {");
  }
  else if ( v3 )
  {
    puts("  \"exp\": {");
  }
  else
  {
    puts("  \"v5\": {");
  }
  printf("      \"catalog\":\"0x%08X\"\n", a2);
  return puts("  }\n}");
}

//----- (00405DFE) --------------------------------------------------------
int v5_GetPrograms()
{
  int result; // eax
  _DWORD v1[3]; // [esp+2Eh] [ebp-1Ah] BYREF
  char v2; // [esp+3Ah] [ebp-Eh]
  char v3; // [esp+3Bh] [ebp-Dh]
  int i; // [esp+3Ch] [ebp-Ch]

  memset(globalStatus, 0, 0xA0Cu);
  v3 = 0;
  v2 = 0;
  result = v5_SystemVersion(v1);
  if ( result )
  {
    if ( isIq2ProductId((int)v1) )
      v3 = 1;
    if ( isExpProductId((int)v1) )
      v2 = 1;
    result = v5_SetProgramStatus();
    for ( i = 0; i <= 7; ++i )
    {
      result = dword_520478[36 * i];
      if ( result )
        result = vexlog(
                   -2,
                   "slot %d: name %24s: size %d: time %s\n",
                   i + 1,
                   (const char *)&globalStatus[36 * i + 115],
                   *((_DWORD *)&unk_520474 + 36 * i),
                   (const char *)&globalStatus[36 * i + 135]);
    }
  }
  return result;
}
// 520260: using guessed type int globalStatus[];
// 520478: using guessed type _DWORD dword_520478[277];
// 405DFE: using guessed type _DWORD var_1A[3];

//----- (00405F14) --------------------------------------------------------
int v5_GetProgramsJson()
{
  int result; // eax
  const char *v1; // esi
  int *v2; // eax
  _DWORD v3[3]; // [esp+28h] [ebp-30h] BYREF
  int i; // [esp+34h] [ebp-24h]
  int v5; // [esp+38h] [ebp-20h]
  char v6; // [esp+3Eh] [ebp-1Ah]
  char v7; // [esp+3Fh] [ebp-19h]

  memset(globalStatus, 0, 0xA0Cu);
  v7 = 0;
  v6 = 0;
  result = v5_SystemVersion(v3);
  if ( result )
  {
    if ( isIq2ProductId((int)v3) )
      v7 = 1;
    if ( isExpProductId((int)v3) )
      v6 = 1;
    v5_SetProgramStatus();
    puts("{");
    if ( v7 )
    {
      puts("  \"iq2\": {");
    }
    else if ( v6 )
    {
      puts("  \"exp\": {");
    }
    else
    {
      puts("  \"v5\": {");
    }
    puts("    \"programs\": {");
    printf("      \"count\":%d,\n", dword_520284);
    puts("      \"items\": [");
    v5 = 0;
    for ( i = 0; i <= 7; ++i )
    {
      if ( dword_520478[36 * i] )
      {
        if ( v5 )
          puts(",");
        v1 = (const char *)&globalStatus[36 * i + 135];
        v2 = v5_TypeToString(dword_520478[36 * i]);
        printf(
          "        { \"slot\": %d, \"file\": \"%s\", \"binfile\": \"%s\", \"size\": %d, \"type\": \"%s\", \"time\": \"%s\" }",
          i + 1,
          (const char *)&globalStatus[36 * i + 115],
          (const char *)&globalStatus[36 * i + 125],
          *((_DWORD *)&unk_520474 + 36 * i),
          (const char *)v2,
          v1);
        v5 = 1;
      }
    }
    return puts("\n      ]\n    }\n  }\n}");
  }
  return result;
}
// 520260: using guessed type int globalStatus[];
// 520284: using guessed type int dword_520284;
// 520478: using guessed type _DWORD dword_520478[277];
// 405F14: using guessed type _DWORD var_30[3];

//----- (00406103) --------------------------------------------------------
int __cdecl v5_SystemStatusJson(int a1, const char *a2, const char *a3)
{
  int result; // eax
  const char *v4; // eax
  unsigned __int8 v5[15]; // [esp+1Dh] [ebp-1Bh] BYREF
  bool v6; // [esp+2Ch] [ebp-Ch]
  char v7; // [esp+2Dh] [ebp-Bh]
  bool v8; // [esp+2Eh] [ebp-Ah]
  bool v9; // [esp+2Fh] [ebp-9h]

  memset(globalStatus, 0, 0xA0Cu);
  v7 = 0;
  v6 = 0;
  v9 = isIq2ProductId(a1);
  v8 = isExpProductId(a1);
  if ( isControllerProductId(a1) )
  {
    v7 = 1;
    v6 = (*(_BYTE *)(a1 + 10) & 3) == 0;
  }
  if ( !v6 )
  {
    result = v5_SystemStatus((int)v5, (int)v5);
    if ( result != 118 )
    {
      if ( !v7 )
        return result;
      v6 = 1;
    }
  }
  v5_SetSystemStatus(v5);
  puts("{");
  puts("  \"device\": {");
  printf("    \"admin\":\"%s\",\n", a2);
  printf("    \"user\":\"%s\",\n", a3);
  if ( v7 )
    v4 = "controller";
  else
    v4 = "brain";
  printf("    \"connection\":\"%s\"\n", v4);
  puts("  },");
  if ( v9 )
  {
    puts("  \"iq2\": {");
  }
  else if ( v8 )
  {
    puts("  \"exp\": {");
  }
  else
  {
    puts("  \"v5\": {");
  }
  puts("    \"system\": {");
  if ( !v6 )
  {
    printf("      \"device_dirty\":\"%d\",\n", dword_5202A0 & 1);
    printf("      \"files_dirty\":\"%d\",\n", ((unsigned int)dword_5202A0 >> 1) & 1);
    printf("      \"ui_dirty\":\"%d\",\n", ((unsigned int)dword_5202A0 >> 2) & 1);
    printf("      \"error_dirty\":\"%d\",\n", ((unsigned int)dword_5202A0 >> 3) & 1);
    printf("      \"flags\":\"0x%08X\",\n", dword_5202A0);
    printf("      \"screen_id\":\"%d\",\n", (unsigned __int8)byte_5202A4);
    printf("      \"battery\":%d,\n", byte_5202A5);
    printf("      \"controller_battery\":%0d,\n", byte_5202A6);
    printf("      \"partner_battery\":%d,\n", byte_5202A7);
    printf("      \"radio_quality\":%d,\n", byte_5202A8);
    printf("      \"radio_present\":%d,\n", ((unsigned int)dword_5202A0 >> 9) & 1);
    printf("      \"radio_linked\":%d,\n", ((unsigned int)dword_5202A0 >> 10) & 1);
    printf("      \"battery_charging\":%d,\n", ((unsigned int)dword_5202A0 >> 17) & 1);
    printf("      \"low_battery\":%d,\n", ((unsigned int)dword_5202A0 >> 19) & 1);
    printf("      \"controller_tethered\":%d\n", ((unsigned int)dword_5202A0 >> 8) & 1);
  }
  puts("    }");
  puts("  }");
  return puts("}");
}
// 520260: using guessed type int globalStatus[];
// 5202A0: using guessed type int dword_5202A0;
// 5202A4: using guessed type char byte_5202A4;
// 5202A5: using guessed type char byte_5202A5;
// 5202A6: using guessed type char byte_5202A6;
// 5202A7: using guessed type char byte_5202A7;
// 5202A8: using guessed type char byte_5202A8;

//----- (00406421) --------------------------------------------------------
int __cdecl appVersionJson(const char *a1, const char *a2, const char *a3, const char *a4)
{
  puts("{");
  printf("  \"%s\": {\n", "app");
  printf("    \"name\":\"%s\",\n", a1);
  printf("    \"version\":\"%s\",\n", a2);
  printf("    \"date\":\"%s\",\n", a3);
  printf("    \"time\":\"%s\"\n", a4);
  return puts("  }\n}");
}

//----- (004064A4) --------------------------------------------------------
BOOL __cdecl isControllerProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 17 || *(_BYTE *)(a1 + 9) == 33 || *(_BYTE *)(a1 + 9) == 23 || *(_BYTE *)(a1 + 9) == 97;
}

//----- (004064E1) --------------------------------------------------------
BOOL __cdecl isV5ControllerProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 17;
}

//----- (004064FD) --------------------------------------------------------
BOOL __cdecl isV5ProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 16 || *(_BYTE *)(a1 + 9) == 20 || *(_BYTE *)(a1 + 9) == 17;
}

//----- (0040652F) --------------------------------------------------------
BOOL __cdecl isV5BrainProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 16 || *(_BYTE *)(a1 + 9) == 20;
}

//----- (00406556) --------------------------------------------------------
BOOL __cdecl isIq2ProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 32 || *(_BYTE *)(a1 + 9) == 33;
}

//----- (0040657D) --------------------------------------------------------
BOOL __cdecl isIq2BrainProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 32;
}

//----- (00406599) --------------------------------------------------------
BOOL __cdecl isExpProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 22 || *(_BYTE *)(a1 + 9) == 23 || *(_BYTE *)(a1 + 9) == 96 || *(_BYTE *)(a1 + 9) == 97;
}

//----- (004065D6) --------------------------------------------------------
BOOL __cdecl isExpBrainProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 22 || *(_BYTE *)(a1 + 9) == 96;
}

//----- (004065FD) --------------------------------------------------------
BOOL __cdecl isSlowEraseProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 32
      || *(_BYTE *)(a1 + 9) == 33
      || *(_BYTE *)(a1 + 9) == 22
      || *(_BYTE *)(a1 + 9) == 23
      || *(_BYTE *)(a1 + 9) == 96
      || *(_BYTE *)(a1 + 9) == 97;
}

//----- (00406650) --------------------------------------------------------
BOOL __cdecl isV5ProtocolProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 16
      || *(_BYTE *)(a1 + 9) == 20
      || *(_BYTE *)(a1 + 9) == 17
      || *(_BYTE *)(a1 + 9) == 32
      || *(_BYTE *)(a1 + 9) == 33
      || *(_BYTE *)(a1 + 9) == 22
      || *(_BYTE *)(a1 + 9) == 23
      || *(_BYTE *)(a1 + 9) == 24
      || *(_BYTE *)(a1 + 9) == 112
      || *(_BYTE *)(a1 + 9) == 96
      || *(_BYTE *)(a1 + 9) == 97;
}

//----- (004066DA) --------------------------------------------------------
BOOL __cdecl isGpsProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 24;
}

//----- (004066F6) --------------------------------------------------------
BOOL __cdecl isTestProductId(int a1)
{
  return *(_BYTE *)(a1 + 9) == 112;
}

//----- (00406712) --------------------------------------------------------
char *systemVersionString()
{
  sprintf(str1_6662, "%d.%d.%db%d%s", 1, 0, 0, 28, str2_6663);
  return str1_6662;
}

//----- (0040675B) --------------------------------------------------------
char *__cdecl versionString(unsigned int a1)
{
  sprintf(str1_6667, "%d.%d.%d.%d", HIBYTE(a1), BYTE2(a1), BYTE1(a1), (unsigned __int8)a1);
  return str1_6667;
}

//----- (004067AF) --------------------------------------------------------
const char *__cdecl v5GetTime(__time32_t *Time)
{
  const char *Str; // [esp+1Ch] [ebp-Ch]

  if ( *Time <= 1451606400 )
    *Time += 946684800;
  Str = ctime(Time);
  if ( !Str )
  {
    *Time = 0;
    Str = ctime(Time);
  }
  if ( Str && Str[strlen(Str) - 1] == 10 )
    Str[strlen(Str) - 1] = 0;
  return Str;
}

//----- (00406847) --------------------------------------------------------
long double __cdecl v5TransferTimer(int a1, int a2, const char *a3, char a4)
{
  const char *v4; // eax
  double v6; // [esp+48h] [ebp-10h]

  v6 = 0.0;
  if ( a1 )
  {
    clock_gettime(0, &timeend_6679);
    v6 = (double)((long double)timeend_6679 + (long double)dword_520CEC / 1000000000.0)
       - (double)((long double)timestart_6678 + (long double)dword_520CE4 / 1000000000.0);
    if ( a4 )
    {
      if ( a3 )
        v4 = a3;
      else
        v4 = "???";
      vexlog(
        2,
        "\r%-20s: time %6.2f seconds for %6d bytes, data rate %6.0f bytes/sec\n",
        v4,
        v6,
        a2,
        (double)((long double)a2 / v6));
    }
  }
  else
  {
    clock_gettime(0, &timestart_6678);
  }
  return v6;
}
// 520CE0: using guessed type int timestart_6678;
// 520CE4: using guessed type int dword_520CE4;
// 520CE8: using guessed type int timeend_6679;
// 520CEC: using guessed type int dword_520CEC;
// 406847: using guessed type const char *arg_8;

//----- (00406925) --------------------------------------------------------
unsigned int __cdecl read_file(char *FileName, void **a2)
{
  size_t v3; // [esp+14h] [ebp-14h]
  unsigned int ElementCount; // [esp+18h] [ebp-10h]
  FILE *Stream; // [esp+1Ch] [ebp-Ch]

  if ( !FileName )
    return -1;
  Stream = fopen(FileName, "rb");
  if ( !Stream )
    return -1;
  fseek(Stream, 0, 2);
  ElementCount = ftell(Stream);
  fseek(Stream, 0, 0);
  if ( !ElementCount || ElementCount > 0xC00000 )
  {
    fclose(Stream);
    return -1;
  }
  *a2 = malloc((ElementCount + 3) & 0xFFFFFFFC);
  if ( !*a2 )
    return -1;
  memset(*a2, 0, (ElementCount + 3) & 0xFFFFFFFC);
  v3 = fread(*a2, 1u, ElementCount, Stream);
  fclose(Stream);
  if ( v3 == ElementCount )
    return ElementCount;
  vexerr(255, "file read error: %s\n", FileName);
  free(*a2);
  return -1;
}

//----- (00406A80) --------------------------------------------------------
void *__cdecl decodeBase64(char *Str)
{
  int v1; // eax
  char v3; // [esp+18h] [ebp-30h]
  int v4; // [esp+1Ch] [ebp-2Ch]
  int v5; // [esp+20h] [ebp-28h]
  void *v6; // [esp+28h] [ebp-20h]
  signed int v7; // [esp+2Ch] [ebp-1Ch]
  signed int j; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]
  unsigned int i; // [esp+38h] [ebp-10h]
  int v11; // [esp+3Ch] [ebp-Ch]

  v7 = strlen(Str);
  v11 = 3 * v7 / 4;
  for ( i = 0; i <= 0x40; ++i )
    lookup_6695[(unsigned __int8)chars_6696[i]] = i;
  if ( Str[v7 - 1] == 61 )
  {
    --v11;
    if ( Str[v7 - 2] == 61 )
      --v11;
  }
  v6 = malloc(v11 + 1);
  if ( v6 )
  {
    memset(v6, 0, v11 + 1);
    v9 = 0;
    for ( j = 0; j < v7; j += 4 )
    {
      v5 = (unsigned __int8)lookup_6695[Str[j + 1]];
      v4 = (unsigned __int8)lookup_6695[Str[j + 2]];
      v3 = lookup_6695[Str[j + 3]];
      *((_BYTE *)v6 + v9) = (v5 >> 4) | (4 * lookup_6695[Str[j]]);
      *((_BYTE *)v6 + v9 + 1) = (v4 >> 2) | (16 * v5);
      v1 = v9 + 2;
      v9 += 3;
      *((_BYTE *)v6 + v1) = v3 & 0x3F | ((_BYTE)v4 << 6);
    }
  }
  return v6;
}

//----- (00406C4F) --------------------------------------------------------
int __cdecl gzip_compress_binary(int a1, unsigned int a2, void **a3)
{
  int v4; // [esp+24h] [ebp-44h] BYREF
  unsigned int v5; // [esp+28h] [ebp-40h]
  int v6; // [esp+30h] [ebp-38h]
  size_t v7; // [esp+34h] [ebp-34h]
  int v8; // [esp+38h] [ebp-30h]
  int v9; // [esp+44h] [ebp-24h]
  int v10; // [esp+48h] [ebp-20h]
  int v11; // [esp+4Ch] [ebp-1Ch]
  size_t Size; // [esp+5Ch] [ebp-Ch]

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v5 = a2;
  v4 = a1;
  v7 = 0;
  v6 = 0;
  deflateInit2_(&v4, 0xFFFFFFFF, 8, 31, 8, 0, "1.2.11", 56);
  Size = (deflateBound(&v4, v5) + 4107) & 0xFFF000;
  if ( Size > 0x2FFFFF )
    return -1;
  *a3 = malloc(Size);
  v7 = Size;
  v6 = (int)*a3;
  if ( deflate(&v4, 4u) != 1 || deflateEnd(&v4) )
    return -1;
  else
    return v8;
}

//----- (00406D4C) --------------------------------------------------------
void vexLoggerInit()
{
  ;
}

//----- (00406D4E) --------------------------------------------------------
int __cdecl vexlogLevel(int a1)
{
  int result; // eax

  result = a1;
  nLogLevel = a1;
  return result;
}
// 44C2A0: using guessed type int nLogLevel;

//----- (00406D5C) --------------------------------------------------------
int vexlog(int a1, char *Format, ...)
{
  int result; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  va_list va; // [esp+38h] [ebp+10h] BYREF

  va_start(va, Format);
  result = nLogLevel;
  if ( a1 <= nLogLevel )
  {
    v3 = ___acrt_iob_func(1u);
    vfprintf(v3, Format, va);
    v4 = ___acrt_iob_func(1u);
    return fflush(v4);
  }
  return result;
}
// 44C2A0: using guessed type int nLogLevel;

//----- (00406DB8) --------------------------------------------------------
int vexlogFlush()
{
  FILE *v0; // eax

  v0 = ___acrt_iob_func(1u);
  return fflush(v0);
}

//----- (00406DD7) --------------------------------------------------------
int vexerr(int a1, char *Format, ...)
{
  FILE *v2; // eax
  FILE *v3; // eax
  va_list va; // [esp+38h] [ebp+10h] BYREF

  va_start(va, Format);
  v2 = ___acrt_iob_func(2u);
  vfprintf(v2, Format, va);
  v3 = ___acrt_iob_func(2u);
  return fflush(v3);
}

//----- (00406E28) --------------------------------------------------------
int __cdecl v5_FileTransferProgress(int a1, int a2)
{
  return v5_FileTransferShowProgress(a1, a2, 1);
}

//----- (00406E4B) --------------------------------------------------------
char *__cdecl v5_FileTransferMetadata(char *Source, char *a2, char *a3)
{
  char *result; // eax

  result = a3;
  if ( Source )
  {
    strcpy(transfer_action, Source);
    result = (char *)g_jsonmode;
    if ( !g_jsonmode )
    {
      result = (char *)g_quietmode;
      if ( g_quietmode <= 1 )
      {
        if ( (_BYTE)a3 )
          result = (char *)vexlog(2, "\r%-8s : ", Source);
      }
    }
  }
  if ( a2 )
    return strcpy(transfer_phase, a2);
  return result;
}
// 44BF70: using guessed type int g_quietmode;
// 520044: using guessed type int g_jsonmode;

//----- (00406EC0) --------------------------------------------------------
int __cdecl v5_FileTransferShowProgressBash(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( !a1 )
  {
    dot_6640 = 0;
    last_pct_6641 = 0;
  }
  result = dot_6640;
  if ( dot_6640 != 100 )
  {
    if ( a1 < last_pct_6641 )
      last_pct_6641 = a1;
    v2 = last_pct_6641;
    last_pct_6641 = a1;
    while ( 1 )
    {
      result = v2;
      if ( v2 > a1 )
        break;
      if ( v2 > 99 )
      {
        if ( dot_6640 != 51 )
          vexlog(2, "100");
        vexlog(2, "\n");
        dot_6640 = 100;
      }
      else if ( v2 / 2 >= dot_6640 )
      {
        if ( dot_6640 % 5 )
          vexlog(2, ".");
        else
          vexlog(2, "%d", 2 * dot_6640);
        ++dot_6640;
        ___acrt_iob_func(1u);
        vexlogFlush();
      }
      ++v2;
    }
  }
  return result;
}
// 520E80: using guessed type int dot_6640;
// 520E84: using guessed type int last_pct_6641;

//----- (0040700E) --------------------------------------------------------
int __cdecl v5_FileTransferShowProgressJson(int a1)
{
  int result; // eax
  const char *v2; // [esp+28h] [ebp-10h]
  const char *v3; // [esp+2Ch] [ebp-Ch]

  if ( !a1 )
    last_pct_6649 = -1;
  if ( a1 < last_pct_6649 )
    last_pct_6649 = a1;
  if ( a1 > last_pct_6649 )
  {
    v3 = transfer_phase;
    if ( !transfer_phase )
      v3 = "undefined";
    v2 = transfer_action;
    if ( !transfer_action )
      v2 = "undefined";
    vexlog(-3, "{ \"phase\":\"%s\", \"action\":\"%s\", \"percent\": %d }\n", v3, v2, a1);
  }
  result = a1;
  last_pct_6649 = a1;
  return result;
}
// 520E88: using guessed type int last_pct_6649;

//----- (0040709C) --------------------------------------------------------
int __cdecl v5_FileTransferShowProgress(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // [esp+2Ch] [ebp-Ch]

  if ( a2 != 100 && a2 )
    v4 = 100 * a1 / a2;
  else
    v4 = a1;
  if ( v4 < 0 )
    v4 = 0;
  if ( v4 > 100 )
    v4 = 100;
  if ( !v4 )
    v4 = a1 != 0;
  if ( g_jsonmode && a3 )
    return v5_FileTransferShowProgressJson(v4);
  result = g_quietmode;
  if ( g_quietmode <= 1 )
  {
    if ( a3 )
      return v5_FileTransferShowProgressBash(v4);
  }
  return result;
}
// 44BF70: using guessed type int g_quietmode;
// 520044: using guessed type int g_jsonmode;

//----- (00407134) --------------------------------------------------------
char *__cdecl replace_str(char *Str, char *SubStr, const char *a3)
{
  size_t v4; // eax
  char *v5; // [esp+1Ch] [ebp-Ch]

  v5 = strstr(Str, SubStr);
  if ( !v5 )
    return Str;
  strncpy(buffer_6630, Str, v5 - Str);
  buffer_6630[v5 - Str] = 0;
  v4 = strlen(SubStr);
  sprintf(&buffer_6630[v5 - Str], "%s%s", a3, &v5[v4]);
  return buffer_6630;
}

//----- (004071C5) --------------------------------------------------------
char *__cdecl create_ini_file(char *Source, int a2, unsigned int a3, const char *a4)
{
  char Destination[64]; // [esp+10h] [ebp-B8h] BYREF
  __time32_t Time; // [esp+50h] [ebp-78h] BYREF
  char v7[32]; // [esp+54h] [ebp-74h] BYREF
  char v8[32]; // [esp+74h] [ebp-54h] BYREF
  char Buffer[32]; // [esp+94h] [ebp-34h] BYREF
  struct tm *Tm; // [esp+B4h] [ebp-14h]
  size_t i; // [esp+B8h] [ebp-10h]
  char *v12; // [esp+BCh] [ebp-Ch]

  if ( !Source )
    return 0;
  if ( a2 <= 0 )
    a2 = 1;
  if ( a2 > 8 )
    a2 = 8;
  if ( a3 >= 0x3E8 )
    a3 = 999;
  sprintf(Buffer, "%d", a2 - 1);
  sprintf(v8, "USER%03dx", a3);
  time(&Time);
  Tm = localtime(&Time);
  strftime(v7, 0x1Au, "%Y-%m-%d %H:%M:%S", Tm);
  memset(Destination, 0, sizeof(Destination));
  strncpy(Destination, Source, 0x3Fu);
  for ( i = 0; strlen(Destination) > i; ++i )
  {
    if ( Destination[i] == 46 )
      Destination[i] = 0;
  }
  v12 = replace_str(inifile, "<programname>", Destination);
  strcpy(final_6639, v12);
  v12 = replace_str(final_6639, "<slot>", Buffer);
  strcpy(final_6639, v12);
  v12 = replace_str(final_6639, "<icon>", v8);
  strcpy(final_6639, v12);
  v12 = replace_str(final_6639, "<date>", v7);
  strcpy(final_6639, v12);
  if ( a4 )
    v12 = replace_str(final_6639, "<desc>", a4);
  else
    v12 = replace_str(final_6639, "<desc>", "VEX program");
  strcpy(final_6639, v12);
  return final_6639;
}
// 4071C5: using guessed type char Destination[64];

//----- (00407424) --------------------------------------------------------
int __cdecl v5_TransferParameterSet(char a1, char a2, char a3, int a4)
{
  int result; // eax

  transferParams = a1;
  byte_522EA1 = a2;
  byte_522EA2 = a3;
  result = a4;
  dword_522EA4 = a4;
  return result;
}
// 522EA0: using guessed type char transferParams;
// 522EA1: using guessed type char byte_522EA1;
// 522EA2: using guessed type char byte_522EA2;
// 522EA4: using guessed type int dword_522EA4;

//----- (00407462) --------------------------------------------------------
int __cdecl v5_GetDir(unsigned __int8 a1)
{
  int *v1; // eax
  __time32_t Time; // [esp+38h] [ebp-60h] BYREF
  char v4[7]; // [esp+3Dh] [ebp-5Bh] BYREF
  int v5; // [esp+44h] [ebp-54h]
  int v6; // [esp+50h] [ebp-48h]
  __time32_t v7; // [esp+54h] [ebp-44h]
  char v8[34]; // [esp+5Ch] [ebp-3Ch] BYREF
  char v9[6]; // [esp+7Eh] [ebp-1Ah] BYREF
  unsigned __int16 v10; // [esp+84h] [ebp-14h]
  const char *v11; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  if ( v5_FileGetDirCount(a1, a1, 0, (int)v9) != 118 )
    return 1;
  vexlog(-2, "dir vid %02X ----- %d\n", a1, v10);
  for ( i = 0; i < v10; ++i )
  {
    if ( v5_FileGetDirEntry((unsigned __int8)i, i, 0, v4) == 118 )
    {
      Time = v7;
      v11 = v5GetTime(&Time);
      v1 = v5_TypeToString(v6);
      vexlog(-2, "file %24s: size %6d : type %s: time %s\n", v8, v5, (const char *)v1, v11);
    }
    else
    {
      vexlog(-2, "file entry error\n");
    }
  }
  return 0;
}
// 407462: using guessed type char var_1A[6];
// 407462: using guessed type char var_5B[7];
// 407462: using guessed type char anonymous_0[34];

//----- (00407573) --------------------------------------------------------
int v5_GetFdt()
{
  char v1[6]; // [esp+29h] [ebp-21Fh] BYREF
  unsigned __int8 v2; // [esp+2Fh] [ebp-219h]
  char v3[511]; // [esp+31h] [ebp-217h]
  int v4; // [esp+230h] [ebp-18h]
  int v5; // [esp+234h] [ebp-14h]
  int v6; // [esp+238h] [ebp-10h]
  int i; // [esp+23Ch] [ebp-Ch]

  if ( v5_FdtStatus((int)v1, v1) == 118 )
  {
    if ( v2 )
    {
      for ( i = 0; i < v2; ++i )
      {
        if ( v3[8 * i + 1] )
        {
          v6 = (*(_WORD *)&v3[8 * i + 3] >> 14) & 3;
          v5 = HIBYTE(*(_WORD *)&v3[8 * i + 3]) & 0x3F;
          v4 = (unsigned __int8)*(_WORD *)&v3[8 * i + 3];
          vexlog(-2, "%2d: %d.%d.%d.b%d\n", (unsigned __int8)v3[8 * i], v6, v5, v4, (unsigned __int8)v3[8 * i + 2]);
        }
      }
    }
    return 0;
  }
  else
  {
    vexlog(-2, "fdt error\n");
    return 1;
  }
}

//----- (0040768D) --------------------------------------------------------
BOOL __cdecl v5_LoadAndRun(unsigned __int8 a1, char *Source, char a3)
{
  char v3; // cl
  int v5[4]; // [esp+28h] [ebp-10h] BYREF

  if ( a3 )
    v3 = 0x80;
  else
    v3 = 0;
  return v5_FileLoadAndRun(a1, a1, v3, Source, v5) != 118;
}
// 40768D: using guessed type int var_10[4];

//----- (004076E2) --------------------------------------------------------
BOOL __cdecl v5_LoadAndRunSlot(unsigned __int8 a1, int a2, char a3)
{
  char v3; // cl
  char Buffer[32]; // [esp+28h] [ebp-30h] BYREF
  int v6[4]; // [esp+48h] [ebp-10h] BYREF

  if ( a2 <= 0 )
    a2 = 1;
  if ( a2 > 8 )
    a2 = 8;
  sprintf(Buffer, "___s_%02X.bin", a2 - 1);
  if ( a3 )
    v3 = 0x80;
  else
    v3 = 0;
  return v5_FileLoadAndRun(a1, a1, v3, Buffer, v6) != 118;
}
// 4076E2: using guessed type int var_10[4];

//----- (0040776E) --------------------------------------------------------
BOOL __cdecl v5_Erase(unsigned __int8 a1, char *Str)
{
  char v3; // cl
  char Buffer[4]; // [esp+2Ch] [ebp-2Ch] BYREF
  int v5; // [esp+30h] [ebp-28h]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+38h] [ebp-20h]
  int v8; // [esp+3Ch] [ebp-1Ch] BYREF
  int v9; // [esp+44h] [ebp-14h]
  char v10; // [esp+4Bh] [ebp-Dh]
  char *Source; // [esp+4Ch] [ebp-Ch]

  v10 = 1;
  if ( !Str )
    return 1;
  *(_DWORD *)Buffer = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  Source = Str;
  if ( strlen(Str) == 1 )
  {
    v9 = strtol(Str, 0, 0);
    if ( v9 <= 0 || v9 > 8 )
      return 1;
    sprintf(Buffer, "slot_%d.bin", v9);
    Source = Buffer;
  }
  if ( v10 )
    v3 = 0x80;
  else
    v3 = 0;
  return v5_FileErase(a1, a1, v3, Source, &v8) != 118 || v5_FileExit(118, 0, 0) != 118;
}

//----- (0040786F) --------------------------------------------------------
int __cdecl v5_SetRadioChannel(unsigned __int8 a1)
{
  int v2; // [esp+18h] [ebp-20h] BYREF
  _DWORD v3[2]; // [esp+20h] [ebp-18h] BYREF
  char v4; // [esp+2Ah] [ebp-Eh]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( !v5_SystemVersion(v3) )
    return 3;
  if ( !isV5ControllerProductId((int)v3) )
    return 0;
  if ( (v4 & 1) != 0 )
    return 0;
  if ( v5_FileCtrl(a1, 1, a1, &v2) == 118 )
  {
    for ( i = 0; i <= 4; ++i )
    {
      serialSleep(0xC8u);
      if ( !v5_SystemVersion(v3) )
        return 3;
      if ( (v4 & 2) != 0 )
        return 0;
      serialSleep(0x320u);
    }
  }
  return 1;
}
// 40786F: using guessed type _DWORD var_18[2];

//----- (0040793E) --------------------------------------------------------
int __cdecl v5_Download(
        char a1,
        char *Source,
        _BYTE *a3,
        int a4,
        unsigned __int8 a5,
        char a6,
        void (__cdecl *a7)(size_t, int))
{
  int v8; // eax
  unsigned __int16 v9; // ax
  int v10; // [esp+26h] [ebp-72h] BYREF
  unsigned __int16 v11; // [esp+2Ch] [ebp-6Ch]
  char Src[4]; // [esp+38h] [ebp-60h] BYREF
  int v13; // [esp+3Ch] [ebp-5Ch]
  int v14; // [esp+40h] [ebp-58h]
  int v15; // [esp+44h] [ebp-54h]
  unsigned int v16; // [esp+48h] [ebp-50h]
  int v17; // [esp+4Ch] [ebp-4Ch]
  int v18; // [esp+50h] [ebp-48h]
  char v19[24]; // [esp+54h] [ebp-44h] BYREF
  _DWORD v20[3]; // [esp+6Ch] [ebp-2Ch] BYREF
  size_t v21; // [esp+78h] [ebp-20h]
  int v22; // [esp+7Ch] [ebp-1Ch]
  void *v23; // [esp+80h] [ebp-18h]
  size_t v24; // [esp+84h] [ebp-14h]
  size_t Size; // [esp+88h] [ebp-10h]
  int v26; // [esp+8Ch] [ebp-Ch]

  v26 = 58720256;
  v22 = Crc32Generate(a3, a4, 0);
  if ( !v5_SystemAlive(0) )
    return 2;
  if ( !v5_SystemVersion(v20) )
    return 3;
  if ( !isV5ProtocolProductId((int)v20) )
    return 1;
  if ( isControllerProductId((int)v20) )
    serialSetTimeout((HANDLE *)g_serial, 2500);
  if ( isSlowEraseProductId((int)v20) )
  {
    serialSetTimeout((HANDLE *)g_serial, 20000);
    if ( a1 == -1 && isIq2ProductId((int)v20) )
    {
      v26 = 271581184;
    }
    else if ( a1 == -1 && isExpProductId((int)v20) )
    {
      v26 = 812646400;
    }
  }
  Src[0] = 1;
  Src[1] = a6;
  Src[2] = a1;
  Src[3] = 1;
  v13 = a4;
  v14 = v26;
  v15 = v22;
  v16 = v5_FileNameToType(Source);
  v17 = time(0) - 946684800;
  if ( dword_522EA4 )
    v8 = dword_522EA4;
  else
    v8 = 1;
  v18 = v8;
  strcpy(v19, Source);
  v5TransferTimer(0, 0, 0, byte_522EA2);
  if ( transferParams )
  {
    v26 = 117440512;
    v14 = 117440512;
    v16 = 1634625890;
  }
  else if ( byte_522EA1 )
  {
    v16 = 1936615778;
  }
  if ( v5_FileTransferInitialize((int)Src, Src, (int)&v10) != 118 )
    return 4;
  serialSleep(0x14u);
  if ( transferParams && v5_FileSetLinkedFile((unsigned __int8)transferParams, 64, 0, "python_vm.bin", 0) != 118 )
    return 4;
  v9 = v11;
  if ( v11 > 0x1000u )
    v9 = 4096;
  v21 = v9;
  v24 = a4;
  v23 = a3;
  if ( a7 )
    a7(0, a4);
  while ( (int)v24 > 0 )
  {
    if ( v21 >= v24 )
      Size = v24;
    else
      Size = v21;
    Size = (Size + 3) & 0xFFFFFFFC;
    if ( v5_FileDataWrite(v26, v26, v23, Size, 0) != 118 )
      return 4;
    v24 -= Size;
    v26 += Size;
    v23 = (char *)v23 + Size;
    if ( byte_522EA2 && !a7 )
    {
      vexlog(2, "\r%6d", a4 - v24);
      vexlogFlush();
    }
    if ( a7 )
      a7(a4 - v24, a4);
  }
  if ( !isSlowEraseProductId((int)v20) && !isControllerProductId((int)v20) )
    serialSetTimeout((HANDLE *)g_serial, 2000);
  if ( v5_FileExit(a5, a5, 0) != 118 && ((unsigned __int8)a1 <= 0xCu || !isV5ControllerProductId((int)v20)) )
    return 1;
  if ( a7 )
    a7(a4, a4);
  v5TransferTimer(1, a4, Source, byte_522EA2);
  serialSetTimeout((HANDLE *)g_serial, 500);
  return 0;
}
// 522EA0: using guessed type char transferParams;
// 522EA1: using guessed type char byte_522EA1;
// 522EA2: using guessed type char byte_522EA2;
// 522EA4: using guessed type int dword_522EA4;
// 40793E: using guessed type _DWORD var_2C[3];
// 40793E: using guessed type char anonymous_0[24];

//----- (00407D68) --------------------------------------------------------
int __cdecl v5_Upload(
        char a1,
        char *Source,
        void **a3,
        int *a4,
        unsigned __int8 a5,
        char a6,
        void (__cdecl *a7)(int, int))
{
  unsigned __int16 v8; // ax
  int v9; // [esp+2Ch] [ebp-7Ch] BYREF
  int v10; // [esp+32h] [ebp-76h] BYREF
  unsigned __int16 v11; // [esp+38h] [ebp-70h]
  int v12; // [esp+3Ah] [ebp-6Eh]
  int v13; // [esp+3Eh] [ebp-6Ah]
  char Src[4]; // [esp+44h] [ebp-64h] BYREF
  int v15; // [esp+48h] [ebp-60h]
  int v16; // [esp+4Ch] [ebp-5Ch]
  int v17; // [esp+50h] [ebp-58h]
  int v18; // [esp+54h] [ebp-54h]
  int v19; // [esp+58h] [ebp-50h]
  int v20; // [esp+5Ch] [ebp-4Ch]
  char v21[24]; // [esp+60h] [ebp-48h] BYREF
  _DWORD v22[3]; // [esp+78h] [ebp-30h] BYREF
  int v23; // [esp+84h] [ebp-24h]
  int v24; // [esp+88h] [ebp-20h]
  unsigned int v25; // [esp+8Ch] [ebp-1Ch]
  void *v26; // [esp+90h] [ebp-18h]
  int v27; // [esp+94h] [ebp-14h]
  unsigned int v28; // [esp+98h] [ebp-10h]
  int v29; // [esp+9Ch] [ebp-Ch]

  v29 = 0;
  if ( !v5_SystemAlive(0) )
    return 2;
  if ( !v5_SystemVersion(v22) )
    return 3;
  if ( !isV5ProtocolProductId((int)v22) )
    return 1;
  Src[0] = 2;
  Src[1] = a6;
  Src[2] = a1;
  Src[3] = 0;
  v15 = 0;
  v16 = v29;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  strcpy(v21, Source);
  v5TransferTimer(0, 0, 0, byte_522EA2);
  if ( v5_FileTransferInitialize((int)Src, Src, (int)&v10) != 118 )
    return 4;
  v8 = v11;
  if ( v11 > 0x1000u )
    v8 = 4096;
  v25 = v8;
  v27 = v12;
  if ( a6 == 2 )
    v27 = *a4;
  if ( v27 > 0x400000 )
    return 1;
  *a3 = malloc((v27 + 3) & 0xFFFFFFFC);
  v26 = *a3;
  v24 = v27;
  if ( a7 )
    a7(0, v24);
  while ( v27 > 0 )
  {
    if ( v25 >= v27 )
      v28 = v27;
    else
      v28 = v25;
    v28 = (v28 + 3) & 0xFFFFFFFC;
    if ( !v5_FileDataRead(v29, v29, v28, &v9, v26) )
      return 4;
    v27 -= v28;
    v29 += v28;
    v26 = (char *)v26 + v28;
    if ( a7 )
      a7(v24 - v27, v24);
  }
  v23 = Crc32Generate(*a3, v12, 0);
  if ( v23 == v13 )
    *a4 = v12;
  if ( v5_FileExit(a5, a5, 0) != 118 )
    return 4;
  if ( a7 )
    a7(v24, v24);
  v5TransferTimer(1, *a4, Source, byte_522EA2);
  return 0;
}
// 522EA2: using guessed type char byte_522EA2;
// 407D68: using guessed type _DWORD var_30[3];
// 407D68: using guessed type char anonymous_0[24];

//----- (0040803D) --------------------------------------------------------
int __cdecl v5_ScreenCapture(char *FileName)
{
  int v2; // eax
  _DWORD v3[3]; // [esp+2Ch] [ebp-2Ch] BYREF
  int v4; // [esp+38h] [ebp-20h] BYREF
  void *Block; // [esp+3Ch] [ebp-1Ch] BYREF
  int v6; // [esp+40h] [ebp-18h]
  int v7; // [esp+44h] [ebp-14h]
  int v8; // [esp+48h] [ebp-10h]
  int v9; // [esp+4Ch] [ebp-Ch]

  v9 = 480;
  v8 = 272;
  v7 = 512;
  v4 = 557056;
  v6 = 0;
  if ( !v5_SystemVersion(v3) )
    return 3;
  if ( isControllerProductId((int)v3) )
    return 1;
  if ( isIq2ProductId((int)v3) || isExpProductId((int)v3) )
  {
    v9 = 160;
    v8 = 128;
    v7 = 160;
    v6 = 1;
    v2 = 40960;
    v4 = 40960;
  }
  else if ( isGpsProductId((int)v3) )
  {
    v9 = 640;
    v8 = 400;
    v7 = 640;
    v6 = 2;
    v2 = 256000;
    v4 = 256000;
  }
  else
  {
    v2 = isTestProductId((int)v3);
    if ( (_BYTE)v2 )
    {
      v9 = 320;
      v8 = 240;
      v7 = 320;
      v6 = 1;
      v2 = 153600;
      v4 = 153600;
    }
  }
  if ( v5_SystemScreenCapture(v2) != 118 && !isGpsProductId((int)v3)
    || v5_Upload(1, "screen", &Block, &v4, 0, 2, 0)
    || !Block )
  {
    return 1;
  }
  writeImage(FileName, v9, v8, v7, (int)Block, v6);
  free(Block);
  return 0;
}
// 40803D: using guessed type _DWORD var_2C[3];

//----- (004081FD) --------------------------------------------------------
int __usercall v5_AutorunFlagSet@<eax>(int a1@<eax>, unsigned __int8 a2, char *Source, char a4)
{
  void *v4; // esp
  char *v5; // eax
  char Str[4096]; // [esp+30h] [ebp-1058h] BYREF
  size_t Size; // [esp+1030h] [ebp-58h] BYREF
  void *Src; // [esp+1034h] [ebp-54h] BYREF
  int v10[14]; // [esp+103Bh] [ebp-4Dh] BYREF
  int v11; // [esp+1074h] [ebp-14h]
  char *v12; // [esp+1078h] [ebp-10h]
  int v13; // [esp+107Ch] [ebp-Ch]

  v4 = alloca(a1);
  v13 = 1;
  if ( v5_FileMetadataGet(a2, a2, 0, Source, (int)v10) == 118 )
  {
    Src = 0;
    v5 = basename(Source);
    v13 = v5_Upload(1, v5, &Src, (int *)&Size, 0, 1, 0);
    if ( !v13 )
    {
      if ( (int)Size > 2048 )
        return 1;
      memset(Str, 0, sizeof(Str));
      memcpy(Str, Src, Size);
      free(Src);
      v12 = strstr(Str, "[options]");
      if ( v12 )
      {
        if ( *(v12 - 1) == 10 )
          --v12;
        *v12 = 0;
      }
      if ( a4 )
        strcat(Str, "\n[options]\nautorun      = \"true\"\n");
      v11 = strlen(Str);
      return v5_Download(1, Source, Str, v11, 0, 1, 0);
    }
  }
  return v13;
}
// 4081FD: using guessed type int var_4D[14];

//----- (00408403) --------------------------------------------------------
int v5_ReadUserData()
{
  int result; // eax
  _DWORD v1[3]; // [esp+13h] [ebp-15h] BYREF
  char v2; // [esp+1Fh] [ebp-9h]

  result = v5_SystemVersion(v1);
  if ( result )
  {
    v2 = isV5ControllerProductId((int)v1);
    serialReadUserData((int (__cdecl *)(char *, int, char *))v5_GetUserData, v2);
  }
  return result;
}
// 408403: using guessed type _DWORD var_15[3];

//----- (00408448) --------------------------------------------------------
int __cdecl iq2_GetControllerVersions(_DWORD *a1, _DWORD *a2)
{
  char v3[273]; // [esp+17h] [ebp-111h] BYREF

  if ( !a1 || !a2 )
    return 1;
  *a1 = 0;
  *a2 = 0;
  v5_Cdc2ExtCmdSet(88);
  if ( iq2_CtrlGetVersions((int)v3, v3) == 118 && (v5_Cdc2ExtCmdSet(0), v3[3] > 0xAu) )
  {
    *a1 = ((unsigned __int8)v3[7] << 8)
        + ((unsigned __int8)v3[6] << 16)
        + ((unsigned __int8)v3[5] << 24)
        + (unsigned __int8)v3[8];
    *a2 = ((unsigned __int8)v3[11] << 8)
        + ((unsigned __int8)v3[10] << 16)
        + ((unsigned __int8)v3[9] << 24)
        + (unsigned __int8)v3[12];
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (00408551) --------------------------------------------------------
int __cdecl iq2_GetControllerLocalPairId(_DWORD *a1)
{
  char v2[273]; // [esp+17h] [ebp-111h] BYREF

  if ( !a1 )
    return 1;
  *a1 = 0;
  v5_Cdc2ExtCmdSet(88);
  if ( iq2_CtrlGetInfo((int)v2, v2) == 118 && (v5_Cdc2ExtCmdSet(-1), v2[3] > 6u) )
  {
    *a1 = ((unsigned __int8)v2[6] << 8)
        + ((unsigned __int8)v2[7] << 16)
        + ((unsigned __int8)v2[8] << 24)
        + (unsigned __int8)v2[5];
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (00408603) --------------------------------------------------------
int __cdecl iq2_GetControllerRemotePairId(_DWORD *a1)
{
  char v2[273]; // [esp+17h] [ebp-111h] BYREF

  if ( !a1 )
    return 1;
  *a1 = 0;
  v5_Cdc2ExtCmdSet(88);
  if ( iq2_CtrlGetPairId((int)v2, v2) == 118 && (v5_Cdc2ExtCmdSet(-1), v2[3] > 6u) )
  {
    *a1 = ((unsigned __int8)v2[6] << 8)
        + ((unsigned __int8)v2[7] << 16)
        + ((unsigned __int8)v2[8] << 24)
        + (unsigned __int8)v2[5];
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (004086B5) --------------------------------------------------------
BOOL iq2_ControllerAtmelRadioBootloaderEntry()
{
  char v1[8]; // [esp+10h] [ebp-98h] BYREF
  int v2; // [esp+18h] [ebp-90h] BYREF
  char v3; // [esp+1Ch] [ebp-8Ch]
  DWORD nNumberOfBytesToWrite; // [esp+98h] [ebp-10h]
  int v5; // [esp+9Ch] [ebp-Ch]

  v2 = 399101098;
  v3 = 1;
  nNumberOfBytesToWrite = 5;
  v5 = v5_SendCommand((unsigned __int8 *)&v2, 5, v1, 5);
  return v5 != 5 || v1[4] != 118;
}

//----- (00408733) --------------------------------------------------------
BOOL iq2_ControllerAtmelRadioBootloaderExit()
{
  char v1[8]; // [esp+10h] [ebp-98h] BYREF
  int v2; // [esp+18h] [ebp-90h] BYREF
  char v3; // [esp+1Ch] [ebp-8Ch]
  DWORD nNumberOfBytesToWrite; // [esp+98h] [ebp-10h]
  int v5; // [esp+9Ch] [ebp-Ch]

  v2 = 399101098;
  v3 = 2;
  nNumberOfBytesToWrite = 5;
  v5 = v5_SendCommand((unsigned __int8 *)&v2, 5, v1, 5);
  return v5 != 5 || v1[4] != 118;
}

//----- (004087B1) --------------------------------------------------------
int iq2_ControllerAtmelCdcBootloaderEntry()
{
  int v1; // [esp+18h] [ebp-90h] BYREF
  char v2; // [esp+1Ch] [ebp-8Ch]
  DWORD nNumberOfBytesToWrite; // [esp+98h] [ebp-10h]

  v1 = 399101098;
  v2 = 3;
  nNumberOfBytesToWrite = 5;
  v5_SendCommand((unsigned __int8 *)&v1, 5, 0, 0);
  return 0;
}

//----- (00408813) --------------------------------------------------------
int __cdecl iq2_ControllerAtmelStatus(_BYTE *a1, _DWORD *a2)
{
  char v3[16]; // [esp+18h] [ebp-A0h] BYREF
  int v4; // [esp+28h] [ebp-90h] BYREF
  char v5; // [esp+2Ch] [ebp-8Ch]
  DWORD nNumberOfBytesToWrite; // [esp+A8h] [ebp-10h]
  int v7; // [esp+ACh] [ebp-Ch]

  if ( !a1 )
    return 1;
  v4 = 399101098;
  v5 = 4;
  nNumberOfBytesToWrite = 5;
  serialSetTimeout((HANDLE *)g_serial, 200);
  v7 = v5_SendCommand((unsigned __int8 *)&v4, 5, v3, 10);
  if ( v7 == 10 && v3[9] == 118 )
  {
    if ( a2 )
      *a2 = ((unsigned __int8)v3[6] << 8)
          + ((unsigned __int8)v3[5] << 16)
          + ((unsigned __int8)v3[4] << 24)
          + (unsigned __int8)v3[7];
    *a1 = v3[8];
    serialSetTimeout((HANDLE *)g_serial, 500);
    return 0;
  }
  else
  {
    serialSetTimeout((HANDLE *)g_serial, 500);
    return 1;
  }
}

//----- (00408932) --------------------------------------------------------
int __cdecl v5_ControllerVersionsGet(void *a1)
{
  v5_Cdc2ExtCmdSet(88);
  if ( v5_CtrlVersionsGet((int)a1, a1) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (0040897A) --------------------------------------------------------
int __cdecl v5_ControllerVersionsExpectGet(void *a1)
{
  v5_Cdc2ExtCmdSet(88);
  if ( v5_CtrlVersionsExpectGet((int)a1, a1) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (004089C2) --------------------------------------------------------
int __cdecl v5_ControllerEraseFlash(int a1, int a2)
{
  v5_Cdc2ExtCmdSet(88);
  serialSetTimeout((HANDLE *)g_serial, 4000);
  if ( v5_CtrlEraseFlash(a1, a1, a2) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    serialSetTimeout((HANDLE *)g_serial, 500);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    serialSetTimeout((HANDLE *)g_serial, 500);
    return 1;
  }
}

//----- (00408A53) --------------------------------------------------------
int __cdecl v5_ControllerWriteFlash(int a1, void *Src, int a3, unsigned __int8 a4)
{
  v5_Cdc2ExtCmdSet(88);
  if ( v5_CtrlWriteFlash(a1, a1, Src, a3, a4) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (00408AC0) --------------------------------------------------------
int __cdecl v5_ControllerValidateFlash(int a1, int a2, int a3, int a4, int a5)
{
  v5_Cdc2ExtCmdSet(88);
  if ( v5_CtrlValidateFlash(a1, a1, a2, a3, a4, a5) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (00408B27) --------------------------------------------------------
int v5_ControllerForceRadioUpdate()
{
  int v0; // eax

  v0 = v5_Cdc2ExtCmdSet(88);
  if ( v5_CtrlForceRadioUpdate(v0) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (00408B6C) --------------------------------------------------------
int __cdecl v5_ControllerRadioInfo(void *a1)
{
  v5_Cdc2ExtCmdSet(88);
  if ( v5_CtrlRadioInfoGet((int)a1, a1) == 118 )
  {
    v5_Cdc2ExtCmdSet(-1);
    return 0;
  }
  else
  {
    v5_Cdc2ExtCmdSet(-1);
    return 1;
  }
}

//----- (00408BB4) --------------------------------------------------------
int __cdecl v5_DownloadPythonVm(int a1, char *FileName, char a3, unsigned __int8 a4)
{
  char v5[28]; // [esp+30h] [ebp-428h] BYREF
  int v6; // [esp+4Ch] [ebp-40Ch] BYREF
  int v7[2]; // [esp+430h] [ebp-28h] BYREF
  int v8; // [esp+438h] [ebp-20h]
  int file; // [esp+43Ch] [ebp-1Ch]
  int *v10; // [esp+440h] [ebp-18h]
  char *v11; // [esp+444h] [ebp-14h]
  int v12; // [esp+448h] [ebp-10h]
  int v13; // [esp+44Ch] [ebp-Ch]

  v13 = 1;
  v12 = 0;
  if ( a4 )
  {
    v12 = (int)v5_FileTransferProgress;
    v5_FileTransferMetadata("download", "python", (char *)a4);
  }
  if ( FileName )
  {
    v7[0] = 0;
    file = 0;
    file = read_file(FileName, (void **)v7);
    if ( v7[0] && file > 1024 )
    {
      v11 = (char *)v7[0];
      v10 = (int *)(v7[0] + 28);
      v8 = v7[0];
      if ( *(_BYTE *)v7[0] == 31 && *(_BYTE *)(v8 + 1) == 0x8B )
      {
        v7[1] = V5_GzipInflateBuffer(v7[0], 512, (int)v5, 1024, 0);
        v11 = v5;
        v10 = &v6;
      }
      v5_TransferParameterSet(0, 0, a3, *v10);
      if ( isV5ProductId(a1) && *(_DWORD *)v11 == 894981720 )
      {
        return v5_Download(64, "python_vm.bin", (_BYTE *)v7[0], file, 1u, 1, (void (__cdecl *)(size_t, int))v12);
      }
      else if ( isIq2ProductId(a1) && *(_DWORD *)v11 == 844191320 || isExpProductId(a1) && *(_DWORD *)v11 == 1163417176 )
      {
        return v5_Download(255, "python_vm.bin", (_BYTE *)v7[0], file, 1u, 6, (void (__cdecl *)(size_t, int))v12);
      }
    }
  }
  else if ( isV5ProductId(a1) )
  {
    v5_TransferParameterSet(0, 0, a3, _python_vm_version);
    return v5_Download(64, "python_vm.bin", _python_vm, 180047, 1u, 1, (void (__cdecl *)(size_t, int))v12);
  }
  else if ( isIq2ProductId(a1) )
  {
    return v5_Download(255, "python_vm.bin", _python_vm_iq2, 215941, 1u, 6, (void (__cdecl *)(size_t, int))v12);
  }
  else if ( isExpProductId(a1) )
  {
    return v5_Download(255, "python_vm.bin", _python_vm_exp, 248781, 1u, 6, (void (__cdecl *)(size_t, int))v12);
  }
  return v13;
}
// 44C420: using guessed type int _python_vm_version;
// 44C440: using guessed type _BYTE _python_vm[3543];

//----- (00408F20) --------------------------------------------------------
int __cdecl v5_VerboseCommsSet(unsigned __int8 a1)
{
  int result; // eax

  result = a1;
  bVerboseComms = a1;
  return result;
}
// 522EA8: using guessed type char bVerboseComms;

//----- (00408F38) --------------------------------------------------------
int v5_VerboseCommsGet()
{
  return (unsigned __int8)bVerboseComms;
}
// 522EA8: using guessed type char bVerboseComms;

//----- (00408F40) --------------------------------------------------------
int __cdecl v5_Cdc2TargetSet(int a1)
{
  int result; // eax

  result = a1;
  cdc2Target = a1;
  return result;
}
// 522EAC: using guessed type int cdc2Target;

//----- (00408F4E) --------------------------------------------------------
int __cdecl v5_Cdc2ExtCmdSet(int a1)
{
  int result; // eax

  if ( a1 >= 0 )
  {
    cdc2ExtCmdLast = cdc2ExtCmd;
    result = a1;
    cdc2ExtCmd = a1;
  }
  else
  {
    result = cdc2ExtCmdLast;
    cdc2ExtCmd = cdc2ExtCmdLast;
  }
  return result;
}
// 522EB0: using guessed type int cdc2ExtCmd;
// 522EB4: using guessed type int cdc2ExtCmdLast;

//----- (00408F78) --------------------------------------------------------
int *__cdecl v5_TypeToString(int a1)
{
  str_6644 = a1;
  byte_522EBC = 0;
  return &str_6644;
}
// 522EB8: using guessed type int str_6644;
// 522EBC: using guessed type char byte_522EBC;

//----- (00408FB2) --------------------------------------------------------
int __cdecl v5_StringToType(char *a1)
{
  return (a1[3] << 24) + ((a1[2] << 16) & 0xFF0000) + (unsigned __int16)(a1[1] << 8) + (unsigned __int8)*a1;
}

//----- (0040901D) --------------------------------------------------------
unsigned int __cdecl v5_FileNameToType(char *Str)
{
  char *v2; // [esp+14h] [ebp-14h]
  _BYTE *v3; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = 0;
  v2 = strchr(Str, 46);
  if ( v2 )
  {
    v3 = v2 + 1;
    for ( i = 0; i <= 3; ++i )
    {
      v5 = (v5 >> 8) | ((char)*v3 << 24);
      if ( *v3 )
        ++v3;
    }
  }
  return v5;
}

//----- (00409089) --------------------------------------------------------
int __cdecl v5_SendCommand(unsigned __int8 *a1, signed int nNumberOfBytesToWrite, char *a3, int Size)
{
  unsigned __int8 v5; // [esp+17h] [ebp-21h]
  int j; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v7; // [esp+22h] [ebp-16h]
  int i; // [esp+24h] [ebp-14h]
  unsigned __int8 *v9; // [esp+28h] [ebp-10h]
  signed int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+2Ch] [ebp-Ch]

  v10 = 0;
  if ( g_serial )
  {
    if ( !g_quietmode && bVerboseComms )
    {
      printf("TX (%4d):", nNumberOfBytesToWrite);
      for ( i = 0; i < nNumberOfBytesToWrite && i <= 47; ++i )
        printf("%02X ", a1[i]);
      putchar(10);
    }
    serialFlush((HANDLE *)g_serial);
    if ( a3 && Size > 0 )
      memset(a3, 0, Size);
    if ( !serialWrite((HANDLE *)g_serial, a1, nNumberOfBytesToWrite) )
    {
      if ( !a3 )
        return 0;
      if ( serialRead((HANDLE *)g_serial, a3, 4u) )
        return 0;
      v5 = a3[2];
      v7 = (unsigned __int8)a3[3];
      v9 = (unsigned __int8 *)(a3 + 4);
      v11 = 4;
      if ( v5 == 86 && (v7 & 0x80) != 0 )
      {
        if ( serialRead((HANDLE *)g_serial, v9, 1u) )
          return 0;
        v7 = ((v7 << 8) & 0x7F00) + *v9;
        v9 = (unsigned __int8 *)(a3 + 5);
        v11 = 5;
      }
      if ( v7 > (unsigned int)(Size - 4) )
      {
        vexerr(255, "rx buffer size error %d %d\n", v7, Size - 4);
        return 0;
      }
      if ( serialRead((HANDLE *)g_serial, v9, v7) )
        return 0;
      v10 = v7 + v11;
      if ( v5 == 86 && (unsigned __int16)Crc16Generate(a3, v10, 0) )
        return 0;
      if ( !g_quietmode && bVerboseComms )
      {
        printf("RX (%4d):", v10);
        for ( j = 0; j < v10 && j <= 95; ++j )
          printf("%02X ", (unsigned __int8)a3[j]);
        putchar(10);
      }
    }
  }
  return v10;
}
// 44BF70: using guessed type int g_quietmode;
// 522EA8: using guessed type char bVerboseComms;

//----- (00409345) --------------------------------------------------------
int __cdecl v5_SimpleMessage(char a1, int a2)
{
  int result; // eax

  *(_BYTE *)a2 = -55;
  *(_BYTE *)(a2 + 1) = 54;
  *(_BYTE *)(a2 + 2) = -72;
  *(_BYTE *)(a2 + 3) = 71;
  *(_BYTE *)(a2 + 4) = a1;
  result = a2;
  *(_DWORD *)(a2 + 128) = 5;
  return result;
}

//----- (00409386) --------------------------------------------------------
int __cdecl v5_SystemAlive(int a1)
{
  int v2[3]; // [esp+1Ah] [ebp-9Eh] BYREF
  __int16 v3; // [esp+26h] [ebp-92h]
  int v4[33]; // [esp+28h] [ebp-90h] BYREF
  int v5; // [esp+ACh] [ebp-Ch]

  v5_SimpleMessage(33, (int)v4);
  v5 = v5_SendCommand((unsigned __int8 *)v4, v4[32], (char *)v2, 14);
  if ( v5 == 14 && a1 )
  {
    *(_DWORD *)a1 = v2[0];
    *(_DWORD *)(a1 + 4) = v2[1];
    *(_DWORD *)(a1 + 8) = v2[2];
    *(_WORD *)(a1 + 12) = v3;
  }
  return v5;
}

//----- (0040940A) --------------------------------------------------------
int __cdecl v5_SystemVersion(_DWORD *a1)
{
  int v2[3]; // [esp+1Ch] [ebp-9Ch] BYREF
  int v3[33]; // [esp+28h] [ebp-90h] BYREF
  int v4; // [esp+ACh] [ebp-Ch]

  v5_SimpleMessage(164, (int)v3);
  v4 = v5_SendCommand((unsigned __int8 *)v3, v3[32], (char *)v2, 12);
  if ( v4 == 12 && a1 )
  {
    *a1 = v2[0];
    a1[1] = v2[1];
    a1[2] = v2[2];
  }
  return v4;
}

//----- (00409483) --------------------------------------------------------
int __cdecl v5_ExtendedMessage(char a1, int a2, void *Src, int Size)
{
  char v5; // dl
  __int16 v6; // ax
  int v7; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  if ( (unsigned int)Size > 0x2000 )
    return 0;
  *(_BYTE *)a2 = -55;
  *(_BYTE *)(a2 + 1) = 54;
  *(_BYTE *)(a2 + 2) = -72;
  *(_BYTE *)(a2 + 3) = cdc2Target + 71;
  if ( cdc2ExtCmd )
    v5 = cdc2ExtCmd;
  else
    v5 = 86;
  *(_BYTE *)(a2 + 4) = v5;
  *(_BYTE *)(a2 + 5) = a1;
  if ( Size > 127 )
  {
    *(_BYTE *)(a2 + 6) = BYTE1(Size) | 0x80;
    *(_BYTE *)(a2 + 7) = Size;
    v7 = 1;
  }
  else
  {
    *(_BYTE *)(a2 + 6) = Size;
  }
  if ( Src )
  {
    if ( Size > 0 )
    {
      memcpy((void *)(a2 + v7 + 7), Src, Size);
      v7 += Size;
    }
  }
  v6 = Crc16Generate((_BYTE *)a2, v7 + 7, 0);
  *(_BYTE *)(a2 + v7 + 7) = HIBYTE(v6);
  *(_BYTE *)(a2 + v7 + 1 + 7) = v6;
  *(_DWORD *)(a2 + 8203) = v7 + 9;
  return *(_DWORD *)(a2 + 8203);
}
// 522EAC: using guessed type int cdc2Target;
// 522EB0: using guessed type int cdc2ExtCmd;

//----- (004095C6) --------------------------------------------------------
int __usercall v5_FileCtrl@<eax>(int a1@<eax>, char a2, char a3, _DWORD *a4)
{
  void *v4; // esp
  int v5; // edx
  int v7; // [esp+23h] [ebp-2025h] BYREF
  int v8; // [esp+27h] [ebp-2021h]
  char Src[2]; // [esp+2Bh] [ebp-201Dh] BYREF
  _BYTE v10[8207]; // [esp+2Dh] [ebp-201Bh] BYREF
  int v11; // [esp+203Ch] [ebp-Ch]

  v4 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  v5_ExtendedMessage(16, (int)v10, Src, 2);
  v11 = v5_SendCommand(v10, *(signed int *)&v10[8203], (char *)&v7, 8);
  if ( v11 == 8 )
  {
    if ( a4 )
    {
      v5 = v8;
      *a4 = v7;
      a4[1] = v5;
    }
  }
  else
  {
    BYTE1(v8) = -1;
  }
  return BYTE1(v8);
}

//----- (0040968A) --------------------------------------------------------
int __usercall v5_FileTransferInitialize@<eax>(int a1@<eax>, void *Src, int a3)
{
  void *v3; // esp
  int v5; // [esp+1Bh] [ebp-202Dh] BYREF
  int v6; // [esp+1Fh] [ebp-2029h]
  int v7; // [esp+23h] [ebp-2025h]
  int v8; // [esp+27h] [ebp-2021h]
  __int16 v9; // [esp+2Bh] [ebp-201Dh]
  _BYTE v10[8207]; // [esp+2Dh] [ebp-201Bh] BYREF
  int v11; // [esp+203Ch] [ebp-Ch]

  v3 = alloca(a1);
  if ( !Src )
    return 255;
  v5_ExtendedMessage(17, (int)v10, Src, 52);
  v11 = v5_SendCommand(v10, *(signed int *)&v10[8203], (char *)&v5, 18);
  if ( v11 == 18 )
  {
    if ( a3 )
    {
      *(_DWORD *)a3 = v5;
      *(_DWORD *)(a3 + 4) = v6;
      *(_DWORD *)(a3 + 8) = v7;
      *(_DWORD *)(a3 + 12) = v8;
      *(_WORD *)(a3 + 16) = v9;
    }
  }
  else
  {
    BYTE1(v6) = -1;
  }
  return BYTE1(v6);
}

//----- (0040974C) --------------------------------------------------------
int __usercall v5_FileExit@<eax>(int a1@<eax>, char a2, _DWORD *a3)
{
  void *v3; // esp
  int v4; // edx
  int v6; // [esp+24h] [ebp-2024h] BYREF
  int v7; // [esp+28h] [ebp-2020h]
  char Src; // [esp+2Ch] [ebp-201Ch] BYREF
  _BYTE v9[8207]; // [esp+2Dh] [ebp-201Bh] BYREF
  int v10; // [esp+203Ch] [ebp-Ch]

  v3 = alloca(a1);
  Src = a2;
  v5_ExtendedMessage(18, (int)v9, &Src, 1);
  v10 = v5_SendCommand(v9, *(signed int *)&v9[8203], (char *)&v6, 8);
  if ( v10 == 8 )
  {
    if ( a3 )
    {
      v4 = v7;
      *a3 = v6;
      a3[1] = v4;
    }
  }
  else
  {
    BYTE1(v7) = -1;
  }
  return BYTE1(v7);
}

//----- (004097FA) --------------------------------------------------------
int __usercall v5_FileDataWrite@<eax>(int a1@<eax>, int a2, void *Src, size_t Size, _DWORD *a5)
{
  void *v5; // esp
  int v6; // edx
  int v8; // [esp+11h] [ebp-4027h] BYREF
  int v9; // [esp+15h] [ebp-4023h]
  int v10; // [esp+19h] [ebp-401Fh] BYREF
  _BYTE v11[3]; // [esp+1Dh] [ebp-401Bh] BYREF
  _BYTE v12[8207]; // [esp+201Dh] [ebp-201Bh] BYREF
  int v13; // [esp+402Ch] [ebp-Ch]

  v5 = alloca(a1);
  v10 = a2;
  memcpy(v11, Src, Size);
  v5_ExtendedMessage(19, (int)v12, &v10, Size + 4);
  v13 = v5_SendCommand(v12, *(signed int *)&v12[8203], (char *)&v8, 8);
  if ( v13 == 8 )
  {
    if ( a5 )
    {
      v6 = v9;
      *a5 = v8;
      a5[1] = v6;
    }
  }
  else
  {
    BYTE1(v9) = -1;
  }
  return BYTE1(v9);
}

//----- (004098BC) --------------------------------------------------------
unsigned int __usercall v5_FileDataRead@<eax>(int a1@<eax>, int a2, unsigned __int16 a3, _DWORD *a4, void *a5)
{
  void *v5; // esp
  char v7[8196]; // [esp+2Fh] [ebp-4029h] BYREF
  int Src; // [esp+2033h] [ebp-2025h] BYREF
  unsigned __int16 v9; // [esp+2037h] [ebp-2021h]
  _BYTE v10[8207]; // [esp+2039h] [ebp-201Fh] BYREF
  int v11; // [esp+4048h] [ebp-10h]
  unsigned int v12; // [esp+404Ch] [ebp-Ch]

  v5 = alloca(a1);
  Src = a2;
  v9 = a3;
  v5_ExtendedMessage(20, (int)v10, &Src, 6);
  v12 = v5_SendCommand(v10, *(signed int *)&v10[8203], v7, a3 + 12);
  if ( v12 <= 5 )
    return 0;
  v11 = 1;
  if ( v7[3] < 0 )
    ++v11;
  if ( a4 )
    *a4 = *(_DWORD *)&v7[v11 + 4];
  if ( a5 )
    memcpy(a5, &v7[v11 + 8], a3);
  return v12;
}

//----- (004099BC) --------------------------------------------------------
int __usercall v5_FileSetLinkedFile@<eax>(int a1@<eax>, char a2, char a3, char *Source, _DWORD *a5)
{
  void *v5; // esp
  int v6; // edx
  int v8; // [esp+2Bh] [ebp-203Dh] BYREF
  int v9; // [esp+2Fh] [ebp-2039h]
  char Src[2]; // [esp+33h] [ebp-2035h] BYREF
  char v11[24]; // [esp+35h] [ebp-2033h] BYREF
  _BYTE v12[8207]; // [esp+4Dh] [ebp-201Bh] BYREF
  int v13; // [esp+205Ch] [ebp-Ch]

  v5 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  strncpy(v11, Source, 0x17u);
  v11[23] = 0;
  v5_ExtendedMessage(21, (int)v12, Src, 26);
  v13 = v5_SendCommand(v12, *(signed int *)&v12[8203], (char *)&v8, 8);
  if ( v13 == 8 )
  {
    if ( a5 )
    {
      v6 = v9;
      *a5 = v8;
      a5[1] = v6;
    }
  }
  else
  {
    BYTE1(v9) = -1;
  }
  return BYTE1(v9);
}

//----- (00409AA7) --------------------------------------------------------
int __usercall v5_FileGetDirCount@<eax>(int a1@<eax>, char a2, char a3, int a4)
{
  void *v4; // esp
  int v6; // [esp+21h] [ebp-2027h] BYREF
  int v7; // [esp+25h] [ebp-2023h]
  __int16 v8; // [esp+29h] [ebp-201Fh]
  char Src[2]; // [esp+2Bh] [ebp-201Dh] BYREF
  _BYTE v10[8207]; // [esp+2Dh] [ebp-201Bh] BYREF
  int v11; // [esp+203Ch] [ebp-Ch]

  v4 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  v5_ExtendedMessage(22, (int)v10, Src, 2);
  v11 = v5_SendCommand(v10, *(signed int *)&v10[8203], (char *)&v6, 10);
  if ( v11 == 10 )
  {
    if ( a4 )
    {
      *(_DWORD *)a4 = v6;
      *(_DWORD *)(a4 + 4) = v7;
      *(_WORD *)(a4 + 8) = v8;
    }
  }
  else
  {
    BYTE1(v7) = -1;
  }
  return BYTE1(v7);
}

//----- (00409B76) --------------------------------------------------------
int __usercall v5_FileGetDirEntry@<eax>(int a1@<eax>, char a2, char a3, void *a4)
{
  void *v4; // esp
  char Src[5]; // [esp+2Ah] [ebp-205Eh] BYREF
  unsigned __int8 v7; // [esp+2Fh] [ebp-2059h]
  char v8[2]; // [esp+6Bh] [ebp-201Dh] BYREF
  _BYTE v9[8207]; // [esp+6Dh] [ebp-201Bh] BYREF
  size_t Size; // [esp+207Ch] [ebp-Ch]

  v4 = alloca(a1);
  v8[0] = a2;
  v8[1] = a3;
  v5_ExtendedMessage(23, (int)v9, v8, 2);
  Size = v5_SendCommand(v9, *(signed int *)&v9[8203], Src, 65);
  if ( (int)Size <= 0 || Size > 0x41 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a4 )
  {
    memcpy(a4, Src, Size);
  }
  return v7;
}

//----- (00409C4A) --------------------------------------------------------
int __usercall v5_FileLoadAndRun@<eax>(int a1@<eax>, char a2, char a3, char *Source, _DWORD *a5)
{
  void *v5; // esp
  int v6; // edx
  int v8; // [esp+2Bh] [ebp-203Dh] BYREF
  int v9; // [esp+2Fh] [ebp-2039h]
  char Src[2]; // [esp+33h] [ebp-2035h] BYREF
  char v11[24]; // [esp+35h] [ebp-2033h] BYREF
  _BYTE v12[8207]; // [esp+4Dh] [ebp-201Bh] BYREF
  int v13; // [esp+205Ch] [ebp-Ch]

  v5 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  strncpy(v11, Source, 0x17u);
  v11[23] = 0;
  v5_ExtendedMessage(24, (int)v12, Src, 26);
  v13 = v5_SendCommand(v12, *(signed int *)&v12[8203], (char *)&v8, 8);
  if ( v13 == 8 )
  {
    if ( a5 )
    {
      v6 = v9;
      *a5 = v8;
      a5[1] = v6;
    }
  }
  else
  {
    BYTE1(v9) = -1;
  }
  return BYTE1(v9);
}

//----- (00409D35) --------------------------------------------------------
int __usercall v5_FileMetadataGet@<eax>(int a1@<eax>, char a2, char a3, char *Source, int a5)
{
  void *v5; // esp
  int v7; // [esp+2Ah] [ebp-206Eh] BYREF
  int v8; // [esp+2Eh] [ebp-206Ah]
  int v9; // [esp+32h] [ebp-2066h]
  int v10; // [esp+36h] [ebp-2062h]
  int v11; // [esp+3Ah] [ebp-205Eh]
  int v12; // [esp+3Eh] [ebp-205Ah]
  int v13; // [esp+42h] [ebp-2056h]
  int v14; // [esp+46h] [ebp-2052h]
  int v15; // [esp+4Ah] [ebp-204Eh]
  int v16; // [esp+4Eh] [ebp-204Ah]
  int v17; // [esp+52h] [ebp-2046h]
  int v18; // [esp+56h] [ebp-2042h]
  int v19; // [esp+5Ah] [ebp-203Eh]
  int v20; // [esp+5Eh] [ebp-203Ah]
  char v21; // [esp+62h] [ebp-2036h]
  char Src[2]; // [esp+63h] [ebp-2035h] BYREF
  char v23[24]; // [esp+65h] [ebp-2033h] BYREF
  _BYTE v24[8207]; // [esp+7Dh] [ebp-201Bh] BYREF
  int v25; // [esp+208Ch] [ebp-Ch]

  v5 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  strncpy(v23, Source, 0x17u);
  v23[23] = 0;
  v5_ExtendedMessage(25, (int)v24, Src, 26);
  v25 = v5_SendCommand(v24, *(signed int *)&v24[8203], (char *)&v7, 57);
  if ( v25 == 57 )
  {
    if ( a5 )
    {
      *(_DWORD *)a5 = v7;
      *(_DWORD *)(a5 + 4) = v8;
      *(_DWORD *)(a5 + 8) = v9;
      *(_DWORD *)(a5 + 12) = v10;
      *(_DWORD *)(a5 + 16) = v11;
      *(_DWORD *)(a5 + 20) = v12;
      *(_DWORD *)(a5 + 24) = v13;
      *(_DWORD *)(a5 + 28) = v14;
      *(_DWORD *)(a5 + 32) = v15;
      *(_DWORD *)(a5 + 36) = v16;
      *(_DWORD *)(a5 + 40) = v17;
      *(_DWORD *)(a5 + 44) = v18;
      *(_DWORD *)(a5 + 48) = v19;
      *(_DWORD *)(a5 + 52) = v20;
      *(_BYTE *)(a5 + 56) = v21;
    }
  }
  else
  {
    BYTE1(v8) = -1;
  }
  return BYTE1(v8);
}

//----- (00409E9E) --------------------------------------------------------
int __usercall v5_FileMetadataSet@<eax>(int a1@<eax>, char a2, char a3, char *Source, int a5, _DWORD *a6)
{
  void *v6; // esp
  int v7; // edx
  int v9; // [esp+2Bh] [ebp-204Dh] BYREF
  int v10; // [esp+2Fh] [ebp-2049h]
  char Src[2]; // [esp+33h] [ebp-2045h] BYREF
  int v12; // [esp+35h] [ebp-2043h]
  int v13; // [esp+39h] [ebp-203Fh]
  int v14; // [esp+3Dh] [ebp-203Bh]
  int v15; // [esp+41h] [ebp-2037h]
  char v16[24]; // [esp+45h] [ebp-2033h] BYREF
  _BYTE v17[8207]; // [esp+5Dh] [ebp-201Bh] BYREF
  int v18; // [esp+206Ch] [ebp-Ch]

  v6 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  strncpy(v16, Source, 0x17u);
  v16[23] = 0;
  v12 = *(_DWORD *)(a5 + 2);
  v13 = *(_DWORD *)(a5 + 6);
  v14 = *(_DWORD *)(a5 + 10);
  v15 = *(_DWORD *)(a5 + 14);
  v5_ExtendedMessage(26, (int)v17, Src, 42);
  v18 = v5_SendCommand(v17, *(signed int *)&v17[8203], (char *)&v9, 8);
  if ( v18 == 8 )
  {
    if ( a6 )
    {
      v7 = v10;
      *a6 = v9;
      a6[1] = v7;
    }
  }
  else
  {
    BYTE1(v10) = -1;
  }
  return BYTE1(v10);
}

//----- (00409FB9) --------------------------------------------------------
int __usercall v5_FileErase@<eax>(int a1@<eax>, char a2, char a3, char *Source, _DWORD *a5)
{
  void *v5; // esp
  int v6; // edx
  int v8; // [esp+2Bh] [ebp-203Dh] BYREF
  int v9; // [esp+2Fh] [ebp-2039h]
  char Src[2]; // [esp+33h] [ebp-2035h] BYREF
  char v11[24]; // [esp+35h] [ebp-2033h] BYREF
  _BYTE v12[8207]; // [esp+4Dh] [ebp-201Bh] BYREF
  int v13; // [esp+205Ch] [ebp-Ch]

  v5 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  strncpy(v11, Source, 0x17u);
  v11[23] = 0;
  v5_ExtendedMessage(27, (int)v12, Src, 26);
  v13 = v5_SendCommand(v12, *(signed int *)&v12[8203], (char *)&v8, 8);
  if ( v13 == 8 )
  {
    if ( a5 )
    {
      v6 = v9;
      *a5 = v8;
      a5[1] = v6;
    }
  }
  else
  {
    BYTE1(v9) = -1;
  }
  return BYTE1(v9);
}

//----- (0040A0A4) --------------------------------------------------------
int __usercall v5_SystemStatus@<eax>(int a1@<eax>, int a2)
{
  void *v2; // esp
  int v4; // [esp+1Eh] [ebp-202Ah] BYREF
  int v5; // [esp+22h] [ebp-2026h]
  int v6; // [esp+26h] [ebp-2022h]
  __int16 v7; // [esp+2Ah] [ebp-201Eh]
  char v8; // [esp+2Ch] [ebp-201Ch]
  _BYTE v9[8207]; // [esp+2Dh] [ebp-201Bh] BYREF
  int v10; // [esp+203Ch] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(32, (int)v9, 0, 0);
  v10 = v5_SendCommand(v9, *(signed int *)&v9[8203], (char *)&v4, 15);
  if ( v10 == 15 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = v4;
      *(_DWORD *)(a2 + 4) = v5;
      *(_DWORD *)(a2 + 8) = v6;
      *(_WORD *)(a2 + 12) = v7;
      *(_BYTE *)(a2 + 14) = v8;
    }
  }
  else
  {
    BYTE1(v5) = -1;
  }
  return BYTE1(v5);
}

//----- (0040A158) --------------------------------------------------------
int __usercall v5_DeviceStatus@<eax>(int a1@<eax>, char *a2)
{
  void *v2; // esp
  int Src; // [esp+19h] [ebp-281Fh] BYREF
  char v5; // [esp+1Eh] [ebp-281Ah]
  char v6; // [esp+1Fh] [ebp-2819h]
  int v7; // [esp+20h] [ebp-2818h] BYREF
  _BYTE v8[8207]; // [esp+81Dh] [ebp-201Bh] BYREF
  size_t Size; // [esp+282Ch] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(33, (int)v8, 0, 0);
  Size = v5_SendCommand(v8, *(signed int *)&v8[8203], (char *)&Src, 2052);
  if ( (int)Size <= 0 || Size > 0x109 )
  {
    a2[5] = -1;
  }
  else if ( a2 )
  {
    if ( Src >= 0 )
    {
      memcpy(a2, &Src, Size);
    }
    else
    {
      *(_DWORD *)a2 = Src;
      a2[4] = v5;
      a2[5] = v6;
      memcpy(a2 + 6, &v7, Size - 6);
    }
  }
  return (unsigned __int8)a2[5];
}

//----- (0040A25D) --------------------------------------------------------
int __usercall v5_BrainStatus@<eax>(int a1@<eax>, int a2)
{
  void *v2; // esp
  int v4; // [esp+1Ch] [ebp-204Ch] BYREF
  int v5; // [esp+20h] [ebp-2048h]
  int v6; // [esp+24h] [ebp-2044h]
  int v7; // [esp+28h] [ebp-2040h]
  int v8; // [esp+2Ch] [ebp-203Ch]
  int v9; // [esp+30h] [ebp-2038h]
  int v10; // [esp+34h] [ebp-2034h]
  int v11; // [esp+38h] [ebp-2030h]
  int v12; // [esp+3Ch] [ebp-202Ch]
  int v13; // [esp+40h] [ebp-2028h]
  int v14; // [esp+44h] [ebp-2024h]
  char v15; // [esp+48h] [ebp-2020h]
  _BYTE v16[8211]; // [esp+49h] [ebp-201Fh] BYREF
  int v17; // [esp+205Ch] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(34, (int)v16, 0, 0);
  v17 = v5_SendCommand(v16, *(signed int *)&v16[8203], (char *)&v4, 45);
  if ( v17 == 45 || v17 == 41 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = v4;
      *(_DWORD *)(a2 + 4) = v5;
      *(_DWORD *)(a2 + 8) = v6;
      *(_DWORD *)(a2 + 12) = v7;
      *(_DWORD *)(a2 + 16) = v8;
      *(_DWORD *)(a2 + 20) = v9;
      *(_DWORD *)(a2 + 24) = v10;
      *(_DWORD *)(a2 + 28) = v11;
      *(_DWORD *)(a2 + 32) = v12;
      *(_DWORD *)(a2 + 36) = v13;
      *(_DWORD *)(a2 + 40) = v14;
      *(_BYTE *)(a2 + 44) = v15;
      if ( v17 == 41 )
      {
        *(_DWORD *)&v16[8207] = a2;
        *(_WORD *)(a2 + 43) = *(_WORD *)(a2 + 39);
        memset((void *)(a2 + 39), 0, 4u);
      }
    }
  }
  else
  {
    BYTE1(v5) = -1;
  }
  return BYTE1(v5);
}

//----- (0040A397) --------------------------------------------------------
int __usercall v5_FdtStatus@<eax>(int a1@<eax>, char *a2)
{
  void *v2; // esp
  int Src; // [esp+19h] [ebp-281Fh] BYREF
  char v5; // [esp+1Eh] [ebp-281Ah]
  char v6; // [esp+1Fh] [ebp-2819h]
  int v7; // [esp+20h] [ebp-2818h] BYREF
  _BYTE v8[8207]; // [esp+81Dh] [ebp-201Bh] BYREF
  size_t Size; // [esp+282Ch] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(35, (int)v8, 0, 0);
  Size = v5_SendCommand(v8, *(signed int *)&v8[8203], (char *)&Src, 2052);
  if ( (int)Size <= 4 || Size > 0x206 )
    return 255;
  if ( a2 )
  {
    if ( Src >= 0 )
    {
      memcpy(a2, &Src, Size);
    }
    else
    {
      *(_DWORD *)a2 = Src;
      a2[4] = v5;
      a2[5] = v6;
      memcpy(a2 + 6, &v7, Size - 6);
    }
  }
  if ( a2 )
    return (unsigned __int8)a2[5];
  else
    return 118;
}

//----- (0040A4A9) --------------------------------------------------------
int __usercall v5_LogStatus@<eax>(int a1@<eax>, int a2)
{
  void *v2; // esp
  int v4; // [esp+14h] [ebp-2034h] BYREF
  int v5; // [esp+18h] [ebp-2030h]
  int v6; // [esp+1Ch] [ebp-202Ch]
  int v7; // [esp+20h] [ebp-2028h]
  int v8; // [esp+24h] [ebp-2024h]
  int v9; // [esp+28h] [ebp-2020h]
  char v10; // [esp+2Ch] [ebp-201Ch]
  _BYTE v11[8207]; // [esp+2Dh] [ebp-201Bh] BYREF
  int v12; // [esp+203Ch] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(36, (int)v11, 0, 0);
  v12 = v5_SendCommand(v11, *(signed int *)&v11[8203], (char *)&v4, 25);
  if ( v12 == 25 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = v4;
      *(_DWORD *)(a2 + 4) = v5;
      *(_DWORD *)(a2 + 8) = v6;
      *(_DWORD *)(a2 + 12) = v7;
      *(_DWORD *)(a2 + 16) = v8;
      *(_DWORD *)(a2 + 20) = v9;
      *(_BYTE *)(a2 + 24) = v10;
    }
  }
  else
  {
    BYTE1(v5) = -1;
  }
  return BYTE1(v5);
}

//----- (0040A56D) --------------------------------------------------------
int __usercall v5_LogRead@<eax>(int a1@<eax>, char *a2, int a3, unsigned int a4)
{
  void *v4; // esp
  int Src; // [esp+11h] [ebp-2827h] BYREF
  char v7; // [esp+16h] [ebp-2822h]
  char v8; // [esp+17h] [ebp-2821h]
  int v9; // [esp+18h] [ebp-2820h] BYREF
  int v10[2]; // [esp+815h] [ebp-2023h] BYREF
  _BYTE v11[8207]; // [esp+81Dh] [ebp-201Bh] BYREF
  size_t Size; // [esp+282Ch] [ebp-Ch]

  v4 = alloca(a1);
  if ( a4 > 0xFA )
    a4 = 250;
  v10[0] = a3;
  v10[1] = a4;
  v5_ExtendedMessage(37, (int)v11, v10, 8);
  Size = v5_SendCommand(v11, *(signed int *)&v11[8203], (char *)&Src, 2052);
  if ( (int)Size <= 4 || Size > 0x3F6 )
    return 255;
  if ( a2 )
  {
    if ( Src >= 0 )
    {
      memcpy(a2, &Src, Size);
    }
    else
    {
      *(_DWORD *)a2 = Src;
      a2[4] = v7;
      a2[5] = v8;
      memcpy(a2 + 6, &v9, Size - 6);
    }
  }
  if ( a2 )
    return (unsigned __int8)a2[5];
  else
    return 118;
}

//----- (0040A6A3) --------------------------------------------------------
int __usercall v5_ProgramStatus@<eax>(int a1@<eax>, char a2, char a3, char *Source, int a5)
{
  void *v5; // esp
  int v7; // [esp+29h] [ebp-203Fh] BYREF
  int v8; // [esp+2Dh] [ebp-203Bh]
  __int16 v9; // [esp+31h] [ebp-2037h]
  char Src[2]; // [esp+33h] [ebp-2035h] BYREF
  char v11[24]; // [esp+35h] [ebp-2033h] BYREF
  _BYTE v12[8207]; // [esp+4Dh] [ebp-201Bh] BYREF
  int v13; // [esp+205Ch] [ebp-Ch]

  v5 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  strncpy(v11, Source, 0x17u);
  v11[23] = 0;
  v5_ExtendedMessage(28, (int)v12, Src, 26);
  v13 = v5_SendCommand(v12, *(signed int *)&v12[8203], (char *)&v7, 10);
  if ( v13 == 10 )
  {
    if ( a5 )
    {
      *(_DWORD *)a5 = v7;
      *(_DWORD *)(a5 + 4) = v8;
      *(_WORD *)(a5 + 8) = v9;
    }
  }
  else
  {
    BYTE1(v8) = -1;
  }
  return BYTE1(v8);
}

//----- (0040A799) --------------------------------------------------------
int __usercall v5_SystemScreenCapture@<eax>(int a1@<eax>)
{
  void *v1; // esp
  char v3[5]; // [esp+15h] [ebp-2023h] BYREF
  unsigned __int8 v4; // [esp+1Ah] [ebp-201Eh]
  _BYTE v5[8207]; // [esp+1Dh] [ebp-201Bh] BYREF
  int v6; // [esp+202Ch] [ebp-Ch]

  v1 = alloca(a1);
  v5_ExtendedMessage(40, (int)v5, 0, 0);
  v6 = v5_SendCommand(v5, *(signed int *)&v5[8203], v3, 8);
  if ( v6 != 8 )
    return (unsigned __int8)-1;
  return v4;
}
// 40A799: using guessed type char var_2023[5];

//----- (0040A813) --------------------------------------------------------
int __usercall v5_ProgramSlotInfo_14@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[5]; // [esp+18h] [ebp-20A0h] BYREF
  unsigned __int8 v5; // [esp+1Dh] [ebp-209Bh]
  _BYTE v6[8207]; // [esp+9Dh] [ebp-201Bh] BYREF
  size_t Size; // [esp+20ACh] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(49, (int)v6, 0, 0);
  Size = v5_SendCommand(v6, *(signed int *)&v6[8203], Src, 133);
  if ( (int)Size <= 0 || Size > 0x85 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a2 )
  {
    memcpy(a2, Src, Size);
  }
  return v5;
}

//----- (0040A8BB) --------------------------------------------------------
int __usercall v5_ProgramSlotInfo_58@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[5]; // [esp+18h] [ebp-20A0h] BYREF
  unsigned __int8 v5; // [esp+1Dh] [ebp-209Bh]
  _BYTE v6[8207]; // [esp+9Dh] [ebp-201Bh] BYREF
  size_t Size; // [esp+20ACh] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(50, (int)v6, 0, 0);
  Size = v5_SendCommand(v6, *(signed int *)&v6[8203], Src, 133);
  if ( (int)Size <= 0 || Size > 0x85 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a2 )
  {
    memcpy(a2, Src, Size);
  }
  return v5;
}

//----- (0040A963) --------------------------------------------------------
size_t __usercall v5_GetUserData@<eax>(int a1@<eax>, void *Src, int Size, void *a4)
{
  void *v4; // esp
  char v6[2052]; // [esp+1Bh] [ebp-292Dh] BYREF
  char v7[2]; // [esp+81Fh] [ebp-2129h] BYREF
  _BYTE v8[3]; // [esp+821h] [ebp-2127h] BYREF
  _BYTE v9[8207]; // [esp+921h] [ebp-2027h] BYREF
  int v10; // [esp+2930h] [ebp-18h]
  size_t v11; // [esp+2934h] [ebp-14h]
  int v12; // [esp+2938h] [ebp-10h]
  size_t v13; // [esp+293Ch] [ebp-Ch]

  v4 = alloca(a1);
  v13 = 0;
  if ( Size > 240 )
    Size = 240;
  v7[0] = 1;
  v7[1] = Size;
  if ( Size > 0 )
    memcpy(v8, Src, Size);
  v11 = Size + 2;
  v5_ExtendedMessage(39, (int)v9, v7, Size + 2);
  v10 = v5_SendCommand(v9, *(signed int *)&v9[8203], v6, 2052);
  if ( v10 > 0 && (unsigned int)v10 <= 0x804 && a4 )
  {
    v12 = 3;
    if ( v6[3] < 0 )
      ++v12;
    v13 = v10 - v12 - 6;
    if ( (int)v13 <= 0 )
      return 0;
    else
      memcpy(a4, &v6[v12 + 4], v13);
  }
  return v13;
}

//----- (0040AA8A) --------------------------------------------------------
int __usercall v5_UserProgramControl@<eax>(int a1@<eax>, char a2, char a3, void *a4)
{
  void *v4; // esp
  char v6[2]; // [esp+26h] [ebp-20A2h] BYREF
  char Src[5]; // [esp+28h] [ebp-20A0h] BYREF
  unsigned __int8 v8; // [esp+2Dh] [ebp-209Bh]
  _BYTE v9[8207]; // [esp+ADh] [ebp-201Bh] BYREF
  size_t Size; // [esp+20BCh] [ebp-Ch]

  v4 = alloca(a1);
  v6[0] = a2;
  v6[1] = a3;
  v5_ExtendedMessage(41, (int)v9, v6, 2);
  Size = v5_SendCommand(v9, *(signed int *)&v9[8203], Src, 133);
  if ( (int)Size <= 0 || Size > 0x85 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a4 )
  {
    memcpy(a4, Src, Size);
  }
  return v8;
}

//----- (0040AB60) --------------------------------------------------------
int __usercall v5_KVLoad@<eax>(int a1@<eax>, char *Str, void *a3, int Size)
{
  void *v4; // esp
  char v6[5]; // [esp+10h] [ebp-20A8h] BYREF
  unsigned __int8 v7; // [esp+15h] [ebp-20A3h]
  __int16 v8; // [esp+16h] [ebp-20A2h] BYREF
  _BYTE v9[8207]; // [esp+95h] [ebp-2023h] BYREF
  int v10; // [esp+20A4h] [ebp-14h]
  int v11; // [esp+20A8h] [ebp-10h]
  size_t v12; // [esp+20ACh] [ebp-Ch]

  v4 = alloca(a1);
  if ( !Str )
    return 255;
  v11 = strlen(Str);
  if ( v11 > 31 )
    return 255;
  memset(a3, 0, Size);
  v5_ExtendedMessage(46, (int)v9, Str, v11 + 1);
  v10 = v5_SendCommand(v9, *(signed int *)&v9[8203], v6, 133);
  if ( v10 <= 0 || (unsigned int)v10 > 0x85 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a3 && v7 == 118 )
  {
    v12 = v10 - 1;
    if ( v10 - 1 > Size )
      v12 = Size;
    memcpy(a3, &v8, v12);
  }
  return v7;
}
// 40AB60: using guessed type char var_20A8[5];

//----- (0040AC79) --------------------------------------------------------
int __usercall v5_KVSave@<eax>(int a1@<eax>, char *Str, char *Source)
{
  void *v3; // esp
  char Destination[128]; // [esp+10h] [ebp-2128h] BYREF
  char v6[5]; // [esp+90h] [ebp-20A8h] BYREF
  unsigned __int8 v7; // [esp+95h] [ebp-20A3h]
  _BYTE v8[8207]; // [esp+115h] [ebp-2023h] BYREF
  size_t v10; // [esp+2128h] [ebp-10h]
  size_t Count; // [esp+212Ch] [ebp-Ch]

  v3 = alloca(a1);
  if ( !Str )
    return 255;
  Count = strlen(Str);
  if ( (int)Count > 31 )
    Count = 31;
  v10 = strlen(Source);
  memset(Destination, 0, sizeof(Destination));
  strncpy(Destination, Str, Count);
  strncpy(&Destination[Count + 1], Source, v10);
  v5_ExtendedMessage(47, (int)v8, Destination, Count + v10 + 2);
  if ( !v5_SendCommand(v8, *(signed int *)&v8[8203], v6, 133) )
    return (unsigned __int8)-1;
  return v7;
}
// 40AC79: using guessed type char Destination[128];
// 40AC79: using guessed type char var_20A8[5];

//----- (0040AD93) --------------------------------------------------------
int __usercall v5_FactoryEnable@<eax>(int a1@<eax>)
{
  void *v1; // esp
  char v3[8]; // [esp+11h] [ebp-2027h] BYREF
  int Src; // [esp+19h] [ebp-201Fh] BYREF
  _BYTE v5[8207]; // [esp+1Dh] [ebp-201Bh] BYREF

  v1 = alloca(a1);
  Src = 1246448717;
  v5_ExtendedMessage(255, (int)v5, &Src, 4);
  v5_SendCommand(v5, *(signed int *)&v5[8203], v3, 8);
  return 118;
}
// 40AD93: using guessed type char var_2027[8];

//----- (0040AE07) --------------------------------------------------------
int __usercall v5_FactoryResetBrain@<eax>(int a1@<eax>)
{
  void *v1; // esp
  int Src; // [esp+19h] [ebp-201Fh] BYREF
  _BYTE v4[8207]; // [esp+1Dh] [ebp-201Bh] BYREF

  v1 = alloca(a1);
  Src = 894842198;
  v5_ExtendedMessage(242, (int)v4, &Src, 4);
  v5_SendCommand(v4, *(signed int *)&v4[8203], 0, 0);
  return 118;
}

//----- (0040AE77) --------------------------------------------------------
int __usercall v5_FactorySpecial@<eax>(int a1@<eax>, char a2, char a3, char a4, char a5, char a6)
{
  void *v6; // esp
  char v8[5]; // [esp+30h] [ebp-2038h] BYREF
  unsigned __int8 v9; // [esp+35h] [ebp-2033h]
  char Src[5]; // [esp+38h] [ebp-2030h] BYREF
  _BYTE v11[8207]; // [esp+3Dh] [ebp-202Bh] BYREF
  int v12; // [esp+204Ch] [ebp-1Ch]

  v6 = alloca(a1);
  Src[0] = a2;
  Src[1] = a3;
  Src[2] = a4;
  Src[3] = a5;
  Src[4] = a6;
  v5_ExtendedMessage(254, (int)v11, Src, 5);
  v12 = v5_SendCommand(v11, *(signed int *)&v11[8203], v8, 8);
  if ( v12 != 8 )
    return (unsigned __int8)-1;
  return v9;
}
// 40AE77: using guessed type char var_2038[5];

//----- (0040AF71) --------------------------------------------------------
int __usercall v5_FwUpdateStatus@<eax>(int a1@<eax>, _DWORD *a2)
{
  void *v2; // esp
  char v4[10]; // [esp+13h] [ebp-2025h] BYREF
  _BYTE v5[8207]; // [esp+1Dh] [ebp-201Bh] BYREF
  int v6; // [esp+202Ch] [ebp-Ch]

  v2 = alloca(a1);
  v5_ExtendedMessage(241, (int)v5, 0, 0);
  v6 = v5_SendCommand(v5, *(signed int *)&v5[8203], v4, 10);
  if ( v6 != 10 )
    return -1;
  *a2 = (unsigned __int8)v4[7];
  return (unsigned __int8)v4[6];
}

//----- (0040AFFA) --------------------------------------------------------
int __usercall iq2_CtrlGetPairId@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[265]; // [esp+10h] [ebp-2128h] BYREF
  _BYTE v5[8207]; // [esp+119h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2128h] [ebp-10h]
  unsigned __int8 v7; // [esp+212Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(98, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 265);
  if ( (int)Size <= 0 || Size > 0x109 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a2 )
  {
    memcpy(a2, Src, Size);
  }
  return v7;
}

//----- (0040B09D) --------------------------------------------------------
int __usercall iq2_CtrlGetDevState@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[265]; // [esp+10h] [ebp-2128h] BYREF
  _BYTE v5[8207]; // [esp+119h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2128h] [ebp-10h]
  unsigned __int8 v7; // [esp+212Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(104, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 265);
  if ( (int)Size <= 0 || Size > 0x109 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a2 )
  {
    memcpy(a2, Src, Size);
  }
  return v7;
}

//----- (0040B140) --------------------------------------------------------
int __usercall iq2_CtrlGetVersions@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[265]; // [esp+10h] [ebp-2128h] BYREF
  _BYTE v5[8207]; // [esp+119h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2128h] [ebp-10h]
  unsigned __int8 v7; // [esp+212Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(103, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 265);
  if ( (int)Size <= 0 || Size > 0x109 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a2 )
  {
    memcpy(a2, Src, Size);
  }
  return v7;
}

//----- (0040B1E3) --------------------------------------------------------
int __usercall iq2_CtrlGetInfo@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[265]; // [esp+10h] [ebp-2128h] BYREF
  _BYTE v5[8207]; // [esp+119h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2128h] [ebp-10h]
  unsigned __int8 v7; // [esp+212Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(114, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 265);
  if ( (int)Size <= 0 || Size > 0x109 )
  {
    return (unsigned __int8)-1;
  }
  else if ( a2 )
  {
    memcpy(a2, Src, Size);
  }
  return v7;
}

//----- (0040B286) --------------------------------------------------------
int __usercall v5_CtrlVersionsGet@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[23]; // [esp+12h] [ebp-2036h] BYREF
  _BYTE v5[8207]; // [esp+29h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2038h] [ebp-10h]
  unsigned __int8 v7; // [esp+203Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(57, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 23);
  if ( Size == 23 )
  {
    if ( a2 )
      memcpy(a2, Src, Size);
  }
  else
  {
    return (unsigned __int8)-1;
  }
  return v7;
}

//----- (0040B31F) --------------------------------------------------------
int __usercall v5_CtrlVersionsExpectGet@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[23]; // [esp+12h] [ebp-2036h] BYREF
  _BYTE v5[8207]; // [esp+29h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2038h] [ebp-10h]
  unsigned __int8 v7; // [esp+203Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(73, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 23);
  if ( Size == 23 )
  {
    if ( a2 )
      memcpy(a2, Src, Size);
  }
  else
  {
    return (unsigned __int8)-1;
  }
  return v7;
}

//----- (0040B3B8) --------------------------------------------------------
int __usercall v5_CtrlEraseFlash@<eax>(int a1@<eax>, char a2, int a3)
{
  void *v3; // esp
  char Src; // [esp+1Ch] [ebp-202Ch] BYREF
  int v6; // [esp+1Dh] [ebp-202Bh]
  char v7[8]; // [esp+21h] [ebp-2027h] BYREF
  _BYTE v8[8207]; // [esp+29h] [ebp-201Fh] BYREF
  int v9; // [esp+2038h] [ebp-10h]
  char v10; // [esp+203Fh] [ebp-9h]

  v3 = alloca(a1);
  v10 = 118;
  Src = a2;
  v6 = a3;
  v5_ExtendedMessage(59, (int)v8, &Src, 5);
  v9 = v5_SendCommand(v8, *(signed int *)&v8[8203], v7, 8);
  if ( v9 <= 0 || (unsigned int)v9 > 8 )
    return (unsigned __int8)-1;
  else
    return (unsigned __int8)v7[5];
}

//----- (0040B471) --------------------------------------------------------
int __usercall v5_CtrlWriteFlash@<eax>(int a1@<eax>, char a2, void *Src, int a4, unsigned __int8 a5)
{
  void *v5; // esp
  int v7; // eax
  void *v8; // esp
  void *v9; // esp
  char v10; // [esp+10h] [ebp-2048h] BYREF
  __int16 v11; // [esp+11h] [ebp-2047h]
  char v12; // [esp+13h] [ebp-2045h]
  unsigned __int8 v13; // [esp+14h] [ebp-2044h]
  _BYTE v14[3]; // [esp+15h] [ebp-2043h] BYREF
  unsigned __int8 v15; // [esp+1Ch] [ebp-203Ch]
  char v16[8]; // [esp+29h] [ebp-202Fh] BYREF
  _BYTE v17[8207]; // [esp+31h] [ebp-2027h] BYREF
  int v18; // [esp+2040h] [ebp-18h]
  void *v19; // [esp+2044h] [ebp-14h]
  int v20; // [esp+2048h] [ebp-10h]
  char v21; // [esp+204Fh] [ebp-9h]

  v5 = alloca(a1);
  v15 = a5;
  v21 = 118;
  if ( a5 > 0xF8u )
    return 255;
  v20 = v15 + 4;
  v7 = 16 * (((unsigned int)v15 + 20) / 0x10);
  v8 = alloca(v7);
  v9 = alloca(v7);
  v19 = &v10;
  v10 = a2;
  v11 = a4;
  v12 = BYTE2(a4);
  v13 = v15;
  memcpy(v14, Src, v15);
  v5_ExtendedMessage(60, (int)v17, v19, v15 + 5);
  v18 = v5_SendCommand(v17, *(signed int *)&v17[8203], v16, 8);
  if ( v18 <= 0 || (unsigned int)v18 > 8 )
    return (unsigned __int8)-1;
  else
    return (unsigned __int8)v16[5];
}

//----- (0040B5BF) --------------------------------------------------------
int __usercall v5_CtrlValidateFlash@<eax>(int a1@<eax>, int a2, int a3, int a4, int a5, int a6)
{
  void *v6; // esp
  char v8[4]; // [esp+18h] [ebp-2040h] BYREF
  char Src[9]; // [esp+1Ch] [ebp-203Ch] BYREF
  int v10; // [esp+25h] [ebp-2033h]
  int v11; // [esp+29h] [ebp-202Fh]
  int v12; // [esp+2Dh] [ebp-202Bh]
  char v13[8]; // [esp+31h] [ebp-2027h] BYREF
  _BYTE v14[8207]; // [esp+39h] [ebp-201Fh] BYREF
  int v15; // [esp+2048h] [ebp-10h]
  char v16; // [esp+204Fh] [ebp-9h]

  v6 = alloca(a1);
  v16 = 118;
  if ( a2 == 11 )
  {
    Src[0] = 11;
    Src[1] = HIBYTE(a3);
    Src[2] = BYTE2(a3);
    Src[3] = BYTE1(a3);
    Src[4] = a3;
    Src[5] = HIBYTE(a3);
    Src[6] = BYTE2(a3);
    Src[7] = BYTE1(a3);
    Src[8] = a3;
    v10 = a4;
    v11 = a5;
    v12 = a6;
    v5_ExtendedMessage(62, (int)v14, Src, 21);
  }
  else
  {
    v8[0] = a2;
    v8[1] = HIBYTE(a3);
    v8[2] = BYTE2(a3);
    v8[3] = BYTE1(a3);
    v5_ExtendedMessage(62, (int)v14, v8, 4);
  }
  v15 = v5_SendCommand(v14, *(signed int *)&v14[8203], v13, 8);
  if ( v15 <= 0 || (unsigned int)v15 > 8 )
    return (unsigned __int8)-1;
  else
    return (unsigned __int8)v13[5];
}

//----- (0040B730) --------------------------------------------------------
int __usercall v5_CtrlForceRadioUpdate@<eax>(int a1@<eax>)
{
  void *v1; // esp
  char v3[8]; // [esp+11h] [ebp-2027h] BYREF
  _BYTE v4[8207]; // [esp+19h] [ebp-201Fh] BYREF
  int v5; // [esp+2028h] [ebp-10h]
  char v6; // [esp+202Fh] [ebp-9h]

  v1 = alloca(a1);
  v6 = 118;
  v5_ExtendedMessage(63, (int)v4, 0, 0);
  v5 = v5_SendCommand(v4, *(signed int *)&v4[8203], v3, 8);
  if ( v5 <= 0 || (unsigned int)v5 > 8 )
    return (unsigned __int8)-1;
  else
    return (unsigned __int8)v3[5];
}

//----- (0040B7B9) --------------------------------------------------------
int __usercall v5_CtrlRadioInfoGet@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // esp
  char Src[39]; // [esp+12h] [ebp-2046h] BYREF
  _BYTE v5[8207]; // [esp+39h] [ebp-201Fh] BYREF
  size_t Size; // [esp+2048h] [ebp-10h]
  unsigned __int8 v7; // [esp+204Fh] [ebp-9h]

  v2 = alloca(a1);
  v7 = 118;
  v5_ExtendedMessage(53, (int)v5, 0, 0);
  Size = v5_SendCommand(v5, *(signed int *)&v5[8203], Src, 39);
  if ( Size == 39 )
  {
    if ( a2 )
      memcpy(a2, Src, Size);
  }
  else
  {
    return (unsigned __int8)-1;
  }
  return v7;
}

//----- (0040B854) --------------------------------------------------------
FILE *__cdecl fmemopenw(void *a1, size_t ElementSize)
{
  CHAR PrefixString[7]; // [esp+21h] [ebp-217h] BYREF
  CHAR TempFileName[261]; // [esp+28h] [ebp-210h] BYREF
  CHAR Buffer[247]; // [esp+12Dh] [ebp-10Bh] BYREF
  int FileHandle; // [esp+224h] [ebp-14h] BYREF
  FILE *Stream; // [esp+228h] [ebp-10h]
  errno_t v8; // [esp+22Ch] [ebp-Ch]

  v8 = -1;
  strcpy(PrefixString, "xPfTF_");
  if ( !GetTempPathA(0xF7u, Buffer) )
    return 0;
  if ( !GetTempFileNameA(Buffer, PrefixString, 0, TempFileName) )
    return 0;
  v8 = __sopen_s(&FileHandle, TempFileName, 37314, 16, 384);
  if ( v8 )
    return 0;
  if ( FileHandle == -1 )
    return 0;
  Stream = __fdopen(FileHandle, "wb+");
  if ( Stream )
  {
    fwrite(a1, ElementSize, 1u, Stream);
    rewind(Stream);
    return Stream;
  }
  else
  {
    __close(FileHandle);
    return 0;
  }
}

//----- (0040B995) --------------------------------------------------------
_BYTE *__cdecl str_lower(_BYTE *a1)
{
  _BYTE *i; // [esp+1Ch] [ebp-Ch]

  for ( i = a1; *i; ++i )
  {
    if ( _isupper((char)*i) )
      *i += 32;
  }
  return a1;
}

//----- (0040B9DD) --------------------------------------------------------
int __cdecl V5_ZipReadLocalHeader(unsigned __int16 *Buffer, void *a2, signed int Size)
{
  signed int v4; // [esp+18h] [ebp-10h]
  size_t ElementCount; // [esp+1Ch] [ebp-Ch]

  if ( fread(Buffer, 1u, 0x1Eu, fp) < 0x1E )
    return -1;
  v4 = Buffer[13];
  if ( Buffer[13] )
  {
    if ( v4 <= Size )
      ElementCount = Buffer[13];
    else
      ElementCount = Size;
    v4 -= ElementCount;
    memset(a2, 0, Size);
    if ( fread(a2, 1u, ElementCount, fp) < ElementCount )
      return -1;
    *((_BYTE *)a2 + Size - 1) = 0;
  }
  if ( fseek(fp, Buffer[14] + v4, 1) )
    return -1;
  else
    return 0;
}

//----- (0040BAEC) --------------------------------------------------------
size_t __cdecl nextBufferFile(_DWORD *a1)
{
  size_t v1; // eax
  size_t v3; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  if ( fp )
  {
    v1 = nLeft;
    if ( (unsigned int)nLeft > 0x2000 )
      v1 = 0x2000;
    v3 = fread(&buf, 1u, v1, fp);
    if ( a1 )
      *a1 = &buf;
  }
  nLeft -= v3;
  return v3;
}
// 524EE0: using guessed type int nLeft;

//----- (0040BB60) --------------------------------------------------------
int __cdecl V5_ZipReadData(int a1, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-18h] BYREF
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]

  if ( !fp )
    return -1;
  if ( a1 )
  {
    nLeft = *(_DWORD *)(a3 + 18);
    v6 = nextBufferFile(&v4);
    v5 = V5_ZipInflateBufferRaw(v4, v6, a1, a2, (int (__cdecl *)(int *))nextBufferFile);
    if ( *(_DWORD *)(a3 + 22) != v5 )
      return -1;
  }
  else if ( fseek(fp, *(_DWORD *)(a3 + 22), 1) )
  {
    return -1;
  }
  return 0;
}
// 524EE0: using guessed type int nLeft;

//----- (0040BC0E) --------------------------------------------------------
int __cdecl V5_ZipReadEndRecord(void *a1)
{
  int v2; // eax
  size_t ElementCount; // [esp+10h] [ebp-18h]
  unsigned int v4; // [esp+14h] [ebp-14h]
  char *Src; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !fp )
    return -1;
  Src = 0;
  if ( fseek(fp, 0, 2) )
    return -1;
  v4 = ftell(fp);
  if ( v4 <= 0x16 )
    return -1;
  v2 = v4;
  if ( v4 > 0x2000 )
    v2 = 0x2000;
  ElementCount = v2;
  if ( fseek(fp, v4 - v2, 0) )
    return -1;
  if ( fread(&buf, 1u, ElementCount, fp) < ElementCount )
    return -1;
  for ( i = ElementCount - 22; i >= 0; --i )
  {
    Src = (char *)&buf + i;
    if ( *(_DWORD *)((char *)&buf + i) == 101010256 )
      break;
  }
  if ( i < 0 )
    return -1;
  if ( Src )
    memcpy(a1, Src, 0x16u);
  if ( *((_WORD *)a1 + 2) || *((_WORD *)a1 + 3) || *((_WORD *)a1 + 5) != *((_WORD *)a1 + 4) )
    return -1;
  else
    return 0;
}

//----- (0040BD8A) --------------------------------------------------------
int __cdecl vexosZipLoad(char *FileName, _DWORD *a2, size_t ElementSize)
{
  const char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  int v7; // [esp+1Ch] [ebp-9Ch] BYREF
  char v8[64]; // [esp+20h] [ebp-98h] BYREF
  int Buffer[5]; // [esp+60h] [ebp-58h] BYREF
  unsigned int v10; // [esp+76h] [ebp-42h]
  char v11[22]; // [esp+7Eh] [ebp-3Ah] BYREF
  int ReflectedInput; // [esp+94h] [ebp-24h]
  int v13; // [esp+98h] [ebp-20h]
  int *v14; // [esp+9Ch] [ebp-1Ch]
  unsigned __int8 *v15; // [esp+A0h] [ebp-18h]
  char v16; // [esp+A7h] [ebp-11h]
  int v17; // [esp+A8h] [ebp-10h]
  int v18; // [esp+ACh] [ebp-Ch]

  v18 = 0;
  v17 = 0;
  if ( ElementSize )
    fp = fmemopenw(FileName, ElementSize);
  else
    fp = fopen(FileName, "rb");
  if ( !a2 )
    return -1;
  if ( !*a2 || !a2[1] )
    return -1;
  v13 = a2[8];
  if ( fp )
  {
    if ( fseek(fp, 0, 2) )
      return -1;
    if ( !V5_ZipReadEndRecord(v11) )
    {
      if ( fseek(fp, 0, 0) )
        return -1;
      v16 = 1;
      while ( v16 )
      {
        if ( V5_ZipReadLocalHeader((unsigned __int16 *)Buffer, v8, 64) == -1 )
          v16 = 0;
        if ( Buffer[0] == 67324752 )
        {
          v15 = 0;
          v7 = 0;
          v14 = &v7;
          v4 = str_lower(v8);
          if ( strstr(v4, "boot.bin") )
          {
            v15 = (unsigned __int8 *)*a2;
            v14 = a2 + 5;
            ++v17;
          }
          v5 = str_lower(v8);
          if ( strstr(v5, "assets.bin") )
          {
            v15 = (unsigned __int8 *)a2[1];
            v14 = a2 + 6;
            ++v17;
          }
          v6 = str_lower(v8);
          if ( strstr(v6, "manifest.json") )
          {
            v15 = (unsigned __int8 *)a2[2];
            v14 = a2 + 7;
            ++v17;
          }
          if ( !v15 )
          {
            v15 = (unsigned __int8 *)a2[3];
            a2[8] = v13;
            v14 = a2 + 8;
          }
          if ( V5_ZipReadData((int)v15, *v14, (int)Buffer) )
          {
            v16 = 0;
            *v14 = 0;
            v15 = 0;
            v18 = -1;
          }
          else
          {
            *v14 = v10;
          }
          if ( v15 )
          {
            ReflectedInput = Crc32GenerateReflectedInput(v15, v10, -1);
            ReflectedInput = Crc32Reflect32(~ReflectedInput);
            if ( ReflectedInput != *(int *)((char *)&Buffer[3] + 2) )
            {
              v16 = 0;
              v18 = -1;
            }
          }
        }
        else
        {
          v16 = 0;
        }
      }
    }
    fclose(fp);
  }
  else
  {
    v18 = -1;
  }
  if ( v17 <= 2 )
    return -1;
  return v18;
}
// 40BD8A: using guessed type char var_3A[22];

//----- (0040C06C) --------------------------------------------------------
int __cdecl vexosZipLoadNamedEntry(char *FileName, _DWORD *a2, size_t ElementSize, char *SubStr)
{
  int v5; // [esp+1Ch] [ebp-9Ch] BYREF
  char Str[64]; // [esp+20h] [ebp-98h] BYREF
  int Buffer[5]; // [esp+60h] [ebp-58h] BYREF
  unsigned int v8; // [esp+76h] [ebp-42h]
  char v9[22]; // [esp+7Eh] [ebp-3Ah] BYREF
  int ReflectedInput; // [esp+94h] [ebp-24h]
  int v11; // [esp+98h] [ebp-20h]
  int *v12; // [esp+9Ch] [ebp-1Ch]
  unsigned __int8 *v13; // [esp+A0h] [ebp-18h]
  char v14; // [esp+A7h] [ebp-11h]
  int v15; // [esp+A8h] [ebp-10h]
  int v16; // [esp+ACh] [ebp-Ch]

  v16 = 0;
  v15 = 0;
  if ( ElementSize )
    fp = fmemopenw(FileName, ElementSize);
  else
    fp = fopen(FileName, "rb");
  if ( !a2 )
    return -1;
  v11 = a2[8];
  if ( fp )
  {
    if ( fseek(fp, 0, 2) )
      return -1;
    if ( !V5_ZipReadEndRecord(v9) )
    {
      if ( fseek(fp, 0, 0) )
        return -1;
      v14 = 1;
      while ( v14 )
      {
        if ( V5_ZipReadLocalHeader((unsigned __int16 *)Buffer, Str, 64) == -1 )
          v14 = 0;
        if ( Buffer[0] == 67324752 )
        {
          v13 = 0;
          v5 = 0;
          v12 = &v5;
          if ( strstr(Str, SubStr) )
          {
            v13 = (unsigned __int8 *)a2[4];
            v12 = a2 + 9;
            ++v15;
            v14 = 0;
          }
          if ( !v13 )
          {
            v13 = (unsigned __int8 *)a2[3];
            a2[8] = v11;
            v12 = a2 + 8;
          }
          if ( V5_ZipReadData((int)v13, *v12, (int)Buffer) )
          {
            v14 = 0;
            *v12 = 0;
            v13 = 0;
            v16 = -1;
          }
          else
          {
            *v12 = v8;
          }
          if ( v13 )
          {
            ReflectedInput = Crc32GenerateReflectedInput(v13, v8, -1);
            ReflectedInput = Crc32Reflect32(~ReflectedInput);
            if ( ReflectedInput != *(int *)((char *)&Buffer[3] + 2) )
            {
              v14 = 0;
              v16 = -1;
            }
          }
        }
        else
        {
          v14 = 0;
        }
      }
    }
    fclose(fp);
  }
  else
  {
    v16 = -1;
  }
  if ( !v15 )
    return -1;
  return v16;
}
// 40C06C: using guessed type char var_3A[22];

//----- (0040C2BD) --------------------------------------------------------
int __cdecl V5_ZipInflateAlloc(int a1, int a2, int a3)
{
  int v4; // [esp+Ch] [ebp-4h]

  if ( heapPtr + a3 * a2 >= (unsigned int)&heapPtr )
    return 0;
  v4 = heapPtr;
  heapPtr += a3 * a2;
  return v4;
}
// 534F00: using guessed type int heapPtr;

//----- (0040C301) --------------------------------------------------------
void V5_ZipInflateFree()
{
  ;
}

//----- (0040C303) --------------------------------------------------------
int __cdecl V5_ZipInflateBufferRaw(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int *))
{
  int v6; // [esp+10h] [ebp-48h] BYREF
  int v7; // [esp+14h] [ebp-44h] BYREF
  int v8; // [esp+18h] [ebp-40h]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  int (__cdecl *v12)(int, int, int); // [esp+34h] [ebp-24h]
  int (*v13)(); // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+4Ch] [ebp-Ch]

  v12 = zalloc;
  v13 = zfree;
  v14 = 0;
  v7 = a1;
  v8 = a2;
  heapPtr = (int)&inflateHeap;
  v15 = inflateInit2_(&v7, -15, "1.2.11", 56);
  if ( v15 )
    return 0;
  v9 = a3;
  v10 = a4;
  do
  {
    v15 = inflate((int)&v7, 0);
    if ( v15 != 1 )
    {
      if ( a5 )
      {
        v8 = a5(&v6);
        if ( v8 )
          v7 = v6;
      }
      else
      {
        v8 = 0;
      }
    }
  }
  while ( !v15 );
  inflateEnd(&v7);
  return v11;
}
// 4E9BC0: using guessed type int (__cdecl *zalloc)(int, int, int);
// 4E9BC4: using guessed type int (*zfree)();
// 534F00: using guessed type int heapPtr;

//----- (0040C3D4) --------------------------------------------------------
int __cdecl V5_GzipInflateBuffer(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int *))
{
  int v6; // [esp+10h] [ebp-48h] BYREF
  int v7; // [esp+14h] [ebp-44h] BYREF
  int v8; // [esp+18h] [ebp-40h]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  int (__cdecl *v12)(int, int, int); // [esp+34h] [ebp-24h]
  int (*v13)(); // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int v15; // [esp+4Ch] [ebp-Ch]

  v12 = zalloc;
  v13 = zfree;
  v14 = 0;
  v7 = a1;
  v8 = a2;
  heapPtr = (int)&inflateHeap;
  v15 = inflateInit2_(&v7, 31, "1.2.11", 56);
  if ( v15 )
    return 0;
  v9 = a3;
  v10 = a4;
  do
  {
    v15 = inflate((int)&v7, 0);
    if ( v15 != 1 )
    {
      if ( a5 )
      {
        v8 = a5(&v6);
        if ( v8 )
          v7 = v6;
      }
      else
      {
        v8 = 0;
      }
    }
  }
  while ( !v15 );
  inflateEnd(&v7);
  return v11;
}
// 4E9BC0: using guessed type int (__cdecl *zalloc)(int, int, int);
// 4E9BC4: using guessed type int (*zfree)();
// 534F00: using guessed type int heapPtr;

//----- (0040C4A5) --------------------------------------------------------
int __cdecl vexosProcessBootData(char *Src, int *a2, int *a3)
{
  int v4; // [esp+14h] [ebp-44h]
  int v5; // [esp+18h] [ebp-40h]
  unsigned int v6; // [esp+1Ch] [ebp-3Ch]
  unsigned int v7; // [esp+1Ch] [ebp-3Ch]
  unsigned int v8; // [esp+20h] [ebp-38h]
  unsigned int v9; // [esp+20h] [ebp-38h]
  unsigned int j; // [esp+28h] [ebp-30h]
  int *v11; // [esp+2Ch] [ebp-2Ch]
  int *v12; // [esp+2Ch] [ebp-2Ch]
  int i; // [esp+30h] [ebp-28h]
  int v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  unsigned int v16; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+3Ch] [ebp-1Ch]
  int v18; // [esp+3Ch] [ebp-1Ch]

  *a2 = -1;
  memcpy(buffer, Src, 0x200u);
  v16 = buffer[39];
  v8 = v16 & 0xFFFFFE00;
  if ( v16 >= 0x2001 )
    return 0;
  if ( v8 + 2048 > 0x2000000 )
    return 0;
  qmemcpy(buffer, &Src[v8], sizeof(buffer));
  memcpy(&PartitionHeader, (char *)buffer + v16 - (v16 & 0xFFFFFE00), 0x380u);
  v15 = 0;
  v14 = 0;
  for ( i = 0; i <= 13; ++i )
  {
    v17 = 4 * *((_DWORD *)&unk_537814 + 16 * i);
    v9 = v17 & 0xFFFFFE00;
    if ( *((_DWORD *)&unk_53780C + 16 * i) == 0x1000000 )
    {
      if ( (*((_DWORD *)&unk_537818 + 16 * i) & 0x7000) != 0 )
      {
        if ( dword_537820[16 * i] )
          v14 = 64;
      }
      if ( v9 + 2048 > 0x2000000 )
        return 0;
      qmemcpy(buffer, &Src[v9], sizeof(buffer));
      v11 = (_DWORD *)((char *)buffer + v17 - (v17 & 0xFFFFFE00));
      for ( j = 0; j <= 0x1FF; ++j )
      {
        if ( *v11 == -559038737 )
        {
          v12 = v11 + 1;
          v5 = *v12;
          v11 = v12 + 1;
          v4 = *v11;
          v18 = 4 * *((_DWORD *)&unk_537814 + 16 * i) + v5 - *((_DWORD *)&unk_53780C + 16 * i);
          if ( (v18 & 0xFFFFFE00) + 2048 > 0x2000000 )
            return 0;
          qmemcpy(buffer, &Src[v18 & 0xFFFFFE00], sizeof(buffer));
          v6 = v18 - (v18 & 0xFFFFFE00);
          *a2 = (*((char *)buffer + v6 + 3) >> 2 << 8) & 0x3F00 | (*((char *)buffer + v6 + 1) << 16) | (*((char *)buffer + v6) << 24) | *((char *)buffer + v6 + 2);
          v17 = 4 * *((_DWORD *)&unk_537814 + 16 * i) + v4 - *((_DWORD *)&unk_53780C + 16 * i);
          if ( (v17 & 0xFFFFFE00) + 2048 > 0x2000000 )
            return 0;
          qmemcpy(buffer, &Src[v17 & 0xFFFFFE00], sizeof(buffer));
          v7 = v17 - (v17 & 0xFFFFFE00);
          *a3 = (*((char *)&buffer[1] + v7 + 3) >> 2 << 8) & 0x3F00 | (*((char *)&buffer[1] + v7 + 1) << 16) | (*((char *)&buffer[1] + v7) << 24) | *((char *)&buffer[1] + v7 + 2);
        }
        ++v11;
      }
    }
    if ( !v17 )
      return v15 + v14;
    v15 = 4 * *((_DWORD *)&PartitionHeader + 16 * i) + v17;
  }
  return 0;
}
// 534F20: using guessed type _DWORD buffer[512];
// 537820: using guessed type _DWORD dword_537820[216];

//----- (0040C85C) --------------------------------------------------------
int __cdecl vexosIsXilinxImage(void *Src)
{
  int i; // [esp+18h] [ebp-10h]
  unsigned __int8 v3; // [esp+1Fh] [ebp-9h]

  memcpy(buffer, Src, 0x200u);
  v3 = 1;
  for ( i = 0; i <= 7; ++i )
  {
    if ( buffer[i] != -352321538 )
      v3 = 0;
  }
  if ( buffer[8] != -1432791706 )
    return 0;
  return v3;
}
// 534F20: using guessed type _DWORD buffer[512];

//----- (0040C8D0) --------------------------------------------------------
int __cdecl vexosIsIq2Image(int a1)
{
  unsigned __int8 v2; // [esp+Fh] [ebp-1h]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 616) == 1986361393 )
    return *(_DWORD *)(a1 + 620) == 1769026145;
  return v2;
}

//----- (0040C90A) --------------------------------------------------------
int __cdecl vexosIsExpImage(int a1)
{
  unsigned __int8 v2; // [esp+Fh] [ebp-1h]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 1360) == 1986361393 )
    return *(_DWORD *)(a1 + 1364) == 1983210337;
  return v2;
}

//----- (0040C944) --------------------------------------------------------
const char *__cdecl strsep(const char **a1, char *Control)
{
  const char *v2; // ebx
  const char *v3; // eax
  const char *v5; // [esp+1Ch] [ebp-Ch]

  v5 = *a1;
  if ( *a1 )
  {
    v2 = *a1;
    *a1 = &v2[strcspn(*a1, Control)];
    if ( **a1 )
    {
      v3 = (*a1)++;
      *v3 = 0;
    }
    else
    {
      *a1 = 0;
    }
  }
  return v5;
}

//----- (0040C9AA) --------------------------------------------------------
int __cdecl vexosFilenameToVersion(const void *a1)
{
  int v2; // [esp+1Ch] [ebp-ACh] BYREF
  char v3[128]; // [esp+20h] [ebp-A8h] BYREF
  int v4; // [esp+A0h] [ebp-28h]
  char *String; // [esp+A4h] [ebp-24h]
  int i; // [esp+A8h] [ebp-20h]
  int v7; // [esp+ACh] [ebp-1Ch]

  v7 = 0;
  qmemcpy(v3, a1, sizeof(v3));
  v2 = (int)v3;
  for ( i = 0; ; ++i )
  {
    String = (char *)strsep((const char **)&v2, "_");
    if ( !String )
      break;
    if ( i > 1 )
    {
      v4 = strtol(String, 0, 0);
      v7 = (v7 << 8) | v4;
    }
  }
  return v7;
}

//----- (0040CA4F) --------------------------------------------------------
int __cdecl vexosCatalogToLatestVersion(int a1)
{
  int v2; // [esp+14h] [ebp-14h] BYREF
  const char *v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = 0;
  v2 = a1;
  while ( 1 )
  {
    v3 = strsep((const char **)&v2, "\n");
    if ( !v3 )
      break;
    v4 = vexosFilenameToVersion(v3);
  }
  return v4;
}

//----- (0040CA93) --------------------------------------------------------
char *__cdecl vexosVersionToString(int a1)
{
  size_t v1; // eax

  sprintf(str_6656, "%d.%d.%d", HIBYTE(a1), BYTE2(a1), BYTE1(a1));
  if ( (_BYTE)a1 )
  {
    v1 = strlen(str_6656);
    sprintf(&str_6656[v1], "b%d", (unsigned __int8)a1);
  }
  return str_6656;
}

//----- (0040CB21) --------------------------------------------------------
int __cdecl vexosRead(char *FileName, void **a2, size_t ElementSize)
{
  a2[5] = (void *)0x800000;
  a2[6] = (void *)0x800000;
  a2[7] = (void *)2048;
  a2[8] = (void *)0x80000;
  if ( !*a2 )
    *a2 = malloc((size_t)a2[5]);
  if ( !a2[1] )
    a2[1] = malloc((size_t)a2[6]);
  if ( !a2[2] )
    a2[2] = malloc((size_t)a2[7]);
  if ( !a2[3] )
    a2[3] = malloc((size_t)a2[8]);
  return vexosZipLoad(FileName, a2, ElementSize);
}

//----- (0040CBE8) --------------------------------------------------------
int __cdecl versionFromManifest(int a1)
{
  int v1; // ebx
  int v2; // ebx
  int v3; // ebx
  int v5; // [esp+10h] [ebp-18h] BYREF
  char *String; // [esp+14h] [ebp-14h]
  char *Str; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = 0;
  Str = 0;
  if ( *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 28) )
  {
    v5 = *(_DWORD *)(a1 + 8);
    do
      Str = (char *)strsep((const char **)&v5, "\n");
    while ( Str && !strstr(Str, "version") );
  }
  if ( Str )
  {
    for ( String = Str; *String != 46 && *String; ++String )
      ;
    if ( *String == 46 )
    {
      v8 = strtol(--String, 0, 0);
      String += 2;
      if ( *String == 46 )
        ++String;
      v1 = v8 << 8;
      v8 = v1 | strtol(String, 0, 0);
      String += 2;
      if ( *String == 46 )
        ++String;
      v2 = v8 << 8;
      v8 = v2 | strtol(String, 0, 0);
      String += 2;
      if ( *String == 46 )
        ++String;
      v3 = v8 << 8;
      return v3 | strtol(String, 0, 0);
    }
  }
  return v8;
}

//----- (0040CD63) --------------------------------------------------------
int __cdecl v5_firmwareWaitForControllerConnection(unsigned __int8 a1)
{
  _DWORD v2[2]; // [esp+2Ch] [ebp-1Ch] BYREF
  char v3; // [esp+36h] [ebp-12h]
  int v4; // [esp+38h] [ebp-10h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v5 = 30;
  v4 = 0;
  v5_FileTransferMetadata("flash", 0, (char *)a1);
  v5_FileTransferShowProgress(0, 100, a1);
  while ( v5 > 0 )
  {
    serialSleep(0x3E8u);
    if ( !v5_SystemVersion(v2) )
      return 4;
    if ( !isV5ControllerProductId((int)v2) )
      return 0;
    if ( (v3 & 3) != 0 )
    {
      if ( ++v4 == 2 )
        return 0;
    }
    else
    {
      v4 = 0;
    }
    --v5;
  }
  return 1;
}
// 40CD63: using guessed type _DWORD var_1C[2];

//----- (0040CE2B) --------------------------------------------------------
int __cdecl v5_firmwareWaitForCompletion(unsigned __int8 a1)
{
  int result; // eax
  int v2; // [esp+24h] [ebp-14h] BYREF
  int updated; // [esp+28h] [ebp-10h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v2 = 0;
  v5_FileTransferMetadata("flash", 0, (char *)a1);
  v5_FileTransferShowProgress(0, 100, a1);
  v4 = 0;
  while ( 1 )
  {
    updated = v5_FwUpdateStatus((int)&v2, &v2);
    if ( !updated )
      return v5_FileTransferShowProgress(v2, 100, a1);
    if ( updated == -1 && v4 > 30 )
      break;
    if ( updated == -1 )
      ++v4;
    else
      v4 = 0;
    if ( v2 > 0 )
      v5_FileTransferShowProgress(v2, 100, a1);
    serialSleep(0x64u);
  }
  if ( g_jsonmode || (result = g_quietmode, g_quietmode <= 1) )
  {
    v5_FileTransferMetadata("error", 0, (char *)a1);
    if ( !g_jsonmode )
      v5_FileTransferShowProgress(0, 100, a1);
    return v5_FileTransferShowProgress(100, 100, a1);
  }
  return result;
}
// 44BF70: using guessed type int g_quietmode;
// 520044: using guessed type int g_jsonmode;

//----- (0040CF7C) --------------------------------------------------------
int __cdecl v5_VersionCheck(int a1, int a2)
{
  if ( a2 == a1 )
    return 0;
  if ( HIBYTE(a1) == HIBYTE(a2) )
  {
    if ( BYTE2(a1) == BYTE2(a2) )
    {
      if ( BYTE1(a1) == BYTE1(a2) )
      {
        if ( (unsigned __int8)a2 > (unsigned __int8)a1 && (_BYTE)a1 )
        {
          return 1;
        }
        else if ( (_BYTE)a2 == (_BYTE)a1 || (_BYTE)a2 )
        {
          return -1;
        }
        else
        {
          return 1;
        }
      }
      else if ( BYTE1(a1) <= BYTE1(a2) )
      {
        return 1;
      }
      else
      {
        return -1;
      }
    }
    else if ( BYTE2(a1) <= BYTE2(a2) )
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }
  else if ( HIBYTE(a1) <= HIBYTE(a2) )
  {
    return 1;
  }
  else
  {
    return -1;
  }
}

//----- (0040D069) --------------------------------------------------------
int __cdecl v5_firmwareUpdate(char *Source, size_t ElementSize, int a3, unsigned __int8 a4, unsigned __int8 a5)
{
  char *v5; // eax
  int v7; // eax
  char v8[27]; // [esp+33h] [ebp-85h] BYREF
  char v9[4]; // [esp+4Eh] [ebp-6Ah]
  char v10[4]; // [esp+52h] [ebp-66h]
  unsigned __int8 v11; // [esp+56h] [ebp-62h]
  unsigned __int8 v12; // [esp+57h] [ebp-61h]
  unsigned __int8 v13; // [esp+58h] [ebp-60h]
  unsigned __int8 v14; // [esp+59h] [ebp-5Fh]
  int v15[2]; // [esp+60h] [ebp-58h] BYREF
  _DWORD v16[3]; // [esp+68h] [ebp-50h] BYREF
  char v17[4]; // [esp+74h] [ebp-44h] BYREF
  int v18; // [esp+78h] [ebp-40h] BYREF
  bool v19; // [esp+7Fh] [ebp-39h]
  char v20[4]; // [esp+80h] [ebp-38h]
  char v21[4]; // [esp+84h] [ebp-34h]
  char v22[4]; // [esp+88h] [ebp-30h]
  int v23; // [esp+8Ch] [ebp-2Ch]
  char IsExpImage; // [esp+91h] [ebp-27h]
  char IsIq2Image; // [esp+92h] [ebp-26h]
  char IsXilinxImage; // [esp+93h] [ebp-25h]
  char v27[4]; // [esp+94h] [ebp-24h]
  char v28[4]; // [esp+98h] [ebp-20h]
  int v29; // [esp+9Ch] [ebp-1Ch]
  int v30; // [esp+A0h] [ebp-18h]
  int v31; // [esp+A4h] [ebp-14h]
  bool v32; // [esp+ABh] [ebp-Dh]
  int v33; // [esp+ACh] [ebp-Ch]

  v18 = 0;
  v31 = 0;
  *(_DWORD *)v17 = 0;
  if ( vexosRead(Source, &zipdata_1, ElementSize) < 0 )
    return 0;
  v30 = Crc32Generate(zipdata_1, *(unsigned int *)dword_537B94, 0);
  v29 = Crc32Generate((_BYTE *)dword_537B84, *(unsigned int *)dword_537B98, 0);
  if ( !g_quietmode )
  {
    vexlog(2, "boot        : %8d (0x%08X) bytes, crc %08X\n", *(_DWORD *)dword_537B94, *(_DWORD *)dword_537B94, v30);
    vexlog(2, "assets      : %8d (0x%08X) bytes, crc %08X\n", *(_DWORD *)dword_537B98, *(_DWORD *)dword_537B98, v29);
  }
  *(_DWORD *)v28 = versionFromManifest((int)&zipdata_1);
  if ( !g_quietmode )
    vexlog(2, "manifest    : %08X\n", *(_DWORD *)v28);
  if ( !ElementSize )
  {
    v5 = basename(Source);
    *(_DWORD *)v27 = vexosFilenameToVersion(v5);
    if ( !g_quietmode )
      vexlog(2, "filename    : %08X\n", *(_DWORD *)v27);
    if ( *(_DWORD *)v27 != *(_DWORD *)v28 )
    {
      if ( g_quietmode <= 1 )
        vexlog(2, "mis-matched vexos file name\n");
      return 1;
    }
  }
  IsXilinxImage = vexosIsXilinxImage(zipdata_1);
  IsIq2Image = vexosIsIq2Image((int)zipdata_1);
  IsExpImage = vexosIsExpImage((int)zipdata_1);
  if ( IsXilinxImage )
  {
    v31 = vexosProcessBootData((char *)zipdata_1, &v18, (int *)v17);
    if ( !g_quietmode )
    {
      vexlog(2, "file  cpu0  : %08X\n", v18);
      vexlog(2, "btag  cpu0  : %08X\n", *(_DWORD *)v17);
    }
    if ( v31 != *(_DWORD *)dword_537B94 )
    {
      if ( g_quietmode <= 1 )
        vexlog(2, "size mismatch error\n");
      return 1;
    }
  }
  else
  {
    v18 = *(_DWORD *)v28;
  }
  if ( !v5_SystemAlive(0) )
    return 2;
  if ( !v5_SystemVersion(v16) )
    return 3;
  if ( isV5ProductId((int)v16) && IsXilinxImage != 1 )
  {
    if ( g_quietmode <= 1 )
      vexlog(2, "wrong vexos format for V5\n");
    return 1;
  }
  if ( isIq2BrainProductId((int)v16) && IsIq2Image != 1 )
  {
    if ( g_quietmode <= 1 )
      vexlog(2, "wrong vexos format for IQ2\n");
    return 1;
  }
  if ( isExpBrainProductId((int)v16) && IsExpImage != 1 )
  {
    if ( g_quietmode <= 1 )
      vexlog(2, "wrong vexos format for EXP\n");
    return 1;
  }
  if ( v5_BrainStatus((int)v8, (int)v8) != 118 )
    return 1;
  v23 = ((unsigned __int8)v8[9] << 8)
      + ((unsigned __int8)v8[8] << 16)
      + ((unsigned __int8)v8[7] << 24)
      + (unsigned __int8)v8[10];
  *(_DWORD *)v22 = ((unsigned __int8)v8[13] << 8)
                 + ((unsigned __int8)v8[12] << 16)
                 + ((unsigned __int8)v8[11] << 24)
                 + (unsigned __int8)v8[14];
  *(_DWORD *)v21 = ((unsigned __int8)v8[17] << 8)
                 + ((unsigned __int8)v8[16] << 16)
                 + ((unsigned __int8)v8[15] << 24)
                 + (unsigned __int8)v8[18];
  *(_DWORD *)v20 = (v14 << 8) + (v12 << 16) + (v11 << 24) + v13;
  if ( !g_quietmode )
  {
    vexlog(2, "brain vexos : %08X\n", v23);
    vexlog(2, "brain cpu0  : %08X\n", *(_DWORD *)v22);
    vexlog(2, "brain cpu1  : %08X\n", *(_DWORD *)v21);
    vexlog(2, "brain backup: %08X\n", *(_DWORD *)v20);
    vexlog(2, "brain flags : %08X\n", *(_DWORD *)v9);
    vexlog(2, "brain flags2: %08X\n", *(_DWORD *)v10);
  }
  if ( (*(_DWORD *)v10 & 0x10000) != 0 )
  {
    if ( g_quietmode <= 1 )
      vexlog(2, "V5 field controller not supported !\n");
    return 1;
  }
  if ( (*(_DWORD *)v10 & 0x20000) != 0 )
  {
    if ( g_quietmode <= 1 )
      vexlog(2, "In ROM bootloader !\n");
    goto LABEL_59;
  }
  if ( (*(_DWORD *)v10 & 0x40000) != 0 )
  {
    if ( g_quietmode <= 1 )
      vexlog(2, "In RAM bootloader !\n");
    return iq2_bootloader_update(Source, ElementSize, a4);
  }
  else
  {
    if ( (*(_WORD *)v17 & 0x100) == 0 )
    {
LABEL_59:
      v19 = v5_VersionCheck(*(int *)v22, v18) >= 0;
      v7 = a5 ^ 1;
      if ( (_BYTE)v7 )
      {
        v7 = !v19;
        if ( (_BYTE)v7 )
        {
          if ( g_quietmode <= 1 )
            vexlog(2, "downgrade not possible\n");
          return 1;
        }
      }
      if ( !v5_FactoryEnable(v7) )
        return 4;
      if ( isV5ControllerProductId((int)v16) )
      {
        if ( v5_FileLoadAndRun((int)v15, 1, 128, "stop", v15) != 118 )
          return 4;
        serialSleep(0x3E8u);
      }
      v33 = 0;
      if ( a4 )
        v33 = (int)v5_FileTransferProgress;
      v32 = (*(_DWORD *)v9 & 0x10000) != 0;
      if ( !a3 && *(_DWORD *)v22 == v18 && v23 == *(_DWORD *)v28 )
      {
        if ( g_quietmode <= 1 )
          vexlog(2, "vexos update part 1, skipped, versions match....\n");
      }
      else
      {
        if ( g_quietmode <= 1 )
          vexlog(2, "vexos update part 1, please wait....\n");
        v5_FileTransferMetadata("download", "vexos", (char *)a4);
        if ( v5_Download(240, "boot.bin", zipdata_1, *(int *)dword_537B94, 0, 14, (void (__cdecl *)(size_t, int))v33) )
          return 1;
        if ( isV5ControllerProductId((int)v16) && v5_firmwareWaitForControllerConnection(a4) )
          return 1;
        v5_firmwareWaitForCompletion(a4);
        v32 = 1;
        serialSleep(0x1F4u);
      }
      if ( v32 )
      {
        if ( g_quietmode <= 1 )
          vexlog(2, "vexos update part 2, please wait....\n");
        v5_FileTransferMetadata("download", "assets", (char *)a4);
        if ( v5_Download(
               240,
               "assets.bin",
               (_BYTE *)dword_537B84,
               *(int *)dword_537B98,
               0,
               13,
               (void (__cdecl *)(size_t, int))v33) )
        {
          return 1;
        }
        if ( isV5ControllerProductId((int)v16) && v5_firmwareWaitForControllerConnection(a4) )
          return 1;
        v5_firmwareWaitForCompletion(a4);
      }
      else if ( g_quietmode <= 1 )
      {
        vexlog(2, "vexos update part 2, skipped, versions match....\n");
      }
      if ( g_quietmode <= 1 )
        vexlog(2, "vexos update complete\n");
      return 0;
    }
    if ( g_quietmode <= 1 )
      vexlog(2, "V5 field controller firmware not supported !\n");
    return 1;
  }
}
// 44BF70: using guessed type int g_quietmode;
// 40D069: using guessed type int var_40;
// 40D069: using guessed type _DWORD var_50[3];
// 40D069: using guessed type _DWORD var_2C;

//----- (0040D948) --------------------------------------------------------
int curl_dylib_init()
{
  CHAR Filename[260]; // [esp+18h] [ebp-110h] BYREF
  HMODULE hModule; // [esp+11Ch] [ebp-Ch]

  if ( dl_curl )
    return 0;
  hModule = LoadLibraryA("libcurl.dll");
  if ( hModule )
  {
    curl_global_init = (int (__cdecl *)(_DWORD))GetProcAddress(hModule, "curl_global_init");
    curl_global_cleanup = GetProcAddress(hModule, "curl_global_cleanup");
    curl_easy_init = GetProcAddress(hModule, "curl_easy_init");
    curl_easy_setopt = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))GetProcAddress(hModule, "curl_easy_setopt");
    curl_easy_perform = (int (__cdecl *)(_DWORD))GetProcAddress(hModule, "curl_easy_perform");
    curl_easy_cleanup = (int (__cdecl *)(_DWORD))GetProcAddress(hModule, "curl_easy_cleanup");
    curl_easy_strerror = (int (__cdecl *)(_DWORD))GetProcAddress(hModule, "curl_easy_strerror");
    if ( curl_global_init )
    {
      if ( curl_global_cleanup )
      {
        if ( curl_easy_init )
        {
          if ( curl_easy_setopt )
          {
            if ( curl_easy_perform )
            {
              if ( curl_easy_cleanup )
              {
                if ( curl_easy_strerror )
                {
                  dl_curl = 1;
                  if ( GetModuleFileNameA(hModule, Filename, 0x104u) && !g_jsonmode && !g_quietmode )
                    vexlog(2, "libcurl: loaded from %s\n", Filename);
                  return 0;
                }
                else
                {
                  return 1;
                }
              }
              else
              {
                return 1;
              }
            }
            else
            {
              return 1;
            }
          }
          else
          {
            return 1;
          }
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    vexerr(255, "libcurl: not installed\n");
    return 1;
  }
}
// 44BF70: using guessed type int g_quietmode;
// 520044: using guessed type int g_jsonmode;
// 535740: using guessed type char dl_curl;
// 535744: using guessed type int (__cdecl *curl_global_init)(_DWORD);
// 535748: using guessed type int (*curl_global_cleanup)(void);
// 53574C: using guessed type int (*curl_easy_init)(void);
// 535750: using guessed type int (__cdecl *curl_easy_setopt)(_DWORD, _DWORD, _DWORD);
// 535754: using guessed type int (__cdecl *curl_easy_perform)(_DWORD);
// 535758: using guessed type int (__cdecl *curl_easy_cleanup)(_DWORD);
// 53575C: using guessed type int (__cdecl *curl_easy_strerror)(_DWORD);

//----- (0040DB52) --------------------------------------------------------
int __cdecl curlWriteMemoryCallback(void *Src, int a2, int a3, int a4)
{
  void *v5; // [esp+14h] [ebp-14h]
  int Size; // [esp+1Ch] [ebp-Ch]

  Size = a3 * a2;
  v5 = realloc(*(void **)a4, *(_DWORD *)(a4 + 4) + a3 * a2 + 1);
  if ( v5 )
  {
    *(_DWORD *)a4 = v5;
    memcpy((void *)(*(_DWORD *)(a4 + 4) + *(_DWORD *)a4), Src, Size);
    *(_DWORD *)(a4 + 4) += Size;
    *(_BYTE *)(*(_DWORD *)a4 + *(_DWORD *)(a4 + 4)) = 0;
    return a3 * a2;
  }
  else
  {
    vexerr(255, "not enough memory (realloc returned NULL)\n");
    return 0;
  }
}

//----- (0040DC02) --------------------------------------------------------
int __cdecl v5_firmwareGetCatalog(const char *a1)
{
  const char *v2; // eax
  char Buffer[256]; // [esp+1Ch] [ebp-11Ch] BYREF
  void *Block[2]; // [esp+11Ch] [ebp-1Ch] BYREF
  int v5; // [esp+124h] [ebp-14h]
  int v6; // [esp+128h] [ebp-10h]
  int v7; // [esp+12Ch] [ebp-Ch]

  v7 = -1;
  if ( !a1 )
    return 0;
  if ( curl_dylib_init() == 1 )
    return 0;
  Block[0] = malloc(1u);
  Block[1] = 0;
  sprintf(Buffer, "%scatalog.txt", a1);
  vexlog(4, "catalog: %s\n", Buffer);
  curl_global_init(3);
  v6 = curl_easy_init();
  if ( v6 )
  {
    curl_easy_setopt(v6, 10002, Buffer);
    curl_easy_setopt(v6, 64, 0);
    curl_easy_setopt(v6, 20011, curlWriteMemoryCallback);
    curl_easy_setopt(v6, 10001, Block);
    curl_easy_setopt(v6, 10018, "libcurl-agent/1.0");
    v5 = curl_easy_perform(v6);
    if ( v5 )
    {
      v2 = (const char *)curl_easy_strerror(v5);
      vexerr(255, "curl_easy_perform() failed: %s\n", v2);
    }
    else
    {
      v7 = vexosCatalogToLatestVersion((int)Block[0]);
    }
    curl_easy_cleanup(v6);
    free(Block[0]);
  }
  curl_global_cleanup();
  return v7;
}
// 535744: invalid function type has been ignored
// 53574C: invalid function type has been ignored
// 535750: invalid function type has been ignored
// 535754: invalid function type has been ignored
// 53575C: invalid function type has been ignored
// 535758: invalid function type has been ignored
// 535748: invalid function type has been ignored
// 535744: using guessed type int (__cdecl *curl_global_init)(_DWORD);
// 535748: using guessed type int (*curl_global_cleanup)(void);
// 53574C: using guessed type int (*curl_easy_init)(void);
// 535750: using guessed type int (__cdecl *curl_easy_setopt)(_DWORD, _DWORD, _DWORD);
// 535754: using guessed type int (__cdecl *curl_easy_perform)(_DWORD);
// 535758: using guessed type int (__cdecl *curl_easy_cleanup)(_DWORD);
// 53575C: using guessed type int (__cdecl *curl_easy_strerror)(_DWORD);

//----- (0040DDAA) --------------------------------------------------------
int __cdecl v5_firmwareGetVersion(const char *a1, const char *a2, int a3, void **a4)
{
  const char *v5; // eax
  char Buffer[256]; // [esp+2Ch] [ebp-11Ch] BYREF
  void *Block; // [esp+12Ch] [ebp-1Ch] BYREF
  char v8[4]; // [esp+130h] [ebp-18h]
  int v9; // [esp+134h] [ebp-14h]
  int v10; // [esp+138h] [ebp-10h]
  int v11; // [esp+13Ch] [ebp-Ch]

  *a4 = 0;
  if ( !a1 )
    return 0;
  if ( curl_dylib_init() == 1 )
    return 0;
  Block = malloc(1u);
  *(_DWORD *)v8 = 0;
  v11 = a3;
  sprintf(Buffer, "%s%s_%d_%d_%d_%d.vexos", a1, a2, HIBYTE(a3), BYTE2(a3), BYTE1(a3), (unsigned __int8)a3);
  vexlog(4, "vexos  : %s\n", Buffer);
  curl_global_init(3);
  v10 = curl_easy_init();
  if ( v10 )
  {
    curl_easy_setopt(v10, 10002, Buffer);
    curl_easy_setopt(v10, 64, 0);
    if ( g_quietmode )
      curl_easy_setopt(v10, 43, 1);
    else
      curl_easy_setopt(v10, 43, 0);
    curl_easy_setopt(v10, 20011, curlWriteMemoryCallback);
    curl_easy_setopt(v10, 10001, &Block);
    curl_easy_setopt(v10, 10018, "libcurl-agent/1.0");
    v9 = curl_easy_perform(v10);
    if ( v9 )
    {
      v5 = (const char *)curl_easy_strerror(v9);
      vexerr(255, "vexos  : curl_easy_perform() failed %s\n", v5);
    }
    else
    {
      vexerr(255, "vexos  : received %d bytes\n", *(_DWORD *)v8);
      *a4 = Block;
    }
    curl_easy_cleanup(v10);
    if ( !*a4 )
      free(Block);
  }
  curl_global_cleanup();
  return *(_DWORD *)v8;
}
// 44BF70: using guessed type int g_quietmode;
// 535744: using guessed type int (__cdecl *curl_global_init)(_DWORD);
// 535748: using guessed type int (*curl_global_cleanup)(void);
// 53574C: using guessed type int (*curl_easy_init)(void);
// 535750: using guessed type int (__cdecl *curl_easy_setopt)(_DWORD, _DWORD, _DWORD);
// 535754: using guessed type int (__cdecl *curl_easy_perform)(_DWORD);
// 535758: using guessed type int (__cdecl *curl_easy_cleanup)(_DWORD);
// 53575C: using guessed type int (__cdecl *curl_easy_strerror)(_DWORD);

//----- (0040E008) --------------------------------------------------------
int __cdecl writeImage(char *FileName, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char v13; // cl
  char *v14; // eax
  char v15; // cl
  char *v16; // eax
  char v17; // cl
  char *v18; // eax
  size_t v20; // [esp+30h] [ebp-58h] BYREF
  int v21; // [esp+34h] [ebp-54h]
  int v22; // [esp+38h] [ebp-50h]
  int v23; // [esp+3Ch] [ebp-4Ch]
  void *v24; // [esp+40h] [ebp-48h]
  int ii; // [esp+44h] [ebp-44h]
  char *v26; // [esp+48h] [ebp-40h]
  _WORD *v27; // [esp+4Ch] [ebp-3Ch]
  int n; // [esp+50h] [ebp-38h]
  int m; // [esp+54h] [ebp-34h]
  char *v30; // [esp+58h] [ebp-30h]
  char *v31; // [esp+5Ch] [ebp-2Ch]
  int k; // [esp+60h] [ebp-28h]
  int j; // [esp+64h] [ebp-24h]
  char *v34; // [esp+68h] [ebp-20h]
  char *v35; // [esp+6Ch] [ebp-1Ch]
  int i; // [esp+70h] [ebp-18h]
  int info_struct; // [esp+74h] [ebp-14h]
  FILE *Stream; // [esp+78h] [ebp-10h]
  int v39; // [esp+7Ch] [ebp-Ch]

  v39 = 0;
  v20 = 0;
  info_struct = 0;
  v24 = 0;
  Stream = fopen(FileName, "wb");
  if ( Stream )
  {
    v20 = (size_t)png_create_write_struct("1.6.30", 0, 0);
    if ( v20 )
    {
      info_struct = (int)png_create_info_struct(v20);
      if ( info_struct )
      {
        v6 = png_set_longjmp_fn((_DWORD *)v20, (int)longjmp, 0x40u);
        if ( _setjmp3(v6, 0) )
        {
          vexerr(255, "Error during png creation\n");
          v39 = 1;
        }
        else
        {
          png_init_io(v20, (int)Stream);
          png_set_IHDR(v20, info_struct, a2, a3, 8u, 2u, 0, 0, 0);
          png_write_info(v20, info_struct);
          v24 = malloc(3 * a2);
          if ( !a6 )
          {
            v23 = a5;
            for ( i = 0; i < a3; ++i )
            {
              v35 = (char *)(4 * a4 * i + v23);
              v34 = (char *)v24;
              for ( j = 0; j < a2; ++j )
              {
                v7 = v34++;
                *v7 = v35[2];
                v8 = v34++;
                *v8 = v35[1];
                v9 = v34++;
                *v9 = *v35;
                v35 += 4;
              }
              png_write_row((_BYTE *)v20, v24);
            }
          }
          if ( a6 == 2 )
          {
            v22 = a5;
            for ( k = 0; k < a3; ++k )
            {
              v31 = (char *)(a4 * k + v22);
              v30 = (char *)v24;
              for ( m = 0; m < a2; ++m )
              {
                v10 = v30++;
                *v10 = *v31;
                v11 = v30++;
                *v11 = *v31;
                v12 = v30++;
                *v12 = *v31++;
              }
              png_write_row((_BYTE *)v20, v24);
            }
          }
          else
          {
            v21 = a5;
            for ( n = 0; n < a3; ++n )
            {
              v27 = (_WORD *)(2 * a4 * n + v21);
              v26 = (char *)v24;
              for ( ii = 0; ii < a2; ++ii )
              {
                v13 = *v27;
                v14 = v26++;
                *v14 = v13 & 0xF8;
                v15 = (*v27 >> 11) & 0x1C | (32 * *v27);
                v16 = v26++;
                *v16 = v15;
                v17 = *v27 >> 5;
                v18 = v26++;
                *v18 = v17 & 0xF8;
                ++v27;
              }
              png_write_row((_BYTE *)v20, v24);
            }
          }
          png_write_end(v20);
        }
      }
      else
      {
        vexerr(255, "Could not allocate info struct\n");
        v39 = 1;
      }
    }
    else
    {
      vexerr(255, "Could not allocate write struct\n");
      v39 = 1;
    }
  }
  else
  {
    vexerr(255, "Could not open file %s for writing\n", FileName);
    v39 = 1;
  }
  if ( Stream )
    fclose(Stream);
  if ( info_struct )
    png_free_data((void *)v20, info_struct, 0x7FFF, -1);
  if ( v20 )
    png_destroy_write_struct((int *)&v20, 0);
  return v39;
}
// 424E70: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);

//----- (0040E444) --------------------------------------------------------
unsigned int Crc32GenerateTable()
{
  unsigned int result; // eax
  int v1; // [esp+4h] [ebp-Ch]
  unsigned int j; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i <= 0xFF; ++i )
  {
    v1 = i << 24;
    for ( j = 0; j <= 7; ++j )
    {
      if ( v1 >= 0 )
        v1 *= 2;
      else
        v1 = (2 * v1) ^ 0x4C11DB7;
    }
    result = i;
    _crc32_table[i] = v1;
  }
  _table32Generated = 1;
  return result;
}
// 535760: using guessed type int _crc32_table[256];
// 535B60: using guessed type char _table32Generated;

//----- (0040E4AE) --------------------------------------------------------
unsigned int Crc16GenerateTable()
{
  unsigned int result; // eax
  __int16 v1; // [esp+6h] [ebp-Ah]
  unsigned int j; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i <= 0xFF; ++i )
  {
    v1 = (_WORD)i << 8;
    for ( j = 0; j <= 7; ++j )
    {
      if ( v1 >= 0 )
        v1 *= 2;
      else
        v1 = (2 * v1) ^ 0x1021;
    }
    result = i;
    _crc16_table[i] = v1;
  }
  _table16Generated = 1;
  return result;
}
// 535B80: using guessed type __int16 _crc16_table[256];
// 535D80: using guessed type char _table16Generated;

//----- (0040E520) --------------------------------------------------------
int Crc32GenerateReverseTable()
{
  int result; // eax
  int j; // [esp+4h] [ebp-Ch]
  unsigned __int8 v2; // [esp+Ah] [ebp-6h]
  unsigned __int8 v3; // [esp+Bh] [ebp-5h]
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i <= 255; ++i )
  {
    v3 = 0;
    v2 = i;
    for ( j = 0; j <= 7; ++j )
    {
      v3 = v2 & 1 | (2 * v3);
      v2 >>= 1;
    }
    result = v3;
    _bitrev_table[i] = v3;
  }
  return result;
}

//----- (0040E583) --------------------------------------------------------
int __cdecl Crc32Reflect8(unsigned __int8 a1)
{
  return (unsigned __int8)_bitrev_table[a1];
}

//----- (0040E59C) --------------------------------------------------------
int __cdecl Crc32Reflect32(int a1)
{
  _BYTE *v1; // ebx
  _BYTE *v2; // ebx
  _BYTE *v3; // ebx
  int v5; // [esp+8h] [ebp-10h] BYREF
  int *v6; // [esp+Ch] [ebp-Ch]
  unsigned __int8 *v7; // [esp+10h] [ebp-8h]

  v7 = (unsigned __int8 *)&a1;
  v6 = &v5;
  LOBYTE(v5) = Crc32Reflect8(HIBYTE(a1));
  v1 = (char *)v6 + 1;
  *v1 = Crc32Reflect8(v7[2]);
  v2 = (char *)v6 + 2;
  *v2 = Crc32Reflect8(v7[1]);
  v3 = (char *)v6 + 3;
  *v3 = Crc32Reflect8(*v7);
  return v5;
}

//----- (0040E624) --------------------------------------------------------
int __cdecl Crc32Generate(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // eax
  unsigned int i; // [esp+Ch] [ebp-4h]

  if ( !_table32Generated )
  {
    Crc32GenerateTable();
    Crc32GenerateReverseTable();
  }
  for ( i = 0; i < a2; ++i )
  {
    v3 = a1++;
    a3 = (a3 << 8) ^ _crc32_table[(unsigned __int8)(HIBYTE(a3) ^ *v3)];
  }
  return a3;
}
// 535760: using guessed type int _crc32_table[256];
// 535B60: using guessed type char _table32Generated;

//----- (0040E691) --------------------------------------------------------
int __cdecl Crc32GenerateReflectedInput(unsigned __int8 *a1, unsigned int a2, int a3)
{
  unsigned __int8 *v3; // eax
  unsigned int i; // [esp+10h] [ebp-8h]

  if ( !_table32Generated )
  {
    Crc32GenerateTable();
    Crc32GenerateReverseTable();
  }
  for ( i = 0; i < a2; ++i )
  {
    v3 = a1++;
    a3 = (a3 << 8) ^ _crc32_table[(unsigned __int8)(HIBYTE(a3) ^ Crc32Reflect8(*v3))];
  }
  return a3;
}
// 535760: using guessed type int _crc32_table[256];
// 535B60: using guessed type char _table32Generated;

//----- (0040E70E) --------------------------------------------------------
int __cdecl Crc16Generate(_BYTE *a1, unsigned int a2, unsigned __int16 a3)
{
  _BYTE *v3; // eax
  unsigned int i; // [esp+10h] [ebp-4h]

  if ( !_table16Generated )
    Crc16GenerateTable();
  for ( i = 0; i < a2; ++i )
  {
    v3 = a1++;
    a3 = (a3 << 8) ^ _crc16_table[(unsigned __int8)(HIBYTE(a3) ^ *v3)];
  }
  return a3;
}
// 535B80: using guessed type __int16 _crc16_table[256];
// 535D80: using guessed type char _table16Generated;

//----- (0040E784) --------------------------------------------------------
int debugRxBuffer()
{
  int result; // eax
  char v1; // [esp+17h] [ebp-11h]
  int v2; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  v2 = dword_536000 + 1;
  v1 = v5_VerboseCommsGet();
  result = g_quietmode;
  if ( !g_quietmode && v1 )
  {
    vexlog(2, "RX (%4d):", v2);
    for ( i = 0; i < v2 && i <= 47; ++i )
      printf("%02X ", byte_535EFD[i]);
    return vexlog(2, "\n");
  }
  return result;
}
// 44BF70: using guessed type int g_quietmode;
// 535EFD: using guessed type unsigned __int8 byte_535EFD[259];
// 536000: using guessed type int dword_536000;

//----- (0040E817) --------------------------------------------------------
int __cdecl cc264xSendData(unsigned __int8 *a1, signed int nNumberOfBytesToWrite)
{
  char v3; // [esp+1Bh] [ebp-Dh]
  int i; // [esp+1Ch] [ebp-Ch]

  v3 = v5_VerboseCommsGet();
  if ( !g_serial )
    return -1;
  if ( !g_quietmode && v3 )
  {
    vexlog(2, "TX (%4d):", nNumberOfBytesToWrite);
    for ( i = 0; i < nNumberOfBytesToWrite && i <= 47; ++i )
      vexlog(2, "%02X ", a1[i]);
    vexlog(2, "\n");
  }
  serialFlush((HANDLE *)g_serial);
  if ( serialWrite((HANDLE *)g_serial, a1, nNumberOfBytesToWrite) )
    return -1;
  else
    return nNumberOfBytesToWrite;
}
// 44BF70: using guessed type int g_quietmode;

//----- (0040E8E9) --------------------------------------------------------
int __cdecl cc2642OptimizeDownloadSize(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // eax
  int *v3; // [esp+1Ch] [ebp-1Ch]
  unsigned int j; // [esp+20h] [ebp-18h]
  _DWORD *v5; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  char v7; // [esp+2Fh] [ebp-9h]

  v3 = (int *)a1[7];
  result = *v3;
  if ( *v3 == 536951808 )
  {
    if ( bFullRadioProgram )
    {
      bFullRadioProgram = 0;
      return vexlog(4, "cc264x: radio fw no optimization, %d sectors, %08X bytes\n", a1[13], a1[4]);
    }
    else
    {
      v7 = 0;
      for ( i = 0; i <= 31 && v7 != 1; ++i )
      {
        v5 = (int *)((char *)v3 + ((a1[4] - 0x2000) & 0xFFFFFFFC));
        for ( j = 0; j <= 0x7FF; ++j )
        {
          v2 = v5++;
          if ( *v2 != -1 )
          {
            v7 = 1;
            break;
          }
        }
        if ( v7 != 1 )
        {
          a1[4] -= 0x2000;
          --a1[13];
        }
      }
      return vexlog(4, "cc264x: radio fw optimized to %d sectors, %08X bytes\n", *(_DWORD *)dword_535ED4, dword_535EB0);
    }
  }
  return result;
}
// 535EB0: using guessed type int dword_535EB0;
// 53608C: using guessed type char bFullRadioProgram;

//----- (0040EA0A) --------------------------------------------------------
int __cdecl cc264xSendBootloadCommand(int a1)
{
  unsigned __int8 v1; // al
  unsigned __int8 v2; // cl
  unsigned __int8 v3; // al
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // cl
  unsigned __int8 v7; // al
  int v8; // ecx
  unsigned __int8 v9; // al
  unsigned __int8 v10; // cl
  unsigned __int8 v11; // al
  unsigned __int8 v12; // cl
  unsigned __int8 v13; // al
  unsigned __int8 v14; // cl
  unsigned __int8 v15; // al
  int v16; // ecx
  unsigned __int8 v17; // al
  unsigned __int8 *v18; // eax
  unsigned __int8 v19; // dl
  unsigned __int8 v21[256]; // [esp+1Ch] [ebp-11Ch] BYREF
  int j; // [esp+11Ch] [ebp-1Ch]
  int v23; // [esp+120h] [ebp-18h]
  unsigned int i; // [esp+124h] [ebp-14h]
  unsigned __int8 *v25; // [esp+128h] [ebp-10h]
  unsigned __int8 v26; // [esp+12Fh] [ebp-9h]

  v26 = 2;
  if ( *(_BYTE *)(a1 + 72) )
  {
    v1 = v26++;
    v21[v1] = *(_BYTE *)(a1 + 72);
  }
  if ( *(_DWORD *)(a1 + 76) != -1 )
  {
    v2 = HIBYTE(*(_DWORD *)(a1 + 76));
    v3 = v26++;
    v21[v3] = v2;
    v4 = BYTE2(*(_DWORD *)(a1 + 76));
    v5 = v26++;
    v21[v5] = v4;
    v6 = BYTE1(*(_DWORD *)(a1 + 76));
    v7 = v26++;
    v21[v7] = v6;
    v8 = *(_DWORD *)(a1 + 76);
    v9 = v26++;
    v21[v9] = v8;
  }
  if ( *(_DWORD *)(a1 + 80) != -1 )
  {
    v10 = HIBYTE(*(_DWORD *)(a1 + 80));
    v11 = v26++;
    v21[v11] = v10;
    v12 = BYTE2(*(_DWORD *)(a1 + 80));
    v13 = v26++;
    v21[v13] = v12;
    v14 = BYTE1(*(_DWORD *)(a1 + 80));
    v15 = v26++;
    v21[v15] = v14;
    v16 = *(_DWORD *)(a1 + 80);
    v17 = v26++;
    v21[v17] = v16;
  }
  if ( *(_DWORD *)(a1 + 84) && *(_DWORD *)(a1 + 88) )
  {
    v25 = *(unsigned __int8 **)(a1 + 84);
    for ( i = 0; *(_DWORD *)(a1 + 88) > i && v26 != 0xFF; ++i )
    {
      v18 = v25++;
      v19 = v26++;
      v21[v19] = *v18;
    }
  }
  v23 = 0;
  for ( j = 2; j < v26; ++j )
    v23 += v21[j];
  v21[1] = v23;
  v21[0] = v26;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 33) = 0;
  *(_BYTE *)(a1 + 34) = 0;
  *(_DWORD *)(a1 + 4) = 200;
  return cc264xSendData(v21, v26);
}
// 40EA0A: using guessed type unsigned __int8 var_11C[256];

//----- (0040EC2C) --------------------------------------------------------
int cc264xBootloadSendAck()
{
  int v1; // [esp+1Eh] [ebp-Ah] BYREF

  LOWORD(v1) = -13312;
  return cc264xSendData((unsigned __int8 *)&v1, 2);
}

//----- (0040EC50) --------------------------------------------------------
int cc264xBootloadSendNak()
{
  int v1; // [esp+1Eh] [ebp-Ah] BYREF

  LOWORD(v1) = 13056;
  return cc264xSendData((unsigned __int8 *)&v1, 2);
}

//----- (0040EC74) --------------------------------------------------------
int cc264xBootloadSendHello()
{
  int v1; // [esp+1Eh] [ebp-Ah] BYREF

  LOWORD(v1) = 21845;
  return cc264xSendData((unsigned __int8 *)&v1, 2);
}

//----- (0040EC98) --------------------------------------------------------
BOOL __cdecl cc264xBootloadValidateChecksum(int a1)
{
  int i; // [esp+8h] [ebp-8h]
  int v3; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = 2; i < *(unsigned __int8 *)(a1 + 356); ++i )
    v3 += *(unsigned __int8 *)(a1 + i + 356);
  return v3 == *(unsigned __int8 *)(a1 + 357);
}

//----- (0040ECFA) --------------------------------------------------------
int __cdecl cc264xBootloadClearCommand(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = -1;
  *(_DWORD *)(a1 + 80) = -1;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 92) = 0;
  result = a1;
  *(_BYTE *)(a1 + 35) = 0;
  return result;
}

//----- (0040ED3D) --------------------------------------------------------
int __cdecl cc264xSendBootloaderPing(int a1)
{
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 32;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040ED63) --------------------------------------------------------
int __cdecl cc264xSendBootloaderGetStatus(int a1)
{
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 35;
  *(_BYTE *)(a1 + 92) = 1;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040ED90) --------------------------------------------------------
int __cdecl cc264xSendBootloaderGetChipId(int a1)
{
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 40;
  *(_BYTE *)(a1 + 92) = 1;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040EDBD) --------------------------------------------------------
int __cdecl cc264xSendBootloaderGetChecksum(int a1, int a2, int a3)
{
  char v4[12]; // [esp+1Ch] [ebp-Ch] BYREF

  v4[0] = 0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = 0;
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 39;
  *(_DWORD *)(a1 + 76) = a2;
  *(_DWORD *)(a1 + 80) = a3;
  *(_DWORD *)(a1 + 84) = v4;
  *(_DWORD *)(a1 + 88) = 4;
  *(_BYTE *)(a1 + 92) = 1;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040EE1F) --------------------------------------------------------
int __cdecl cc264xSendBootloaderReadMemory32(int a1, int a2, char a3)
{
  char v4[10]; // [esp+1Eh] [ebp-Ah] BYREF

  v4[0] = 1;
  v4[1] = a3;
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 42;
  *(_DWORD *)(a1 + 76) = a2;
  *(_DWORD *)(a1 + 84) = v4;
  *(_DWORD *)(a1 + 88) = 2;
  *(_BYTE *)(a1 + 92) = 1;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040EE72) --------------------------------------------------------
int __cdecl cc264xSendBootloaderEraseBlock(int a1, int a2)
{
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 38;
  *(_DWORD *)(a1 + 76) = a2;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040EEA1) --------------------------------------------------------
int __cdecl cc264xSendBootloaderDownload(int a1, int a2, int a3)
{
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 33;
  *(_DWORD *)(a1 + 76) = a2;
  *(_DWORD *)(a1 + 80) = a3;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040EED9) --------------------------------------------------------
int __cdecl cc264xSendBootloaderWriteData(int a1, int a2, unsigned __int8 a3)
{
  cc264xBootloadClearCommand(a1);
  *(_BYTE *)(a1 + 72) = 36;
  *(_DWORD *)(a1 + 84) = a2;
  *(_DWORD *)(a1 + 88) = a3;
  return cc264xSendBootloadCommand(a1);
}

//----- (0040EF18) --------------------------------------------------------
unsigned int __cdecl cc264xResponseToWordBE(unsigned int *a1)
{
  return _byteswap_ulong(*a1);
}

//----- (0040EF64) --------------------------------------------------------
int __cdecl cc264xResponseToWordLE(unsigned __int8 *a1)
{
  return (a1[1] << 8) | (a1[2] << 16) | (a1[3] << 24) | *a1;
}

//----- (0040EFB0) --------------------------------------------------------
int __cdecl cc264xCrc32Gen(unsigned __int8 *a1, unsigned int a2)
{
  int ReflectedInput; // eax

  ReflectedInput = Crc32GenerateReflectedInput(a1, a2, -1);
  return ~Crc32Reflect32(ReflectedInput);
}

//----- (0040EFE8) --------------------------------------------------------
int __cdecl cc264xBootloaderCommsReply(unsigned __int8 a1)
{
  int result; // eax
  unsigned __int8 v2; // al

  result = radio_dfu;
  if ( radio_dfu == 1 )
  {
    if ( a1 == 0xCC )
    {
      *((_BYTE *)&radio_dfu + 33) = 1;
      if ( *((_BYTE *)&radio_dfu + 92) )
      {
        result = (int)&radio_dfu;
        radio_dfu = 2;
      }
      else
      {
        radio_dfu = 0;
        result = debugRxBuffer();
      }
    }
    if ( a1 == 51 )
    {
      *((_BYTE *)&radio_dfu + 34) = 1;
      radio_dfu = 0;
      return debugRxBuffer();
    }
  }
  else if ( radio_dfu > 1 )
  {
    if ( radio_dfu == 2 )
    {
      if ( a1 )
      {
        *((_BYTE *)&radio_dfu + 356) = a1;
        *((_BYTE *)&radio_dfu + 486) = 1;
        result = (int)&radio_dfu;
        if ( a1 > 0x81u )
          radio_dfu = 0;
        else
          ++radio_dfu;
      }
    }
    else
    {
      if ( radio_dfu != 3 )
        goto LABEL_27;
      if ( *((_BYTE *)&radio_dfu + 486) >= *((_BYTE *)&radio_dfu + 356) )
      {
        result = (int)&radio_dfu;
        radio_dfu = 0;
      }
      else
      {
        v2 = *((_BYTE *)&radio_dfu + 486);
        *((_BYTE *)&radio_dfu + 486) = v2 + 1;
        *((_BYTE *)&radio_dfu + v2 + 356) = a1;
        result = *((unsigned __int8 *)&radio_dfu + 356);
        if ( *((_BYTE *)&radio_dfu + 486) == (_BYTE)result )
        {
          debugRxBuffer();
          if ( cc264xBootloadValidateChecksum((int)&radio_dfu) )
            cc264xBootloadSendAck();
          else
            cc264xBootloadSendNak();
          *((_BYTE *)&radio_dfu + 35) = 1;
          result = (int)&radio_dfu;
          radio_dfu = 0;
        }
      }
    }
  }
  else
  {
    if ( radio_dfu )
    {
LABEL_27:
      result = (int)&radio_dfu;
      radio_dfu = 0;
      return result;
    }
    if ( !a1 )
      radio_dfu = 1;
  }
  return result;
}
// 535EA0: using guessed type int radio_dfu;

//----- (0040F187) --------------------------------------------------------
int __cdecl cc264xWaitForReply(int a1, char a2)
{
  int v3; // [esp+2Ch] [ebp-Ch]

  *(_DWORD *)(a1 + 352) = 0;
  do
  {
    v3 = serialRead((HANDLE *)g_serial, (void *)(*(_DWORD *)(a1 + 352) + 80 + a1 + 13), 1u);
    if ( v3 )
      break;
    cc264xBootloaderCommsReply(*(_BYTE *)(a1 + *(_DWORD *)(a1 + 352) + 93));
    ++*(_DWORD *)(a1 + 352);
    if ( *(_BYTE *)(a1 + 33) )
    {
      if ( a2 )
        break;
    }
  }
  while ( (!*(_BYTE *)(a1 + 34) || !a2) && !*(_BYTE *)(a1 + 35) );
  return v3;
}

//----- (0040F249) --------------------------------------------------------
BOOL __cdecl cc264xWaitForAck(int a1)
{
  return !cc264xWaitForReply(a1, 1) && *(_BYTE *)(a1 + 33);
}

//----- (0040F284) --------------------------------------------------------
BOOL __cdecl cc264xWaitForResponse(int a1)
{
  return !cc264xWaitForReply(a1, 0) && *(_BYTE *)(a1 + 35);
}

//----- (0040F2BF) --------------------------------------------------------
int __cdecl cc264xBootloaderGetChipId(_DWORD *a1)
{
  cc264xSendBootloaderGetChipId((int)a1);
  if ( !cc264xWaitForResponse((int)a1) )
    return 1;
  a1[14] = cc264xResponseToWordBE((_DWORD *)((char *)a1 + 358));
  a1[15] = a1[14] >> 28;
  if ( a1[15] == 11 )
  {
    dword_535ED0 = 4096;
    *(_DWORD *)dword_535ED4 = 29;
    dword_535EB0 = 118784;
    vexlog(4, "cc264x: 2640 found, recalculate parameters\n");
  }
  return 0;
}
// 535EB0: using guessed type int dword_535EB0;
// 535ED0: using guessed type int dword_535ED0;

//----- (0040F353) --------------------------------------------------------
int __cdecl cc264xBootloaderGetMemorySizes(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]

  cc264xSendBootloaderReadMemory32(a1, 1073938476, 1);
  if ( !cc264xWaitForResponse(a1) )
    return 1;
  *(_DWORD *)(a1 + 40) = dword_535ED0 * (unsigned __int8)cc264xResponseToWordLE((unsigned __int8 *)(a1 + 358));
  cc264xSendBootloaderReadMemory32(a1, 1074274896, 1);
  if ( !cc264xWaitForResponse(a1) )
    return 1;
  v2 = cc264xResponseToWordLE((unsigned __int8 *)(a1 + 358)) & 3;
  switch ( v2 )
  {
    case 2:
      *(_DWORD *)(a1 + 44) = 0x4000;
      break;
    case 3:
      *(_DWORD *)(a1 + 44) = 20480;
      break;
    case 1:
      *(_DWORD *)(a1 + 44) = 10240;
      break;
    default:
      *(_DWORD *)(a1 + 44) = 4096;
      break;
  }
  cc264xSendBootloaderReadMemory32(a1, *(_DWORD *)(a1 + 40) - 88, 1);
  if ( !cc264xWaitForResponse(a1) )
    return 1;
  *(_DWORD *)(a1 + 68) = cc264xResponseToWordLE((unsigned __int8 *)(a1 + 358));
  if ( *(_DWORD *)(a1 + 68) == -1 && *(_DWORD *)(a1 + 64) == 536951808 && *(_DWORD *)(a1 + 40) == 360448 )
  {
    *(_DWORD *)dword_535ED4 = 44;
    dword_535EB0 = 360448;
    vexlog(4, "cc264x: reconfigured for full update\n");
  }
  return 0;
}
// 535EB0: using guessed type int dword_535EB0;
// 535ED0: using guessed type int dword_535ED0;

//----- (0040F4DB) --------------------------------------------------------
int __cdecl cc264xBootloaderGetChecksum(int a1)
{
  cc264xSendBootloaderGetChecksum(a1, *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  if ( !cc264xWaitForResponse(a1) )
    return 1;
  *(_DWORD *)(a1 + 20) = cc264xResponseToWordBE((unsigned int *)(a1 + 358));
  if ( *(_DWORD *)(a1 + 28) )
    *(_DWORD *)(a1 + 24) = cc264xCrc32Gen(*(unsigned __int8 **)(a1 + 28), *(_DWORD *)(a1 + 16));
  return 0;
}

//----- (0040F55F) --------------------------------------------------------
int __cdecl cc264xBootloaderEraseFlash(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  vexlog(4, "cc264x: flash erase\n");
  *(_DWORD *)(a1 + 8) = 0;
  do
  {
    if ( *(_DWORD *)(a1 + 8) > (unsigned int)(dword_535ED0 * *(_DWORD *)dword_535ED4) )
      return 1;
    vexlog(4, "cc264x: flash erase %d %08X\n", *(_DWORD *)(a1 + 8), v2);
    if ( *(_DWORD *)(a1 + 488) )
      (*(void (__cdecl **)(_DWORD, int))(a1 + 488))(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 52));
    cc264xSendBootloaderEraseBlock(a1, *(_DWORD *)(a1 + 8));
    if ( !cc264xWaitForAck(a1) )
      return 1;
    cc264xSendBootloaderGetStatus(a1);
    if ( !cc264xWaitForResponse(a1) )
      return 1;
    if ( *(_BYTE *)(a1 + 358) != 64 )
      return 1;
    *(_DWORD *)(a1 + 8) += dword_535ED0;
  }
  while ( *(_DWORD *)(a1 + 8) < (unsigned int)(*(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 52)) );
  vexlog(4, "cc264x: flash erase done\n");
  if ( *(_DWORD *)(a1 + 488) )
    (*(void (__cdecl **)(int, int))(a1 + 488))(100, 100);
  *(_DWORD *)(a1 + 8) = 0;
  return 0;
}
// 40F5BE: variable 'v2' is possibly undefined
// 535ED0: using guessed type int dword_535ED0;

//----- (0040F6DC) --------------------------------------------------------
int __cdecl cc264xBootloaderWriteFlash(int a1)
{
  int v2; // [esp+18h] [ebp-10h]
  char v3; // [esp+1Fh] [ebp-9h]

  vexlog(4, "cc264x: flash write %08X %08X\n", *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
  cc264xSendBootloaderDownload(a1, *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  if ( !cc264xWaitForAck(a1) )
    return 1;
  v3 = 0;
  while ( v3 != 1 )
  {
    v2 = *(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(a1 + 8) >= (unsigned int)(*(_DWORD *)(a1 + 48) * *(_DWORD *)(a1 + 52))
      || *(_DWORD *)(a1 + 8) >= (unsigned int)(*(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 16)) )
    {
      vexlog(4, "cc264x: flash write done\n");
      if ( *(_DWORD *)(a1 + 488) )
        (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 488))(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
      v3 = 1;
    }
    else
    {
      vexlog(4, "cc264x: flash write: %08X\n", *(_DWORD *)(a1 + 8));
      if ( *(_DWORD *)(a1 + 488) )
        (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 488))(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 16));
      cc264xSendBootloaderWriteData(a1, v2, 0x80u);
      *(_DWORD *)(a1 + 8) += 128;
      if ( !cc264xWaitForAck(a1) )
        return 1;
      cc264xSendBootloaderGetStatus(a1);
      if ( !cc264xWaitForResponse(a1) )
        return 1;
      if ( *(_BYTE *)(a1 + 358) != 64 )
        return 1;
    }
  }
  return 0;
}

//----- (0040F8CE) --------------------------------------------------------
int __cdecl cc264xFirmwareUpdateFromBuffer(int a1, unsigned int a2, unsigned __int8 a3)
{
  memset(&radio_dfu, 0, 0x1ECu);
  *(&radio_dfu + 3) = 0;
  *(&radio_dfu + 4) = 0x40000;
  *(&radio_dfu + 12) = 0x2000;
  *(&radio_dfu + 13) = 32;
  *(&radio_dfu + 7) = a1;
  if ( !*(&radio_dfu + 7) || !a2 )
    return 1;
  if ( *(&radio_dfu + 4) <= a2 )
    cc2642OptimizeDownloadSize(&radio_dfu);
  *(&radio_dfu + 16) = *(_DWORD *)*(&radio_dfu + 7);
  if ( *(&radio_dfu + 16) == 536887296 || *(&radio_dfu + 16) == 536951808 )
  {
    cc264xBootloadSendHello();
    if ( cc264xWaitForAck((int)&radio_dfu) )
    {
      cc264xSendBootloaderPing((int)&radio_dfu);
      if ( cc264xWaitForAck((int)&radio_dfu) )
      {
        if ( cc264xBootloaderGetChipId(&radio_dfu) == 1 )
        {
          return 1;
        }
        else if ( *(&radio_dfu + 15) == 3 && *(&radio_dfu + 16) != 536951808
               || *(&radio_dfu + 15) == 11 && *(&radio_dfu + 16) != 536887296 )
        {
          vexlog(2, "cc264x: firmware mismatch error\n");
          return 1;
        }
        else if ( cc264xBootloaderGetMemorySizes((int)&radio_dfu) == 1 )
        {
          return 1;
        }
        else
        {
          if ( !g_quietmode )
          {
            vexlog(2, "cc264x: Chip ID    %08X/%d\n", *(&radio_dfu + 14), *(&radio_dfu + 15));
            vexlog(2, "cc264x: Flash Size %08X\n", *(&radio_dfu + 10));
            vexlog(2, "cc264x: Ram Size   %08X\n", *(&radio_dfu + 11));
            vexlog(2, "cc264x: Flash Sig  %08X\n", *(&radio_dfu + 17));
          }
          if ( *(&radio_dfu + 4) <= a2 )
          {
            if ( a3 )
              *(&radio_dfu + 122) = (int)v5_FileTransferProgress;
            v5_FileTransferMetadata("erase", "ctrl_radio", (char *)a3);
            if ( cc264xBootloaderEraseFlash((int)&radio_dfu) == 1 )
            {
              return 1;
            }
            else
            {
              v5_FileTransferMetadata("flash", "ctrl_radio", (char *)a3);
              if ( cc264xBootloaderWriteFlash((int)&radio_dfu) == 1 )
              {
                return 1;
              }
              else if ( cc264xBootloaderGetChecksum((int)&radio_dfu) == 1 )
              {
                return 1;
              }
              else
              {
                if ( !g_quietmode )
                {
                  vexlog(2, "cc264x: Radio CRC  %08X\n", *(&radio_dfu + 5));
                  vexlog(2, "cc264x: Fw    CRC  %08X\n", *(&radio_dfu + 6));
                }
                return 0;
              }
            }
          }
          else
          {
            return 1;
          }
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    vexlog(2, "cc264x: firmware file error\n");
    return 1;
  }
}
// 44BF70: using guessed type int g_quietmode;
// 535EA0: using guessed type int radio_dfu;

//----- (0040FC0C) --------------------------------------------------------
int __cdecl cc264xFirmwareUpdateFromFile(char *FileName, unsigned __int8 a2)
{
  int v3; // [esp+28h] [ebp-10h] BYREF
  unsigned int file; // [esp+2Ch] [ebp-Ch]

  v3 = 0;
  file = read_file(FileName, (void **)&v3);
  if ( v3 && file )
    return cc264xFirmwareUpdateFromBuffer(v3, file, a2);
  else
    return 1;
}

//----- (0040FC64) --------------------------------------------------------
int __cdecl V5_TarFileSize(int a1)
{
  char *v2; // [esp+0h] [ebp-10h]
  unsigned int i; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v4 = 1;
  v2 = (char *)(a1 + 134);
  for ( i = 0; i <= 0xA; ++i )
  {
    v5 += v4 * (*v2 - 48);
    v4 *= 8;
    --v2;
  }
  return v5;
}

//----- (0040FCB6) --------------------------------------------------------
int __cdecl V5_TarReadNext(const void **a1, char *Destination, size_t Count, const void **a4)
{
  int v5; // [esp+1Ch] [ebp-1Ch]

  if ( !a1 )
    return 0;
  if ( !*a1 )
    return 0;
  if ( !a4 )
    return 0;
  *a4 = 0;
  qmemcpy(header, *a1, 0x200u);
  *a1 = (char *)*a1 + 512;
  if ( strncmp(byte_5361A1, "ustar", 5u) )
    return 0;
  v5 = V5_TarFileSize((int)header);
  if ( byte_53613C == 48 )
  {
    *a4 = *a1;
    strncpy(Destination, header, Count);
    Destination[Count - 1] = 0;
  }
  *a1 = (char *)*a1 + 512 * ((unsigned int)(v5 + 511) >> 9);
  return v5;
}
// 53613C: using guessed type char byte_53613C;

//----- (0040FDC4) --------------------------------------------------------
const char *__cdecl getSystemProgramName(unsigned int a1)
{
  if ( a1 > 3 )
    return "Prog";
  else
    return _vexProgTypes[a1];
}
// 4E9D14: using guessed type char *_vexProgTypes[4];

//----- (0040FDE2) --------------------------------------------------------
const char *__cdecl getErrorString(unsigned int a1)
{
  if ( a1 > 0x19 )
    return "unknown error";
  else
    return (const char *)*(&_error_descp + a1);
}
// 4E9BE0: using guessed type void *_error_descp;

//----- (0040FE0B) --------------------------------------------------------
char *__cdecl getDevTypeString(unsigned int a1)
{
  char *v2; // [esp+1Ch] [ebp-Ch]

  if ( a1 > 0x1C )
    v2 = (char *)&unk_50F070;
  else
    v2 = _devTypes[a1];
  if ( !*v2 )
  {
    sprintf(str1_6646, "device (%d)", a1);
    return str1_6646;
  }
  return v2;
}
// 4E9CA0: using guessed type char *_devTypes[15];

//----- (0040FE60) --------------------------------------------------------
char *__cdecl getLogTypeString(unsigned int a1)
{
  _BYTE *v2; // [esp+1Ch] [ebp-Ch]

  if ( a1 > 0xC )
    v2 = &unk_50F070;
  else
    v2 = *(&_logTypes + a1);
  if ( !*v2 )
  {
    sprintf(str1_6651, "log (%d)", a1);
    return str1_6651;
  }
  return v2;
}
// 4E9C60: using guessed type void *_logTypes;

//----- (0040FEB5) --------------------------------------------------------
int __cdecl getLogDisplayType(_BYTE *a1)
{
  int result; // eax

  if ( a1[1] == 10 || a1[1] == 11 || a1[1] == 12 )
    return 4;
  if ( (char)a1[1] < 0 )
    return 5;
  switch ( a1[2] )
  {
    case 2:
    case 8:
    case 9:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x16:
    case 0x17:
    case 0x18:
      result = 2;
      break;
    case 0xD:
      result = 1;
      break;
    case 0xE:
      if ( *a1 > 0xAu )
        result = 3;
      else
        result = 2;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0040FF37) --------------------------------------------------------
char *__cdecl getLogDescription(unsigned __int8 *a1)
{
  int v2; // eax
  int v3; // eax
  const char *v4; // esi
  const char *v5; // ebx
  const char *v6; // ecx
  const char *v7; // edx
  const char *v8; // esi
  const char *v9; // ebx
  const char *v10; // ecx
  const char *v11; // edx
  const char *v12; // ebx
  char *LogTypeString; // eax
  const char *SystemProgramName; // eax
  const char *v15; // eax
  int v16; // ebx
  const char *v17; // eax
  int v18; // ebx
  const char *ErrorString; // esi
  char *DevTypeString; // eax
  int v21; // ebx
  const char *v22; // eax
  const char *v23; // eax
  int v24; // ebx
  const char *v25; // eax
  const char *v26; // eax
  int v27; // ebx
  const char *v28; // eax
  int v29; // esi
  int v30; // ebx
  const char *v31; // eax
  const char *v32; // eax
  const char *v33; // eax
  const char *v34; // eax
  double v35; // [esp+28h] [ebp-10h]

  sprintf(dscbufr_6671, "unknown entry");
  switch ( a1[1] )
  {
    case 0xAu:
      if ( (a1[2] & 0xC0) != 0 )
        sprintf(dscbufr_6671, "XXX-%02d-%04d", a1[2] & 0x3F, a1[3] + (*a1 << 8));
      else
        sprintf(dscbufr_6671, "VRC-%02d-%04d", a1[2] & 0x3F, a1[3] + (*a1 << 8));
      return dscbufr_6671;
    case 0xBu:
      switch ( a1[2] )
      {
        case 1u:
          sprintf(dscbufr_6671, "Q-%04d", (*a1 << 8) + a1[3]);
          break;
        case 2u:
          sprintf(dscbufr_6671, "R16-%d-%d", *a1, a1[3]);
          break;
        case 3u:
          sprintf(dscbufr_6671, "QF-%d-%d", *a1, a1[3]);
          break;
        case 4u:
          sprintf(dscbufr_6671, "SF-%d-%d", *a1, a1[3]);
          break;
        case 5u:
          sprintf(dscbufr_6671, "F-%d-%d", *a1, a1[3]);
          break;
        case 6u:
          sprintf(dscbufr_6671, "PS-%d-%d", *a1, a1[3]);
          break;
        case 7u:
          sprintf(dscbufr_6671, "DS-%d-%d", *a1, a1[3]);
          break;
        case 8u:
          sprintf(dscbufr_6671, "P-%d-%d", *a1, a1[3]);
          break;
        case 9u:
          sprintf(dscbufr_6671, "P-%04d", (*a1 << 8) + a1[3]);
          break;
        case 0x62u:
          sprintf(dscbufr_6671, "X-%d-%d", *a1, a1[3]);
          break;
        case 0x63u:
          sprintf(dscbufr_6671, "X-%04d", (*a1 << 8) + a1[3]);
          break;
        default:
          sprintf(dscbufr_6671, "match error");
          break;
      }
      return dscbufr_6671;
    case 0xCu:
      sprintf(dscbufr_6671, "--> %02d:%02d:%02d", *a1, a1[3], a1[2]);
      return dscbufr_6671;
  }
  if ( (a1[1] & 0x80u) != 0 )
  {
    if ( a1[1] != 0x80 )
    {
      if ( a1[1] == 0x90 )
      {
        sprintf(dscbufr_6671, "Program: Tamper");
      }
      else if ( a1[1] == 0xA0 )
      {
        v3 = *a1;
        if ( v3 == 1 )
        {
          if ( (a1[3] & 8) != 0 )
            v4 = "B2 ";
          else
            v4 = (const char *)&unk_50F070;
          if ( (a1[3] & 4) != 0 )
            v5 = "B1 ";
          else
            v5 = (const char *)&unk_50F070;
          if ( (a1[3] & 2) != 0 )
            v6 = "R2 ";
          else
            v6 = (const char *)&unk_50F070;
          if ( (a1[3] & 1) != 0 )
            v7 = "R1 ";
          else
            v7 = (const char *)&unk_50F070;
          sprintf(dscbufr_6671, "FC: Cable - %s%s%s%s%d", v7, v6, v5, v4, a1[2]);
        }
        else if ( v3 == 2 )
        {
          if ( (a1[3] & 8) != 0 )
            v8 = "B2 ";
          else
            v8 = (const char *)&unk_50F070;
          if ( (a1[3] & 4) != 0 )
            v9 = "B1 ";
          else
            v9 = (const char *)&unk_50F070;
          if ( (a1[3] & 2) != 0 )
            v10 = "R2 ";
          else
            v10 = (const char *)&unk_50F070;
          if ( (a1[3] & 1) != 0 )
            v11 = "R1 ";
          else
            v11 = (const char *)&unk_50F070;
          sprintf(dscbufr_6671, "FC: Radio - %s%s%s%s%d", v11, v10, v9, v8, a1[2]);
        }
        else
        {
          sprintf(dscbufr_6671, "FC: %02X %02X %02X", *a1, a1[3], a1[2]);
        }
      }
      else
      {
        sprintf(dscbufr_6671, "X: %02X %02X %02X", *a1, a1[3], a1[2]);
      }
      return dscbufr_6671;
    }
    v2 = *a1;
    if ( v2 == 18 )
    {
      sprintf(dscbufr_6671, "Program error: Abort");
      return dscbufr_6671;
    }
    if ( *a1 > 0x12u )
    {
      if ( v2 == 19 )
      {
        sprintf(dscbufr_6671, "Program error: Sdk");
        return dscbufr_6671;
      }
      if ( v2 == 20 )
      {
        sprintf(dscbufr_6671, "Program error: Sdk Mismatch");
        return dscbufr_6671;
      }
    }
    else if ( v2 == 17 )
    {
      sprintf(dscbufr_6671, "Program error: Invalid");
      return dscbufr_6671;
    }
    sprintf(dscbufr_6671, "U: %02X %02X %02X", *a1, a1[3], a1[2]);
    return dscbufr_6671;
  }
  switch ( a1[2] )
  {
    case 2u:
      goto LABEL_71;
    case 7u:
      if ( a1[1] == 9 )
      {
        sprintf(dscbufr_6671, "Radio linked");
      }
      else if ( a1[1] == 4 )
      {
        sprintf(dscbufr_6671, "Field tether connected");
      }
      else
      {
LABEL_82:
        if ( a1[1] == 3 )
        {
          v18 = *a1;
          ErrorString = getErrorString(a1[2]);
          DevTypeString = getDevTypeString(a1[3]);
          sprintf(dscbufr_6671, "%s %s on port %d", DevTypeString, ErrorString, v18);
        }
        else if ( a1[1] == 4 )
        {
          sprintf(dscbufr_6671, "Field tether disconnected");
        }
        else
        {
LABEL_71:
          v12 = getErrorString(a1[2]);
          LogTypeString = getLogTypeString(a1[1]);
          sprintf(dscbufr_6671, "%s %s", LogTypeString, v12);
        }
      }
      break;
    case 8u:
      goto LABEL_82;
    case 9u:
    case 0x18u:
      goto LABEL_97;
    case 0xBu:
      if ( a1[3] == 2 )
      {
        SystemProgramName = getSystemProgramName(0);
        sprintf(dscbufr_6671, "%s Run", SystemProgramName);
      }
      else if ( a1[3] != 1 || *a1 )
      {
        v16 = *a1;
        v17 = getErrorString(a1[2]);
        sprintf(dscbufr_6671, "%s slot %d", v17, v16);
      }
      else
      {
        v15 = getSystemProgramName(*a1 + 1);
        sprintf(dscbufr_6671, "%s Run", v15);
      }
      return dscbufr_6671;
    case 0xEu:
      v21 = a1[3];
      v35 = (long double)*a1 * 0.064;
      v22 = getErrorString(a1[2]);
      sprintf(dscbufr_6671, "%s %5.2fV  %d%% Capacity", v22, v35, v21);
      return dscbufr_6671;
    case 0xFu:
      if ( a1[3] )
      {
        v24 = a1[3];
        v25 = getErrorString(a1[2]);
        sprintf(dscbufr_6671, "%s Cell %d", v25, v24);
      }
      else
      {
        v23 = getErrorString(a1[2]);
        sprintf(dscbufr_6671, "%s Voltage", v23);
      }
      return dscbufr_6671;
    case 0x10u:
      v26 = getErrorString(a1[2]);
      sprintf(dscbufr_6671, "%s AFE fault", v26);
      return dscbufr_6671;
    case 0x11u:
      v27 = *a1;
      v28 = getErrorString(a1[2]);
      sprintf(dscbufr_6671, "Motor %s on port %d", v28, v27);
      return dscbufr_6671;
    case 0x12u:
      v29 = *a1;
      v30 = a1[3];
      v31 = getErrorString(a1[2]);
      sprintf(dscbufr_6671, "Motor %s %d on port %d", v31, v30, v29);
      return dscbufr_6671;
    case 0x16u:
      v32 = getErrorString(a1[2]);
      sprintf(dscbufr_6671, "%s Error", v32);
      return dscbufr_6671;
    case 0x17u:
      v33 = getErrorString(a1[2]);
      sprintf(dscbufr_6671, "Motor %s Error", v33);
      return dscbufr_6671;
    default:
      if ( a1[2] > 0x19u )
      {
        sprintf(dscbufr_6671, "?: %02X %02X %02X %02X", *a1, a1[3], a1[2], a1[1]);
      }
      else
      {
LABEL_97:
        v34 = getErrorString(a1[2]);
        sprintf(dscbufr_6671, "%s", v34);
      }
      break;
  }
  return dscbufr_6671;
}

//----- (00410AF2) --------------------------------------------------------
char *__cdecl timeToStr(unsigned int a1)
{
  sprintf(
    str_6713,
    "%02d:%02d:%02d",
    (int)(a1 / 0x3E8) / 3600 % 24,
    (int)(a1 / 0x3E8) / 60 % 60,
    (int)(a1 / 0x3E8) % 60);
  return str_6713;
}

//----- (00410BF0) --------------------------------------------------------
int __cdecl decodeLogEntry(int a1, int a2, char a3, char a4)
{
  char *LogDescription; // ebx
  char *v5; // eax
  const char *v7; // edi
  int LogDisplayType; // esi
  char *v9; // ebx
  char *v10; // eax

  if ( a3 != 1 )
  {
    LogDescription = getLogDescription((unsigned __int8 *)a2);
    v5 = timeToStr(*(_DWORD *)(a2 + 4));
    return vexlog(2, "%4d: %s %s\n", a1, v5, LogDescription);
  }
  else
  {
    if ( a4 )
      v7 = (const char *)&unk_50F070;
    else
      v7 = ",";
    LogDisplayType = getLogDisplayType((_BYTE *)a2);
    v9 = getLogDescription((unsigned __int8 *)a2);
    v10 = timeToStr(*(_DWORD *)(a2 + 4));
    return vexlog(
             2,
             "      { \"index\": %d, \"time\": \"%s\", \"description\": \"%s\", \"type\": %d }%s\n",
             a1,
             v10,
             v9,
             LogDisplayType,
             v7);
  }
}
// 410BF0: using guessed type _DWORD arg_0;

//----- (00410CBE) --------------------------------------------------------
BOOL __cdecl read_log(int a1, char a2, unsigned __int8 a3)
{
  int v3; // eax
  _DWORD *v5; // ecx
  int v6; // edx
  char v7[11]; // [esp+24h] [ebp-454h] BYREF
  unsigned __int16 v8; // [esp+2Fh] [ebp-449h]
  _BYTE v9[3]; // [esp+31h] [ebp-447h] BYREF
  char v10[7]; // [esp+41Bh] [ebp-5Dh] BYREF
  int v11; // [esp+422h] [ebp-56h]
  int v12; // [esp+434h] [ebp-44h]
  int v13; // [esp+438h] [ebp-40h]
  void *Block; // [esp+43Ch] [ebp-3Ch]
  char v15[4]; // [esp+440h] [ebp-38h]
  char v16[4]; // [esp+444h] [ebp-34h]
  int v17; // [esp+448h] [ebp-30h]
  int j; // [esp+44Ch] [ebp-2Ch]
  int i; // [esp+450h] [ebp-28h]
  int v20; // [esp+454h] [ebp-24h]
  _DWORD *v21; // [esp+458h] [ebp-20h]
  char v22; // [esp+45Fh] [ebp-19h]
  int v23; // [esp+460h] [ebp-18h]
  int v24; // [esp+464h] [ebp-14h]
  int (__cdecl *v25)(int, int); // [esp+468h] [ebp-10h]
  char v26; // [esp+46Eh] [ebp-Ah]
  char v27; // [esp+46Fh] [ebp-9h]

  v27 = 0;
  v26 = 0;
  v25 = 0;
  if ( a1 < 0 )
  {
    v26 = 1;
    a1 = -a1;
  }
  if ( v5_LogStatus((int)v10, (int)v10) == 118 )
  {
    v17 = v11;
    if ( !a1 )
      a1 = v17;
    v24 = a1;
    if ( v17 < a1 )
      v24 = v17;
    v23 = v24;
    *(_DWORD *)v16 = v24;
    v3 = 100;
    if ( v24 <= 100 )
      v3 = v24;
    *(_DWORD *)v15 = v3;
    v22 = 0;
    Block = malloc(8 * v24);
    if ( !Block )
      return 1;
    if ( a3 )
    {
      v25 = v5_FileTransferProgress;
      v5_FileTransferMetadata("upload", "log", (char *)a3);
    }
    if ( v25 )
      v25(0, *(_DWORD *)v16);
    do
    {
      if ( v5_LogRead((int)v7, v7, v23, *(unsigned int *)v15) == 118 )
      {
        v24 -= v8;
        v23 -= v8;
        v21 = v9;
        v20 = 1;
        while ( v20 <= v8 )
        {
          v13 = v8 + v23 - v20;
          if ( v13 >= 0 )
          {
            v5 = (char *)Block + 8 * v13;
            v6 = v21[1];
            *v5 = *v21;
            v5[1] = v6;
          }
          ++v20;
          v21 += 2;
        }
        if ( v23 <= 0 )
          v22 = 1;
        if ( v25 )
          v25(*(_DWORD *)v16 - v24, *(_DWORD *)v16);
      }
      else
      {
        v22 = 1;
        v27 = 1;
      }
    }
    while ( v22 != 1 );
    if ( v25 )
      v25(*(_DWORD *)v16, *(_DWORD *)v16);
    if ( v27 != 1 )
    {
      if ( a2 )
      {
        vexlog(2, "{\n");
        vexlog(2, "  \"log\": {\n");
        vexlog(2, "    \"count\": %d,\n", *(_DWORD *)v16);
        vexlog(2, "    \"items\": [\n");
      }
      v12 = *(_DWORD *)v16 - 1;
      if ( v26 )
      {
        for ( i = 0; i < v12; ++i )
          decodeLogEntry(i, (int)Block + 8 * i, a2, 0);
        decodeLogEntry(v12, (int)Block + 8 * v12, a2, 1);
      }
      else
      {
        for ( j = v12; j > 0; --j )
          decodeLogEntry(j, (int)Block + 8 * j, a2, 0);
        decodeLogEntry(0, (int)Block, a2, 1);
      }
      if ( a2 )
      {
        vexlog(2, "    ]\n");
        vexlog(2, "  }\n");
        vexlog(2, "}\n");
      }
    }
    if ( Block )
      free(Block);
  }
  else
  {
    v27 = 1;
  }
  return v27 == 1;
}

//----- (00411088) --------------------------------------------------------
_BYTE *__cdecl str_lower_0(_BYTE *a1)
{
  _BYTE *i; // [esp+1Ch] [ebp-Ch]

  for ( i = a1; *i; ++i )
  {
    if ( _isupper((char)*i) )
      *i += 32;
  }
  return a1;
}

//----- (004110D0) --------------------------------------------------------
int __cdecl iq2_controller_update(char *FileName, unsigned __int8 a2)
{
  int **v3; // eax
  char v4; // [esp+2Bh] [ebp-1Dh] BYREF
  char *SubStr; // [esp+2Ch] [ebp-1Ch]
  int v6; // [esp+30h] [ebp-18h]
  int ObjectItemCaseSensitive; // [esp+34h] [ebp-14h]
  void *Block; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]

  v4 = 0;
  if ( iq2_ControllerAtmelStatus(&v4, 0) == 1 )
    return 1;
  Size = 0x800000;
  dword_536504 = 0x80000;
  if ( !dword_5364EC )
    dword_5364EC = (int)malloc(Size);
  if ( !::FileName )
    ::FileName = (char *)malloc(dword_536504);
  if ( vexosZipLoadNamedEntry(FileName, zipdata, 0, "manifest.json") )
    return 1;
  Block = cJSON_ParseWithLength((int)::FileName, dword_536504);
  if ( !Block )
    return 1;
  ObjectItemCaseSensitive = (int)cJSON_GetObjectItemCaseSensitive((int)Block, "ctrl");
  if ( !ObjectItemCaseSensitive )
    goto LABEL_19;
  v6 = (int)cJSON_GetObjectItemCaseSensitive(ObjectItemCaseSensitive, "radio");
  if ( !v6 || !cJSON_GetObjectItemCaseSensitive(v6, "file") )
    goto LABEL_19;
  SubStr = (char *)cJSON_GetObjectItemCaseSensitive(v6, "file")[4];
  if ( !g_quietmode )
  {
    v3 = cJSON_GetObjectItemCaseSensitive(v6, "version");
    vexlog(2, "ctrl radio version = %s\n", (const char *)v3[4]);
    vexlog(2, "ctrl radio file = %s\n", SubStr);
  }
  Size = 0x800000;
  dword_536504 = 0x80000;
  if ( vexosZipLoadNamedEntry(FileName, zipdata, 0, SubStr) )
  {
LABEL_19:
    cJSON_Delete((void **)Block);
    return 1;
  }
  cJSON_Delete((void **)Block);
  v9 = 0;
  v9 = iq2_ControllerAtmelRadioBootloaderEntry();
  if ( !v9 )
  {
    v9 = cc264xFirmwareUpdateFromBuffer((int)::FileName, dword_536504, a2);
    iq2_ControllerAtmelRadioBootloaderExit();
  }
  return v9;
}
// 44BF70: using guessed type int g_quietmode;
// 5364E0: using guessed type _DWORD zipdata[3];
// 5364EC: using guessed type int dword_5364EC;

//----- (00411322) --------------------------------------------------------
int __cdecl iq2_controller_atmel_update(char *FileName)
{
  char *v2; // eax
  int **v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  char Destination[64]; // [esp+20h] [ebp-68h] BYREF
  unsigned int v9; // [esp+60h] [ebp-28h] BYREF
  char v10; // [esp+67h] [ebp-21h] BYREF
  char *Source; // [esp+68h] [ebp-20h]
  int v12; // [esp+6Ch] [ebp-1Ch]
  int ObjectItemCaseSensitive; // [esp+70h] [ebp-18h]
  void *Block; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]
  bool v16; // [esp+7Fh] [ebp-9h]

  v10 = 0;
  v9 = 0;
  v16 = iq2_ControllerAtmelStatus(&v10, &v9) != 1;
  Size = 0x800000;
  dword_536504 = 0x80000;
  if ( !dword_5364EC )
    dword_5364EC = (int)malloc(Size);
  if ( !::FileName )
    ::FileName = (char *)malloc(dword_536504);
  if ( vexosZipLoadNamedEntry(FileName, zipdata, 0, "manifest.json") )
    return 1;
  Block = cJSON_ParseWithLength((int)::FileName, dword_536504);
  if ( !Block )
    return 1;
  ObjectItemCaseSensitive = (int)cJSON_GetObjectItemCaseSensitive((int)Block, "ctrl");
  if ( !ObjectItemCaseSensitive )
    goto LABEL_31;
  v12 = (int)cJSON_GetObjectItemCaseSensitive(ObjectItemCaseSensitive, "cdc");
  if ( !v12 || !cJSON_GetObjectItemCaseSensitive(v12, "file") )
    goto LABEL_31;
  Source = (char *)cJSON_GetObjectItemCaseSensitive(v12, "file")[4];
  if ( !g_quietmode )
  {
    v2 = versionString(v9);
    vexlog(2, "ctrl cdc current = %s\n", v2);
    v3 = cJSON_GetObjectItemCaseSensitive(v12, "version");
    vexlog(2, "ctrl cdc version = %s\n", (const char *)v3[4]);
    vexlog(2, "ctrl cdc file = %s\n", Source);
  }
  Size = 0x800000;
  dword_536504 = 0x80000;
  memset(Destination, 0, sizeof(Destination));
  strncpy(Destination, Source, 0x3Eu);
  if ( vexosZipLoadNamedEntry(FileName, zipdata, 0, Source) )
  {
LABEL_31:
    cJSON_Delete((void **)Block);
    return 1;
  }
  cJSON_Delete((void **)Block);
  v15 = 1;
  v4 = str_lower_0(Destination);
  if ( strstr(v4, "iqv2") )
  {
    v15 = usb_detect_device_iq2_ctrl(1);
  }
  else
  {
    v5 = str_lower_0(Destination);
    if ( strstr(v5, "exp") )
      v15 = usb_detect_device_exp_ctrl(1);
  }
  if ( !v15 && v16 )
  {
    iq2_ControllerAtmelCdcBootloaderEntry();
    serialSleep(0x1F4u);
  }
  v6 = str_lower_0(Destination);
  if ( strstr(v6, "iqv2") )
  {
    if ( !v15 )
      v15 = iq2_atmel_update(::FileName, dword_536504);
  }
  else
  {
    v7 = str_lower_0(Destination);
    if ( strstr(v7, "exp") )
    {
      if ( !v15 )
        v15 = exp_atmel_update(::FileName, dword_536504);
    }
    else
    {
      vexerr(255, "unknown file type %s\n", Destination);
      v15 = 1;
    }
  }
  if ( v15 == 1 )
    vexerr(255, "Controller: Atmel update error\n");
  return v15;
}
// 44BF70: using guessed type int g_quietmode;
// 5364E0: using guessed type _DWORD zipdata[3];
// 5364EC: using guessed type int dword_5364EC;
// 411322: using guessed type unsigned int var_28;

//----- (004116DC) --------------------------------------------------------
int __cdecl iq2_bootloader_update(char *FileName, size_t ElementSize, unsigned __int8 a3)
{
  int **v4; // eax
  char *v5; // eax
  char *SubStr; // [esp+30h] [ebp-18h]
  int **ObjectItemCaseSensitive; // [esp+34h] [ebp-14h]
  void **Block; // [esp+38h] [ebp-10h]
  void (__cdecl *v9)(size_t, int); // [esp+3Ch] [ebp-Ch]

  dword_536540 = 0x800000;
  dword_536544 = 0x80000;
  if ( !dword_53652C )
    dword_53652C = (int)malloc(dword_536540);
  if ( !dword_536530 )
    dword_536530 = (int)malloc(dword_536544);
  if ( vexosZipLoadNamedEntry(FileName, zipdata_0, ElementSize, "manifest.json") )
    return 1;
  Block = (void **)cJSON_ParseWithLength(dword_536530, dword_536544);
  if ( !Block )
    return 1;
  ObjectItemCaseSensitive = cJSON_GetObjectItemCaseSensitive((int)Block, "bootloader");
  if ( !ObjectItemCaseSensitive || !cJSON_GetObjectItemCaseSensitive((int)ObjectItemCaseSensitive, "file") )
    goto LABEL_20;
  SubStr = (char *)cJSON_GetObjectItemCaseSensitive((int)ObjectItemCaseSensitive, "file")[4];
  if ( !g_quietmode )
  {
    v4 = cJSON_GetObjectItemCaseSensitive((int)ObjectItemCaseSensitive, "version");
    vexlog(2, "rom bootloader version = %s\n", (const char *)v4[4]);
    vexlog(2, "rom bootloader file = %s\n", SubStr);
  }
  dword_536540 = 0x800000;
  dword_536544 = 0x80000;
  if ( vexosZipLoadNamedEntry(FileName, zipdata_0, ElementSize, SubStr) )
  {
LABEL_20:
    cJSON_Delete(Block);
    return 1;
  }
  cJSON_Delete(Block);
  v9 = 0;
  if ( a3 )
    v9 = (void (__cdecl *)(size_t, int))v5_FileTransferProgress;
  if ( g_quietmode <= 1 )
    vexlog(2, "vexos update bootloader, please wait....\n");
  v5 = v5_FileTransferMetadata("download", "bootloader", (char *)a3);
  if ( v5_FactoryEnable((int)v5) )
    return v5_Download(240, "rom.bin", (_BYTE *)dword_536530, dword_536544, 0, 15, v9) != 0;
  else
    return 4;
}
// 44BF70: using guessed type int g_quietmode;
// 536520: using guessed type _DWORD zipdata_0[3];
// 53652C: using guessed type int dword_53652C;

//----- (00411954) --------------------------------------------------------
int __stdcall cJSON_GetErrorPtr()
{
  return global_error + dword_536564;
}
// 536560: using guessed type int global_error;
// 536564: using guessed type int dword_536564;

//----- (00411962) --------------------------------------------------------
int __stdcall cJSON_GetStringValue(int a1)
{
  if ( cJSON_IsString(a1) )
    return *(_DWORD *)(a1 + 16);
  else
    return 0;
}

//----- (0041198B) --------------------------------------------------------
long double __stdcall cJSON_GetNumberValue(int a1)
{
  if ( cJSON_IsNumber(a1) )
    return *(double *)(a1 + 24);
  else
    return NAN;
}

//----- (004119B5) --------------------------------------------------------
char *__stdcall cJSON_Version()
{
  sprintf(version_5279, "%i.%i.%i", 1, 7, 15);
  return version_5279;
}

//----- (004119EE) --------------------------------------------------------
int __cdecl case_insensitive_strcmp(_BYTE *a1, unsigned __int8 *a2)
{
  int v3; // ebx
  int v4; // ebx

  if ( !a1 || !a2 )
    return 1;
  if ( a1 == a2 )
    return 0;
  while ( 1 )
  {
    v3 = _tolower((unsigned __int8)*a1);
    if ( v3 != _tolower(*a2) )
      break;
    if ( !*a1 )
      return 0;
    ++a1;
    ++a2;
  }
  v4 = _tolower((unsigned __int8)*a1);
  return v4 - _tolower(*a2);
}

//----- (00411A91) --------------------------------------------------------
void *__cdecl cJSON_strdup(char *Str, int (__cdecl **a2)(size_t))
{
  void *v3; // [esp+18h] [ebp-10h]
  size_t Size; // [esp+1Ch] [ebp-Ch]

  if ( !Str )
    return 0;
  Size = strlen(Str) + 1;
  v3 = (void *)(*a2)(Size);
  if ( !v3 )
    return 0;
  memcpy(v3, Str, Size);
  return v3;
}

//----- (00411AFE) --------------------------------------------------------
void (__cdecl *__stdcall cJSON_InitHooks(int a1))(void *Block)
{
  void (__cdecl *result)(void *); // eax

  if ( a1 )
  {
    global_hooks = malloc;
    if ( *(_DWORD *)a1 )
      global_hooks = *(void *(__cdecl **)(size_t))a1;
    off_4E9D44 = free;
    if ( *(_DWORD *)(a1 + 4) )
      off_4E9D44 = *(void (__cdecl **)(void *))(a1 + 4);
    off_4E9D48 = 0;
    result = (void (__cdecl *)(void *))global_hooks;
    if ( global_hooks == malloc )
    {
      result = off_4E9D44;
      if ( off_4E9D44 == free )
        off_4E9D48 = realloc;
    }
  }
  else
  {
    global_hooks = malloc;
    off_4E9D44 = free;
    off_4E9D48 = realloc;
  }
  return result;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);
// 4E9D44: using guessed type void (__cdecl *off_4E9D44)(void *Block);
// 4E9D48: using guessed type void *(__cdecl *off_4E9D48)(void *Block, size_t Size);

//----- (00411B93) --------------------------------------------------------
void *__cdecl cJSON_New_Item(int (__cdecl **a1)(int))
{
  void *v2; // [esp+1Ch] [ebp-Ch]

  v2 = (void *)(*a1)(40);
  if ( v2 )
    memset(v2, 0, 0x28u);
  return v2;
}

//----- (00411BD0) --------------------------------------------------------
void **__stdcall cJSON_Delete(void **Block)
{
  void **result; // eax
  void **v2; // [esp+1Ch] [ebp-Ch]

  while ( Block )
  {
    v2 = (void **)*Block;
    if ( ((unsigned int)Block[3] & 0x100) == 0 && Block[2] )
      cJSON_Delete(Block[2]);
    if ( ((unsigned int)Block[3] & 0x100) == 0 && Block[4] )
      off_4E9D44(Block[4]);
    if ( ((unsigned int)Block[3] & 0x200) == 0 )
    {
      if ( Block[8] )
        off_4E9D44(Block[8]);
    }
    off_4E9D44(Block);
    result = v2;
    Block = v2;
  }
  return result;
}
// 4E9D44: using guessed type void (__cdecl *off_4E9D44)(void *Block);

//----- (00411C88) --------------------------------------------------------
int get_decimal_point()
{
  return 46;
}

//----- (00411C8E) --------------------------------------------------------
int __cdecl parse_number(int a1, _DWORD *a2)
{
  unsigned __int8 v3[64]; // [esp+28h] [ebp-60h] BYREF
  unsigned __int8 *v4; // [esp+68h] [ebp-20h] BYREF
  unsigned __int8 decimal_point; // [esp+6Fh] [ebp-19h]
  double v6; // [esp+70h] [ebp-18h]
  unsigned int v7; // [esp+7Ch] [ebp-Ch]

  v6 = 0.0;
  v4 = 0;
  decimal_point = get_decimal_point();
  v7 = 0;
  if ( !a2 || !*a2 )
    return 0;
  v7 = 0;
  while ( 2 )
  {
    if ( v7 <= 0x3E && v7 + a2[2] < a2[1] )
    {
      switch ( *(_BYTE *)(*a2 + a2[2] + v7) )
      {
        case '+':
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'E':
        case 'e':
          v3[v7] = *(_BYTE *)(*a2 + a2[2] + v7);
          goto LABEL_8;
        case '.':
          v3[v7] = decimal_point;
LABEL_8:
          ++v7;
          continue;
        default:
          goto LABEL_11;
      }
    }
    break;
  }
LABEL_11:
  v3[v7] = 0;
  v6 = __mingw_strtod(v3, &v4);
  if ( v4 == v3 )
    return 0;
  *(double *)(a1 + 24) = v6;
  if ( v6 < 2147483647.0 )
  {
    if ( v6 > -2147483648.0 )
      *(_DWORD *)(a1 + 20) = (int)v6;
    else
      *(_DWORD *)(a1 + 20) = 0x80000000;
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 0x7FFFFFFF;
  }
  *(_DWORD *)(a1 + 12) = 8;
  a2[2] += v4 - v3;
  return 1;
}
// 411D3B: conditional instruction was optimized away because %arg_4.4!=0
// 411C8E: using guessed type unsigned __int8 var_60[64];

//----- (00411E17) --------------------------------------------------------
long double __stdcall cJSON_SetNumberHelper(int a1, double a2)
{
  if ( a2 < 2147483647.0 )
  {
    if ( a2 > -2147483648.0 )
      *(_DWORD *)(a1 + 20) = (int)a2;
    else
      *(_DWORD *)(a1 + 20) = 0x80000000;
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 0x7FFFFFFF;
  }
  *(double *)(a1 + 24) = a2;
  return *(double *)(a1 + 24);
}

//----- (00411E95) --------------------------------------------------------
void *__stdcall cJSON_SetValuestring(int a1, char *Str)
{
  size_t v3; // ebx
  void *v4; // [esp+1Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a1 + 12) & 0x10) == 0 || (*(_DWORD *)(a1 + 12) & 0x100) != 0 )
    return 0;
  v3 = strlen(Str);
  if ( v3 > strlen(*(const char **)(a1 + 16)) )
  {
    v4 = cJSON_strdup(Str, (int (__cdecl **)(size_t))&global_hooks);
    if ( v4 )
    {
      if ( *(_DWORD *)(a1 + 16) )
        cJSON_free(*(void **)(a1 + 16));
      *(_DWORD *)(a1 + 16) = v4;
      return v4;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    strcpy(*(char **)(a1 + 16), Str);
    return *(void **)(a1 + 16);
  }
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00411F56) --------------------------------------------------------
int __cdecl ensure(_DWORD *a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  void *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+34h] [ebp+Ch]

  if ( !a1 || !*a1 )
    return 0;
  if ( a1[1] && a1[2] >= a1[1] )
    return 0;
  if ( a2 < 0 )
    return 0;
  v5 = a1[2] + a2 + 1;
  if ( (unsigned int)v5 <= a1[1] )
    return *a1 + a1[2];
  if ( a1[4] )
    return 0;
  if ( (unsigned int)v5 <= 0x3FFFFFFF )
  {
    v3 = 2 * v5;
  }
  else
  {
    if ( v5 < 0 )
      return 0;
    v3 = 0x7FFFFFFF;
  }
  if ( a1[8] )
  {
    v4 = (void *)((int (__cdecl *)(_DWORD, int))a1[8])(*a1, v3);
    if ( !v4 )
    {
LABEL_20:
      ((void (__cdecl *)(_DWORD))a1[7])(*a1);
      a1[1] = 0;
      *a1 = 0;
      return 0;
    }
  }
  else
  {
    v4 = (void *)((int (__cdecl *)(int))a1[6])(v3);
    if ( !v4 )
      goto LABEL_20;
    memcpy(v4, (const void *)*a1, a1[2] + 1);
    ((void (__cdecl *)(_DWORD))a1[7])(*a1);
  }
  a1[1] = v3;
  *a1 = v4;
  return (int)v4 + a1[2];
}

//----- (00412110) --------------------------------------------------------
void __cdecl update_offset(_DWORD *a1)
{
  if ( a1 )
  {
    if ( *a1 )
      a1[2] += strlen((const char *)(*a1 + a1[2]));
  }
}

//----- (00412160) --------------------------------------------------------
BOOL __cdecl compare_double(double a1, double a2)
{
  long double v2; // fst7

  if ( fabs(a1) <= fabs(a2) )
    v2 = fabs(a2);
  else
    v2 = fabs(a1);
  return (double)v2 * 2.220446049250313e-16 >= fabs(a1 - a2);
}

//----- (004121BE) --------------------------------------------------------
int __cdecl print_number(int a1, _DWORD *a2)
{
  unsigned int v2; // eax
  double v4; // [esp+20h] [ebp-48h] BYREF
  char Buffer[22]; // [esp+2Dh] [ebp-3Bh] BYREF
  int v6; // [esp+43h] [ebp-25h]
  char decimal_point; // [esp+47h] [ebp-21h]
  double v8; // [esp+48h] [ebp-20h]
  int v9; // [esp+54h] [ebp-14h]
  unsigned int i; // [esp+58h] [ebp-10h]
  unsigned int v11; // [esp+5Ch] [ebp-Ch]

  v9 = 0;
  v8 = *(double *)(a1 + 24);
  v11 = 0;
  i = 0;
  *(_DWORD *)Buffer = 0;
  v6 = 0;
  v2 = 0;
  do
  {
    *(_DWORD *)&Buffer[v2 + 3] = 0;
    v2 += 4;
  }
  while ( v2 < ((Buffer - &Buffer[3] + 26) & 0xFFFFFFFC) );
  decimal_point = get_decimal_point();
  v4 = 0.0;
  if ( !a2 )
    return 0;
  if ( isnan(v8) || __fpclassify(SLODWORD(v8), SHIDWORD(v8)) == 1280 )
  {
    v11 = sprintf(Buffer, "null");
  }
  else if ( v8 == (long double)*(int *)(a1 + 20) )
  {
    v11 = sprintf(Buffer, "%d", *(_DWORD *)(a1 + 20));
  }
  else
  {
    v11 = sprintf(Buffer, "%1.15g", v8);
    if ( sscanf(Buffer, "%lg", &v4) != 1 || !compare_double(v4, v8) )
      v11 = sprintf(Buffer, "%1.17g", v8);
  }
  if ( v11 >= 0x1A )
    return 0;
  v9 = ensure(a2, v11 + 1);
  if ( !v9 )
    return 0;
  for ( i = 0; i < v11; ++i )
  {
    if ( decimal_point == Buffer[i] )
      *(_BYTE *)(v9 + i) = 46;
    else
      *(_BYTE *)(i + v9) = Buffer[i];
  }
  *(_BYTE *)(v9 + i) = 0;
  a2[2] += v11;
  return 1;
}
// 4121BE: using guessed type char Buffer[22];

//----- (004123C8) --------------------------------------------------------
int __cdecl parse_hex4(int a1)
{
  unsigned int i; // [esp+8h] [ebp-8h]
  int v3; // [esp+Ch] [ebp-4h]

  v3 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    if ( *(_BYTE *)(a1 + i) <= 0x2Fu || *(_BYTE *)(a1 + i) > 0x39u )
    {
      if ( *(_BYTE *)(a1 + i) <= 0x40u || *(_BYTE *)(a1 + i) > 0x46u )
      {
        if ( *(_BYTE *)(a1 + i) <= 0x60u || *(_BYTE *)(a1 + i) > 0x66u )
          return 0;
        v3 = *(unsigned __int8 *)(a1 + i) + v3 - 87;
      }
      else
      {
        v3 = *(unsigned __int8 *)(a1 + i) + v3 - 55;
      }
    }
    else
    {
      v3 = *(unsigned __int8 *)(a1 + i) + v3 - 48;
    }
    if ( i <= 2 )
      v3 *= 16;
  }
  return v3;
}

//----- (004124B7) --------------------------------------------------------
int __cdecl utf16_literal_to_utf8(int a1, int a2, _DWORD *a3)
{
  unsigned int v4; // [esp+Ch] [ebp-18h]
  unsigned int v5; // [esp+18h] [ebp-Ch]
  char v6; // [esp+1Ch] [ebp-8h]
  unsigned __int8 v7; // [esp+1Dh] [ebp-7h]
  unsigned __int8 i; // [esp+1Eh] [ebp-6h]
  unsigned __int8 v9; // [esp+1Fh] [ebp-5h]
  unsigned int v10; // [esp+20h] [ebp-4h]

  v6 = 0;
  if ( a2 - a1 <= 5 )
    return 0;
  v5 = parse_hex4(a1 + 2);
  if ( v5 > 0xDBFF && v5 <= 0xDFFF )
    return 0;
  if ( v5 <= 0xD7FF || v5 > 0xDBFF )
  {
    v7 = 6;
    v10 = v5;
  }
  else
  {
    v7 = 12;
    if ( a2 - (a1 + 6) <= 5 )
      return 0;
    if ( *(_BYTE *)(a1 + 6) != 92 )
      return 0;
    if ( *(_BYTE *)(a1 + 7) != 117 )
      return 0;
    v4 = parse_hex4(a1 + 8);
    if ( v4 <= 0xDBFF || v4 > 0xDFFF )
      return 0;
    v10 = ((v5 << 10) & 0xFFC00 | v4 & 0x3FF) + 0x10000;
  }
  if ( v10 <= 0x7F )
  {
    v9 = 1;
    goto LABEL_21;
  }
  if ( v10 <= 0x7FF )
  {
    v9 = 2;
    v6 = -64;
    goto LABEL_21;
  }
  if ( v10 <= 0xFFFF )
  {
    v9 = 3;
    v6 = -32;
    goto LABEL_21;
  }
  if ( v10 > 0x10FFFF )
    return 0;
  v9 = 4;
  v6 = -16;
LABEL_21:
  for ( i = v9 - 1; i; --i )
  {
    *(_BYTE *)(*a3 + i) = v10 & 0x3F | 0x80;
    v10 >>= 6;
  }
  if ( v9 <= 1u )
    *(_BYTE *)*a3 = v10 & 0x7F;
  else
    *(_BYTE *)*a3 = v6 | v10;
  *a3 += v9;
  return v7;
}

//----- (0041269D) --------------------------------------------------------
int __cdecl parse_string(int a1, int a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  _BYTE *v11; // [esp+14h] [ebp-24h] BYREF
  _BYTE *v12; // [esp+18h] [ebp-20h]
  unsigned __int8 v13; // [esp+1Fh] [ebp-19h]
  int v14; // [esp+20h] [ebp-18h]
  _BYTE *v15; // [esp+24h] [ebp-14h]
  _BYTE *v16; // [esp+28h] [ebp-10h]
  _BYTE *v17; // [esp+2Ch] [ebp-Ch]

  v17 = (_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8) + 1);
  v16 = (_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8) + 1);
  v11 = 0;
  v15 = 0;
  if ( *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 34 )
    goto LABEL_27;
  v12 = 0;
  v14 = 0;
  while ( (unsigned int)&v16[-*(_DWORD *)a2] < *(_DWORD *)(a2 + 4) && *v16 != 34 )
  {
    if ( *v16 == 92 )
    {
      if ( (unsigned int)&v16[-*(_DWORD *)a2 + 1] >= *(_DWORD *)(a2 + 4) )
        goto LABEL_27;
      ++v14;
      ++v16;
    }
    ++v16;
  }
  if ( (unsigned int)&v16[-*(_DWORD *)a2] < *(_DWORD *)(a2 + 4)
    && *v16 == 34
    && (v12 = &v16[-*(_DWORD *)(a2 + 8) - *(_DWORD *)a2 - v14],
        (v15 = (_BYTE *)(*(int (__cdecl **)(_BYTE *))(a2 + 16))(v12 + 1)) != 0) )
  {
    v11 = v15;
    while ( v17 < v16 )
    {
      if ( *v17 == 92 )
      {
        v13 = 2;
        if ( v16 - v17 <= 0 )
          goto LABEL_27;
        switch ( v17[1] )
        {
          case '"':
          case '/':
          case '\\':
            v9 = v11++;
            *v9 = v17[1];
            break;
          case 'b':
            v4 = v11++;
            *v4 = 8;
            break;
          case 'f':
            v5 = v11++;
            *v5 = 12;
            break;
          case 'n':
            v6 = v11++;
            *v6 = 10;
            break;
          case 'r':
            v7 = v11++;
            *v7 = 13;
            break;
          case 't':
            v8 = v11++;
            *v8 = 9;
            break;
          case 'u':
            v13 = utf16_literal_to_utf8((int)v17, (int)v16, &v11);
            if ( !v13 )
              goto LABEL_27;
            break;
          default:
            goto LABEL_27;
        }
        v17 += v13;
      }
      else
      {
        v2 = v17++;
        v3 = v11++;
        *v3 = *v2;
      }
    }
    *v11 = 0;
    *(_DWORD *)(a1 + 12) = 16;
    *(_DWORD *)(a1 + 16) = v15;
    *(_DWORD *)(a2 + 8) = &v16[-*(_DWORD *)a2];
    ++*(_DWORD *)(a2 + 8);
    return 1;
  }
  else
  {
LABEL_27:
    if ( v15 )
      (*(void (__cdecl **)(_BYTE *))(a2 + 20))(v15);
    if ( v17 )
      *(_DWORD *)(a2 + 8) = &v17[-*(_DWORD *)a2];
    return 0;
  }
}

//----- (00412935) --------------------------------------------------------
int __cdecl print_string_ptr(_BYTE *Src, _DWORD *a2)
{
  unsigned int v3; // eax
  char *v4; // eax
  int v5; // eax
  size_t Size; // [esp+1Ch] [ebp-1Ch]
  char *v7; // [esp+20h] [ebp-18h]
  _BYTE *v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  char *Buffer; // [esp+28h] [ebp-10h]
  _BYTE *i; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 *v12; // [esp+2Ch] [ebp-Ch]

  v9 = 0;
  if ( !a2 )
    return 0;
  if ( Src )
  {
    for ( i = Src; ; ++i )
    {
      if ( !*i )
      {
        Size = i - Src + v9;
        v8 = (_BYTE *)ensure(a2, Size + 3);
        if ( !v8 )
          return 0;
        if ( !v9 )
        {
          *v8 = 34;
          memcpy(v8 + 1, Src, Size);
          v8[Size + 1] = 34;
          v8[Size + 2] = 0;
          return 1;
        }
        *v8 = 34;
        Buffer = v8 + 1;
        v12 = Src;
        while ( 2 )
        {
          if ( !*v12 )
          {
            v8[Size + 1] = 34;
            v8[Size + 2] = 0;
            return 1;
          }
          if ( *v12 > 0x1Fu && *v12 != 34 && *v12 != 92 )
          {
            *Buffer = *v12;
LABEL_46:
            ++v12;
            ++Buffer;
            continue;
          }
          break;
        }
        v4 = Buffer++;
        *v4 = 92;
        v5 = *v12;
        if ( v5 == 12 )
        {
          *Buffer = 102;
          goto LABEL_46;
        }
        if ( *v12 > 0xCu )
        {
          switch ( v5 )
          {
            case 34:
              *Buffer = 34;
              goto LABEL_46;
            case 92:
              *Buffer = 92;
              goto LABEL_46;
            case 13:
              *Buffer = 114;
              goto LABEL_46;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 9:
              *Buffer = 116;
              goto LABEL_46;
            case 10:
              *Buffer = 110;
              goto LABEL_46;
            case 8:
              *Buffer = 98;
              goto LABEL_46;
          }
        }
        sprintf(Buffer, "u%04x", *v12);
        Buffer += 4;
        goto LABEL_46;
      }
      v3 = (unsigned __int8)*i;
      if ( v3 > 0xD )
      {
        if ( v3 == 34 || v3 == 92 )
        {
LABEL_14:
          ++v9;
          continue;
        }
      }
      else if ( (unsigned __int8)*i >= 0xCu || v3 - 8 <= 2 )
      {
        goto LABEL_14;
      }
      if ( *i <= 0x1Fu )
        v9 += 5;
    }
  }
  v7 = (char *)ensure(a2, 3);
  if ( !v7 )
    return 0;
  strcpy(v7, "\"\"");
  return 1;
}

//----- (00412BA7) --------------------------------------------------------
int __cdecl print_string(int a1, _DWORD *a2)
{
  return print_string_ptr(*(_BYTE **)(a1 + 16), a2);
}

//----- (00412BC4) --------------------------------------------------------
_DWORD *__cdecl buffer_skip_whitespace(_DWORD *a1)
{
  if ( !a1 || !*a1 )
    return 0;
  if ( a1[2] >= a1[1] )
    return a1;
  while ( a1[2] < a1[1] && *(_BYTE *)(*a1 + a1[2]) <= 0x20u )
    ++a1[2];
  if ( a1[2] == a1[1] )
    --a1[2];
  return a1;
}
// 412BE1: conditional instruction was optimized away because %arg_0.4!=0
// 412C0B: conditional instruction was optimized away because %arg_0.4!=0

//----- (00412C55) --------------------------------------------------------
_DWORD *__cdecl skip_utf8_bom(_DWORD *a1)
{
  if ( !a1 || !*a1 || a1[2] )
    return 0;
  if ( (unsigned int)(a1[2] + 4) < a1[1] && !strncmp((const char *)(*a1 + a1[2]), &byte_50FC1A, 3u) )
    a1[2] += 3;
  return a1;
}
// 412C7F: conditional instruction was optimized away because %arg_0.4!=0

//----- (00412CD1) --------------------------------------------------------
void *__stdcall cJSON_ParseWithOpts(char *Str, _DWORD *a2, int a3)
{
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  if ( !Str )
    return 0;
  v4 = strlen(Str) + 1;
  return cJSON_ParseWithLengthOpts((int)Str, v4, a2, a3);
}

//----- (00412D1C) --------------------------------------------------------
void *__stdcall cJSON_ParseWithLengthOpts(int a1, unsigned int a2, _DWORD *a3, int a4)
{
  unsigned int i; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  int v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h] BYREF
  unsigned int v10; // [esp+24h] [ebp-24h]
  unsigned int v11; // [esp+28h] [ebp-20h]
  void *(__cdecl *v12)(size_t); // [esp+30h] [ebp-18h]
  void (__cdecl *v13)(void *); // [esp+34h] [ebp-14h]
  void *(__cdecl *v14)(void *, size_t); // [esp+38h] [ebp-10h]
  void *Block; // [esp+3Ch] [ebp-Ch]

  for ( i = 0; i < 0x1C; i += 4 )
    *(int *)((char *)&v9 + i) = 0;
  Block = 0;
  global_error = 0;
  dword_536564 = 0;
  if ( !a1 )
    goto LABEL_13;
  if ( !a2 )
    goto LABEL_13;
  v9 = a1;
  v10 = a2;
  v11 = 0;
  v12 = global_hooks;
  v13 = off_4E9D44;
  v14 = off_4E9D48;
  Block = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( !Block )
    goto LABEL_13;
  v5 = skip_utf8_bom(&v9);
  v6 = buffer_skip_whitespace(v5);
  if ( parse_value((int)Block, v6) && (!a4 || (buffer_skip_whitespace(&v9), v11 < v10) && !*(_BYTE *)(v9 + v11)) )
  {
    if ( a3 )
      *a3 = v11 + v9;
    return Block;
  }
  else
  {
LABEL_13:
    if ( Block )
      cJSON_Delete((void **)Block);
    if ( a1 )
    {
      v8 = 0;
      if ( v11 >= v10 )
      {
        if ( v10 )
          v8 = v10 - 1;
      }
      else
      {
        v8 = v11;
      }
      if ( a3 )
        *a3 = v8 + a1;
      global_error = a1;
      dword_536564 = v8;
    }
    return 0;
  }
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);
// 4E9D44: using guessed type void (__cdecl *off_4E9D44)(void *Block);
// 4E9D48: using guessed type void *(__cdecl *off_4E9D48)(void *Block, size_t Size);
// 536560: using guessed type int global_error;
// 536564: using guessed type int dword_536564;

//----- (00412E98) --------------------------------------------------------
void *__stdcall cJSON_Parse(char *Str)
{
  return cJSON_ParseWithOpts(Str, 0, 0);
}

//----- (00412EC0) --------------------------------------------------------
void *__stdcall cJSON_ParseWithLength(int a1, unsigned int a2)
{
  return cJSON_ParseWithLengthOpts(a1, a2, 0, 0);
}

//----- (00412EEF) --------------------------------------------------------
void *__cdecl print(int a1, void *a2, int a3)
{
  char *v3; // edx
  void *Src[9]; // [esp+18h] [ebp-30h] BYREF
  void *v6; // [esp+3Ch] [ebp-Ch]

  v6 = 0;
  memset(Src, 0, sizeof(Src));
  Src[0] = (void *)(*(int (__cdecl **)(int))a3)(default_buffer_size_5552);
  Src[1] = (void *)default_buffer_size_5552;
  Src[5] = a2;
  Src[6] = *(void **)a3;
  Src[7] = *(void **)(a3 + 4);
  Src[8] = *(void **)(a3 + 8);
  if ( Src[0] && print_value(a1, Src) )
  {
    update_offset(Src);
    if ( *(_DWORD *)(a3 + 8) )
    {
      v6 = (void *)(*(int (__cdecl **)(void *, char *))(a3 + 8))(Src[0], (char *)Src[2] + 1);
      if ( v6 )
      {
        Src[0] = 0;
        return v6;
      }
    }
    else
    {
      v6 = (void *)(*(int (__cdecl **)(char *))a3)((char *)Src[2] + 1);
      if ( v6 )
      {
        v3 = (char *)Src[2] + 1;
        if ( (char *)Src[2] + 1 > Src[1] )
          v3 = (char *)Src[1];
        memcpy(v6, Src[0], (size_t)v3);
        *((_BYTE *)Src[2] + (unsigned int)v6) = 0;
        (*(void (__cdecl **)(void *))(a3 + 4))(Src[0]);
        return v6;
      }
    }
  }
  if ( Src[0] )
    (*(void (__cdecl **)(void *))(a3 + 4))(Src[0]);
  if ( v6 )
    (*(void (__cdecl **)(void *))(a3 + 4))(v6);
  return 0;
}
// 50FCC8: using guessed type int default_buffer_size_5552;

//----- (00413045) --------------------------------------------------------
void *__stdcall cJSON_Print(int a1)
{
  return print(a1, (void *)1, (int)&global_hooks);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (0041306A) --------------------------------------------------------
void *__stdcall cJSON_PrintUnformatted(int a1)
{
  return print(a1, 0, (int)&global_hooks);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (0041308F) --------------------------------------------------------
void *__stdcall cJSON_PrintBuffered(int a1, void *Size, void *a3)
{
  void *Block[11]; // [esp+1Ch] [ebp-2Ch] BYREF

  memset(Block, 0, 0x24u);
  if ( (int)Size < 0 )
    return 0;
  Block[0] = global_hooks((size_t)Size);
  if ( !Block[0] )
    return 0;
  Block[1] = Size;
  Block[2] = 0;
  Block[4] = 0;
  Block[5] = a3;
  Block[6] = global_hooks;
  Block[7] = off_4E9D44;
  Block[8] = off_4E9D48;
  if ( print_value(a1, Block) )
    return Block[0];
  off_4E9D44(Block[0]);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);
// 4E9D44: using guessed type void (__cdecl *off_4E9D44)(void *Block);
// 4E9D48: using guessed type void *(__cdecl *off_4E9D48)(void *Block, size_t Size);

//----- (00413139) --------------------------------------------------------
int __stdcall cJSON_PrintPreallocated(int a1, int a2, int a3, int a4)
{
  int v5[11]; // [esp+1Ch] [ebp-2Ch] BYREF

  memset(v5, 0, 0x24u);
  if ( a3 < 0 || !a2 )
    return 0;
  v5[0] = a2;
  v5[1] = a3;
  v5[2] = 0;
  v5[4] = 1;
  v5[5] = a4;
  v5[6] = (int)global_hooks;
  v5[7] = (int)off_4E9D44;
  v5[8] = (int)off_4E9D48;
  return print_value(a1, v5);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);
// 4E9D44: using guessed type void (__cdecl *off_4E9D44)(void *Block);
// 4E9D48: using guessed type void *(__cdecl *off_4E9D48)(void *Block, size_t Size);

//----- (004131B6) --------------------------------------------------------
int __cdecl parse_value(int a1, _DWORD *a2)
{
  if ( !a2 || !*a2 )
    return 0;
  if ( (unsigned int)(a2[2] + 4) <= a2[1] && !strncmp((const char *)(*a2 + a2[2]), "null", 4u) )
  {
    *(_DWORD *)(a1 + 12) = 4;
    a2[2] += 4;
    return 1;
  }
  else if ( (unsigned int)(a2[2] + 5) <= a2[1] && !strncmp((const char *)(*a2 + a2[2]), "false", 5u) )
  {
    *(_DWORD *)(a1 + 12) = 1;
    a2[2] += 5;
    return 1;
  }
  else if ( (unsigned int)(a2[2] + 4) <= a2[1] && !strncmp((const char *)(*a2 + a2[2]), "true", 4u) )
  {
    *(_DWORD *)(a1 + 12) = 2;
    *(_DWORD *)(a1 + 20) = 1;
    a2[2] += 4;
    return 1;
  }
  else if ( a2[2] < a2[1] && *(_BYTE *)(*a2 + a2[2]) == 34 )
  {
    return parse_string(a1, (int)a2);
  }
  else if ( a2[2] < a2[1]
         && (*(_BYTE *)(*a2 + a2[2]) == 45 || *(_BYTE *)(*a2 + a2[2]) > 0x2Fu && *(_BYTE *)(*a2 + a2[2]) <= 0x39u) )
  {
    return parse_number(a1, a2);
  }
  else if ( a2[2] < a2[1] && *(_BYTE *)(*a2 + a2[2]) == 91 )
  {
    return parse_array(a1, (int)a2);
  }
  else if ( a2[2] < a2[1] && *(_BYTE *)(*a2 + a2[2]) == 123 )
  {
    return parse_object(a1, (int)a2);
  }
  else
  {
    return 0;
  }
}
// 4131D9: conditional instruction was optimized away because %arg_4.4!=0
// 41323E: conditional instruction was optimized away because %arg_4.4!=0
// 4132A3: conditional instruction was optimized away because %arg_4.4!=0
// 413312: conditional instruction was optimized away because %arg_4.4!=0
// 413353: conditional instruction was optimized away because %arg_4.4!=0
// 4133BC: conditional instruction was optimized away because %arg_4.4!=0
// 4133FA: conditional instruction was optimized away because %arg_4.4!=0

//----- (0041343B) --------------------------------------------------------
int __cdecl print_value(int a1, _DWORD *a2)
{
  int v3; // eax
  size_t Size; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+1Ch] [ebp-Ch]
  char *v7; // [esp+1Ch] [ebp-Ch]
  void *v8; // [esp+1Ch] [ebp-Ch]

  if ( !a1 || !a2 )
    return 0;
  v3 = (unsigned __int8)*(_DWORD *)(a1 + 12);
  if ( v3 == 8 )
    return print_number(a1, a2);
  if ( (unsigned __int8)*(_DWORD *)(a1 + 12) > 8u )
  {
    if ( v3 == 32 )
      return print_array(a1, a2);
    if ( (unsigned __int8)*(_DWORD *)(a1 + 12) <= 0x20u )
    {
      if ( v3 == 16 )
        return print_string(a1, a2);
      return 0;
    }
    if ( v3 == 64 )
      return print_object(a1, a2);
    if ( v3 != 128 )
      return 0;
    if ( *(_DWORD *)(a1 + 16) )
    {
      Size = strlen(*(const char **)(a1 + 16)) + 1;
      v8 = (void *)ensure(a2, Size);
      if ( v8 )
      {
        memcpy(v8, *(const void **)(a1 + 16), Size);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    switch ( v3 )
    {
      case 2:
        v7 = (char *)ensure(a2, 5);
        if ( v7 )
        {
          strcpy(v7, "true");
          return 1;
        }
        else
        {
          return 0;
        }
      case 4:
        v5 = (char *)ensure(a2, 5);
        if ( v5 )
        {
          strcpy(v5, "null");
          return 1;
        }
        else
        {
          return 0;
        }
      case 1:
        v6 = (char *)ensure(a2, 6);
        if ( v6 )
        {
          strcpy(v6, "false");
          return 1;
        }
        else
        {
          return 0;
        }
      default:
        return 0;
    }
  }
}

//----- (00413649) --------------------------------------------------------
int __cdecl parse_array(int a1, int a2)
{
  void **v3; // [esp+14h] [ebp-14h]
  _DWORD *v4; // [esp+18h] [ebp-10h]
  void **Block; // [esp+1Ch] [ebp-Ch]

  Block = 0;
  v4 = 0;
  if ( *(_DWORD *)(a2 + 12) > 0x3E7u )
    return 0;
  ++*(_DWORD *)(a2 + 12);
  if ( *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 91 )
    goto LABEL_23;
  ++*(_DWORD *)(a2 + 8);
  buffer_skip_whitespace((_DWORD *)a2);
  if ( !a2 || *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 93 )
  {
    if ( a2 && *(_DWORD *)(a2 + 8) < *(_DWORD *)(a2 + 4) )
    {
      --*(_DWORD *)(a2 + 8);
      while ( 1 )
      {
        v3 = (void **)cJSON_New_Item((int (__cdecl **)(int))(a2 + 16));
        if ( !v3 )
          break;
        if ( Block )
        {
          *v4 = v3;
          v3[1] = v4;
        }
        else
        {
          Block = v3;
        }
        v4 = v3;
        ++*(_DWORD *)(a2 + 8);
        buffer_skip_whitespace((_DWORD *)a2);
        if ( !parse_value((int)v3, (_DWORD *)a2) )
          break;
        buffer_skip_whitespace((_DWORD *)a2);
        if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 44 )
        {
          if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 93 )
            break;
          goto LABEL_20;
        }
      }
    }
    else
    {
      --*(_DWORD *)(a2 + 8);
    }
LABEL_23:
    if ( Block )
      cJSON_Delete(Block);
    return 0;
  }
LABEL_20:
  --*(_DWORD *)(a2 + 12);
  if ( Block )
    Block[1] = v4;
  *(_DWORD *)(a1 + 12) = 32;
  *(_DWORD *)(a1 + 8) = Block;
  ++*(_DWORD *)(a2 + 8);
  return 1;
}
// 4137A5: conditional instruction was optimized away because %arg_4.4!=0
// 4137D3: conditional instruction was optimized away because %arg_4.4!=0

//----- (00413868) --------------------------------------------------------
int __cdecl print_array(int a1, _DWORD *a2)
{
  int v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // [esp+14h] [ebp-14h]
  _DWORD *v7; // [esp+18h] [ebp-10h]
  _BYTE *v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-Ch]
  _BYTE *v10; // [esp+1Ch] [ebp-Ch]
  _BYTE *v11; // [esp+1Ch] [ebp-Ch]

  v7 = *(_DWORD **)(a1 + 8);
  if ( !a2 )
    return 0;
  v8 = (_BYTE *)ensure(a2, 1);
  if ( !v8 )
    return 0;
  *v8 = 91;
  ++a2[2];
  ++a2[3];
  while ( v7 )
  {
    if ( !print_value((int)v7, a2) )
      return 0;
    update_offset(a2);
    if ( *v7 )
    {
      if ( a2[5] )
        v3 = 2;
      else
        v3 = 1;
      v6 = v3;
      v9 = ensure(a2, v3 + 1);
      if ( !v9 )
        return 0;
      v4 = (_BYTE *)v9;
      v10 = (_BYTE *)(v9 + 1);
      *v4 = 44;
      if ( a2[5] )
      {
        v5 = v10++;
        *v5 = 32;
      }
      *v10 = 0;
      a2[2] += v6;
    }
    v7 = (_DWORD *)*v7;
  }
  v11 = (_BYTE *)ensure(a2, 2);
  if ( !v11 )
    return 0;
  *v11 = 93;
  v11[1] = 0;
  --a2[3];
  return 1;
}

//----- (004139EF) --------------------------------------------------------
int __cdecl parse_object(int a1, int a2)
{
  void **v3; // [esp+14h] [ebp-14h]
  _DWORD *v4; // [esp+18h] [ebp-10h]
  void **Block; // [esp+1Ch] [ebp-Ch]

  Block = 0;
  v4 = 0;
  if ( *(_DWORD *)(a2 + 12) > 0x3E7u )
    return 0;
  ++*(_DWORD *)(a2 + 12);
  if ( !a2 || *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 123 )
    goto LABEL_26;
  ++*(_DWORD *)(a2 + 8);
  buffer_skip_whitespace((_DWORD *)a2);
  if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 125 )
  {
    if ( *(_DWORD *)(a2 + 8) < *(_DWORD *)(a2 + 4) )
    {
      --*(_DWORD *)(a2 + 8);
      while ( 1 )
      {
        v3 = (void **)cJSON_New_Item((int (__cdecl **)(int))(a2 + 16));
        if ( !v3 )
          break;
        if ( Block )
        {
          *v4 = v3;
          v3[1] = v4;
        }
        else
        {
          Block = v3;
        }
        v4 = v3;
        ++*(_DWORD *)(a2 + 8);
        buffer_skip_whitespace((_DWORD *)a2);
        if ( !parse_string((int)v3, a2) )
          break;
        buffer_skip_whitespace((_DWORD *)a2);
        v3[8] = v3[4];
        v3[4] = 0;
        if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) )
          break;
        if ( *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 58 )
          break;
        ++*(_DWORD *)(a2 + 8);
        buffer_skip_whitespace((_DWORD *)a2);
        if ( !parse_value((int)v3, (_DWORD *)a2) )
          break;
        buffer_skip_whitespace((_DWORD *)a2);
        if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 44 )
        {
          if ( *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 4) || *(_BYTE *)(*(_DWORD *)a2 + *(_DWORD *)(a2 + 8)) != 125 )
            break;
          goto LABEL_23;
        }
      }
    }
    else
    {
      --*(_DWORD *)(a2 + 8);
    }
LABEL_26:
    if ( Block )
      cJSON_Delete(Block);
    return 0;
  }
LABEL_23:
  --*(_DWORD *)(a2 + 12);
  if ( Block )
    Block[1] = v4;
  *(_DWORD *)(a1 + 12) = 64;
  *(_DWORD *)(a1 + 8) = Block;
  ++*(_DWORD *)(a2 + 8);
  return 1;
}
// 413A7D: conditional instruction was optimized away because %arg_4.4!=0
// 413AAB: conditional instruction was optimized away because %arg_4.4!=0
// 413B7F: conditional instruction was optimized away because %arg_4.4!=0
// 413BF4: conditional instruction was optimized away because %arg_4.4!=0
// 413C22: conditional instruction was optimized away because %arg_4.4!=0

//----- (00413CBD) --------------------------------------------------------
int __cdecl print_object(int a1, _DWORD *a2)
{
  int v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // eax
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  int v10; // eax
  _BYTE *v11; // eax
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+1Ch] [ebp-1Ch]
  unsigned int j; // [esp+20h] [ebp-18h]
  unsigned int i; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  _BYTE *v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+2Ch] [ebp-Ch]
  int v21; // [esp+2Ch] [ebp-Ch]
  _BYTE *v22; // [esp+2Ch] [ebp-Ch]
  _BYTE *v23; // [esp+2Ch] [ebp-Ch]
  _BYTE *v24; // [esp+2Ch] [ebp-Ch]

  v17 = *(_DWORD *)(a1 + 8);
  if ( !a2 )
    return 0;
  if ( a2[5] )
    v3 = 2;
  else
    v3 = 1;
  v12 = v3;
  v18 = ensure(a2, v3 + 1);
  if ( !v18 )
    return 0;
  v4 = (_BYTE *)v18;
  v19 = (_BYTE *)(v18 + 1);
  *v4 = 123;
  ++a2[3];
  if ( a2[5] )
    *v19 = 10;
  a2[2] += v12;
  while ( v17 )
  {
    if ( a2[5] )
    {
      v20 = ensure(a2, a2[3]);
      if ( !v20 )
        return 0;
      for ( i = 0; i < a2[3]; ++i )
      {
        v5 = (_BYTE *)v20++;
        *v5 = 9;
      }
      a2[2] += a2[3];
    }
    if ( !print_string_ptr(*(_BYTE **)(v17 + 32), a2) )
      return 0;
    update_offset(a2);
    if ( a2[5] )
      v6 = 2;
    else
      v6 = 1;
    v13 = v6;
    v21 = ensure(a2, v6);
    if ( !v21 )
      return 0;
    v7 = (_BYTE *)v21;
    v22 = (_BYTE *)(v21 + 1);
    *v7 = 58;
    if ( a2[5] )
      *v22 = 9;
    a2[2] += v13;
    if ( !print_value(v17, a2) )
      return 0;
    update_offset(a2);
    v14 = (a2[5] != 0) + (*(_DWORD *)v17 != 0);
    v23 = (_BYTE *)ensure(a2, v14 + 1);
    if ( !v23 )
      return 0;
    if ( *(_DWORD *)v17 )
    {
      v8 = v23++;
      *v8 = 44;
    }
    if ( a2[5] )
    {
      v9 = v23++;
      *v9 = 10;
    }
    *v23 = 0;
    a2[2] += v14;
    v17 = *(_DWORD *)v17;
  }
  if ( a2[5] )
    v10 = a2[3] + 1;
  else
    v10 = 2;
  v24 = (_BYTE *)ensure(a2, v10);
  if ( !v24 )
    return 0;
  if ( a2[5] )
  {
    for ( j = 0; j < a2[3] - 1; ++j )
    {
      v11 = v24++;
      *v11 = 9;
    }
  }
  *v24 = 125;
  v24[1] = 0;
  --a2[3];
  return 1;
}

//----- (00413FE4) --------------------------------------------------------
int __stdcall cJSON_GetArraySize(int a1)
{
  int v2; // [esp+8h] [ebp-8h]
  _DWORD *i; // [esp+Ch] [ebp-4h]

  v2 = 0;
  if ( !a1 )
    return 0;
  for ( i = *(_DWORD **)(a1 + 8); i; i = (_DWORD *)*i )
    ++v2;
  return v2;
}

//----- (00414029) --------------------------------------------------------
_DWORD *__cdecl get_array_item(int a1, int a2)
{
  _DWORD *i; // [esp+Ch] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = *(_DWORD **)(a1 + 8); i && a2; i = (_DWORD *)*i )
    --a2;
  return i;
}

//----- (0041406B) --------------------------------------------------------
_DWORD *__stdcall cJSON_GetArrayItem(int a1, int a2)
{
  if ( a2 >= 0 )
    return get_array_item(a1, a2);
  else
    return 0;
}

//----- (00414094) --------------------------------------------------------
int **__cdecl get_object_item(int a1, char *Str1, int a3)
{
  int **v4; // [esp+1Ch] [ebp-Ch]

  if ( !a1 || !Str1 )
    return 0;
  v4 = *(int ***)(a1 + 8);
  if ( a3 )
  {
    while ( v4 && v4[8] && strcmp(Str1, (const char *)v4[8]) )
      v4 = (int **)*v4;
  }
  else
  {
    while ( v4 && case_insensitive_strcmp(Str1, (unsigned __int8 *)v4[8]) )
      v4 = (int **)*v4;
  }
  if ( v4 && v4[8] )
    return v4;
  else
    return 0;
}

//----- (0041413E) --------------------------------------------------------
int **__stdcall cJSON_GetObjectItem(int a1, char *Str1)
{
  return get_object_item(a1, Str1, 0);
}

//----- (00414162) --------------------------------------------------------
int **__stdcall cJSON_GetObjectItemCaseSensitive(int a1, char *Str1)
{
  return get_object_item(a1, Str1, 1);
}

//----- (00414186) --------------------------------------------------------
BOOL __stdcall cJSON_HasObjectItem(int a1, char *Str1)
{
  return cJSON_GetObjectItem(a1, Str1) != 0;
}

//----- (004141AD) --------------------------------------------------------
int __cdecl suffix_object(_DWORD *a1, int a2)
{
  int result; // eax

  *a1 = a2;
  result = a2;
  *(_DWORD *)(a2 + 4) = a1;
  return result;
}

//----- (004141C4) --------------------------------------------------------
_DWORD *__cdecl create_reference(void *Src, int (__cdecl **a2)(int))
{
  int v3; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]

  if ( !Src )
    return 0;
  v4 = cJSON_New_Item(a2);
  if ( !v4 )
    return 0;
  memcpy(v4, Src, 0x28u);
  v4[8] = 0;
  v3 = v4[3];
  BYTE1(v3) |= 1u;
  v4[3] = v3;
  v4[1] = 0;
  *v4 = v4[1];
  return v4;
}

//----- (00414248) --------------------------------------------------------
int __cdecl add_item_to_array(_DWORD *a1, _DWORD *a2)
{
  int v3; // [esp+1Ch] [ebp-Ch]

  if ( !a2 || !a1 || a1 == a2 )
    return 0;
  v3 = a1[2];
  if ( v3 )
  {
    if ( *(_DWORD *)(v3 + 4) )
    {
      suffix_object(*(_DWORD **)(v3 + 4), (int)a2);
      *(_DWORD *)(a1[2] + 4) = a2;
    }
  }
  else
  {
    a1[2] = a2;
    a2[1] = a2;
    *a2 = 0;
  }
  return 1;
}

//----- (004142CE) --------------------------------------------------------
int __stdcall cJSON_AddItemToArray(_DWORD *a1, _DWORD *a2)
{
  return add_item_to_array(a1, a2);
}

//----- (004142EA) --------------------------------------------------------
int __cdecl cast_away_const(int a1)
{
  return a1;
}

//----- (004142F2) --------------------------------------------------------
int __cdecl add_item_to_object(_DWORD *a1, char *Str, _DWORD *a3, int a4, int a5)
{
  int v6; // eax
  int v7; // eax
  int v8; // [esp+18h] [ebp-10h]
  void *v9; // [esp+1Ch] [ebp-Ch]

  if ( !a1 || !Str || !a3 || a1 == a3 )
    return 0;
  if ( a5 )
  {
    v9 = (void *)cast_away_const((int)Str);
    v6 = a3[3];
    BYTE1(v6) |= 2u;
    v8 = v6;
  }
  else
  {
    v9 = cJSON_strdup(Str, (int (__cdecl **)(size_t))a4);
    if ( !v9 )
      return 0;
    v7 = a3[3];
    BYTE1(v7) &= ~2u;
    v8 = v7;
  }
  if ( (a3[3] & 0x200) == 0 )
  {
    if ( a3[8] )
      (*(void (__cdecl **)(_DWORD))(a4 + 4))(a3[8]);
  }
  a3[8] = v9;
  a3[3] = v8;
  return add_item_to_array(a1, a3);
}

//----- (004143CA) --------------------------------------------------------
int __stdcall cJSON_AddItemToObject(_DWORD *a1, char *Str, _DWORD *a3)
{
  return add_item_to_object(a1, Str, a3, (int)&global_hooks, 0);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004143FD) --------------------------------------------------------
int __stdcall cJSON_AddItemToObjectCS(_DWORD *a1, char *Str, _DWORD *a3)
{
  return add_item_to_object(a1, Str, a3, (int)&global_hooks, 1);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414430) --------------------------------------------------------
int __stdcall cJSON_AddItemReferenceToArray(_DWORD *a1, void *Src)
{
  _DWORD *reference; // eax

  if ( !a1 )
    return 0;
  reference = create_reference(Src, (int (__cdecl **)(int))&global_hooks);
  return add_item_to_array(a1, reference);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414469) --------------------------------------------------------
int __stdcall cJSON_AddItemReferenceToObject(_DWORD *a1, char *Str, void *Src)
{
  _DWORD *reference; // eax

  if ( !a1 || !Str )
    return 0;
  reference = create_reference(Src, (int (__cdecl **)(int))&global_hooks);
  return add_item_to_object(a1, Str, reference, (int)&global_hooks, 0);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004144BF) --------------------------------------------------------
void **__stdcall cJSON_AddNullToObject(_DWORD *a1, char *Str)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = (void **)cJSON_CreateNull();
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414516) --------------------------------------------------------
void **__stdcall cJSON_AddTrueToObject(_DWORD *a1, char *Str)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = (void **)cJSON_CreateTrue();
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (0041456D) --------------------------------------------------------
void **__stdcall cJSON_AddFalseToObject(_DWORD *a1, char *Str)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = (void **)cJSON_CreateFalse();
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004145C4) --------------------------------------------------------
void **__stdcall cJSON_AddBoolToObject(_DWORD *a1, char *Str, int a3)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = (void **)cJSON_CreateBool(a3);
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414624) --------------------------------------------------------
double *__stdcall cJSON_AddNumberToObject(_DWORD *a1, char *Str, double a3)
{
  double *Block; // [esp+3Ch] [ebp-Ch]

  Block = cJSON_CreateNumber(a3);
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete((void **)Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414690) --------------------------------------------------------
void **__stdcall cJSON_AddStringToObject(_DWORD *a1, char *Str, char *a3)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = cJSON_CreateString(a3);
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004146F0) --------------------------------------------------------
void **__stdcall cJSON_AddRawToObject(_DWORD *a1, char *Str, char *a3)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = cJSON_CreateRaw(a3);
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414750) --------------------------------------------------------
void **__stdcall cJSON_AddObjectToObject(_DWORD *a1, char *Str)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = (void **)cJSON_CreateObject();
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004147A7) --------------------------------------------------------
void **__stdcall cJSON_AddArrayToObject(_DWORD *a1, char *Str)
{
  void **Block; // [esp+2Ch] [ebp-Ch]

  Block = (void **)cJSON_CreateArray();
  if ( add_item_to_object(a1, Str, Block, (int)&global_hooks, 0) )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004147FE) --------------------------------------------------------
_DWORD **__stdcall cJSON_DetachItemViaPointer(int a1, _DWORD **a2)
{
  if ( !a1 || !a2 )
    return 0;
  if ( a2 != *(_DWORD ***)(a1 + 8) )
    *a2[1] = *a2;
  if ( *a2 )
    (*a2)[1] = a2[1];
  if ( a2 == *(_DWORD ***)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 8) = *a2;
  }
  else if ( !*a2 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = a2[1];
  }
  a2[1] = 0;
  *a2 = 0;
  return a2;
}

//----- (0041488D) --------------------------------------------------------
_DWORD **__stdcall cJSON_DetachItemFromArray(int a1, int a2)
{
  _DWORD *array_item; // eax

  if ( a2 < 0 )
    return 0;
  array_item = get_array_item(a1, a2);
  return cJSON_DetachItemViaPointer(a1, (_DWORD **)array_item);
}

//----- (004148C8) --------------------------------------------------------
void **__stdcall cJSON_DeleteItemFromArray(int a1, int a2)
{
  void **v2; // eax

  v2 = (void **)cJSON_DetachItemFromArray(a1, a2);
  return cJSON_Delete(v2);
}

//----- (004148F3) --------------------------------------------------------
_DWORD **__stdcall cJSON_DetachItemFromObject(int a1, char *Str1)
{
  int **ObjectItem; // [esp+1Ch] [ebp-Ch]

  ObjectItem = cJSON_GetObjectItem(a1, Str1);
  return cJSON_DetachItemViaPointer(a1, ObjectItem);
}

//----- (0041492A) --------------------------------------------------------
_DWORD **__stdcall cJSON_DetachItemFromObjectCaseSensitive(int a1, char *Str1)
{
  int **ObjectItemCaseSensitive; // [esp+1Ch] [ebp-Ch]

  ObjectItemCaseSensitive = cJSON_GetObjectItemCaseSensitive(a1, Str1);
  return cJSON_DetachItemViaPointer(a1, ObjectItemCaseSensitive);
}

//----- (00414961) --------------------------------------------------------
void **__stdcall cJSON_DeleteItemFromObject(int a1, char *Str1)
{
  void **v2; // eax

  v2 = (void **)cJSON_DetachItemFromObject(a1, Str1);
  return cJSON_Delete(v2);
}

//----- (0041498C) --------------------------------------------------------
void **__stdcall cJSON_DeleteItemFromObjectCaseSensitive(int a1, char *Str1)
{
  void **v2; // eax

  v2 = (void **)cJSON_DetachItemFromObjectCaseSensitive(a1, Str1);
  return cJSON_Delete(v2);
}

//----- (004149B7) --------------------------------------------------------
int __stdcall cJSON_InsertItemInArray(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *array_item; // [esp+1Ch] [ebp-Ch]

  if ( a2 < 0 )
    return 0;
  array_item = get_array_item((int)a1, a2);
  if ( !array_item )
    return add_item_to_array(a1, a3);
  *a3 = array_item;
  a3[1] = array_item[1];
  array_item[1] = a3;
  if ( array_item == (_DWORD *)a1[2] )
    a1[2] = a3;
  else
    *(_DWORD *)a3[1] = a3;
  return 1;
}

//----- (00414A47) --------------------------------------------------------
int __stdcall cJSON_ReplaceItemViaPointer(int a1, void **Block, void **a3)
{
  if ( !a1 || !a3 || !Block )
    return 0;
  if ( a3 == Block )
    return 1;
  *a3 = *Block;
  a3[1] = Block[1];
  if ( *a3 )
    *((_DWORD *)*a3 + 1) = a3;
  if ( Block == *(void ***)(a1 + 8) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) == *(_DWORD *)(a1 + 8) )
      a3[1] = a3;
    *(_DWORD *)(a1 + 8) = a3;
  }
  else
  {
    if ( a3[1] )
      *(_DWORD *)a3[1] = a3;
    if ( !*a3 )
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = a3;
  }
  *Block = 0;
  Block[1] = 0;
  cJSON_Delete(Block);
  return 1;
}

//----- (00414B2B) --------------------------------------------------------
int __stdcall cJSON_ReplaceItemInArray(int a1, int a2, void **a3)
{
  void **array_item; // eax

  if ( a2 < 0 )
    return 0;
  array_item = (void **)get_array_item(a1, a2);
  return cJSON_ReplaceItemViaPointer(a1, array_item, a3);
}

//----- (00414B6F) --------------------------------------------------------
int __cdecl replace_item_in_object(int a1, char *Str, int a3, int a4)
{
  int v5; // eax
  void **object_item; // eax

  if ( !a3 || !Str )
    return 0;
  if ( (*(_DWORD *)(a3 + 12) & 0x200) == 0 && *(_DWORD *)(a3 + 32) )
    cJSON_free(*(void **)(a3 + 32));
  *(_DWORD *)(a3 + 32) = cJSON_strdup(Str, (int (__cdecl **)(size_t))&global_hooks);
  if ( !*(_DWORD *)(a3 + 32) )
    return 0;
  v5 = *(_DWORD *)(a3 + 12);
  BYTE1(v5) &= ~2u;
  *(_DWORD *)(a3 + 12) = v5;
  object_item = (void **)get_object_item(a1, Str, a4);
  return cJSON_ReplaceItemViaPointer(a1, object_item, (void **)a3);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414C28) --------------------------------------------------------
int __stdcall cJSON_ReplaceItemInObject(int a1, char *Str, int a3)
{
  return replace_item_in_object(a1, Str, a3, 0);
}

//----- (00414C53) --------------------------------------------------------
int __stdcall cJSON_ReplaceItemInObjectCaseSensitive(int a1, char *Str, int a3)
{
  return replace_item_in_object(a1, Str, a3, 1);
}

//----- (00414C7E) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateNull()
{
  _DWORD *v1; // [esp+1Ch] [ebp-Ch]

  v1 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v1 )
    v1[3] = 4;
  return v1;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414CA8) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateTrue()
{
  _DWORD *v1; // [esp+1Ch] [ebp-Ch]

  v1 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v1 )
    v1[3] = 2;
  return v1;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414CD2) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateFalse()
{
  _DWORD *v1; // [esp+1Ch] [ebp-Ch]

  v1 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v1 )
    v1[3] = 1;
  return v1;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414CFC) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateBool(int a1)
{
  int v1; // edx
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]

  v3 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v3 )
  {
    if ( a1 )
      v1 = 2;
    else
      v1 = 1;
    v3[3] = v1;
  }
  return v3;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414D36) --------------------------------------------------------
double *__stdcall cJSON_CreateNumber(double a1)
{
  double *v2; // [esp+2Ch] [ebp-Ch]

  v2 = (double *)cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v2 )
  {
    *((_DWORD *)v2 + 3) = 8;
    v2[3] = a1;
    if ( a1 < 2147483647.0 )
    {
      if ( a1 > -2147483648.0 )
        *((_DWORD *)v2 + 5) = (int)a1;
      else
        *((_DWORD *)v2 + 5) = 0x80000000;
    }
    else
    {
      *((_DWORD *)v2 + 5) = 0x7FFFFFFF;
    }
  }
  return v2;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414DD0) --------------------------------------------------------
void **__stdcall cJSON_CreateString(char *Str)
{
  void **Block; // [esp+1Ch] [ebp-Ch]

  Block = (void **)cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( !Block )
    return Block;
  Block[3] = (void *)16;
  Block[4] = cJSON_strdup(Str, (int (__cdecl **)(size_t))&global_hooks);
  if ( Block[4] )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414E36) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateStringReference(int a1)
{
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]

  v2 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v2 )
  {
    v2[3] = 272;
    v2[4] = cast_away_const(a1);
  }
  return v2;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414E75) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateObjectReference(int a1)
{
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]

  v2 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v2 )
  {
    v2[3] = 320;
    v2[2] = cast_away_const(a1);
  }
  return v2;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414EB4) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateArrayReference(int a1)
{
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]

  v2 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v2 )
  {
    v2[3] = 288;
    v2[2] = cast_away_const(a1);
  }
  return v2;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414EF3) --------------------------------------------------------
void **__stdcall cJSON_CreateRaw(char *Str)
{
  void **Block; // [esp+1Ch] [ebp-Ch]

  Block = (void **)cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( !Block )
    return Block;
  Block[3] = (void *)128;
  Block[4] = cJSON_strdup(Str, (int (__cdecl **)(size_t))&global_hooks);
  if ( Block[4] )
    return Block;
  cJSON_Delete(Block);
  return 0;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414F59) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateArray()
{
  _DWORD *v1; // [esp+1Ch] [ebp-Ch]

  v1 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v1 )
    v1[3] = 32;
  return v1;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414F83) --------------------------------------------------------
_DWORD *__stdcall cJSON_CreateObject()
{
  _DWORD *v1; // [esp+1Ch] [ebp-Ch]

  v1 = cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( v1 )
    v1[3] = 64;
  return v1;
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00414FAD) --------------------------------------------------------
void **__stdcall cJSON_CreateIntArray(int a1, int a2)
{
  void **Block; // [esp+20h] [ebp-18h]
  double *v4; // [esp+24h] [ebp-14h]
  double *Number; // [esp+28h] [ebp-10h]
  unsigned int i; // [esp+2Ch] [ebp-Ch]

  Number = 0;
  v4 = 0;
  if ( a2 < 0 || !a1 )
    return 0;
  Block = (void **)cJSON_CreateArray();
  for ( i = 0; Block && i < a2; ++i )
  {
    Number = cJSON_CreateNumber((double)*(int *)(4 * i + a1));
    if ( !Number )
    {
      cJSON_Delete(Block);
      return 0;
    }
    if ( i )
      suffix_object(v4, (int)Number);
    else
      Block[2] = Number;
    v4 = Number;
  }
  if ( Block )
  {
    if ( Block[2] )
      *((_DWORD *)Block[2] + 1) = Number;
  }
  return Block;
}

//----- (00415094) --------------------------------------------------------
void **__stdcall cJSON_CreateFloatArray(int a1, int a2)
{
  void **Block; // [esp+10h] [ebp-18h]
  double *v4; // [esp+14h] [ebp-14h]
  double *Number; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  Number = 0;
  v4 = 0;
  if ( a2 < 0 || !a1 )
    return 0;
  Block = (void **)cJSON_CreateArray();
  for ( i = 0; Block && i < a2; ++i )
  {
    Number = cJSON_CreateNumber(*(float *)(4 * i + a1));
    if ( !Number )
    {
      cJSON_Delete(Block);
      return 0;
    }
    if ( i )
      suffix_object(v4, (int)Number);
    else
      Block[2] = Number;
    v4 = Number;
  }
  if ( Block )
  {
    if ( Block[2] )
      *((_DWORD *)Block[2] + 1) = Number;
  }
  return Block;
}

//----- (00415175) --------------------------------------------------------
void **__stdcall cJSON_CreateDoubleArray(int a1, int a2)
{
  void **Block; // [esp+10h] [ebp-18h]
  double *v4; // [esp+14h] [ebp-14h]
  double *Number; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  Number = 0;
  v4 = 0;
  if ( a2 < 0 || !a1 )
    return 0;
  Block = (void **)cJSON_CreateArray();
  for ( i = 0; Block && i < a2; ++i )
  {
    Number = cJSON_CreateNumber(*(double *)(8 * i + a1));
    if ( !Number )
    {
      cJSON_Delete(Block);
      return 0;
    }
    if ( i )
      suffix_object(v4, (int)Number);
    else
      Block[2] = Number;
    v4 = Number;
  }
  if ( Block )
  {
    if ( Block[2] )
      *((_DWORD *)Block[2] + 1) = Number;
  }
  return Block;
}

//----- (00415256) --------------------------------------------------------
void **__stdcall cJSON_CreateStringArray(int a1, int a2)
{
  void **Block; // [esp+10h] [ebp-18h]
  void **v4; // [esp+14h] [ebp-14h]
  void **String; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  String = 0;
  v4 = 0;
  if ( a2 < 0 || !a1 )
    return 0;
  Block = (void **)cJSON_CreateArray();
  for ( i = 0; Block && i < a2; ++i )
  {
    String = cJSON_CreateString(*(char **)(4 * i + a1));
    if ( !String )
    {
      cJSON_Delete(Block);
      return 0;
    }
    if ( i )
      suffix_object(v4, (int)String);
    else
      Block[2] = String;
    v4 = String;
  }
  if ( Block )
  {
    if ( Block[2] )
      *((_DWORD *)Block[2] + 1) = String;
  }
  return Block;
}

//----- (00415337) --------------------------------------------------------
double *__stdcall cJSON_Duplicate(int a1, int a2)
{
  int v2; // eax
  void *v3; // eax
  _DWORD *v5; // [esp+10h] [ebp-18h]
  _DWORD *v6; // [esp+14h] [ebp-14h]
  _DWORD *i; // [esp+18h] [ebp-10h]
  double *Block; // [esp+1Ch] [ebp-Ch]

  Block = 0;
  v6 = 0;
  v5 = 0;
  if ( !a1 )
    goto LABEL_22;
  Block = (double *)cJSON_New_Item((int (__cdecl **)(int))&global_hooks);
  if ( !Block )
    goto LABEL_22;
  v2 = *(_DWORD *)(a1 + 12);
  BYTE1(v2) &= ~1u;
  *((_DWORD *)Block + 3) = v2;
  *((_DWORD *)Block + 5) = *(_DWORD *)(a1 + 20);
  Block[3] = *(double *)(a1 + 24);
  if ( *(_DWORD *)(a1 + 16) )
  {
    *((_DWORD *)Block + 4) = cJSON_strdup(*(char **)(a1 + 16), (int (__cdecl **)(size_t))&global_hooks);
    if ( !*((_DWORD *)Block + 4) )
      goto LABEL_22;
  }
  if ( !*(_DWORD *)(a1 + 32)
    || ((*(_DWORD *)(a1 + 12) & 0x200) == 0
      ? (v3 = cJSON_strdup(*(char **)(a1 + 32), (int (__cdecl **)(size_t))&global_hooks))
      : (v3 = *(void **)(a1 + 32)),
        (*((_DWORD *)Block + 8) = v3) != 0) )
  {
    if ( a2 )
    {
      for ( i = *(_DWORD **)(a1 + 8); i; i = (_DWORD *)*i )
      {
        v5 = (_DWORD *)cJSON_Duplicate(i, 1);
        if ( !v5 )
          goto LABEL_22;
        if ( v6 )
        {
          *v6 = v5;
          v5[1] = v6;
        }
        else
        {
          *((_DWORD *)Block + 2) = v5;
        }
        v6 = v5;
      }
      if ( *((_DWORD *)Block + 2) )
        *(_DWORD *)(*((_DWORD *)Block + 2) + 4) = v5;
      return Block;
    }
    else
    {
      return Block;
    }
  }
  else
  {
LABEL_22:
    if ( Block )
      cJSON_Delete((void **)Block);
    return 0;
  }
}
// 41549E: conditional instruction was optimized away because %Block.4!=0
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (004154E5) --------------------------------------------------------
_DWORD *__cdecl skip_oneline_comment(_DWORD *a1)
{
  _DWORD *result; // eax

  for ( *a1 += 2; ; ++*a1 )
  {
    result = (_DWORD *)*(unsigned __int8 *)*a1;
    if ( !(_BYTE)result )
      break;
    if ( *(_BYTE *)*a1 == 10 )
    {
      result = a1;
      ++*a1;
      return result;
    }
  }
  return result;
}

//----- (0041552D) --------------------------------------------------------
unsigned __int8 **__cdecl skip_multiline_comment(unsigned __int8 **a1)
{
  unsigned __int8 **result; // eax

  for ( *a1 += 2; ; ++*a1 )
  {
    result = (unsigned __int8 **)**a1;
    if ( !(_BYTE)result )
      break;
    if ( **a1 == 42 && (*a1)[1] == 47 )
    {
      result = a1;
      *a1 += 2;
      return result;
    }
  }
  return result;
}

//----- (00415584) --------------------------------------------------------
_DWORD *__cdecl minify_string(unsigned __int8 **a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *(_BYTE *)(*a2)++ = *(*a1)++;
  while ( 1 )
  {
    result = (_DWORD *)**a1;
    if ( !(_BYTE)result )
      break;
    *(_BYTE *)*a2 = **a1;
    if ( **a1 == 34 )
    {
      *(_BYTE *)*a2 = 34;
      ++*a1;
      result = a2;
      ++*a2;
      return result;
    }
    if ( **a1 == 92 && (*a1)[1] == 34 )
      *(_BYTE *)++*a2 = *++*a1;
    ++*a1;
    ++*a2;
  }
  return result;
}

//----- (00415668) --------------------------------------------------------
_BYTE *__stdcall cJSON_Minify(_BYTE *a1)
{
  _BYTE *result; // eax
  int v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v2[0] = (int)a1;
  result = a1;
  if ( a1 )
  {
    while ( *a1 )
    {
      switch ( *a1 )
      {
        case 9:
        case 0xA:
        case 0xD:
        case 0x20:
          ++a1;
          break;
        case 0x22:
          minify_string(&a1, v2);
          break;
        case 0x2F:
          if ( a1[1] == 47 )
          {
            skip_oneline_comment(&a1);
          }
          else if ( a1[1] == 42 )
          {
            skip_multiline_comment(&a1);
          }
          else
          {
            ++a1;
          }
          break;
        default:
          *(_BYTE *)v2[0]++ = *a1++;
          break;
      }
    }
    result = (_BYTE *)v2[0];
    *(_BYTE *)v2[0] = 0;
  }
  return result;
}
// 415668: using guessed type int var_C[3];

//----- (00415734) --------------------------------------------------------
BOOL __stdcall cJSON_IsInvalid(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 0;
}

//----- (00415759) --------------------------------------------------------
BOOL __stdcall cJSON_IsFalse(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 1;
}

//----- (0041577F) --------------------------------------------------------
BOOL __stdcall cJSON_IsTrue(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 2;
}

//----- (004157A5) --------------------------------------------------------
BOOL __stdcall cJSON_IsBool(int a1)
{
  return a1 && (*(_DWORD *)(a1 + 12) & 3) != 0;
}

//----- (004157CA) --------------------------------------------------------
BOOL __stdcall cJSON_IsNull(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 4;
}

//----- (004157F0) --------------------------------------------------------
BOOL __stdcall cJSON_IsNumber(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 8;
}

//----- (00415816) --------------------------------------------------------
BOOL __stdcall cJSON_IsString(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 16;
}

//----- (0041583C) --------------------------------------------------------
BOOL __stdcall cJSON_IsArray(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 32;
}

//----- (00415862) --------------------------------------------------------
BOOL __stdcall cJSON_IsObject(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 64;
}

//----- (00415888) --------------------------------------------------------
BOOL __stdcall cJSON_IsRaw(int a1)
{
  return a1 && (unsigned __int8)*(_DWORD *)(a1 + 12) == 128;
}

//----- (004158B0) --------------------------------------------------------
BOOL __stdcall cJSON_Compare(int a1, int a2, int a3)
{
  int v4; // eax
  int v5; // eax
  int **object_item; // [esp+10h] [ebp-18h]
  int *k; // [esp+10h] [ebp-18h]
  int *j; // [esp+14h] [ebp-14h]
  int **v9; // [esp+14h] [ebp-14h]
  _DWORD *i; // [esp+18h] [ebp-10h]
  _DWORD *v11; // [esp+1Ch] [ebp-Ch]

  if ( !a1 || !a2 || (unsigned __int8)*(_DWORD *)(a1 + 12) != (unsigned __int8)*(_DWORD *)(a2 + 12) )
    return 0;
  v4 = (unsigned __int8)*(_DWORD *)(a1 + 12);
  if ( v4 != 8 )
  {
    if ( (unsigned __int8)*(_DWORD *)(a1 + 12) > 8u )
    {
      if ( v4 != 32 )
      {
        if ( (unsigned __int8)*(_DWORD *)(a1 + 12) > 0x20u )
        {
          if ( v4 != 64 && v4 != 128 )
            return 0;
        }
        else if ( v4 != 16 )
        {
          return 0;
        }
      }
    }
    else if ( !(unsigned __int8)*(_DWORD *)(a1 + 12) || (unsigned __int8)*(_DWORD *)(a1 + 12) > 2u && v4 != 4 )
    {
      return 0;
    }
  }
  if ( a1 == a2 )
    return 1;
  v5 = (unsigned __int8)*(_DWORD *)(a1 + 12);
  if ( v5 == 8 )
    return compare_double(*(double *)(a1 + 24), *(double *)(a2 + 24));
  if ( (unsigned __int8)*(_DWORD *)(a1 + 12) <= 8u )
    return (unsigned __int8)*(_DWORD *)(a1 + 12) && ((unsigned __int8)*(_DWORD *)(a1 + 12) <= 2u || v5 == 4);
  if ( v5 == 32 )
  {
    v11 = *(_DWORD **)(a1 + 8);
    for ( i = *(_DWORD **)(a2 + 8); v11 && i; i = (_DWORD *)*i )
    {
      if ( !cJSON_Compare(v11, i, a3) )
        return 0;
      v11 = (_DWORD *)*v11;
    }
    return v11 == i;
  }
  else
  {
    if ( (unsigned __int8)*(_DWORD *)(a1 + 12) <= 0x20u )
    {
      if ( v5 != 16 )
        return 0;
      return *(_DWORD *)(a1 + 16)
          && *(_DWORD *)(a2 + 16)
          && strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) == 0;
    }
    if ( v5 != 64 )
    {
      if ( v5 != 128 )
        return 0;
      return *(_DWORD *)(a1 + 16)
          && *(_DWORD *)(a2 + 16)
          && strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) == 0;
    }
    for ( j = *(int **)(a1 + 8); j; j = (int *)*j )
    {
      object_item = get_object_item(a2, (char *)j[8], a3);
      if ( !object_item )
        return 0;
      if ( !cJSON_Compare(j, object_item, a3) )
        return 0;
    }
    for ( k = *(int **)(a2 + 8); k; k = (int *)*k )
    {
      v9 = get_object_item(a1, (char *)k[8], a3);
      if ( !v9 )
        return 0;
      if ( !cJSON_Compare(k, v9, a3) )
        return 0;
    }
    return 1;
  }
}
// 415AA7: conditional instruction was optimized away because %arg_0.4!=0
// 415B26: conditional instruction was optimized away because %arg_4.4!=0

//----- (00415BAB) --------------------------------------------------------
void *__stdcall cJSON_malloc(size_t Size)
{
  return global_hooks(Size);
}
// 4E9D40: using guessed type void *(__cdecl *global_hooks)(size_t Size);

//----- (00415BC2) --------------------------------------------------------
void __stdcall cJSON_free(void *Block)
{
  off_4E9D44(Block);
}
// 4E9D44: using guessed type void (__cdecl *off_4E9D44)(void *Block);

//----- (00415BDC) --------------------------------------------------------
int __cdecl vsnwprintf_0(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, va_list Args)
{
  return __vsnwprintf(Buffer, BufferCount, Format, Args);
}

//----- (00415C06) --------------------------------------------------------
int __cdecl vswprintf(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, va_list ArgList)
{
  return vsnwprintf_0(Buffer, BufferCount, (wchar_t *)Format, ArgList);
}

//----- (00415C2E) --------------------------------------------------------
int swprintf(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, ...)
{
  va_list va; // [esp+3Ch] [ebp+14h] BYREF

  va_start(va, Format);
  return vswprintf(Buffer, BufferCount, Format, va);
}

//----- (00415C62) --------------------------------------------------------
HMODULE free_library_handles()
{
  HMODULE result; // eax

  if ( hid_lib_handle )
    FreeLibrary(hid_lib_handle);
  hid_lib_handle = 0;
  result = cfgmgr32_lib_handle;
  if ( cfgmgr32_lib_handle )
    result = (HMODULE)FreeLibrary(cfgmgr32_lib_handle);
  cfgmgr32_lib_handle = 0;
  return result;
}

//----- (00415CB5) --------------------------------------------------------
int lookup_functions()
{
  hid_lib_handle = LoadLibraryW(L"hid.dll");
  if ( hid_lib_handle )
  {
    cfgmgr32_lib_handle = LoadLibraryW(L"cfgmgr32.dll");
    if ( cfgmgr32_lib_handle )
    {
      HidD_GetHidGuid = (int (__stdcall *)(_DWORD))GetProcAddress(hid_lib_handle, "HidD_GetHidGuid");
      if ( HidD_GetHidGuid )
      {
        HidD_GetAttributes = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(hid_lib_handle, "HidD_GetAttributes");
        if ( HidD_GetAttributes )
        {
          HidD_GetSerialNumberString = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                    hid_lib_handle,
                                                                                    "HidD_GetSerialNumberString");
          if ( HidD_GetSerialNumberString )
          {
            HidD_GetManufacturerString = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                      hid_lib_handle,
                                                                                      "HidD_GetManufacturerString");
            if ( HidD_GetManufacturerString )
            {
              HidD_GetProductString = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                   hid_lib_handle,
                                                                                   "HidD_GetProductString");
              if ( HidD_GetProductString )
              {
                HidD_SetFeature = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                               hid_lib_handle,
                                                                               "HidD_SetFeature");
                if ( HidD_SetFeature )
                {
                  HidD_GetFeature = (int)GetProcAddress(hid_lib_handle, "HidD_GetFeature");
                  if ( HidD_GetFeature )
                  {
                    HidD_GetInputReport = (int)GetProcAddress(hid_lib_handle, "HidD_GetInputReport");
                    if ( HidD_GetInputReport )
                    {
                      HidD_GetIndexedString = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                                   hid_lib_handle,
                                                                                                   "HidD_GetIndexedString");
                      if ( HidD_GetIndexedString )
                      {
                        HidD_GetPreparsedData = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(
                                                                                     hid_lib_handle,
                                                                                     "HidD_GetPreparsedData");
                        if ( HidD_GetPreparsedData )
                        {
                          HidD_FreePreparsedData = (int (__stdcall *)(_DWORD))GetProcAddress(
                                                                                hid_lib_handle,
                                                                                "HidD_FreePreparsedData");
                          if ( HidD_FreePreparsedData )
                          {
                            HidP_GetCaps = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(
                                                                                hid_lib_handle,
                                                                                "HidP_GetCaps");
                            if ( HidP_GetCaps )
                            {
                              HidD_SetNumInputBuffers = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(
                                                                                             hid_lib_handle,
                                                                                             "HidD_SetNumInputBuffers");
                              if ( HidD_SetNumInputBuffers )
                              {
                                CM_Locate_DevNodeW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                                  cfgmgr32_lib_handle,
                                                                                                  "CM_Locate_DevNodeW");
                                if ( CM_Locate_DevNodeW )
                                {
                                  CM_Get_Parent = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                               cfgmgr32_lib_handle,
                                                                                               "CM_Get_Parent");
                                  if ( CM_Get_Parent )
                                  {
                                    CM_Get_DevNode_PropertyW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(cfgmgr32_lib_handle, "CM_Get_DevNode_PropertyW");
                                    if ( CM_Get_DevNode_PropertyW )
                                    {
                                      CM_Get_Device_Interface_PropertyW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(cfgmgr32_lib_handle, "CM_Get_Device_Interface_PropertyW");
                                      if ( CM_Get_Device_Interface_PropertyW )
                                      {
                                        CM_Get_Device_Interface_List_SizeW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(cfgmgr32_lib_handle, "CM_Get_Device_Interface_List_SizeW");
                                        if ( CM_Get_Device_Interface_List_SizeW )
                                        {
                                          CM_Get_Device_Interface_ListW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(cfgmgr32_lib_handle, "CM_Get_Device_Interface_ListW");
                                          if ( CM_Get_Device_Interface_ListW )
                                            return 0;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  free_library_handles();
  return -1;
}
// 536578: using guessed type int (__stdcall *HidD_GetHidGuid)(_DWORD);
// 53657C: using guessed type int (__stdcall *HidD_GetAttributes)(_DWORD, _DWORD);
// 536580: using guessed type int (__stdcall *HidD_GetSerialNumberString)(_DWORD, _DWORD, _DWORD);
// 536584: using guessed type int (__stdcall *HidD_GetManufacturerString)(_DWORD, _DWORD, _DWORD);
// 536588: using guessed type int (__stdcall *HidD_GetProductString)(_DWORD, _DWORD, _DWORD);
// 53658C: using guessed type int (__stdcall *HidD_SetFeature)(_DWORD, _DWORD, _DWORD);
// 536590: using guessed type int HidD_GetFeature;
// 536594: using guessed type int HidD_GetInputReport;
// 536598: using guessed type int (__stdcall *HidD_GetIndexedString)(_DWORD, _DWORD, _DWORD, _DWORD);
// 53659C: using guessed type int (__stdcall *HidD_GetPreparsedData)(_DWORD, _DWORD);
// 5365A0: using guessed type int (__stdcall *HidD_FreePreparsedData)(_DWORD);
// 5365A4: using guessed type int (__stdcall *HidP_GetCaps)(_DWORD, _DWORD);
// 5365A8: using guessed type int (__stdcall *HidD_SetNumInputBuffers)(_DWORD, _DWORD);
// 5365AC: using guessed type int (__stdcall *CM_Locate_DevNodeW)(_DWORD, _DWORD, _DWORD);
// 5365B0: using guessed type int (__stdcall *CM_Get_Parent)(_DWORD, _DWORD, _DWORD);
// 5365B4: using guessed type int (__stdcall *CM_Get_DevNode_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 5365B8: using guessed type int (__stdcall *CM_Get_Device_Interface_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 5365BC: using guessed type int (__stdcall *CM_Get_Device_Interface_List_SizeW)(_DWORD, _DWORD, _DWORD, _DWORD);
// 5365C0: using guessed type int (__stdcall *CM_Get_Device_Interface_ListW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041608D) --------------------------------------------------------
_DWORD *new_hid_device()
{
  _DWORD *v1; // [esp+1Ch] [ebp-Ch]

  v1 = calloc(1u, 0x54u);
  *v1 = -1;
  v1[1] = 1;
  *((_WORD *)v1 + 4) = 0;
  v1[3] = 0;
  v1[4] = 0;
  *((_WORD *)v1 + 10) = 0;
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0;
  v1[9] = 0;
  memset(v1 + 10, 0, 0x14u);
  v1[14] = CreateEventA(0, 0, 0, 0);
  memset(v1 + 15, 0, 0x14u);
  v1[19] = CreateEventA(0, 0, 0, 0);
  v1[20] = 0;
  return v1;
}

//----- (004161B8) --------------------------------------------------------
void __cdecl free_hid_device(HANDLE *Block)
{
  CloseHandle(Block[14]);
  CloseHandle(Block[19]);
  CloseHandle(*Block);
  free(Block[7]);
  Block[7] = 0;
  free(Block[3]);
  free(Block[6]);
  free(Block[9]);
  hid_free_enumeration(Block[20]);
  free(Block);
}

//----- (00416254) --------------------------------------------------------
void __cdecl register_winapi_error_to_buffer(void **a1, wchar_t *String)
{
  WCHAR Buffer[1024]; // [esp+24h] [ebp-824h] BYREF
  int v3; // [esp+824h] [ebp-24h]
  wchar_t *v4; // [esp+828h] [ebp-20h]
  size_t v5; // [esp+82Ch] [ebp-1Ch]
  size_t v6; // [esp+830h] [ebp-18h]
  DWORD v7; // [esp+834h] [ebp-14h]
  DWORD dwMessageId; // [esp+838h] [ebp-10h]
  size_t v9; // [esp+83Ch] [ebp-Ch]

  if ( a1 )
  {
    free(*a1);
    *a1 = 0;
    if ( String )
    {
      dwMessageId = GetLastError();
      v7 = FormatMessageW(0x1200u, 0, dwMessageId, 0x400u, Buffer, 0x400u, 0);
      v6 = wcslen(String);
      v5 = v6 + 15;
      v9 = v6 + 15 + v7;
      *a1 = calloc(v9 + 1, 2u);
      v4 = (wchar_t *)*a1;
      if ( v4 )
      {
        v3 = swprintf(v4, v9 + 1, L"%.*ls: (0x%08X) %.*ls", v6, String, dwMessageId, v7, Buffer);
        if ( v3 >= 0 )
        {
          while ( v4[v9 - 1] == 13 || v4[v9 - 1] == 10 || v4[v9 - 1] == 32 )
            v4[--v9] = 0;
        }
        else
        {
          *v4 = 0;
        }
      }
    }
  }
}

//----- (004163EC) --------------------------------------------------------
void __cdecl register_winapi_error(int a1, wchar_t *String)
{
  if ( a1 )
    register_winapi_error_to_buffer((void **)(a1 + 28), String);
}

//----- (00416412) --------------------------------------------------------
void __cdecl register_string_error_to_buffer(void **a1, wchar_t *String)
{
  if ( a1 )
  {
    free(*a1);
    *a1 = 0;
    if ( String )
      *a1 = __wcsdup(String);
  }
}

//----- (00416453) --------------------------------------------------------
void __cdecl register_string_error(int a1, wchar_t *String)
{
  if ( a1 )
    register_string_error_to_buffer((void **)(a1 + 28), String);
}

//----- (00416479) --------------------------------------------------------
HANDLE __cdecl open_device(LPCWSTR lpFileName, int a2)
{
  DWORD v2; // eax

  if ( a2 )
    v2 = -1073741824;
  else
    v2 = 0;
  return CreateFileW(lpFileName, v2, 3u, 0, 3u, 0x40000000u, 0);
}

//----- (004164E1) --------------------------------------------------------
void *hid_version()
{
  return &api_version;
}

//----- (004164E7) --------------------------------------------------------
const char *hid_version_str()
{
  return "0.12.0";
}

//----- (004164ED) --------------------------------------------------------
int hid_init()
{
  if ( !hidapi_initialized )
  {
    if ( lookup_functions() < 0 )
      return -1;
    hidapi_initialized = 1;
  }
  return 0;
}
// 5365CC: using guessed type char hidapi_initialized;

//----- (0041651C) --------------------------------------------------------
int hid_exit()
{
  free_library_handles();
  hidapi_initialized = 0;
  return 0;
}
// 5365CC: using guessed type char hidapi_initialized;

//----- (00416535) --------------------------------------------------------
void *__cdecl hid_internal_get_devnode_property(int a1, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-18h] BYREF
  size_t Count; // [esp+24h] [ebp-14h] BYREF
  int DevNode_PropertyW; // [esp+28h] [ebp-10h]
  void *Block; // [esp+2Ch] [ebp-Ch]

  Count = 0;
  Block = 0;
  DevNode_PropertyW = CM_Get_DevNode_PropertyW(a1, a2, &v4, 0, &Count, 0);
  if ( DevNode_PropertyW != 26 || a3 != v4 )
    return 0;
  Block = calloc(Count, 1u);
  DevNode_PropertyW = CM_Get_DevNode_PropertyW(a1, a2, &v4, Block, &Count, 0);
  if ( !DevNode_PropertyW )
    return Block;
  free(Block);
  return 0;
}
// 5365B4: using guessed type int (__stdcall *CM_Get_DevNode_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00416600) --------------------------------------------------------
void *__cdecl hid_internal_get_device_interface_property(int a1, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-18h] BYREF
  size_t Count; // [esp+24h] [ebp-14h] BYREF
  int Device_Interface_PropertyW; // [esp+28h] [ebp-10h]
  void *Block; // [esp+2Ch] [ebp-Ch]

  Count = 0;
  Block = 0;
  Device_Interface_PropertyW = CM_Get_Device_Interface_PropertyW(a1, a2, &v4, 0, &Count, 0);
  if ( Device_Interface_PropertyW != 26 || a3 != v4 )
    return 0;
  Block = calloc(Count, 1u);
  Device_Interface_PropertyW = CM_Get_Device_Interface_PropertyW(a1, a2, &v4, Block, &Count, 0);
  if ( !Device_Interface_PropertyW )
    return Block;
  free(Block);
  return 0;
}
// 5365B8: using guessed type int (__stdcall *CM_Get_Device_Interface_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004166CB) --------------------------------------------------------
void *__cdecl hid_internal_get_ble_info(void **a1, int a2)
{
  void *result; // eax
  void *v3; // [esp+14h] [ebp-14h]
  void *v4; // [esp+18h] [ebp-10h]
  void *devnode_property; // [esp+1Ch] [ebp-Ch]

  devnode_property = hid_internal_get_devnode_property(a2, (int)&PKEY_DeviceInterface_Bluetooth_Manufacturer, 18);
  if ( devnode_property )
  {
    free(a1[4]);
    a1[4] = devnode_property;
  }
  v4 = hid_internal_get_devnode_property(a2, (int)&PKEY_DeviceInterface_Bluetooth_DeviceAddress, 18);
  if ( v4 )
  {
    free(a1[2]);
    a1[2] = v4;
  }
  result = (void *)CM_Get_Parent(&a2, a2, 0);
  if ( !result )
  {
    result = hid_internal_get_devnode_property(a2, (int)&DEVPKEY_NAME, 18);
    v3 = result;
    if ( result )
    {
      free(a1[5]);
      result = a1;
      a1[5] = v3;
    }
  }
  return result;
}
// 5365B0: invalid function type has been ignored
// 5365B0: using guessed type int (__stdcall *CM_Get_Parent)(_DWORD, _DWORD, _DWORD);

//----- (004167AA) --------------------------------------------------------
int __cdecl hid_internal_get_interface_number(wchar_t *Str)
{
  wchar_t *EndPtr; // [esp+10h] [ebp-18h] BYREF
  int v3; // [esp+14h] [ebp-14h]
  wchar_t *String; // [esp+18h] [ebp-10h]
  wchar_t *SubStr; // [esp+1Ch] [ebp-Ch]

  SubStr = L"&MI_";
  String = wcsstr(Str, L"&MI_");
  if ( !String )
    return -1;
  String += wcslen(SubStr);
  v3 = wcstol(String, &EndPtr, 16);
  if ( String == EndPtr )
    return -1;
  else
    return v3;
}
// 50FEFC: using guessed type wchar_t aMi[5];

//----- (0041681A) --------------------------------------------------------
void __cdecl hid_internal_get_info(int a1, int a2)
{
  wint_t v2; // ax
  wint_t v3; // ax
  int v4; // [esp+1Ch] [ebp-2Ch] BYREF
  int Parent; // [esp+20h] [ebp-28h]
  void *Block; // [esp+24h] [ebp-24h]
  wchar_t *j; // [esp+28h] [ebp-20h]
  wchar_t *Str; // [esp+2Ch] [ebp-1Ch]
  wchar_t *i; // [esp+30h] [ebp-18h]
  wchar_t *String; // [esp+34h] [ebp-14h]
  void *devnode_property; // [esp+38h] [ebp-10h]
  void *v12; // [esp+3Ch] [ebp-Ch]

  v12 = 0;
  devnode_property = 0;
  Block = hid_internal_get_device_interface_property(a1, (int)&DEVPKEY_Device_InstanceId, 18);
  if ( Block )
  {
    Parent = CM_Locate_DevNodeW(&v4, Block, 0);
    if ( !Parent )
    {
      devnode_property = hid_internal_get_devnode_property(v4, (int)&DEVPKEY_Device_HardwareIds, 8210);
      if ( devnode_property )
      {
        for ( String = (wchar_t *)devnode_property; *String; String += wcslen(String) + 1 )
        {
          for ( i = String; *i; ++i )
          {
            v2 = towupper(*i);
            *i = v2;
          }
          *(_DWORD *)(a2 + 28) = hid_internal_get_interface_number(String);
          if ( *(_DWORD *)(a2 + 28) != -1 )
            break;
        }
        Parent = CM_Get_Parent(&v4, v4, 0);
        if ( !Parent )
        {
          v12 = hid_internal_get_devnode_property(v4, (int)&DEVPKEY_Device_CompatibleIds, 8210);
          if ( v12 )
          {
            for ( Str = (wchar_t *)v12; *Str; Str += wcslen(Str) + 1 )
            {
              for ( j = Str; *j; ++j )
              {
                v3 = towupper(*j);
                *j = v3;
              }
              if ( wcsstr(Str, aB) )
              {
                hid_internal_get_ble_info((void **)a2, v4);
                break;
              }
            }
          }
        }
      }
    }
  }
  free(Block);
  free(devnode_property);
  free(v12);
}
// 5365AC: invalid function type has been ignored
// 5365AC: using guessed type int (__stdcall *CM_Locate_DevNodeW)(_DWORD, _DWORD, _DWORD);
// 5365B0: using guessed type int (__stdcall *CM_Get_Parent)(_DWORD, _DWORD, _DWORD);

//----- (00416A30) --------------------------------------------------------
CHAR *__cdecl hid_internal_UTF16toUTF8(LPCWCH lpWideCharStr)
{
  int Count; // [esp+28h] [ebp-10h]
  CHAR *lpMultiByteStr; // [esp+2Ch] [ebp-Ch]

  lpMultiByteStr = 0;
  Count = WideCharToMultiByte(0xFDE9u, 0x80u, lpWideCharStr, -1, 0, 0, 0, 0);
  if ( Count )
  {
    lpMultiByteStr = (CHAR *)calloc(Count, 1u);
    WideCharToMultiByte(0xFDE9u, 0x80u, lpWideCharStr, -1, lpMultiByteStr, Count, 0, 0);
  }
  return lpMultiByteStr;
}

//----- (00416AEF) --------------------------------------------------------
WCHAR *__cdecl hid_internal_UTF8toUTF16(LPCCH lpMultiByteStr)
{
  int Count; // [esp+28h] [ebp-10h]
  WCHAR *lpWideCharStr; // [esp+2Ch] [ebp-Ch]

  lpWideCharStr = 0;
  Count = MultiByteToWideChar(0xFDE9u, 8u, lpMultiByteStr, -1, 0, 0);
  if ( Count )
  {
    lpWideCharStr = (WCHAR *)calloc(Count, 2u);
    MultiByteToWideChar(0xFDE9u, 8u, lpMultiByteStr, -1, lpWideCharStr, Count);
  }
  return lpWideCharStr;
}

//----- (00416B8E) --------------------------------------------------------
_DWORD *__cdecl hid_internal_get_device_info(LPCWCH lpWideCharStr, int a2)
{
  wchar_t *v2; // eax
  wchar_t *v3; // eax
  wchar_t *v4; // eax
  wchar_t String[255]; // [esp+1Ch] [ebp-25Ch] BYREF
  __int16 v7; // [esp+21Ah] [ebp-5Eh]
  __int16 v8[32]; // [esp+21Ch] [ebp-5Ch] BYREF
  int v9; // [esp+25Ch] [ebp-1Ch] BYREF
  int v10; // [esp+260h] [ebp-18h] BYREF
  __int16 v11; // [esp+264h] [ebp-14h]
  __int16 v12; // [esp+266h] [ebp-12h]
  __int16 v13; // [esp+268h] [ebp-10h]
  _DWORD *v14; // [esp+26Ch] [ebp-Ch]

  v9 = 0;
  v14 = calloc(1u, 0x24u);
  v14[8] = 0;
  *v14 = hid_internal_UTF16toUTF8(lpWideCharStr);
  v10 = 12;
  if ( (unsigned __int8)HidD_GetAttributes(a2, &v10) )
  {
    *((_WORD *)v14 + 2) = v11;
    *((_WORD *)v14 + 3) = v12;
    *((_WORD *)v14 + 6) = v13;
  }
  if ( (unsigned __int8)HidD_GetPreparsedData(a2, &v9) )
  {
    if ( HidP_GetCaps(v9, v8) == 1114112 )
    {
      *((_WORD *)v14 + 12) = v8[1];
      *((_WORD *)v14 + 13) = v8[0];
    }
    HidD_FreePreparsedData(v9);
  }
  String[0] = 0;
  HidD_GetSerialNumberString(a2, String, 512);
  v7 = 0;
  v2 = __wcsdup(String);
  v14[2] = v2;
  String[0] = 0;
  HidD_GetManufacturerString(a2, String, 512);
  v7 = 0;
  v3 = __wcsdup(String);
  v14[4] = v3;
  String[0] = 0;
  HidD_GetProductString(a2, String, 512);
  v7 = 0;
  v4 = __wcsdup(String);
  v14[5] = v4;
  hid_internal_get_info((int)lpWideCharStr, (int)v14);
  return v14;
}
// 53657C: invalid function type has been ignored
// 53659C: invalid function type has been ignored
// 5365A4: invalid function type has been ignored
// 5365A0: invalid function type has been ignored
// 536580: invalid function type has been ignored
// 536584: invalid function type has been ignored
// 536588: invalid function type has been ignored
// 53657C: using guessed type int (__stdcall *HidD_GetAttributes)(_DWORD, _DWORD);
// 536580: using guessed type int (__stdcall *HidD_GetSerialNumberString)(_DWORD, _DWORD, _DWORD);
// 536584: using guessed type int (__stdcall *HidD_GetManufacturerString)(_DWORD, _DWORD, _DWORD);
// 536588: using guessed type int (__stdcall *HidD_GetProductString)(_DWORD, _DWORD, _DWORD);
// 53659C: using guessed type int (__stdcall *HidD_GetPreparsedData)(_DWORD, _DWORD);
// 5365A0: using guessed type int (__stdcall *HidD_FreePreparsedData)(_DWORD);
// 5365A4: using guessed type int (__stdcall *HidP_GetCaps)(_DWORD, _DWORD);

//----- (00416D6C) --------------------------------------------------------
_DWORD *__cdecl hid_enumerate(__int16 a1, __int16 a2)
{
  int v3; // [esp+34h] [ebp-44h] BYREF
  __int16 v4; // [esp+38h] [ebp-40h]
  __int16 v5; // [esp+3Ah] [ebp-3Eh]
  size_t Count; // [esp+40h] [ebp-38h] BYREF
  char v7[16]; // [esp+44h] [ebp-34h] BYREF
  _DWORD *device_info; // [esp+54h] [ebp-24h]
  HANDLE hObject; // [esp+58h] [ebp-20h]
  wchar_t *String; // [esp+5Ch] [ebp-1Ch]
  void *Block; // [esp+60h] [ebp-18h]
  int Device_Interface_List_SizeW; // [esp+64h] [ebp-14h]
  _DWORD *v13; // [esp+68h] [ebp-10h]
  _DWORD *v14; // [esp+6Ch] [ebp-Ch]

  v14 = 0;
  v13 = 0;
  Block = 0;
  if ( hid_init() < 0 )
    return 0;
  HidD_GetHidGuid(v7);
  do
  {
    Device_Interface_List_SizeW = CM_Get_Device_Interface_List_SizeW(&Count, v7, 0, 0);
    if ( Device_Interface_List_SizeW )
      break;
    if ( Block )
      free(Block);
    Block = calloc(Count, 2u);
    if ( !Block )
      return 0;
    Device_Interface_List_SizeW = CM_Get_Device_Interface_ListW(v7, 0, Block, Count, 0);
  }
  while ( Device_Interface_List_SizeW == 26 );
  if ( !Device_Interface_List_SizeW )
  {
    for ( String = (wchar_t *)Block; *String; String += wcslen(String) + 1 )
    {
      hObject = (HANDLE)-1;
      hObject = open_device(String, 0);
      if ( hObject != (HANDLE)-1 )
      {
        v3 = 12;
        if ( (unsigned __int8)HidD_GetAttributes(hObject, &v3) && (!a1 || a1 == v4) && (!a2 || a2 == v5) )
        {
          device_info = hid_internal_get_device_info(String, (int)hObject);
          if ( device_info )
          {
            if ( v13 )
              v13[8] = device_info;
            else
              v14 = device_info;
            v13 = device_info;
          }
        }
        CloseHandle(hObject);
      }
    }
  }
  free(Block);
  return v14;
}
// 536578: invalid function type has been ignored
// 5365BC: invalid function type has been ignored
// 5365C0: invalid function type has been ignored
// 536578: using guessed type int (__stdcall *HidD_GetHidGuid)(_DWORD);
// 53657C: using guessed type int (__stdcall *HidD_GetAttributes)(_DWORD, _DWORD);
// 5365BC: using guessed type int (__stdcall *CM_Get_Device_Interface_List_SizeW)(_DWORD, _DWORD, _DWORD, _DWORD);
// 5365C0: using guessed type int (__stdcall *CM_Get_Device_Interface_ListW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00416F66) --------------------------------------------------------
void *__cdecl hid_free_enumeration(void *a1)
{
  void *result; // eax
  void *v2; // [esp+18h] [ebp-10h]
  void *Block; // [esp+1Ch] [ebp-Ch]

  result = a1;
  for ( Block = a1; Block; Block = v2 )
  {
    v2 = (void *)*((_DWORD *)Block + 8);
    free(*(void **)Block);
    free(*((void **)Block + 2));
    free(*((void **)Block + 4));
    free(*((void **)Block + 5));
    free(Block);
    result = v2;
  }
  return result;
}

//----- (00416FCE) --------------------------------------------------------
_DWORD *__cdecl hid_open(__int16 a1, __int16 a2, wchar_t *String1)
{
  const CHAR **v4; // [esp+20h] [ebp-18h]
  _DWORD *v5; // [esp+24h] [ebp-14h]
  const CHAR *lpMultiByteStr; // [esp+28h] [ebp-10h]
  const CHAR **i; // [esp+2Ch] [ebp-Ch]

  lpMultiByteStr = 0;
  v5 = 0;
  v4 = (const CHAR **)hid_enumerate(a1, a2);
  if ( !v4 )
    return 0;
  for ( i = v4; i; i = (const CHAR **)i[8] )
  {
    if ( a1 == *((_WORD *)i + 2) && a2 == *((_WORD *)i + 3) )
    {
      if ( !String1 )
      {
        lpMultiByteStr = *i;
        break;
      }
      if ( i[2] && !wcscmp(String1, (const wchar_t *)i[2]) )
      {
        lpMultiByteStr = *i;
        break;
      }
    }
  }
  if ( lpMultiByteStr )
    v5 = hid_open_path(lpMultiByteStr);
  hid_free_enumeration(v4);
  return v5;
}

//----- (004170A9) --------------------------------------------------------
_DWORD *__cdecl hid_open_path(LPCCH lpMultiByteStr)
{
  void *v1; // eax
  _DWORD *device_info; // eax
  char v4[4]; // [esp+10h] [ebp-58h] BYREF
  unsigned __int16 v5; // [esp+14h] [ebp-54h]
  __int16 v6; // [esp+16h] [ebp-52h]
  __int16 v7; // [esp+18h] [ebp-50h]
  int v8; // [esp+50h] [ebp-18h] BYREF
  HANDLE hObject; // [esp+54h] [ebp-14h]
  void *Block; // [esp+58h] [ebp-10h]
  _DWORD *v11; // [esp+5Ch] [ebp-Ch]

  v11 = 0;
  Block = 0;
  hObject = (HANDLE)-1;
  v8 = 0;
  if ( hid_init() >= 0 )
  {
    Block = hid_internal_UTF8toUTF16(lpMultiByteStr);
    if ( Block )
    {
      hObject = open_device((LPCWSTR)Block, 1);
      if ( hObject != (HANDLE)-1 || (hObject = open_device((LPCWSTR)Block, 0), hObject != (HANDLE)-1) )
      {
        if ( (unsigned __int8)HidD_SetNumInputBuffers(hObject, 64)
          && (unsigned __int8)HidD_GetPreparsedData(hObject, &v8)
          && HidP_GetCaps(v8, v4) == 1114112 )
        {
          v11 = new_hid_device();
          *v11 = hObject;
          hObject = (HANDLE)-1;
          *((_WORD *)v11 + 4) = v6;
          v11[4] = v5;
          *((_WORD *)v11 + 10) = v7;
          v1 = malloc(v11[4]);
          v11[9] = v1;
          device_info = hid_internal_get_device_info((LPCWCH)Block, *v11);
          v11[20] = device_info;
        }
      }
    }
  }
  free(Block);
  CloseHandle(hObject);
  if ( v8 )
    HidD_FreePreparsedData(v8);
  return v11;
}
// 5365A8: invalid function type has been ignored
// 53659C: using guessed type int (__stdcall *HidD_GetPreparsedData)(_DWORD, _DWORD);
// 5365A0: using guessed type int (__stdcall *HidD_FreePreparsedData)(_DWORD);
// 5365A4: using guessed type int (__stdcall *HidP_GetCaps)(_DWORD, _DWORD);
// 5365A8: using guessed type int (__stdcall *HidD_SetNumInputBuffers)(_DWORD, _DWORD);
// 4170A9: using guessed type char var_58[4];

//----- (0041723E) --------------------------------------------------------
DWORD __cdecl hid_write(int a1, void *Src, size_t Size)
{
  DWORD NumberOfBytesTransferred; // [esp+2Ch] [ebp-1Ch] BYREF
  DWORD OverlappedResult; // [esp+30h] [ebp-18h]
  LPCVOID lpBuffer; // [esp+34h] [ebp-14h]
  int v7; // [esp+38h] [ebp-10h]
  int v8; // [esp+3Ch] [ebp-Ch]

  NumberOfBytesTransferred = 0;
  v8 = -1;
  v7 = 0;
  if ( !Src || !Size )
  {
    register_string_error(a1, (wchar_t *)L"Zero buffer/length");
    return v8;
  }
  if ( Size < *(unsigned __int16 *)(a1 + 8) )
  {
    if ( !*(_DWORD *)(a1 + 12) )
      *(_DWORD *)(a1 + 12) = malloc(*(unsigned __int16 *)(a1 + 8));
    lpBuffer = *(LPCVOID *)(a1 + 12);
    memcpy((void *)lpBuffer, Src, Size);
    memset((char *)lpBuffer + Size, 0, *(unsigned __int16 *)(a1 + 8) - Size);
    Size = *(unsigned __int16 *)(a1 + 8);
  }
  else
  {
    lpBuffer = Src;
  }
  OverlappedResult = WriteFile(*(HANDLE *)a1, lpBuffer, Size, 0, (LPOVERLAPPED)(a1 + 60));
  if ( OverlappedResult )
    goto LABEL_13;
  if ( GetLastError() == 997 )
  {
    v7 = 1;
LABEL_13:
    if ( v7 )
    {
      OverlappedResult = WaitForSingleObject(*(HANDLE *)(a1 + 76), 0x3E8u);
      if ( OverlappedResult )
      {
        register_winapi_error(a1, (wchar_t *)L"hid_write/WaitForSingleObject");
      }
      else
      {
        OverlappedResult = GetOverlappedResult(*(HANDLE *)a1, (LPOVERLAPPED)(a1 + 60), &NumberOfBytesTransferred, 0);
        if ( OverlappedResult )
          return NumberOfBytesTransferred;
        else
          register_winapi_error(a1, (wchar_t *)L"hid_write/GetOverlappedResult");
      }
    }
    return v8;
  }
  register_winapi_error(a1, (wchar_t *)aW);
  return v8;
}

//----- (00417415) --------------------------------------------------------
size_t __cdecl hid_read_timeout(int a1, void *a2, unsigned int a3, int dwMilliseconds)
{
  size_t v5; // eax
  DWORD v6; // eax
  DWORD NumberOfBytesRead; // [esp+2Ch] [ebp-1Ch] BYREF
  HANDLE hEvent; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]
  DWORD OverlappedResult; // [esp+38h] [ebp-10h]
  size_t Size; // [esp+3Ch] [ebp-Ch]

  NumberOfBytesRead = 0;
  Size = 0;
  OverlappedResult = 0;
  v9 = 0;
  hEvent = *(HANDLE *)(a1 + 56);
  if ( *(_DWORD *)(a1 + 32) )
  {
    v9 = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 1;
    memset(*(void **)(a1 + 36), 0, *(_DWORD *)(a1 + 16));
    ResetEvent(hEvent);
    OverlappedResult = ReadFile(
                         *(HANDLE *)a1,
                         *(LPVOID *)(a1 + 36),
                         *(_DWORD *)(a1 + 16),
                         &NumberOfBytesRead,
                         (LPOVERLAPPED)(a1 + 40));
    if ( !OverlappedResult )
    {
      if ( GetLastError() != 997 )
      {
        register_winapi_error(a1, (wchar_t *)L"ReadFile");
        CancelIo(*(HANDLE *)a1);
        *(_DWORD *)(a1 + 32) = 0;
        goto LABEL_23;
      }
      v9 = 1;
    }
  }
  if ( v9 )
  {
    if ( dwMilliseconds >= 0 )
    {
      OverlappedResult = WaitForSingleObject(hEvent, dwMilliseconds);
      if ( OverlappedResult )
        return 0;
    }
    OverlappedResult = GetOverlappedResult(*(HANDLE *)a1, (LPOVERLAPPED)(a1 + 40), &NumberOfBytesRead, 1);
  }
  *(_DWORD *)(a1 + 32) = 0;
  if ( OverlappedResult && NumberOfBytesRead )
  {
    if ( **(_BYTE **)(a1 + 36) )
    {
      v6 = NumberOfBytesRead;
      if ( a3 <= NumberOfBytesRead )
        v6 = a3;
      Size = v6;
      memcpy(a2, *(const void **)(a1 + 36), v6);
    }
    else
    {
      v5 = --NumberOfBytesRead;
      if ( a3 <= NumberOfBytesRead )
        v5 = a3;
      Size = v5;
      memcpy(a2, (const void *)(*(_DWORD *)(a1 + 36) + 1), v5);
    }
  }
  if ( !OverlappedResult )
    register_winapi_error(a1, (wchar_t *)L"hid_read_timeout/GetOverlappedResult");
LABEL_23:
  if ( OverlappedResult )
    return Size;
  else
    return -1;
}

//----- (00417634) --------------------------------------------------------
size_t __cdecl hid_read(int a1, void *a2, int a3)
{
  int v3; // eax

  if ( *(_DWORD *)(a1 + 4) )
    v3 = -1;
  else
    v3 = 0;
  return hid_read_timeout(a1, a2, a3, v3);
}

//----- (0041766F) --------------------------------------------------------
int __cdecl hid_set_nonblocking(int a1, int a2)
{
  *(_DWORD *)(a1 + 4) = a2 == 0;
  return 0;
}

//----- (00417689) --------------------------------------------------------
size_t __cdecl hid_send_feature_report(int a1, void *Src, size_t Size)
{
  char v3; // al
  char *v5; // [esp+1Ch] [ebp-Ch]

  if ( Size < *(unsigned __int16 *)(a1 + 20) )
  {
    if ( !*(_DWORD *)(a1 + 24) )
      *(_DWORD *)(a1 + 24) = malloc(*(unsigned __int16 *)(a1 + 20));
    v5 = *(char **)(a1 + 24);
    memcpy(v5, Src, Size);
    memset(&v5[Size], 0, *(unsigned __int16 *)(a1 + 20) - Size);
    v3 = HidD_SetFeature(*(_DWORD *)a1, v5, *(unsigned __int16 *)(a1 + 20));
  }
  else
  {
    v3 = HidD_SetFeature(*(_DWORD *)a1, Src, Size);
  }
  if ( v3 )
    return Size;
  register_winapi_error(a1, (wchar_t *)L"HidD_SetFeature");
  return -1;
}
// 53658C: invalid function type has been ignored
// 53658C: using guessed type int (__stdcall *HidD_SetFeature)(_DWORD, _DWORD, _DWORD);

//----- (0041777A) --------------------------------------------------------
DWORD __cdecl hid_get_report(HANDLE *a1, DWORD dwIoControlCode, _BYTE *lpInBuffer, DWORD nInBufferSize)
{
  struct _OVERLAPPED Overlapped; // [esp+24h] [ebp-24h] BYREF
  DWORD BytesReturned; // [esp+38h] [ebp-10h] BYREF
  BOOL OverlappedResult; // [esp+3Ch] [ebp-Ch]

  BytesReturned = 0;
  memset(&Overlapped, 0, sizeof(Overlapped));
  OverlappedResult = DeviceIoControl(
                       *a1,
                       dwIoControlCode,
                       lpInBuffer,
                       nInBufferSize,
                       lpInBuffer,
                       nInBufferSize,
                       &BytesReturned,
                       &Overlapped);
  if ( OverlappedResult || GetLastError() == 997 )
  {
    OverlappedResult = GetOverlappedResult(*a1, &Overlapped, &BytesReturned, 1);
    if ( OverlappedResult )
    {
      if ( !*lpInBuffer )
        ++BytesReturned;
      return BytesReturned;
    }
    else
    {
      register_winapi_error((int)a1, (wchar_t *)L"Get Input/Feature Report GetOverLappedResult");
      return -1;
    }
  }
  else
  {
    register_winapi_error((int)a1, (wchar_t *)L"Get Input/Feature Report DeviceIoControl");
    return -1;
  }
}

//----- (00417879) --------------------------------------------------------
DWORD __cdecl hid_get_feature_report(HANDLE *a1, _BYTE *lpInBuffer, DWORD nInBufferSize)
{
  return hid_get_report(a1, 0xB0192u, lpInBuffer, nInBufferSize);
}

//----- (004178A2) --------------------------------------------------------
DWORD __cdecl hid_get_input_report(HANDLE *a1, _BYTE *lpInBuffer, DWORD nInBufferSize)
{
  return hid_get_report(a1, 0xB01A2u, lpInBuffer, nInBufferSize);
}

//----- (004178CB) --------------------------------------------------------
void __cdecl hid_close(HANDLE *Block)
{
  if ( Block )
  {
    CancelIo(*Block);
    free_hid_device(Block);
  }
}

//----- (004178F9) --------------------------------------------------------
int __cdecl hid_get_manufacturer_string(int a1, wchar_t *Destination, size_t Count)
{
  if ( *(_DWORD *)(a1 + 80) )
  {
    if ( Destination && Count )
    {
      wcsncpy(Destination, *(const wchar_t **)(*(_DWORD *)(a1 + 80) + 16), Count);
      Destination[Count - 1] = 0;
      return 0;
    }
    else
    {
      register_string_error(a1, (wchar_t *)L"Zero buffer/length");
      return -1;
    }
  }
  else
  {
    register_string_error(a1, (wchar_t *)L"NULL device/info");
    return -1;
  }
}

//----- (00417984) --------------------------------------------------------
int __cdecl hid_get_product_string(int a1, wchar_t *Destination, size_t Count)
{
  if ( *(_DWORD *)(a1 + 80) )
  {
    if ( Destination && Count )
    {
      wcsncpy(Destination, *(const wchar_t **)(*(_DWORD *)(a1 + 80) + 20), Count);
      Destination[Count - 1] = 0;
      return 0;
    }
    else
    {
      register_string_error(a1, (wchar_t *)L"Zero buffer/length");
      return -1;
    }
  }
  else
  {
    register_string_error(a1, (wchar_t *)L"NULL device/info");
    return -1;
  }
}

//----- (00417A0F) --------------------------------------------------------
int __cdecl hid_get_serial_number_string(int a1, wchar_t *Destination, size_t Count)
{
  if ( *(_DWORD *)(a1 + 80) )
  {
    if ( Destination && Count )
    {
      wcsncpy(Destination, *(const wchar_t **)(*(_DWORD *)(a1 + 80) + 8), Count);
      Destination[Count - 1] = 0;
      return 0;
    }
    else
    {
      register_string_error(a1, (wchar_t *)L"Zero buffer/length");
      return -1;
    }
  }
  else
  {
    register_string_error(a1, (wchar_t *)L"NULL device/info");
    return -1;
  }
}

//----- (00417A9A) --------------------------------------------------------
int __cdecl hid_get_indexed_string(_DWORD *a1, int a2, int a3, unsigned int a4)
{
  int v4; // ebx

  if ( a4 > 0xFF )
    v4 = 512;
  else
    v4 = 2 * a4;
  if ( (unsigned __int8)HidD_GetIndexedString(*a1, a2, a3, v4) )
    return 0;
  register_winapi_error((int)a1, (wchar_t *)L"HidD_GetIndexedString");
  return -1;
}
// 536598: invalid function type has been ignored
// 536598: using guessed type int (__stdcall *HidD_GetIndexedString)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00417B0B) --------------------------------------------------------
int __cdecl hid_winapi_get_container_id(int a1, int a2)
{
  int v3; // [esp+28h] [ebp-20h] BYREF
  int v4; // [esp+2Ch] [ebp-1Ch] BYREF
  int v5; // [esp+30h] [ebp-18h] BYREF
  void *Block; // [esp+34h] [ebp-14h]
  int DevNode_PropertyW; // [esp+38h] [ebp-10h]
  void *device_interface_property; // [esp+3Ch] [ebp-Ch]

  Block = 0;
  device_interface_property = 0;
  DevNode_PropertyW = 19;
  if ( a2 )
  {
    Block = hid_internal_UTF8toUTF16(**(LPCCH **)(a1 + 80));
    if ( Block )
    {
      device_interface_property = hid_internal_get_device_interface_property(
                                    (int)Block,
                                    (int)&DEVPKEY_Device_InstanceId,
                                    18);
      if ( device_interface_property )
      {
        DevNode_PropertyW = CM_Locate_DevNodeW(&v5, device_interface_property, 0);
        if ( DevNode_PropertyW )
        {
          register_string_error(a1, (wchar_t *)L"Failed to locate device node");
        }
        else
        {
          v3 = 16;
          DevNode_PropertyW = CM_Get_DevNode_PropertyW(v5, &DEVPKEY_Device_ContainerId, &v4, a2, &v3, 0);
          if ( !DevNode_PropertyW && v4 != 13 )
            DevNode_PropertyW = 19;
          if ( DevNode_PropertyW )
            register_string_error(a1, (wchar_t *)L"Failed to read ContainerId property from device node");
        }
      }
      else
      {
        register_string_error(a1, (wchar_t *)L"Failed to get device interface property InstanceId");
      }
    }
    else
    {
      register_string_error(a1, (wchar_t *)L"Path conversion failure");
    }
    free(Block);
    free(device_interface_property);
    if ( DevNode_PropertyW )
      return -1;
    else
      return 0;
  }
  else
  {
    register_string_error(a1, (wchar_t *)L"Invalid Container ID");
    return -1;
  }
}
// 5365AC: using guessed type int (__stdcall *CM_Locate_DevNodeW)(_DWORD, _DWORD, _DWORD);
// 5365B4: using guessed type int (__stdcall *CM_Get_DevNode_PropertyW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00417C8D) --------------------------------------------------------
const char *__cdecl hid_error(int a1)
{
  if ( !a1 )
    return (const char *)L"hid_error for global errors is not implemented yet";
  if ( *(_DWORD *)(a1 + 28) )
    return *(const char **)(a1 + 28);
  return "S";
}
// 5102D0: using guessed type wchar_t aHidErrorForGlo[51];

//----- (00417CB8) --------------------------------------------------------
int __cdecl exp_dfuGetProperty(char a1)
{
  int result; // eax
  int v2[21]; // [esp+24h] [ebp-174h] BYREF
  char Src[16]; // [esp+78h] [ebp-120h] BYREF
  char v4[2]; // [esp+88h] [ebp-110h] BYREF
  unsigned __int16 v5; // [esp+8Ah] [ebp-10Eh]
  unsigned __int8 v6; // [esp+8Ch] [ebp-10Ch]
  unsigned __int8 v7; // [esp+8Dh] [ebp-10Bh]
  unsigned __int8 v8; // [esp+8Fh] [ebp-109h]
  int v9; // [esp+188h] [ebp-10h]
  int i; // [esp+18Ch] [ebp-Ch]

  Src[0] = 1;
  Src[1] = 0;
  Src[2] = 12;
  Src[3] = 0;
  Src[4] = 7;
  Src[5] = 0;
  Src[6] = 0;
  Src[7] = 2;
  Src[8] = a1;
  Src[9] = 0;
  Src[10] = 0;
  Src[11] = 0;
  Src[12] = 0;
  Src[13] = 0;
  Src[14] = 0;
  Src[15] = 0;
  v9 = hid_write(handle, Src, 0x10u);
  if ( v9 < 0 )
    return vexerr(255, "hid get property error\n");
  v9 = hid_read(handle, v4, 65);
  if ( v9 < 0 )
    return vexerr(255, "hid get property error\n");
  memset(v2, 0, sizeof(v2));
  v2[0] = (unsigned __int8)v4[0];
  v2[1] = v5;
  v2[2] = v6;
  v2[3] = v7;
  v2[4] = v8;
  if ( v8 > 0x10u )
    v2[4] = 16;
  for ( i = 0; ; ++i )
  {
    result = v2[4];
    if ( i >= v2[4] )
      break;
    v2[i + 5] = *(_DWORD *)&v4[4 * i + 8];
  }
  if ( a1 == 11 )
  {
    result = v2[5];
    if ( !v2[5] )
    {
      *(_DWORD *)dfuTransferSize = v2[6];
      return vexlog(4, "set transfer size to %d\n", v2[6]);
    }
  }
  return result;
}

//----- (00417EC5) --------------------------------------------------------
void __cdecl exp_dfuSendBlock(void *Src, int Size)
{
  if ( Size <= 1020 )
  {
    cmd_7145 = 2;
    byte_536601 = 0;
    word_536602 = Size;
    memcpy(&unk_536604, Src, Size);
    if ( (hid_write(handle, &cmd_7145, Size + 4) & 0x80000000) != 0 )
      vexerr(255, "hid write error\n");
  }
}
// 536600: using guessed type char cmd_7145;
// 536601: using guessed type char byte_536601;
// 536602: using guessed type __int16 word_536602;

//----- (00417F56) --------------------------------------------------------
int __cdecl exp_dfuDownload(int a1, int a2)
{
  int Size; // [esp+14h] [ebp-14h]
  char v4; // [esp+1Bh] [ebp-Dh]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( a2 <= 0 )
    return 1;
  v5 = 0;
  v4 = 0;
  while ( v4 != 1 )
  {
    if ( a2 - v5 <= *(int *)dfuTransferSize )
    {
      Size = a2 - v5;
      v4 = 1;
      vexlog(4, "send block %08X %d\n", v5, a2 - v5);
    }
    else
    {
      Size = *(_DWORD *)dfuTransferSize;
      vexlog(4, "send block %08X %d\n", v5, *(_DWORD *)dfuTransferSize);
    }
    exp_dfuSendBlock((void *)(a1 + v5), Size);
    v5 += Size;
  }
  return 0;
}

//----- (00417FF3) --------------------------------------------------------
int __cdecl exp_dfuLoadData(int a1, int a2, __int16 a3, __int16 a4)
{
  if ( hid_init() < 0 )
    return 1;
  handle = (int)hid_open(a3, a4, 0);
  if ( handle )
  {
    exp_dfuGetProperty(11);
    if ( *(_DWORD *)dfuTransferSize )
      exp_dfuDownload(a1, a2);
  }
  else
  {
    vexerr(255, "exp dfu not found\n");
  }
  hid_exit();
  return 1;
}

//----- (00418088) --------------------------------------------------------
int __cdecl exp_ram_bootloader(char *FileName, int a2)
{
  int v3; // [esp+14h] [ebp-14h] BYREF
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  signed int file; // [esp+34h] [ebp+Ch]

  v5 = 8137;
  v4 = 317;
  if ( !FileName )
    return exp_dfuLoadData((int)&_EXP_boot_ram, 76164, v5, v4);
  if ( a2 )
    return exp_dfuLoadData((int)FileName, a2, v5, v4);
  v3 = 0;
  file = read_file(FileName, (void **)&v3);
  if ( file <= 0 )
    return 1;
  else
    return exp_dfuLoadData(v3, file, v5, v4);
}

//----- (0041813C) --------------------------------------------------------
int dfu_dylib_init()
{
  CHAR Filename[260]; // [esp+18h] [ebp-110h] BYREF
  HMODULE hModule; // [esp+11Ch] [ebp-Ch]

  hModule = LoadLibraryA("libusb-1.0.dll");
  if ( hModule )
  {
    usb = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(hModule, "libusb_init");
    libusb_exit = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(hModule, "libusb_exit");
    libusb_open_device_with_vid_pid = (int (__stdcall *)(_DWORD))GetProcAddress(
                                                                   hModule,
                                                                   "libusb_open_device_with_vid_pid");
    libusb_get_device = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(hModule, "libusb_get_device");
    libusb_get_config_descriptor = (int (__stdcall *)(_DWORD))GetProcAddress(hModule, "libusb_get_config_descriptor");
    libusb_set_configuration = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(hModule, "libusb_set_configuration");
    libusb_claim_interface = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(hModule, "libusb_claim_interface");
    libusb_close = (int (__stdcall *)(_DWORD))GetProcAddress(hModule, "libusb_close");
    libusb_control_transfer = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, "libusb_control_transfer");
    libusb_set_option = (int)GetProcAddress(hModule, "libusb_set_option");
    libusb_get_device_list = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(hModule, "libusb_get_device_list");
    libusb_free_device_list = (int (__stdcall *)(_DWORD))GetProcAddress(hModule, "libusb_free_device_list");
    libusb_get_device_descriptor = (int (__stdcall *)(_DWORD, _DWORD))GetProcAddress(
                                                                        hModule,
                                                                        "libusb_get_device_descriptor");
    if ( usb )
    {
      if ( libusb_exit )
      {
        if ( libusb_open_device_with_vid_pid )
        {
          if ( libusb_get_device )
          {
            if ( libusb_get_config_descriptor )
            {
              if ( libusb_set_configuration )
              {
                if ( libusb_claim_interface )
                {
                  if ( libusb_close )
                  {
                    if ( libusb_control_transfer )
                    {
                      if ( libusb_get_device_list )
                      {
                        if ( libusb_free_device_list )
                        {
                          if ( libusb_get_device_descriptor )
                          {
                            if ( GetModuleFileNameA(hModule, Filename, 0x104u) && !g_jsonmode && !g_quietmode )
                              vexlog(2, "libusb: loaded from %s\n", Filename);
                            return 0;
                          }
                          else
                          {
                            return 1;
                          }
                        }
                        else
                        {
                          return 1;
                        }
                      }
                      else
                      {
                        return 1;
                      }
                    }
                    else
                    {
                      return 1;
                    }
                  }
                  else
                  {
                    return 1;
                  }
                }
                else
                {
                  return 1;
                }
              }
              else
              {
                return 1;
              }
            }
            else
            {
              return 1;
            }
          }
          else
          {
            return 1;
          }
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    vexerr(255, "libusb: not installed\n");
    return 1;
  }
}
// 44BF70: using guessed type int g_quietmode;
// 520044: using guessed type int g_jsonmode;
// 536A00: using guessed type int (__stdcall *usb)(_DWORD, _DWORD, _DWORD);
// 536A04: using guessed type int (__stdcall *libusb_exit)(_DWORD, _DWORD);
// 536A08: using guessed type int (__stdcall *libusb_open_device_with_vid_pid)(_DWORD);
// 536A0C: using guessed type int (__stdcall *libusb_get_device)(_DWORD, _DWORD, _DWORD);
// 536A10: using guessed type int (__stdcall *libusb_get_config_descriptor)(_DWORD);
// 536A14: using guessed type int (__stdcall *libusb_set_configuration)(_DWORD, _DWORD);
// 536A18: using guessed type int (__stdcall *libusb_claim_interface)(_DWORD, _DWORD);
// 536A1C: using guessed type int (__stdcall *libusb_close)(_DWORD);
// 536A20: using guessed type int (__cdecl *libusb_control_transfer)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 536A24: using guessed type int libusb_set_option;
// 536A28: using guessed type int (__stdcall *libusb_get_device_list)(_DWORD, _DWORD);
// 536A2C: using guessed type int (__stdcall *libusb_free_device_list)(_DWORD);
// 536A30: using guessed type int (__stdcall *libusb_get_device_descriptor)(_DWORD, _DWORD);

//----- (00418437) --------------------------------------------------------
int __cdecl dfu_download(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, int a5)
{
  return dword_536A20(a1, 33, 1, a4, a2, a5, a3, dfu_timeout);
}
// 50CF04: using guessed type int dfu_timeout;
// 536A20: using guessed type int (__cdecl *dword_536A20)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004184AC) --------------------------------------------------------
int __cdecl dfu_getStatus(int a1, unsigned __int16 a2, int a3)
{
  char v4[6]; // [esp+36h] [ebp-12h] BYREF
  int v5; // [esp+3Ch] [ebp-Ch]

  *(_BYTE *)a3 = 14;
  *(_DWORD *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 8) = 10;
  *(_BYTE *)(a3 + 9) = 0;
  v5 = dword_536A20(a1, 161, 3, 0, a2, v4, 6, dfu_timeout);
  if ( v5 == 6 )
  {
    *(_BYTE *)a3 = v4[0];
    *(_DWORD *)(a3 + 4) = ((unsigned __int8)v4[2] << 8) | ((unsigned __int8)v4[3] << 16) | (unsigned __int8)v4[1];
    *(_BYTE *)(a3 + 8) = v4[4];
    *(_BYTE *)(a3 + 9) = v4[5];
  }
  return v5;
}
// 50CF04: using guessed type int dfu_timeout;
// 536A20: using guessed type int (__cdecl *dword_536A20)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00418576) --------------------------------------------------------
int __cdecl iq2_dfuSendBlock(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4)
{
  int result; // eax
  char v5[8]; // [esp+24h] [ebp-24h] BYREF
  unsigned __int8 v6; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]
  unsigned __int8 v10; // [esp+3Fh] [ebp-9h]

  result = dfu_download(a1, 0, a4, a2, a3);
  v8 = result;
  if ( result >= 0 )
  {
    v10 = 0;
    v9 = 100;
    while ( 1 )
    {
      result = v10 ^ 1;
      if ( !(_BYTE)result )
        break;
      result = dfu_getStatus(a1, 0, (int)v5);
      v7 = result;
      if ( result < 0 )
        break;
      result = v6;
      if ( v6 == 4 || (result = v6, v6 == 3) || (result = v6, v6 == 6) )
      {
        if ( !--v9 )
          return result;
        serialSleep(0xAu);
      }
      else
      {
        v10 = 1;
      }
    }
  }
  return result;
}
// 418576: using guessed type char var_24[8];

//----- (0041862D) --------------------------------------------------------
int __cdecl iq2_dfuDownload(int a1, int a2, int a3, int a4)
{
  unsigned __int16 v4; // ax
  int result; // eax
  int v6; // [esp+10h] [ebp-18h]
  char v7; // [esp+17h] [ebp-11h]
  int v8; // [esp+18h] [ebp-10h]
  unsigned __int16 v9; // [esp+1Ch] [ebp-Ch]

  v9 = 0;
  if ( a3 > 0 )
  {
    v8 = 0;
    v7 = 0;
    while ( v7 != 1 )
    {
      if ( a4 >= a3 - v8 )
      {
        v6 = a3 - v8;
        v7 = 1;
        vexlog(4, "libusb: send block %08X %d\n", v8, a3 - v8);
      }
      else
      {
        v6 = a4;
        vexlog(4, "libusb: send block %08X %d\n", v8, a4);
      }
      v4 = v9++;
      iq2_dfuSendBlock(a1, v4, v8 + a2, v6);
      v8 += v6;
    }
    return iq2_dfuSendBlock(a1, v9, 0, 0);
  }
  return result;
}

//----- (004186FB) --------------------------------------------------------
int __cdecl iq2_dfuLoadData(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-34h]
  int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+14h] [ebp-24h]
  char v8[4]; // [esp+18h] [ebp-20h] BYREF
  int v9; // [esp+1Ch] [ebp-1Ch]
  int device; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  char v12[4]; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  if ( dfu_dylib_init() == 1 )
    return 1;
  *(_DWORD *)v12 = usb(v8, v3, v5);
  v11 = libusb_open_device_with_vid_pid(*(_DWORD *)v8);
  if ( v11 )
  {
    device = libusb_get_device(v11, v4, v6);
    *(_DWORD *)v12 = libusb_get_config_descriptor(device);
    v13 = 0;
    if ( *(int *)v12 >= 0 )
    {
      if ( *(_DWORD *)(v7 + 12) )
      {
        if ( **(_DWORD **)(v7 + 12) )
        {
          if ( *(_BYTE *)(**(_DWORD **)(v7 + 12) + 1) == 4
            && *(_BYTE *)(**(_DWORD **)(v7 + 12) + 7) == 2
            && *(_BYTE *)(**(_DWORD **)(v7 + 12) + 5) == 0xFE
            && *(int *)(**(_DWORD **)(v7 + 12) + 20) > 0 )
          {
            v9 = *(_DWORD *)(**(_DWORD **)(v7 + 12) + 16);
            if ( v9 )
            {
              vexlog(4, "libusb: dfu transfer length %d\n", *(unsigned __int16 *)(v9 + 5));
              v13 = *(unsigned __int16 *)(v9 + 5);
            }
          }
        }
      }
      *(_DWORD *)v12 = libusb_set_configuration(v11, 1);
      if ( *(int *)v12 >= 0 )
      {
        *(_DWORD *)v12 = libusb_claim_interface(v11, 0);
        if ( *(int *)v12 >= 0 )
        {
          if ( v13 > 0 )
            iq2_dfuDownload(v11, a1, a2, v13);
          libusb_close(v11);
          return 0;
        }
        else
        {
          vexerr(255, "libusb: claim interface error %d\n", *(_DWORD *)v12);
          libusb_close(v11);
          return 1;
        }
      }
      else
      {
        vexerr(255, "libusb: set_config error %d\n", *(_DWORD *)v12);
        libusb_close(v11);
        return 1;
      }
    }
    else
    {
      vexerr(255, "libusb_get_config: error %d\n", *(_DWORD *)v12);
      libusb_close(v11);
      return 1;
    }
  }
  else
  {
    vexerr(255, "libusb: open error\n");
    return 1;
  }
}
// 536A00: invalid function type has been ignored
// 536A08: invalid function type has been ignored
// 536A0C: invalid function type has been ignored
// 536A10: invalid function type has been ignored
// 536A1C: invalid function type has been ignored
// 536A14: invalid function type has been ignored
// 536A18: invalid function type has been ignored
// 418721: variable 'v3' is possibly undefined
// 418721: variable 'v5' is possibly undefined
// 41877F: variable 'v4' is possibly undefined
// 41877F: variable 'v6' is possibly undefined
// 4187EE: variable 'v7' is possibly undefined
// 536A00: using guessed type int (__stdcall *usb)(_DWORD, _DWORD, _DWORD);
// 536A08: using guessed type int (__stdcall *libusb_open_device_with_vid_pid)(_DWORD);
// 536A0C: using guessed type int (__stdcall *libusb_get_device)(_DWORD, _DWORD, _DWORD);
// 536A10: using guessed type int (__stdcall *libusb_get_config_descriptor)(_DWORD);
// 536A14: using guessed type int (__stdcall *libusb_set_configuration)(_DWORD, _DWORD);
// 536A18: using guessed type int (__stdcall *libusb_claim_interface)(_DWORD, _DWORD);
// 536A1C: using guessed type int (__stdcall *libusb_close)(_DWORD);

//----- (00418974) --------------------------------------------------------
int __cdecl iq2_ram_bootloader(char *FileName, int a2)
{
  int v3[5]; // [esp+14h] [ebp-14h] BYREF
  signed int file; // [esp+34h] [ebp+Ch]

  v3[2] = 8137;
  v3[1] = 31;
  if ( !FileName )
    return iq2_dfuLoadData((int)&_IQ2_boot_ram, 67364);
  if ( a2 )
    return iq2_dfuLoadData((int)FileName, a2);
  v3[0] = 0;
  file = read_file(FileName, (void **)v3);
  if ( file <= 0 )
    return 1;
  else
    return iq2_dfuLoadData(v3[0], file);
}

//----- (00418A25) --------------------------------------------------------
int __cdecl iq2_atmel_update(char *FileName, int a2)
{
  int v3[5]; // [esp+14h] [ebp-14h] BYREF
  signed int file; // [esp+34h] [ebp+Ch]

  v3[2] = 10376;
  v3[1] = 543;
  if ( !FileName )
    return 1;
  if ( a2 )
    return iq2_dfuLoadData((int)FileName, a2);
  v3[0] = 0;
  file = read_file(FileName, (void **)v3);
  if ( file <= 0 )
    return 1;
  else
    return iq2_dfuLoadData(v3[0], file);
}

//----- (00418AB9) --------------------------------------------------------
int __cdecl exp_atmel_update(char *FileName, int a2)
{
  int v3[5]; // [esp+14h] [ebp-14h] BYREF
  signed int file; // [esp+34h] [ebp+Ch]

  v3[2] = 10376;
  v3[1] = 1567;
  if ( !FileName )
    return 1;
  if ( a2 )
    return iq2_dfuLoadData((int)FileName, a2);
  v3[0] = 0;
  file = read_file(FileName, (void **)v3);
  if ( file <= 0 )
    return 1;
  else
    return iq2_dfuLoadData(v3[0], file);
}

//----- (00418B4D) --------------------------------------------------------
int __cdecl dfu_check_device(int a1, _DWORD *a2, int a3, int a4, const char *a5, const char *a6)
{
  int result; // eax
  int v7[2]; // [esp+2Ah] [ebp-1Eh] BYREF
  int v8; // [esp+32h] [ebp-16h]
  int v9; // [esp+36h] [ebp-12h]
  __int16 v10; // [esp+3Ah] [ebp-Eh]
  int v11[3]; // [esp+3Ch] [ebp-Ch]

  v7[0] = 0;
  v7[1] = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11[0] = libusb_get_device_descriptor(a1, v7);
  if ( v11[0] < 0 )
    return vexerr(255, "libusb: get device descriptor error %d\n", v11[0]);
  result = (unsigned __int16)v8;
  if ( a3 == (unsigned __int16)v8 )
  {
    result = HIWORD(v8);
    if ( a4 == HIWORD(v8) )
    {
      if ( *a2 )
        puts(",");
      printf("      {\"vid\":\"0x%04X\", \"pid\":\"0x%04X\", \"family\":\"%s\", \"device\":\"%s\"}", a3, a4, a5, a6);
      result = (int)a2;
      *a2 = 1;
    }
  }
  return result;
}
// 536A30: invalid function type has been ignored
// 536A30: using guessed type int (__stdcall *libusb_get_device_descriptor)(_DWORD, _DWORD);
// 418B4D: using guessed type int var_C[3];

//----- (00418C13) --------------------------------------------------------
int __cdecl usb_detect(char a1)
{
  int v2; // [esp+0h] [ebp-58h]
  int v3; // [esp+4h] [ebp-54h]
  int v4; // [esp+8h] [ebp-50h]
  int v5; // [esp+34h] [ebp-24h] BYREF
  int v6; // [esp+38h] [ebp-20h] BYREF
  int v7; // [esp+3Ch] [ebp-1Ch] BYREF
  int device_list; // [esp+40h] [ebp-18h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( dfu_dylib_init() == 1 )
    return 1;
  if ( usb(&v7, v3, v4) )
  {
    vexerr(255, "libusb: init error\n");
    return 1;
  }
  else
  {
    device_list = libusb_get_device_list(0, &v6);
    puts("{");
    puts("  \"usb\": {");
    if ( device_list > 0 )
    {
      v5 = 0;
      puts("    \"dfu\": [");
      for ( i = 0; *(_DWORD *)(4 * i + v6); ++i )
      {
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 8137, 31, "iq2", "ram_boot");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 8137, 317, "exp", "ram_boot");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 10376, 543, "iq2", "ctrl");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 10376, 1567, "exp", "ctrl");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 10376, 255, "iq", "brain");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 8137, 12, "dev", "vision");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 8137, 309, "dev", "gps");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 8137, 326, "dev", "aicam3");
        dfu_check_device(*(_DWORD *)(4 * i + v6), &v5, 1317, 42149, "dev", "aicam3");
      }
      if ( v5 )
        putchar(10);
      if ( a1 != 1 )
      {
        v5 = 0;
        puts("    ],");
        puts("    \"vex\": [");
        for ( j = 0; *(_DWORD *)(4 * j + v6); ++j )
        {
          if ( a1 != 1 )
          {
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1281, "v5", "brain");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 512, "iq2", "brain");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1536, "exp", "brain");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1283, "v5", "ctrl");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 528, "iq2", "ctrl");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1552, "exp", "ctrl");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1313, "dev", "gps");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1287, "dev", "vision");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1289, "dev", "aicam3");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 1792, "hydra", "brain");
            dfu_check_device(*(_DWORD *)(4 * j + v6), &v5, 10376, 3, "iq", "brain");
          }
        }
        if ( v5 )
          putchar(10);
      }
      puts("    ]");
    }
    puts("  }\n}");
    libusb_free_device_list(v6);
    libusb_exit(v7, v2);
    return 0;
  }
}
// 536A28: invalid function type has been ignored
// 536A2C: invalid function type has been ignored
// 536A04: invalid function type has been ignored
// 418C3E: variable 'v3' is possibly undefined
// 418C3E: variable 'v4' is possibly undefined
// 419260: variable 'v2' is possibly undefined
// 536A00: using guessed type int (__stdcall *usb)(_DWORD, _DWORD, _DWORD);
// 536A04: using guessed type int (__stdcall *libusb_exit)(_DWORD, _DWORD);
// 536A28: using guessed type int (__stdcall *libusb_get_device_list)(_DWORD, _DWORD);
// 536A2C: using guessed type int (__stdcall *libusb_free_device_list)(_DWORD);

//----- (0041926C) --------------------------------------------------------
int __cdecl usb_detect_device(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-48h]
  int v5; // [esp+4h] [ebp-44h]
  int v6; // [esp+8h] [ebp-40h]
  int v7[2]; // [esp+12h] [ebp-36h] BYREF
  int v8; // [esp+1Ah] [ebp-2Eh]
  int v9; // [esp+1Eh] [ebp-2Ah]
  __int16 v10; // [esp+22h] [ebp-26h]
  int v11; // [esp+24h] [ebp-24h] BYREF
  int v12; // [esp+28h] [ebp-20h] BYREF
  int device_list; // [esp+2Ch] [ebp-1Ch]
  int device_descriptor; // [esp+30h] [ebp-18h]
  int j; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  unsigned __int8 v17; // [esp+3Fh] [ebp-9h]

  if ( dfu_dylib_init() == 1 )
    return 1;
  device_descriptor = usb(&v12, v5, v6);
  if ( device_descriptor )
  {
    vexerr(255, "libusb: init error\n");
    return 1;
  }
  else
  {
    device_list = libusb_get_device_list(0, &v11);
    v17 = 0;
    if ( device_list > 0 )
    {
      v7[0] = 0;
      v7[1] = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      for ( i = 0; *(_DWORD *)(4 * i + v11) && v17 != 1; ++i )
      {
        device_descriptor = libusb_get_device_descriptor(*(_DWORD *)(4 * i + v11), v7);
        if ( device_descriptor >= 0 )
        {
          for ( j = 0; j < a3; ++j )
          {
            if ( (unsigned __int16)v8 == *(_DWORD *)(4 * j + a1) && HIWORD(v8) == *(_DWORD *)(4 * j + a2) )
              v17 = 1;
          }
        }
      }
    }
    libusb_free_device_list(v11);
    libusb_exit(v12, v4);
    return v17 ^ 1;
  }
}
// 419291: variable 'v5' is possibly undefined
// 419291: variable 'v6' is possibly undefined
// 4193D3: variable 'v4' is possibly undefined
// 536A00: using guessed type int (__stdcall *usb)(_DWORD, _DWORD, _DWORD);
// 536A04: using guessed type int (__stdcall *libusb_exit)(_DWORD, _DWORD);
// 536A28: using guessed type int (__stdcall *libusb_get_device_list)(_DWORD, _DWORD);
// 536A2C: using guessed type int (__stdcall *libusb_free_device_list)(_DWORD);
// 536A30: using guessed type int (__stdcall *libusb_get_device_descriptor)(_DWORD, _DWORD);

//----- (004193E4) --------------------------------------------------------
int __cdecl usb_detect_device_iq2_ctrl(char a1)
{
  int v1; // eax
  int v3[2]; // [esp+2Ch] [ebp-1Ch] BYREF
  int v4[5]; // [esp+34h] [ebp-14h] BYREF

  v4[2] = 1;
  v4[0] = 10376;
  v4[1] = 10376;
  v3[0] = 528;
  v3[1] = 543;
  if ( a1 )
    v1 = 2;
  else
    v1 = 1;
  return usb_detect_device((int)v4, (int)v3, v1);
}

//----- (00419443) --------------------------------------------------------
int __cdecl usb_detect_device_exp_ctrl(char a1)
{
  int v1; // eax
  int v3[2]; // [esp+2Ch] [ebp-1Ch] BYREF
  int v4[5]; // [esp+34h] [ebp-14h] BYREF

  v4[2] = 1;
  v4[0] = 10376;
  v4[1] = 10376;
  v3[0] = 1552;
  v3[1] = 1567;
  if ( a1 )
    v1 = 2;
  else
    v1 = 1;
  return usb_detect_device((int)v4, (int)v3, v1);
}

//----- (004194B0) --------------------------------------------------------
int __cdecl clock_getres(int a1, _DWORD *a2)
{
  __int64 v2; // rax
  LARGE_INTEGER v4; // kr00_8
  DWORD TimeAdjustment; // [esp+10h] [ebp-1Ch] BYREF
  DWORD TimeIncrement; // [esp+14h] [ebp-18h] BYREF
  LARGE_INTEGER TimeAdjustmentDisabled[2]; // [esp+18h] [ebp-14h] BYREF

  if ( a1 != 1 )
  {
    if ( a1 > 1 )
    {
      if ( a1 <= 3 )
        goto LABEL_4;
    }
    else if ( !a1 )
    {
LABEL_4:
      GetSystemTimeAdjustment(&TimeAdjustment, &TimeIncrement, (PBOOL)TimeAdjustmentDisabled);
      *a2 = 0;
      LODWORD(v2) = 100 * TimeIncrement;
LABEL_5:
      a2[1] = v2;
      return 0;
    }
    goto LABEL_7;
  }
  if ( !QueryPerformanceFrequency(TimeAdjustmentDisabled) )
  {
LABEL_7:
    *__errno() = 22;
    return -1;
  }
  v4 = TimeAdjustmentDisabled[0];
  *a2 = 0;
  v2 = ((v4.QuadPart >> 1) + 1000000000) / v4.QuadPart;
  if ( (int)v2 > 0 )
    goto LABEL_5;
  a2[1] = 1;
  return 0;
}

//----- (00419580) --------------------------------------------------------
int __cdecl clock_gettime(int a1, _DWORD *a2)
{
  HANDLE hThread; // eax
  unsigned int v3; // edi
  DWORD v4; // esi
  int result; // eax
  HANDLE CurrentProcess; // eax
  DWORD dwHighDateTime; // edi
  DWORD dwLowDateTime; // esi
  int v9; // eax
  int v10; // ebp
  int v11; // edx
  DItype rp; // [esp+28h] [ebp-44h] BYREF
  struct _FILETIME CreationTime; // [esp+30h] [ebp-3Ch] BYREF
  struct _FILETIME ExitTime; // [esp+38h] [ebp-34h] BYREF
  struct _FILETIME KernelTime; // [esp+40h] [ebp-2Ch] BYREF
  struct _FILETIME UserTime; // [esp+48h] [ebp-24h] BYREF

  if ( a1 != 1 )
  {
    if ( a1 <= 1 )
    {
      if ( !a1 )
      {
        GetSystemTimeAsFileTime(&CreationTime);
        v3 = (unsigned __int64)(*(_QWORD *)&CreationTime - 116444736000000000LL) >> 32;
        v4 = CreationTime.dwLowDateTime + 717324288;
        goto LABEL_7;
      }
    }
    else if ( a1 == 2 )
    {
      CurrentProcess = GetCurrentProcess();
      if ( GetProcessTimes(CurrentProcess, &CreationTime, &ExitTime, &KernelTime, &UserTime) )
      {
LABEL_6:
        v3 = (*(_QWORD *)&KernelTime + *(_QWORD *)&UserTime) >> 32;
        v4 = KernelTime.dwLowDateTime + UserTime.dwLowDateTime;
LABEL_7:
        *a2 = __PAIR64__(v3, v4) / 0x989680;
        a2[1] = 100 * (__PAIR64__(v3, v4) % 0x989680);
        return 0;
      }
    }
    else if ( a1 == 3 )
    {
      hThread = GetCurrentThread();
      if ( GetThreadTimes(hThread, &CreationTime, &ExitTime, &KernelTime, &UserTime) )
        goto LABEL_6;
    }
LABEL_10:
    *__errno() = 22;
    return -1;
  }
  if ( !QueryPerformanceFrequency((LARGE_INTEGER *)&KernelTime) || !QueryPerformanceCounter((LARGE_INTEGER *)&UserTime) )
    goto LABEL_10;
  dwHighDateTime = KernelTime.dwHighDateTime;
  dwLowDateTime = KernelTime.dwLowDateTime;
  v9 = __divmoddi4(*(_QWORD *)&UserTime, *(_QWORD *)&KernelTime, &rp);
  *a2 = v9;
  v10 = v9;
  v11 = (1000000000 * rp + (__SPAIR64__(dwHighDateTime, dwLowDateTime) >> 1))
      / __SPAIR64__(dwHighDateTime, dwLowDateTime);
  a2[1] = v11;
  result = 0;
  if ( v11 > 999999999 )
  {
    *a2 = v10 + 1;
    a2[1] = v11 - 1000000000;
  }
  return result;
}

//----- (004197A0) --------------------------------------------------------
int __cdecl clock_nanosleep(int a1, int a2, int *a3, _DWORD *a4)
{
  int v4; // edx
  int v5; // eax
  int v7; // [esp+18h] [ebp-14h] BYREF
  int v8; // [esp+1Ch] [ebp-10h]

  if ( a1 )
  {
    *__errno() = 22;
    return -1;
  }
  else if ( a2 )
  {
    clock_gettime(0, &v7);
    v4 = *a3 - v7;
    v5 = a3[1] - v8;
    v7 = v4;
    if ( v5 < 0 )
    {
      v8 = v5 + 1000000000;
      v7 = v4 - 1;
    }
    else
    {
      v8 = v5;
    }
    return nanosleep(&v7, a4);
  }
  else
  {
    return nanosleep(a3, a4);
  }
}

//----- (00419850) --------------------------------------------------------
int __cdecl clock_settime(int a1, int *a2)
{
  FILETIME FileTime; // [esp+18h] [ebp-24h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+20h] [ebp-1Ch] BYREF

  if ( a1
    || (FileTime = (FILETIME)(a2[1] / 100 + 10000000LL * *a2 + 116444736000000000LL),
        !FileTimeToSystemTime(&FileTime, &SystemTime)) )
  {
    *__errno() = 22;
    return -1;
  }
  else if ( SetSystemTime(&SystemTime) )
  {
    return 0;
  }
  else
  {
    *__errno() = 1;
    return -1;
  }
}

//----- (00419900) --------------------------------------------------------
int __cdecl nanosleep(int *a1, _DWORD *a2)
{
  int v2; // ebx
  unsigned int v3; // esi
  int v4; // ebx
  __int64 v5; // rdi
  unsigned __int64 v6; // rax
  int v7; // eax
  unsigned __int64 v9; // rax
  int v10; // ebx
  int v11; // eax
  __int64 v12; // [esp+18h] [ebp-24h]
  struct _FILETIME SystemTimeAsFileTime; // [esp+20h] [ebp-1Ch] BYREF
  struct _FILETIME lpSystemTimeAsFileTime; // [esp+28h] [ebp-14h] BYREF

  v2 = *a1;
  if ( *a1 < 0 || (v3 = a1[1], v3 > 0x3B9AC9FF) )
  {
    *__errno() = 22;
    return -1;
  }
  else
  {
    if ( a2 )
    {
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      v2 = *a1;
      v3 = a1[1];
    }
    v4 = 1000 * v2 + (int)v3 / 1000000;
    v12 = v4;
    HIDWORD(v5) = v4;
    LODWORD(v5) = v4 >> 31;
    if ( !v4 )
      return 0;
    do
    {
      v6 = __PAIR64__(v5, HIDWORD(v5));
      if ( (_DWORD)v5 || HIDWORD(v5) == -1 )
        v6 = 4294967294LL;
      LODWORD(v5) = (__PAIR64__(v5, HIDWORD(v5)) - v6) >> 32;
      HIDWORD(v5) -= v6;
      v7 = pthread_delay_np_ms(v6);
    }
    while ( v5 && !v7 );
    if ( v7 )
    {
      if ( a2 )
      {
        GetSystemTimeAsFileTime(&lpSystemTimeAsFileTime);
        v9 = (*(_QWORD *)&lpSystemTimeAsFileTime - *(_QWORD *)&SystemTimeAsFileTime) / 0x2710uLL;
        if ( v4 <= v9 )
        {
          v11 = 0;
          v10 = 0;
        }
        else
        {
          v10 = (v4 - v9) / 0x3E8;
          v11 = 1000000 * ((v12 - v9) % 0x3E8);
        }
        *a2 = v10;
        a2[1] = v11;
      }
      *__errno() = 4;
      return -1;
    }
    else
    {
      return 0;
    }
  }
}

//----- (00419A90) --------------------------------------------------------
int __stdcall SetThreadName_VEH(_DWORD **a1)
{
  int result; // eax

  result = 0;
  if ( *a1 )
    return -(**a1 == 1080890248);
  return result;
}

//----- (00419AB0) --------------------------------------------------------
_DWORD *__usercall enterOnceObject@<eax>(int a1@<eax>)
{
  int v2; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // ebx

  pthread_spin_lock(&data_1);
  v2 = once_obj;
  if ( !once_obj )
  {
    v4 = calloc(1u, 0x10u);
    *v4 = a1;
    v4[2] = 1;
    once_obj = (int)v4;
LABEL_7:
    pthread_mutex_init(v4 + 1, 0);
    goto LABEL_9;
  }
  if ( a1 != *(_DWORD *)once_obj )
  {
    while ( 1 )
    {
      v4 = *(_DWORD **)(v2 + 12);
      if ( !v4 )
        break;
      v2 = *(_DWORD *)(v2 + 12);
      if ( *v4 == a1 )
        goto LABEL_8;
    }
    v3 = calloc(1u, 0x10u);
    *v3 = a1;
    v3[2] = 1;
    v4 = v3;
    *(_DWORD *)(v2 + 12) = v3;
    goto LABEL_7;
  }
  v4 = (_DWORD *)once_obj;
LABEL_8:
  ++v4[2];
LABEL_9:
  pthread_spin_unlock(&data_1);
  return v4;
}
// 50CF20: using guessed type __int32 data_1;
// 536A48: using guessed type int once_obj;

//----- (00419B70) --------------------------------------------------------
DWORD pthread_tls_init()
{
  DWORD result; // eax

  result = TlsAlloc();
  _pthread_tls = result;
  if ( result == -1 )
    abort();
  return result;
}

//----- (00419B90) --------------------------------------------------------
int __usercall __pthread_get_pointer@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // ecx
  unsigned int v2; // ebx
  unsigned int v3; // edx
  _DWORD *v4; // esi

  if ( !idListCnt )
    return 0;
  v1 = 0;
  v2 = idListCnt - 1;
  if ( idListCnt == 1 )
  {
    if ( a1 == *((_DWORD *)idList + 1) )
      return *(_DWORD *)idList;
    else
      return 0;
  }
  else
  {
    while ( 1 )
    {
      v3 = (v1 + v2) >> 1;
      v4 = (char *)idList + 8 * v3;
      if ( v4[1] == a1 )
        break;
      if ( v4[1] > a1 )
      {
        if ( v3 == v1 )
          return 0;
        v2 = v3 - 1;
        if ( v3 - 1 < v1 )
          return 0;
      }
      else
      {
        v1 = v3 + 1;
        if ( v2 < v3 + 1 )
          return 0;
      }
    }
    return *v4;
  }
}
// 536A5C: using guessed type int idListCnt;

//----- (00419C10) --------------------------------------------------------
unsigned int __usercall __pthread_register_pointer@<eax>(int a1@<eax>)
{
  int v2; // edi
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  unsigned int v5; // ebx
  int v6; // eax
  _DWORD *Src; // edx
  int v8; // eax
  int v9; // ecx
  int v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // [esp+1Ch] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-20h]

  if ( !a1 )
    return 0;
  v2 = idListCnt;
  v3 = idList;
  if ( idListCnt < (unsigned int)idListMax )
    goto LABEL_8;
  if ( !idListCnt )
  {
    v4 = malloc(0x80u);
    v3 = v4;
    if ( v4 )
    {
      idListMax = 16;
      idList = v4;
      goto LABEL_8;
    }
    return 0;
  }
  v11 = idListMax + 16;
  v12 = realloc(idList, 8 * (idListMax + 16));
  v3 = v12;
  if ( !v12 )
    return 0;
  idListMax = v11;
  idList = v12;
  do
  {
LABEL_8:
    v5 = idListNextId;
    while ( 1 )
    {
      idListNextId = ++v5;
      if ( (v5 & 0x40000000) != 0 )
        break;
      if ( v5 )
        goto LABEL_7;
    }
    idListNextId = 1;
    v5 = 1;
LABEL_7:
    ;
  }
  while ( __pthread_get_pointer(v5) );
  if ( v2 )
  {
    v6 = v2;
    while ( v5 < v3[2 * v6 - 1] )
    {
      if ( !--v6 )
      {
        Src = v3;
        v8 = v2;
        v9 = 8;
LABEL_17:
        v13 = Src;
        memmove((char *)v3 + v9, Src, 8 * v8);
        v3 = v13;
        goto LABEL_18;
      }
    }
    v14 = 8 * v6;
    Src = &v3[2 * v6];
    if ( v2 != v6 )
    {
      v8 = v2 - v6;
      v9 = v14 + 8;
      goto LABEL_17;
    }
    v3 += 2 * v6;
  }
LABEL_18:
  v3[1] = v5;
  *v3 = a1;
  idListCnt = v2 + 1;
  return v5;
}
// 536A54: using guessed type int idListNextId;
// 536A58: using guessed type int idListMax;
// 536A5C: using guessed type int idListCnt;

//----- (00419D70) --------------------------------------------------------
int __usercall push_pthread_mem_part_2@<eax>(int a1@<eax>)
{
  unsigned int v2; // esi
  void *Block; // edi
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // [esp+1Ch] [ebp-20h]

  pthread_mutex_lock(&mtx_pthr_locked);
  v2 = *(_DWORD *)(a1 + 180);
  if ( v2 && idListCnt )
  {
    Block = idList;
    v5 = 0;
    v9 = idListCnt - 1;
    v6 = idListCnt - 1;
    while ( 1 )
    {
      v7 = (v5 + v6) >> 1;
      if ( v2 == *((_DWORD *)idList + 2 * v7 + 1) )
        break;
      if ( v2 < *((_DWORD *)idList + 2 * v7 + 1) )
      {
        if ( v7 == v5 )
          goto LABEL_2;
        v6 = v7 - 1;
      }
      else
      {
        v5 = v7 + 1;
      }
      if ( v6 < v5 )
        goto LABEL_2;
    }
    v8 = v7 + 1;
    if ( idListCnt > v8 )
      memmove((char *)idList + 8 * v8 - 8, (char *)idList + 8 * v8, 8 * (idListCnt - v8));
    idListCnt = v9;
    if ( !v9 )
    {
      free(Block);
      idListMax = 0;
      idListCnt = 0;
    }
  }
LABEL_2:
  if ( *(_DWORD *)(a1 + 44) )
    free(*(void **)(a1 + 44));
  if ( *(_DWORD *)(a1 + 48) )
    free(*(void **)(a1 + 48));
  if ( *(_DWORD *)(a1 + 52) )
    free(*(void **)(a1 + 52));
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 180) = 0;
  memset((void *)((a1 + 4) & 0xFFFFFFFC), 0, 4 * ((a1 - ((a1 + 4) & 0xFFFFFFFC) + 184) >> 2));
  if ( pthr_last )
  {
    *(_DWORD *)(pthr_last + 176) = a1;
    pthr_last = a1;
  }
  else
  {
    pthr_last = a1;
    pthr_root = a1;
  }
  return pthread_mutex_unlock(&mtx_pthr_locked);
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;
// 536A58: using guessed type int idListMax;
// 536A5C: using guessed type int idListCnt;
// 536A64: using guessed type int pthr_last;
// 536A68: using guessed type int pthr_root;

//----- (00419EE0) --------------------------------------------------------
int __usercall leaveOnceObject_part_4@<eax>(int a1@<eax>)
{
  int v2; // ebx
  int v3; // eax
  FILE *v6; // eax

  pthread_spin_lock(&data_1);
  v2 = once_obj;
  if ( once_obj && once_obj != a1 )
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(v2 + 12);
      if ( v3 == a1 || v3 == 0 )
        break;
      v2 = *(_DWORD *)(v2 + 12);
    }
  }
  else
  {
    v3 = once_obj;
    v2 = 0;
  }
  if ( v3 )
  {
    if ( (*(_DWORD *)(a1 + 8))-- == 1 )
    {
      pthread_mutex_destroy((HANDLE **)(a1 + 4));
      if ( v2 )
        *(_DWORD *)(v2 + 12) = *(_DWORD *)(a1 + 12);
      else
        once_obj = *(_DWORD *)(a1 + 12);
      free((void *)a1);
    }
  }
  else
  {
    v6 = ___acrt_iob_func(2u);
    fprintf(v6, "%p not found?!?!\n", (const void *)a1);
  }
  return pthread_spin_unlock(&data_1);
}
// 50CF20: using guessed type __int32 data_1;
// 536A48: using guessed type int once_obj;

//----- (00419FA0) --------------------------------------------------------
int __cdecl _pthread_once_cleanup(int a1)
{
  int result; // eax

  result = pthread_mutex_unlock((volatile signed __int32 *)(a1 + 4));
  if ( a1 )
    return leaveOnceObject_part_4(a1);
  return result;
}

//----- (00419FD0) --------------------------------------------------------
int pop_pthread_mem()
{
  int v0; // ebx
  unsigned int v1; // eax
  void *v3; // eax
  unsigned int v4; // eax
  void *Count; // [esp+0h] [ebp-1Ch]

  pthread_mutex_lock(&mtx_pthr_locked);
  v0 = pthr_root;
  if ( pthr_root )
  {
    v1 = __pthread_register_pointer(pthr_root);
    *(_DWORD *)(v0 + 180) = v1;
    if ( v1 )
    {
      pthr_root = *(_DWORD *)(v0 + 176);
      if ( !pthr_root )
        pthr_last = 0;
      *(_DWORD *)(v0 + 176) = 0;
    }
    else
    {
      v0 = 0;
    }
  }
  else
  {
    v3 = calloc(1u, 0xB8u);
    v0 = (int)v3;
    if ( v3 )
    {
      v4 = __pthread_register_pointer((int)v3);
      if ( v4 )
      {
        *(_DWORD *)(v0 + 180) = v4;
      }
      else
      {
        Count = (void *)v0;
        v0 = 0;
        free(Count);
      }
    }
  }
  pthread_mutex_unlock(&mtx_pthr_locked);
  return v0;
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;
// 536A64: using guessed type int pthr_last;
// 536A68: using guessed type int pthr_root;

//----- (0041A080) --------------------------------------------------------
int __usercall replace_spin_keys_constprop_10@<eax>(int result@<eax>)
{
  _DWORD *v1; // ebx
  unsigned int Value; // eax
  int v3; // eax
  CHAR OutputString[119]; // [esp+15h] [ebp-77h] BYREF

  if ( result )
  {
    v1 = (_DWORD *)result;
    result = pthread_spin_destroy();
    if ( result == 1 )
    {
      strcpy(OutputString, "Error cleaning up spin_keys for thread ");
      memset(&OutputString[40], 0, 0x43u);
      Value = GetCurrentThreadId();
      __ultoa(Value, &OutputString[39], 10);
      v3 = 39;
      if ( !OutputString[39] )
        goto LABEL_11;
      do
      {
        if ( !OutputString[++v3] )
          break;
      }
      while ( v3 != 106 );
      if ( v3 != 106 )
      {
LABEL_11:
        OutputString[v3] = 10;
        OutputString[v3 + 1] = 0;
      }
      OutputDebugStringA(OutputString);
      abort();
    }
    *v1 = -1;
  }
  return result;
}

//----- (0041A130) --------------------------------------------------------
int _pthread_once_raw_part_5_constprop_11()
{
  _DWORD *v0; // eax
  volatile signed __int32 *v1; // esi
  int v2; // ebx
  int v3; // edi
  FILE *v5; // eax

  v0 = enterOnceObject((int)&_pthread_tls_once);
  v1 = v0 + 1;
  v2 = (int)v0;
  pthread_mutex_lock(v0 + 1);
  v3 = _pthread_tls_once;
  if ( _pthread_tls_once )
  {
    if ( _pthread_tls_once != 1 )
    {
      v5 = ___acrt_iob_func(2u);
      fprintf(v5, " once %p is %d\n", &_pthread_tls_once, v3);
    }
  }
  else
  {
    pthread_tls_init();
    _pthread_tls_once = 1;
  }
  pthread_mutex_unlock(v1);
  if ( v2 )
    leaveOnceObject_part_4(v2);
  return 0;
}
// 536A74: using guessed type int _pthread_tls_once;

//----- (0041A1C0) --------------------------------------------------------
LPVOID __pthread_self_lite()
{
  LPVOID Value; // ebx
  int v2; // esi
  HANDLE CurrentProcess; // ebp
  HANDLE CurrentThread; // edi
  HANDLE v5; // eax
  char v6; // al

  if ( _pthread_tls_once != 1 )
    _pthread_once_raw_part_5_constprop_11();
  Value = TlsGetValue(_pthread_tls);
  if ( Value )
    return Value;
  v2 = pop_pthread_mem();
  if ( !__xl_f || !v2 )
    return Value;
  *(_DWORD *)(v2 + 36) = 1;
  *(_DWORD *)(v2 + 60) = GetCurrentThreadId();
  *(_DWORD *)(v2 + 24) = CreateEventA(0, 1, 0, 0);
  *(_DWORD *)(v2 + 28) = -1;
  replace_spin_keys_constprop_10(v2 + 56);
  *(_DWORD *)(v2 + 100) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  CurrentProcess = GetCurrentProcess();
  CurrentThread = GetCurrentThread();
  v5 = GetCurrentProcess();
  if ( !DuplicateHandle(v5, CurrentThread, CurrentProcess, (LPHANDLE)(v2 + 20), 0, 0, 2u)
    || (*(_DWORD *)(v2 + 108) = GetThreadPriority(*(HANDLE *)(v2 + 20)),
        v6 = *(_BYTE *)(v2 + 32),
        *(_DWORD *)(v2 + 104) = 0,
        *(_BYTE *)(v2 + 32) = v6 & 0xCF | 0x10,
        !TlsSetValue(_pthread_tls, (LPVOID)v2)) )
  {
    abort();
  }
  return (LPVOID)v2;
}
// 536A74: using guessed type int _pthread_tls_once;
// 53B028: using guessed type int (__stdcall *__xl_f)(int, int, int);

//----- (0041A310) --------------------------------------------------------
int __cdecl __pth_gpointer_locked(unsigned int a1)
{
  int pointer; // ebx

  if ( !a1 )
    return 0;
  pthread_mutex_lock(&mtx_pthr_locked);
  pointer = __pthread_get_pointer(a1);
  pthread_mutex_unlock(&mtx_pthr_locked);
  return pointer;
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;

//----- (0041A350) --------------------------------------------------------
int __usercall _pthread_cleanup_dest_part_8@<eax>(unsigned int a1@<eax>)
{
  int result; // eax
  volatile __int32 *v2; // ebx
  _DWORD *v3; // esi
  unsigned int v4; // ebp
  int v5; // edi
  bool v6; // cc
  int v7; // [esp+18h] [ebp-24h]
  int v8; // [esp+1Ch] [ebp-20h]

  result = __pth_gpointer_locked(a1);
  if ( result )
  {
    v2 = (volatile __int32 *)(result + 56);
    v3 = (_DWORD *)result;
    v8 = 256;
    while ( 1 )
    {
      pthread_spin_lock(v2);
      if ( !v3[10] )
        return pthread_spin_unlock(v2);
      v7 = 0;
      v4 = 0;
      do
      {
        while ( !*(_BYTE *)(v3[12] + v4) )
        {
          if ( ++v4 >= v3[10] )
            goto LABEL_10;
        }
        v5 = *(_DWORD *)(v3[11] + 4 * v4);
        pthread_rwlock_rdlock(&_pthread_key_lock);
        v6 = *((_DWORD *)_pthread_key_dest + v4) <= 1u;
        *(_DWORD *)(v3[11] + 4 * v4) = 0;
        *(_BYTE *)(v3[12] + v4) = 0;
        if ( !v6 )
        {
          pthread_spin_unlock(v2);
          (*((void (__cdecl **)(int))_pthread_key_dest + v4))(v5);
          pthread_spin_lock(v2);
          v7 = 1;
        }
        ++v4;
        pthread_rwlock_unlock(&_pthread_key_lock);
      }
      while ( v4 < v3[10] );
LABEL_10:
      pthread_spin_unlock(v2);
      result = v7;
      if ( v7 )
      {
        if ( --v8 )
          continue;
      }
      return result;
    }
  }
  return result;
}
// 50CF28: using guessed type int *_pthread_key_lock;

//----- (0041A440) --------------------------------------------------------
int __stdcall __dyn_tls_pthread(int a1, int a2, int a3)
{
  _DWORD *Value; // eax
  int v5; // ebx
  unsigned int v6; // eax
  int v7; // edx
  void *v8; // eax
  unsigned int v9; // eax
  HANDLE **v10; // edi
  void *v11; // eax

  if ( !a2 )
  {
    if ( !a3 && SetThreadName_VEH_handle )
    {
      RemoveVectoredExceptionHandler(SetThreadName_VEH_handle);
      SetThreadName_VEH_handle = 0;
    }
    return 1;
  }
  if ( a2 == 1 )
  {
    SetThreadName_VEH_handle = (PVOID)_IAT_start__(1, SetThreadName_VEH);
    return 1;
  }
  if ( a2 == 3 && _pthread_tls != -1 )
  {
    Value = TlsGetValue(_pthread_tls);
    v5 = (int)Value;
    if ( Value )
    {
      if ( (Value[8] & 0x30) != 0 )
      {
        v6 = Value[45];
        if ( v6 )
          _pthread_cleanup_dest_part_8(v6);
        if ( *(_DWORD *)(v5 + 20) )
        {
          CloseHandle(*(HANDLE *)(v5 + 20));
          if ( *(_DWORD *)(v5 + 24) )
            CloseHandle(*(HANDLE *)(v5 + 24));
          *(_DWORD *)(v5 + 24) = 0;
          *(_DWORD *)(v5 + 20) = 0;
        }
        pthread_mutex_destroy((HANDLE **)(v5 + 28));
        replace_spin_keys_constprop_10(v5 + 56);
        if ( *(_DWORD *)(v5 + 176) )
          goto LABEL_29;
        goto LABEL_16;
      }
      v7 = Value[26];
      v8 = (void *)Value[6];
      if ( !v7 )
      {
        if ( v8 )
          CloseHandle(v8);
        v9 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)(v5 + 24) = 0;
        *(_DWORD *)(v5 + 104) = 1;
        if ( v9 )
          _pthread_cleanup_dest_part_8(v9);
        v10 = (HANDLE **)(v5 + 28);
        if ( (*(_BYTE *)(v5 + 36) & 4) == 0 )
        {
          pthread_mutex_destroy(v10);
          replace_spin_keys_constprop_10(v5 + 56);
          return 1;
        }
        v11 = *(void **)(v5 + 20);
        *(_DWORD *)v5 = -559038737;
        if ( v11 )
          CloseHandle(v11);
        *(_DWORD *)(v5 + 20) = 0;
        pthread_mutex_destroy(v10);
        replace_spin_keys_constprop_10(v5 + 56);
        if ( *(_DWORD *)(v5 + 176) )
          goto LABEL_29;
LABEL_16:
        push_pthread_mem_part_2(v5);
LABEL_29:
        TlsSetValue(_pthread_tls, 0);
        return 1;
      }
      if ( v8 )
        CloseHandle(v8);
      *(_DWORD *)(v5 + 24) = 0;
      pthread_mutex_destroy((HANDLE **)(v5 + 28));
      replace_spin_keys_constprop_10(v5 + 56);
    }
  }
  return 1;
}
// 53931C: using guessed type int __stdcall _IAT_start__(_DWORD, _DWORD);

//----- (0041A670) --------------------------------------------------------
void __stdcall __noreturn pthread_create_wrapper(volatile signed __int32 *a1)
{
  volatile signed __int32 *v1; // ebx
  unsigned int v2; // esi
  void *v3; // eax
  bool v4; // zf
  int (__cdecl *v5)(_DWORD, int); // eax
  int v6; // ebx
  unsigned int v7; // eax
  int v8; // edx
  int v9; // [esp-18h] [ebp-34h]

  pthread_mutex_lock(&mtx_pthr_locked);
  pthread_mutex_lock(a1 + 7);
  if ( _pthread_tls_once != 1 )
    _pthread_once_raw_part_5_constprop_11();
  TlsSetValue(_pthread_tls, (LPVOID)a1);
  *((_DWORD *)a1 + 15) = GetCurrentThreadId();
  pthread_mutex_unlock(a1 + 7);
  if ( !_setjmp3(a1 + 28, 0) )
    goto LABEL_12;
  pthread_mutex_lock(&mtx_pthr_locked);
  while ( 1 )
  {
    v1 = a1 + 7;
    pthread_mutex_lock(a1 + 7);
    v2 = *((_DWORD *)a1 + 1);
    v3 = (void *)*((_DWORD *)a1 + 6);
    if ( v3 )
      CloseHandle(v3);
    v4 = *((_DWORD *)a1 + 5) == 0;
    *((_DWORD *)a1 + 6) = 0;
    if ( v4 )
    {
      *a1 = -559038737;
      pthread_mutex_unlock(v1);
      pthread_mutex_destroy((HANDLE **)v1);
      if ( a1 && !*((_DWORD *)a1 + 44) )
        push_pthread_mem_part_2((int)a1);
      TlsSetValue(_pthread_tls, 0);
      v9 = v8;
    }
    else
    {
      pthread_mutex_unlock(v1);
      pthread_mutex_destroy((HANDLE **)v1);
      *((_DWORD *)a1 + 7) = -1;
      *((_DWORD *)a1 + 26) = 1;
    }
    while ( !pthread_mutex_unlock(&mtx_pthr_locked) )
      Sleep(0);
    __endthreadex(v2);
LABEL_12:
    pthread_mutex_unlock(&mtx_pthr_locked);
    v5 = (int (__cdecl *)(_DWORD, int))*((_DWORD *)a1 + 2);
    if ( v5 )
      v6 = v5(*((_DWORD *)a1 + 1), v9);
    else
      v6 = 128;
    pthread_mutex_lock(&mtx_pthr_locked);
    *((_DWORD *)a1 + 1) = v6;
    v7 = *((_DWORD *)a1 + 45);
    if ( v7 )
      _pthread_cleanup_dest_part_8(v7);
  }
}
// 41A79F: variable 'v9' is possibly undefined
// 41A811: variable 'v8' is possibly undefined
// 424E70: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;
// 536A74: using guessed type int _pthread_tls_once;

//----- (0041A820) --------------------------------------------------------
int __cdecl thread_print_set(int a1)
{
  int result; // eax

  result = a1;
  print_state = a1;
  return result;
}
// 536A4C: using guessed type int print_state;

//----- (0041A830) --------------------------------------------------------
int __cdecl thread_print(unsigned int a1, const char *a2)
{
  int result; // eax
  const void *v3; // edi
  int v4; // esi
  DWORD CurrentThreadId; // ebx
  const void *v6; // eax
  DWORD v7; // eax

  result = print_state;
  if ( print_state )
  {
    if ( a1 )
    {
      v3 = *(const void **)(__pth_gpointer_locked(a1) + 20);
      v4 = *(_DWORD *)__pth_gpointer_locked(a1);
      CurrentThreadId = GetCurrentThreadId();
      v6 = (const void *)__pth_gpointer_locked(a1);
      return printf("T%p %d V=%0X H=%p %s\n", v6, CurrentThreadId, v4, v3, a2);
    }
    else
    {
      v7 = GetCurrentThreadId();
      return printf("T%p %d %s\n", 0, v7, a2);
    }
  }
  return result;
}
// 536A4C: using guessed type int print_state;

//----- (0041A8F0) --------------------------------------------------------
int pthread_timechange_handler_np()
{
  return 0;
}

//----- (0041A900) --------------------------------------------------------
int pthread_num_processors_np()
{
  HANDLE hProcess; // eax
  BOOL v1; // eax
  int v2; // ecx
  ULONG_PTR v3; // edx
  ULONG_PTR ProcessAffinityMask; // [esp+18h] [ebp-14h] BYREF
  ULONG_PTR SystemAffinityMask[4]; // [esp+1Ch] [ebp-10h] BYREF

  hProcess = GetCurrentProcess();
  v1 = GetProcessAffinityMask(hProcess, &ProcessAffinityMask, SystemAffinityMask);
  v2 = 1;
  if ( v1 )
  {
    v3 = ProcessAffinityMask;
    if ( ProcessAffinityMask )
    {
      v2 = 0;
      do
      {
        v2 += v3 & 1;
        v3 >>= 1;
      }
      while ( v3 );
      if ( !v2 )
        return 1;
    }
  }
  return v2;
}
// 41A900: using guessed type ULONG_PTR SystemAffinityMask[4];

//----- (0041A960) --------------------------------------------------------
int __cdecl pthread_set_num_processors_np(int a1)
{
  int v1; // esi
  int v2; // edi
  HANDLE hProcess; // eax
  ULONG_PTR v4; // eax
  DWORD_PTR v5; // ebx
  HANDLE CurrentProcess; // eax
  ULONG_PTR ProcessAffinityMask; // [esp+18h] [ebp-24h] BYREF
  ULONG_PTR SystemAffinityMask[8]; // [esp+1Ch] [ebp-20h] BYREF

  v1 = a1;
  if ( !a1 )
    v1 = 1;
  v2 = 0;
  hProcess = GetCurrentProcess();
  if ( GetProcessAffinityMask(hProcess, &ProcessAffinityMask, SystemAffinityMask) )
  {
    v4 = ProcessAffinityMask;
    v5 = 0;
    if ( ProcessAffinityMask )
    {
      do
      {
        v5 *= 2;
        if ( v1 > v2 && (v4 & 1) != 0 )
        {
          v5 |= 1u;
          ++v2;
        }
        v4 >>= 1;
      }
      while ( v4 );
      ProcessAffinityMask = 0;
    }
    CurrentProcess = GetCurrentProcess();
    SetProcessAffinityMask(CurrentProcess, v5);
  }
  return v2;
}
// 41A960: using guessed type ULONG_PTR SystemAffinityMask[8];

//----- (0041A9F0) --------------------------------------------------------
int __cdecl pthread_once(int *a1, void (*a2)(void))
{
  _DWORD *v2; // eax
  volatile signed __int32 *v3; // ebp
  int v4; // edi
  int v5; // esi
  FILE *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  unsigned int Ix; // [esp+0h] [ebp-3Ch] BYREF
  int v12[2]; // [esp+14h] [ebp-28h] BYREF
  int v13; // [esp+1Ch] [ebp-20h]

  if ( !a2 )
    return 22;
  if ( *a1 != 1 )
  {
    v2 = enterOnceObject((int)a1);
    v3 = v2 + 1;
    v4 = (int)v2;
    pthread_mutex_lock(v2 + 1);
    v5 = *a1;
    if ( *a1 )
    {
      if ( v5 != 1 )
      {
        v7 = ___acrt_iob_func(2u);
        fprintf(v7, " once %p is %d\n", a1, v5);
      }
    }
    else
    {
      v12[0] = (int)_pthread_once_cleanup;
      v12[1] = v4;
      v8 = __pthread_self_lite();
      if ( !v8 )
        BUG();
      v13 = v8[3];
      _InterlockedOr((volatile signed __int32 *)&Ix, 0);
      v9 = __pthread_self_lite();
      if ( !v9 )
      {
        MEMORY[0] = v12;
        BUG();
      }
      v9[3] = v12;
      _InterlockedOr((volatile signed __int32 *)&Ix, 0);
      a2();
      v10 = __pthread_self_lite();
      if ( !v10 )
      {
        MEMORY[0] = v13;
        BUG();
      }
      v10[3] = v13;
      *a1 = 1;
    }
    pthread_mutex_unlock(v3);
    if ( v4 )
      leaveOnceObject_part_4(v4);
  }
  return 0;
}

//----- (0041AB10) --------------------------------------------------------
int __cdecl pthread_key_create(int *a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int *v4; // edi
  int *v5; // eax
  int v6; // edx
  int *v7; // eax
  int v8; // edi
  char *v9; // eax
  int v10; // eax
  int v11; // eax
  int *v12; // [esp+18h] [ebp-24h]
  void *v13; // [esp+1Ch] [ebp-20h]

  result = 22;
  if ( !a1 )
    return result;
  pthread_rwlock_wrlock(&_pthread_key_lock);
  v3 = _pthread_key_max;
  if ( _pthread_key_sch < (unsigned int)_pthread_key_max )
  {
    v4 = (int *)((char *)_pthread_key_dest + 4 * _pthread_key_sch);
    v5 = v4 + 1;
    v6 = _pthread_key_sch;
    if ( !*v4 )
      goto LABEL_23;
    while ( ++v6 != _pthread_key_max )
    {
      v4 = v5++;
      if ( !*(v5 - 1) )
        goto LABEL_23;
    }
  }
  if ( _pthread_key_sch )
  {
    v4 = (int *)_pthread_key_dest;
    if ( !*(_DWORD *)_pthread_key_dest )
    {
      v6 = 0;
LABEL_23:
      *a1 = v6;
      v11 = 1;
      if ( a2 )
        v11 = a2;
      *v4 = v11;
      pthread_rwlock_unlock(&_pthread_key_lock);
      return 0;
    }
    v7 = (int *)((char *)_pthread_key_dest + 4);
    v6 = 0;
    while ( _pthread_key_sch != ++v6 )
    {
      v4 = v7++;
      if ( !*(v7 - 1) )
        goto LABEL_23;
    }
  }
  if ( _pthread_key_max == 0x100000 )
    goto LABEL_26;
  v8 = 2 * _pthread_key_max;
  if ( !(2 * _pthread_key_max) )
    v8 = _pthread_key_max + 1;
  if ( v8 > 0x100000 )
    v8 = 0x100000;
  v9 = (char *)realloc(_pthread_key_dest, 4 * v8);
  if ( !v9 )
  {
LABEL_26:
    pthread_rwlock_unlock(&_pthread_key_lock);
    return 12;
  }
  else
  {
    v13 = v9;
    v12 = (int *)&v9[4 * v3];
    memset(v12, 0, 4 * (v8 - v3));
    _pthread_key_sch = v3 + 1;
    _pthread_key_max = v8;
    v10 = 1;
    if ( a2 )
      v10 = a2;
    _pthread_key_dest = v13;
    *a1 = v3;
    *v12 = v10;
    pthread_rwlock_unlock(&_pthread_key_lock);
    return 0;
  }
}
// 50CF28: using guessed type int *_pthread_key_lock;
// 536A6C: using guessed type int _pthread_key_sch;
// 536A70: using guessed type int _pthread_key_max;

//----- (0041ACB0) --------------------------------------------------------
int __cdecl pthread_key_delete(unsigned int a1)
{
  int result; // eax
  bool v2; // cc
  char *v3; // eax
  char *v4; // esi
  int v5; // edx
  int v6; // ecx

  result = 22;
  if ( _pthread_key_max > a1 && _pthread_key_dest )
  {
    pthread_rwlock_wrlock(&_pthread_key_lock);
    v2 = _pthread_key_sch <= a1;
    *((_DWORD *)_pthread_key_dest + a1) = 0;
    if ( !v2 )
      _pthread_key_sch = a1;
    pthread_mutex_lock(&mtx_pthr_locked);
    if ( idListCnt )
    {
      v3 = (char *)idList;
      v4 = (char *)idList + 8 * idListCnt;
      do
      {
        v5 = *(_DWORD *)v3;
        if ( *(_DWORD *)v3 )
        {
          v6 = *(_DWORD *)(v5 + 44);
          if ( v6 )
          {
            if ( a1 < *(_DWORD *)(v5 + 40) )
            {
              *(_DWORD *)(v6 + 4 * a1) = 0;
              *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v3 + 48) + a1) = 0;
            }
          }
        }
        v3 += 8;
      }
      while ( v4 != v3 );
    }
    pthread_mutex_unlock(&mtx_pthr_locked);
    pthread_rwlock_unlock(&_pthread_key_lock);
    return 0;
  }
  return result;
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;
// 50CF28: using guessed type int *_pthread_key_lock;
// 536A5C: using guessed type int idListCnt;
// 536A6C: using guessed type int _pthread_key_sch;
// 536A70: using guessed type int _pthread_key_max;

//----- (0041AD70) --------------------------------------------------------
int __cdecl pthread_getspecific(unsigned int a1)
{
  DWORD dwErrCode; // ebp
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _DWORD *v4; // ebx
  int v5; // ebx

  dwErrCode = GetLastError();
  v2 = __pthread_self_lite();
  v3 = v2 + 14;
  v4 = v2;
  pthread_spin_lock(v2 + 14);
  if ( v4[10] > a1 && *(_BYTE *)(v4[12] + a1) )
    v5 = *(_DWORD *)(v4[11] + 4 * a1);
  else
    v5 = 0;
  pthread_spin_unlock(v3);
  SetLastError(dwErrCode);
  return v5;
}

//----- (0041ADE0) --------------------------------------------------------
int __cdecl pthread_setspecific(unsigned int a1, int a2)
{
  char *v2; // eax
  _DWORD *v3; // edi
  char *v4; // ebx
  char *v5; // edx
  unsigned int v7; // ebp
  char *v8; // eax
  DWORD dwErrCode; // [esp+14h] [ebp-28h]
  char *v10; // [esp+18h] [ebp-24h]
  char *v11; // [esp+1Ch] [ebp-20h]

  dwErrCode = GetLastError();
  v2 = (char *)__pthread_self_lite();
  v3 = v2 + 56;
  v4 = v2;
  pthread_spin_lock((volatile __int32 *)v2 + 14);
  if ( *((_DWORD *)v4 + 10) > a1 )
  {
    v5 = (char *)*((_DWORD *)v4 + 11);
LABEL_3:
    *(_DWORD *)&v5[4 * a1] = a2;
    *(_BYTE *)(*((_DWORD *)v4 + 12) + a1) = 1;
    pthread_spin_unlock(v3);
    SetLastError(dwErrCode);
    return 0;
  }
  v7 = a1 + 1;
  v8 = (char *)realloc(*((void **)v4 + 11), 4 * (a1 + 1));
  if ( v8 )
  {
    v11 = v8;
    v10 = (char *)realloc(*((void **)v4 + 12), a1 + 1);
    if ( v10 )
    {
      memset(&v11[4 * *((_DWORD *)v4 + 10)], 0, 4 * (v7 - *((_DWORD *)v4 + 10)));
      memset(&v10[*((_DWORD *)v4 + 10)], 0, v7 - *((_DWORD *)v4 + 10));
      v5 = v11;
      *((_DWORD *)v4 + 10) = v7;
      *((_DWORD *)v4 + 11) = v11;
      *((_DWORD *)v4 + 12) = v10;
      goto LABEL_3;
    }
  }
  pthread_spin_unlock(v3);
  return 12;
}

//----- (0041AF00) --------------------------------------------------------
BOOL __cdecl pthread_equal(int a1, int a2)
{
  return a1 == a2;
}

//----- (0041AF10) --------------------------------------------------------
int __cdecl _pthread_cleanup_dest(unsigned int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return _pthread_cleanup_dest_part_8(a1);
  return result;
}

//----- (0041AF30) --------------------------------------------------------
int pthread_self()
{
  _DWORD *v0; // eax
  int v1; // edx

  v0 = __pthread_self_lite();
  v1 = 0;
  if ( v0 )
    return v0[45];
  return v1;
}

//----- (0041AF50) --------------------------------------------------------
int pthread_getevent()
{
  _DWORD *v0; // eax

  v0 = __pthread_self_lite();
  if ( v0 )
    return v0[6];
  else
    return 0;
}

//----- (0041AF70) --------------------------------------------------------
int __cdecl pthread_gethandle(unsigned int a1)
{
  int v1; // eax

  v1 = __pth_gpointer_locked(a1);
  if ( v1 )
    return *(_DWORD *)(v1 + 20);
  else
    return 0;
}

//----- (0041AFA0) --------------------------------------------------------
char *pthread_getclean()
{
  char *v0; // eax
  char *v1; // edx
  bool v2; // zf
  char *result; // eax

  v0 = (char *)__pthread_self_lite();
  v1 = v0 + 12;
  v2 = v0 == 0;
  result = 0;
  if ( !v2 )
    return v1;
  return result;
}

//----- (0041AFC0) --------------------------------------------------------
int __cdecl pthread_get_concurrency(_DWORD *a1)
{
  *a1 = _pthread_concur;
  return 0;
}
// 536A78: using guessed type int _pthread_concur;

//----- (0041AFD0) --------------------------------------------------------
int __cdecl pthread_set_concurrency(int a1)
{
  _pthread_concur = a1;
  return 0;
}
// 536A78: using guessed type int _pthread_concur;

//----- (0041AFE0) --------------------------------------------------------
void __cdecl __noreturn pthread_exit(unsigned int ReturnCode)
{
  unsigned int v1; // esi
  _DWORD *v2; // ebx
  unsigned int v3; // eax
  _DWORD *Value; // eax
  void *v5; // eax
  bool v6; // zf
  void *v7; // eax

  v1 = ReturnCode;
  v2 = __pthread_self_lite();
  v2[1] = ReturnCode;
  v3 = v2[45];
  if ( v3 )
    goto LABEL_10;
  while ( 1 )
  {
    if ( (v2[8] & 0x30) == 0 )
      longjmp(v2 + 28, 1);
    Value = TlsGetValue(_pthread_tls);
    v2 = Value;
    if ( !Value )
      goto LABEL_9;
    v5 = (void *)Value[6];
    if ( !v2[5] )
      break;
    v1 = v2[1];
    v2[26] = 1;
    if ( v5 )
      CloseHandle(v5);
    v6 = (v2[9] & 4) == 0;
    v2[6] = 0;
    if ( v6 )
      goto LABEL_9;
    v7 = (void *)v2[5];
    *v2 = -559038737;
    CloseHandle(v7);
    v6 = v2[44] == 0;
    v2[5] = 0;
    if ( v6 )
      goto LABEL_16;
LABEL_12:
    TlsSetValue(_pthread_tls, 0);
LABEL_9:
    __endthreadex(v1);
LABEL_10:
    _pthread_cleanup_dest_part_8(v3);
  }
  *v2 = -559038737;
  if ( v5 )
    CloseHandle(v5);
  v6 = v2[44] == 0;
  v2[6] = 0;
  v1 = v2[1];
  if ( !v6 )
    goto LABEL_12;
LABEL_16:
  push_pthread_mem_part_2((int)v2);
  goto LABEL_12;
}
// 41B062: variable 'v3' is possibly undefined

//----- (0041B0E0) --------------------------------------------------------
int __pthread_shallcancel()
{
  int result; // eax
  int *v1; // eax
  int *v2; // edx

  if ( !_pthread_cancelling )
    return 0;
  v1 = (int *)__pthread_self_lite();
  v2 = v1;
  if ( !v1 )
    return 0;
  if ( v1[4] > 0 )
    return 0;
  if ( (v1[8] & 3) == 0 )
    return 0;
  result = 1;
  if ( (v2[9] & 1) == 0 )
    return 0;
  return result;
}
// 536A7C: using guessed type int _pthread_cancelling;

//----- (0041B130) --------------------------------------------------------
volatile signed __int32 *__cdecl _pthread_setnobreak(int a1)
{
  volatile signed __int32 *result; // eax

  result = (volatile signed __int32 *)__pthread_self_lite();
  if ( result )
  {
    result += 4;
    if ( a1 <= 0 )
      _InterlockedSub(result, 1u);
    else
      _InterlockedAdd(result, 1u);
  }
  return result;
}

//----- (0041B160) --------------------------------------------------------
void __noreturn _pthread_invoke_cancel()
{
  _BYTE *v0; // ebx
  int i; // ebx

  v0 = __pthread_self_lite();
  v0[32] = v0[32] & 0xF3 | 4;
  _pthread_setnobreak(1);
  _InterlockedSub(&_pthread_cancelling, 1u);
  for ( i = *((_DWORD *)v0 + 3); i; i = *(_DWORD *)(i + 8) )
    (*(void (__cdecl **)(_DWORD))i)(*(_DWORD *)(i + 4));
  _pthread_setnobreak(0);
  pthread_exit(0xDEADBEEF);
}
// 536A7C: using guessed type int _pthread_cancelling;

//----- (0041B1C0) --------------------------------------------------------
DWORD __usercall test_cancel_locked@<eax>(unsigned int a1@<eax>)
{
  DWORD result; // eax
  DWORD v2; // ebx

  result = __pth_gpointer_locked(a1);
  if ( result )
  {
    v2 = result;
    if ( (*(_BYTE *)(result + 32) & 0xC) == 0 )
    {
      result = *(_DWORD *)(result + 104);
      if ( !result )
      {
        result = *(_DWORD *)(v2 + 36) & 3;
        if ( result == 3 )
        {
          result = WaitForSingleObject(*(HANDLE *)(v2 + 24), 0);
          if ( !result )
          {
            pthread_mutex_unlock((volatile signed __int32 *)(v2 + 28));
            _pthread_invoke_cancel();
          }
        }
      }
    }
  }
  return result;
}

//----- (0041B220) --------------------------------------------------------
_BYTE *pthread_testcancel()
{
  _BYTE *result; // eax
  _BYTE *v1; // ebx
  char v2; // al
  int v3; // edx

  result = __pthread_self_lite();
  if ( result )
  {
    v1 = result;
    if ( (result[32] & 0xC) == 0 )
    {
      result = (_BYTE *)_pthread_cancelling;
      if ( _pthread_cancelling )
      {
        pthread_mutex_lock((volatile signed __int32 *)v1 + 7);
        v2 = v1[32];
        if ( (v2 & 3) != 0 )
        {
          v3 = *((_DWORD *)v1 + 9);
          if ( (v3 & 1) != 0 && *((int *)v1 + 4) <= 0 )
          {
            *((_DWORD *)v1 + 9) = v3 & 0xFFFFFFFE;
            v1[32] = v2 & 0xF3 | 4;
            if ( *((_DWORD *)v1 + 6) )
              ResetEvent(*((HANDLE *)v1 + 6));
            pthread_mutex_unlock((volatile signed __int32 *)v1 + 7);
            _pthread_invoke_cancel();
          }
        }
        return (_BYTE *)pthread_mutex_unlock((volatile signed __int32 *)v1 + 7);
      }
    }
  }
  return result;
}
// 536A7C: using guessed type int _pthread_cancelling;

//----- (0041B2B0) --------------------------------------------------------
int __cdecl pthread_delay_np(int *a1)
{
  unsigned __int64 v1; // rax
  _DWORD *v2; // esi
  DWORD dwMilliseconds; // ebx
  void *hHandle; // eax
  _DWORD *v6; // esi

  if ( a1 )
  {
    v1 = _pthread_time_in_ms_from_timespec(a1);
    if ( v1 >= 0xFFFFFFFF )
    {
      v2 = __pthread_self_lite();
      dwMilliseconds = -1;
      pthread_testcancel();
      hHandle = (void *)v2[6];
      if ( !hHandle )
      {
LABEL_11:
        Sleep(dwMilliseconds);
        goto LABEL_5;
      }
LABEL_4:
      WaitForSingleObject(hHandle, dwMilliseconds);
LABEL_5:
      pthread_testcancel();
      return 0;
    }
    dwMilliseconds = v1;
    v6 = __pthread_self_lite();
    if ( dwMilliseconds )
    {
      pthread_testcancel();
      hHandle = (void *)v6[6];
      if ( !hHandle )
        goto LABEL_11;
      goto LABEL_4;
    }
  }
  else
  {
    __pthread_self_lite();
  }
  pthread_testcancel();
  Sleep(0);
  pthread_testcancel();
  return 0;
}

//----- (0041B360) --------------------------------------------------------
int __cdecl pthread_delay_np_ms(DWORD dwMilliseconds)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  void *hHandle; // eax

  v1 = __pthread_self_lite();
  if ( dwMilliseconds )
  {
    v2 = v1;
    pthread_testcancel();
    hHandle = (void *)v2[6];
    if ( hHandle )
      WaitForSingleObject(hHandle, dwMilliseconds);
    else
      Sleep(dwMilliseconds);
    pthread_testcancel();
    return 0;
  }
  else
  {
    pthread_testcancel();
    Sleep(0);
    pthread_testcancel();
    return 0;
  }
}

//----- (0041B3D0) --------------------------------------------------------
int __cdecl pthread_cancel(unsigned int a1)
{
  int v1; // eax
  int v2; // ebx
  char *hObject; // eax
  _DWORD *v4; // eax
  int v5; // edx
  char v6; // al
  void *v8; // eax
  void *v9; // eax
  char v10; // al
  CONTEXT dwFlags; // [esp+14h] [ebp-2E8h] BYREF

  v1 = __pth_gpointer_locked(a1);
  if ( !v1 )
    return 3;
  v2 = v1;
  hObject = *(char **)(v1 + 20);
  if ( (unsigned int)(hObject - 1) > 0xFFFFFFFD || !GetHandleInformation(hObject, &dwFlags.ContextFlags) )
    return 3;
  pthread_mutex_lock((volatile signed __int32 *)(v2 + 28));
  v4 = __pthread_self_lite();
  v5 = 0;
  if ( v4 )
    v5 = v4[45];
  v6 = *(_BYTE *)(v2 + 32);
  if ( a1 == v5 )
  {
    if ( (v6 & 3) == 0 )
    {
      *(_BYTE *)(v2 + 32) = v6 & 0xFC | 1;
      _InterlockedAdd(&_pthread_cancelling, 1u);
      if ( *(_DWORD *)(v2 + 24) )
        SetEvent(*(HANDLE *)(v2 + 24));
      if ( (*(_DWORD *)(v2 + 36) & 3) == 3 )
      {
        *(_DWORD *)(v2 + 36) &= ~1u;
        *(_BYTE *)(v2 + 32) = *(_BYTE *)(v2 + 32) & 0xF3 | 4;
        pthread_mutex_unlock((volatile signed __int32 *)(v2 + 28));
        _pthread_invoke_cancel();
      }
      goto LABEL_11;
    }
    goto LABEL_14;
  }
  if ( (*(_DWORD *)(v2 + 36) & 3) != 3 )
  {
    if ( (v6 & 3) == 0 )
    {
      *(_BYTE *)(v2 + 32) = v6 & 0xFC | 1;
      _InterlockedAdd(&_pthread_cancelling, 1u);
      if ( *(_DWORD *)(v2 + 24) )
        SetEvent(*(HANDLE *)(v2 + 24));
LABEL_11:
      pthread_mutex_unlock((volatile signed __int32 *)(v2 + 28));
      return 0;
    }
    goto LABEL_14;
  }
  if ( (v6 & 0xC) != 0 )
  {
LABEL_14:
    pthread_mutex_unlock((volatile signed __int32 *)(v2 + 28));
    if ( (*(_BYTE *)(v2 + 32) & 0xC) == 0 )
      return 0;
    return 3;
  }
  if ( (v6 & 0xF) == 0 )
  {
    v8 = *(void **)(v2 + 20);
    dwFlags.ContextFlags = 65537;
    SuspendThread(v8);
    if ( WaitForSingleObject(*(HANDLE *)(v2 + 20), 0) == 258 )
    {
      GetThreadContext(*(HANDLE *)(v2 + 20), &dwFlags);
      v9 = *(void **)(v2 + 20);
      dwFlags.Eip = (DWORD)_pthread_invoke_cancel;
      SetThreadContext(v9, &dwFlags);
      v10 = *(_BYTE *)(v2 + 32);
      *(_DWORD *)(v2 + 36) &= ~1u;
      *(_BYTE *)(v2 + 32) = v10 & 0xF0 | 5;
      _InterlockedAdd(&_pthread_cancelling, 1u);
      if ( *(_DWORD *)(v2 + 24) )
        SetEvent(*(HANDLE *)(v2 + 24));
      pthread_mutex_unlock((volatile signed __int32 *)(v2 + 28));
      ResumeThread(*(HANDLE *)(v2 + 20));
    }
    goto LABEL_11;
  }
  return 3;
}
// 536A7C: using guessed type int _pthread_cancelling;

//----- (0041B5E0) --------------------------------------------------------
int __cdecl pthread_kill(unsigned int a1, int a2)
{
  int pointer; // eax

  pthread_mutex_lock(&mtx_pthr_locked);
  pointer = __pthread_get_pointer(a1);
  if ( !pointer
    || *(_DWORD *)(pointer + 180) != a1
    || (*(_BYTE *)(pointer + 32) & 0xC) != 0
    || *(_DWORD *)(pointer + 104)
    || (unsigned int)(*(_DWORD *)(pointer + 20) - 1) > 0xFFFFFFFD )
  {
    pthread_mutex_unlock(&mtx_pthr_locked);
    return 3;
  }
  else
  {
    pthread_mutex_unlock(&mtx_pthr_locked);
    if ( a2 )
    {
      if ( (unsigned int)(a2 - 2) > 0x15 )
        return 22;
      else
        return pthread_cancel(a1);
    }
    else
    {
      return 0;
    }
  }
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;

//----- (0041B680) --------------------------------------------------------
int __cdecl _pthread_get_state(_DWORD *a1, int a2)
{
  return *a1 & a2;
}

//----- (0041B690) --------------------------------------------------------
int __cdecl _pthread_set_state(int *a1, int a2, int a3)
{
  int result; // eax

  result = 22;
  if ( (a3 & ~a2) == 0 )
  {
    result = 0;
    *a1 = a3 | *a1 & ~a2;
  }
  return result;
}

//----- (0041B6C0) --------------------------------------------------------
int __cdecl pthread_attr_init(_DWORD *a1)
{
  a1[3] = 0;
  *a1 = 1;
  a1[1] = 0;
  a1[2] = 0;
  return 0;
}

//----- (0041B6F0) --------------------------------------------------------
int __cdecl pthread_attr_destroy(_DWORD *a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  return 0;
}

//----- (0041B720) --------------------------------------------------------
int __cdecl pthread_attr_setdetachstate(unsigned int *a1, int a2)
{
  int result; // eax

  result = 22;
  if ( (a2 & 0xFFFFFFFB) == 0 )
  {
    *a1 = a2 | *a1 & 0xFFFFFFFB;
    return 0;
  }
  return result;
}

//----- (0041B750) --------------------------------------------------------
int __cdecl pthread_attr_getdetachstate(_DWORD *a1, int *a2)
{
  *a2 = *a1 & 4;
  return 0;
}

//----- (0041B770) --------------------------------------------------------
unsigned int __cdecl pthread_attr_setinheritsched(unsigned int *a1, int a2)
{
  unsigned int result; // eax

  if ( !a1 )
    return 22;
  result = a2 & 0xFFFFFFF7;
  if ( (a2 & 0xFFFFFFF7) != 0 )
    return 22;
  *a1 = a2 | *a1 & 0xFFFFFFF7;
  return result;
}

//----- (0041B7A0) --------------------------------------------------------
int __cdecl pthread_attr_getinheritsched(_DWORD *a1, int *a2)
{
  *a2 = *a1 & 8;
  return 0;
}

//----- (0041B7C0) --------------------------------------------------------
int __cdecl pthread_attr_setscope(unsigned int *a1, int a2)
{
  int result; // eax

  result = 22;
  if ( (a2 & 0xFFFFFFEF) == 0 )
  {
    *a1 = a2 | *a1 & 0xFFFFFFEF;
    return 0;
  }
  return result;
}

//----- (0041B7F0) --------------------------------------------------------
int __cdecl pthread_attr_getscope(_DWORD *a1, int *a2)
{
  *a2 = *a1 & 0x10;
  return 0;
}

//----- (0041B810) --------------------------------------------------------
int __cdecl pthread_attr_getstackaddr(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 4);
  return 0;
}

//----- (0041B820) --------------------------------------------------------
int __cdecl pthread_attr_setstackaddr(int a1, int a2)
{
  *(_DWORD *)(a1 + 4) = a2;
  return 0;
}

//----- (0041B830) --------------------------------------------------------
int __cdecl pthread_attr_getstacksize(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 8);
  return 0;
}

//----- (0041B840) --------------------------------------------------------
int __cdecl pthread_attr_setstacksize(int a1, int a2)
{
  *(_DWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (0041B850) --------------------------------------------------------
int __cdecl pthread_setcancelstate(int a1, int *a2)
{
  LPVOID v2; // eax
  LPVOID v3; // ebx
  int result; // eax

  v2 = __pthread_self_lite();
  if ( !v2 )
    return 22;
  v3 = v2;
  result = 22;
  if ( (a1 & 0xFFFFFFFE) == 0 )
  {
    pthread_mutex_lock((volatile signed __int32 *)v3 + 7);
    if ( a2 )
      *a2 = *((_DWORD *)v3 + 9) & 1;
    *((_DWORD *)v3 + 9) = a1 | *((_DWORD *)v3 + 9) & 0xFFFFFFFE;
    test_cancel_locked(*((_DWORD *)v3 + 45));
    pthread_mutex_unlock((volatile signed __int32 *)v3 + 7);
    return 0;
  }
  return result;
}

//----- (0041B8D0) --------------------------------------------------------
int __cdecl pthread_setcanceltype(int a1, int *a2)
{
  LPVOID v2; // eax
  LPVOID v3; // ebx
  int result; // eax

  v2 = __pthread_self_lite();
  if ( !v2 )
    return 22;
  v3 = v2;
  result = 22;
  if ( (a1 & 0xFFFFFFFD) == 0 )
  {
    pthread_mutex_lock((volatile signed __int32 *)v3 + 7);
    if ( a2 )
      *a2 = *((_DWORD *)v3 + 9) & 2;
    *((_DWORD *)v3 + 9) = a1 | *((_DWORD *)v3 + 9) & 0xFFFFFFFD;
    test_cancel_locked(*((_DWORD *)v3 + 45));
    pthread_mutex_unlock((volatile signed __int32 *)v3 + 7);
    return 0;
  }
  return result;
}

//----- (0041B950) --------------------------------------------------------
int __cdecl pthread_create(_DWORD *a1, _DWORD *a2, HANDLE *a3, HANDLE *a4)
{
  HANDLE **v4; // eax
  HANDLE **v5; // edi
  int v6; // ebx
  HANDLE *EventA; // eax
  HANDLE *v8; // esi
  unsigned int v9; // esi
  bool v10; // zf
  char *v11; // esi
  int v13; // ecx
  int v14; // eax

  v4 = (HANDLE **)pop_pthread_mem();
  if ( !v4 )
    return 11;
  v5 = v4;
  if ( a1 )
    *a1 = v4[45];
  v6 = 0;
  v4[26] = 0;
  v4[9] = (HANDLE *)1;
  v4[5] = (HANDLE *)-1;
  v4[1] = a4;
  v4[2] = a3;
  while ( 1 )
  {
    EventA = (HANDLE *)CreateEventA(0, 1, 0, 0);
    v5[6] = EventA;
    if ( EventA )
      break;
    if ( v6 )
    {
      Sleep(0x14u);
      if ( v6 == 4 )
        break;
    }
    else
    {
      Sleep(0);
    }
    ++v6;
  }
  v5[7] = (HANDLE *)-1;
  replace_spin_keys_constprop_10((int)(v5 + 14));
  v8 = v5[6];
  *v5 = (HANDLE *)-1162743795;
  v5[27] = 0;
  v5[25] = 0;
  if ( !v8 )
  {
LABEL_18:
    if ( a1 )
      *a1 = 0;
    if ( !v5[44] )
      push_pthread_mem_part_2((int)v5);
    return 11;
  }
  v9 = 0;
  if ( a2 )
  {
    v9 = a2[2];
    v10 = (*a2 & 8) == 0;
    v5[9] = (HANDLE *)*a2;
    if ( v10 )
      v5[27] = (HANDLE *)a2[3];
    else
      v5[27] = (HANDLE *)*((_DWORD *)__pthread_self_lite() + 27);
  }
  v11 = (char *)__beginthreadex(0, v9, (_beginthreadex_proc_type)pthread_create_wrapper, v5, 4u, 0);
  if ( (unsigned int)(v11 - 1) > 0xFFFFFFFD )
  {
    if ( v5[6] )
      CloseHandle(v5[6]);
    pthread_mutex_destroy(v5 + 7);
    replace_spin_keys_constprop_10((int)(v5 + 14));
    v5[6] = 0;
    v5[5] = 0;
    goto LABEL_18;
  }
  v13 = (int)v5[27];
  v14 = -15;
  if ( v13 >= -14 )
  {
    v14 = -2;
    if ( v13 >= -1 )
    {
      v14 = 15;
      if ( v13 <= 14 )
      {
        v14 = 2;
        if ( v13 <= 2 )
          v14 = (int)v5[27];
      }
    }
  }
  SetThreadPriority(v11, v14);
  ResetEvent(v5[6]);
  if ( ((_BYTE)v5[9] & 4) != 0 )
  {
    v5[5] = 0;
    ResumeThread(v11);
    CloseHandle(v11);
  }
  else
  {
    v5[5] = (HANDLE *)v11;
    ResumeThread(v11);
  }
  Sleep(0);
  return 0;
}

//----- (0041BBC0) --------------------------------------------------------
int __cdecl pthread_join(unsigned int a1, _DWORD *a2)
{
  int v2; // eax
  int v3; // ebx
  void *hObject; // eax
  int v5; // edi
  _DWORD *v6; // eax
  int v7; // edx
  char *v8; // eax
  DWORD dwFlags[4]; // [esp+1Ch] [ebp-10h] BYREF

  v2 = __pth_gpointer_locked(a1);
  if ( !v2 )
    return 3;
  v3 = v2;
  hObject = *(void **)(v2 + 20);
  if ( !hObject || !GetHandleInformation(hObject, dwFlags) )
    return 3;
  v5 = 22;
  if ( (*(_BYTE *)(v3 + 36) & 4) == 0 )
  {
    v6 = __pthread_self_lite();
    v7 = 0;
    if ( v6 )
      v7 = v6[45];
    if ( a1 == v7 )
    {
      return 36;
    }
    else
    {
      v8 = *(char **)(v3 + 20);
      if ( !*(_DWORD *)(v3 + 104) || (unsigned int)(v8 - 1) <= 0xFFFFFFFD )
      {
        WaitForSingleObject(v8, 0xFFFFFFFF);
        v8 = *(char **)(v3 + 20);
      }
      CloseHandle(v8);
      if ( *(_DWORD *)(v3 + 24) )
        CloseHandle(*(HANDLE *)(v3 + 24));
      *(_DWORD *)(v3 + 24) = 0;
      if ( a2 )
        *a2 = *(_DWORD *)(v3 + 4);
      v5 = 0;
      pthread_mutex_destroy((HANDLE **)(v3 + 28));
      replace_spin_keys_constprop_10(v3 + 56);
      if ( !*(_DWORD *)(v3 + 176) )
        push_pthread_mem_part_2(v3);
    }
  }
  return v5;
}
// 41BBC0: using guessed type DWORD dwFlags[4];

//----- (0041BCD0) --------------------------------------------------------
int __cdecl _pthread_tryjoin(unsigned int a1, _DWORD *a2)
{
  int pointer; // eax
  int v3; // ebx
  void *hObject; // eax
  _DWORD *v5; // eax
  int v6; // edx
  void *v7; // eax
  DWORD dwFlags[4]; // [esp+1Ch] [ebp-10h] BYREF

  pthread_mutex_lock(&mtx_pthr_locked);
  pointer = __pthread_get_pointer(a1);
  if ( !pointer || (v3 = pointer, (hObject = *(void **)(pointer + 20)) == 0) || !GetHandleInformation(hObject, dwFlags) )
  {
    pthread_mutex_unlock(&mtx_pthr_locked);
    return 3;
  }
  if ( (*(_BYTE *)(v3 + 36) & 4) != 0 )
  {
    pthread_mutex_unlock(&mtx_pthr_locked);
    return 22;
  }
  v5 = __pthread_self_lite();
  v6 = 0;
  if ( v5 )
    v6 = v5[45];
  if ( a1 == v6 )
  {
    pthread_mutex_unlock(&mtx_pthr_locked);
    return 36;
  }
  v7 = *(void **)(v3 + 20);
  if ( !*(_DWORD *)(v3 + 104) )
  {
    if ( WaitForSingleObject(v7, 0) && !*(_DWORD *)(v3 + 104) )
    {
      pthread_mutex_unlock(&mtx_pthr_locked);
      return 16;
    }
    v7 = *(void **)(v3 + 20);
  }
  CloseHandle(v7);
  if ( *(_DWORD *)(v3 + 24) )
    CloseHandle(*(HANDLE *)(v3 + 24));
  *(_DWORD *)(v3 + 24) = 0;
  if ( a2 )
    *a2 = *(_DWORD *)(v3 + 4);
  pthread_mutex_destroy((HANDLE **)(v3 + 28));
  replace_spin_keys_constprop_10(v3 + 56);
  if ( !*(_DWORD *)(v3 + 176) )
    push_pthread_mem_part_2(v3);
  pthread_mutex_unlock(&mtx_pthr_locked);
  return 0;
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;
// 41BCD0: using guessed type DWORD dwFlags[4];

//----- (0041BE60) --------------------------------------------------------
int __cdecl pthread_detach(unsigned int a1)
{
  int v1; // ebx
  int v2; // eax
  void *hObject; // edx
  DWORD dwFlags[4]; // [esp+1Ch] [ebp-10h] BYREF

  v1 = __pth_gpointer_locked(a1);
  pthread_mutex_lock(&mtx_pthr_locked);
  if ( v1 && *(_DWORD *)(v1 + 20) && GetHandleInformation(*(HANDLE *)(v1 + 20), dwFlags) )
  {
    v2 = *(_DWORD *)(v1 + 36);
    if ( (v2 & 4) != 0 )
    {
      pthread_mutex_unlock(&mtx_pthr_locked);
      return 22;
    }
    else
    {
      hObject = *(void **)(v1 + 20);
      *(_DWORD *)(v1 + 20) = 0;
      *(_DWORD *)(v1 + 36) = v2 | 4;
      if ( hObject )
      {
        CloseHandle(hObject);
        if ( *(_DWORD *)(v1 + 104) )
        {
          if ( *(_DWORD *)(v1 + 24) )
            CloseHandle(*(HANDLE *)(v1 + 24));
          *(_DWORD *)(v1 + 24) = 0;
          pthread_mutex_destroy((HANDLE **)(v1 + 28));
          replace_spin_keys_constprop_10(v1 + 56);
          if ( !*(_DWORD *)(v1 + 176) )
            push_pthread_mem_part_2(v1);
        }
      }
      pthread_mutex_unlock(&mtx_pthr_locked);
      return 0;
    }
  }
  else
  {
    pthread_mutex_unlock(&mtx_pthr_locked);
    return 3;
  }
}
// 50CF24: using guessed type signed __int32 mtx_pthr_locked;
// 41BE60: using guessed type DWORD dwFlags[4];

//----- (0041BF60) --------------------------------------------------------
int pthread_getconcurrency()
{
  return dummy_concurrency_level;
}
// 536A44: using guessed type int dummy_concurrency_level;

//----- (0041BF70) --------------------------------------------------------
int __cdecl pthread_setconcurrency(int a1)
{
  dummy_concurrency_level = a1;
  return 0;
}
// 536A44: using guessed type int dummy_concurrency_level;

//----- (0041BF80) --------------------------------------------------------
int __cdecl pthread_setname_np(int a1, char *String)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  char *v5; // edi
  ULONG_PTR v6; // eax
  ULONG_PTR Arguments[11]; // [esp+10h] [ebp-2Ch] BYREF

  v2 = 22;
  if ( !String )
    return v2;
  v2 = 3;
  v3 = __pth_gpointer_locked(a1);
  v4 = v3;
  if ( !v3 || *(_DWORD *)(v3 + 180) != a1 || (*(_BYTE *)(v3 + 32) & 0xC) != 0 )
    return v2;
  v2 = *(_DWORD *)(v3 + 104);
  if ( !v2 && (unsigned int)(*(_DWORD *)(v3 + 20) - 1) <= 0xFFFFFFFD )
  {
    v5 = strdup(String);
    if ( !v5 )
      return 12;
    if ( *(_DWORD *)(v4 + 52) )
      free(*(void **)(v4 + 52));
    v6 = *(_DWORD *)(v4 + 60);
    *(_DWORD *)(v4 + 52) = v5;
    Arguments[0] = 4096;
    Arguments[1] = (ULONG_PTR)String;
    Arguments[3] = 0;
    Arguments[2] = v6;
    if ( IsDebuggerPresent() || SetThreadName_VEH_handle )
      RaiseException(0x406D1388u, 0, 4u, Arguments);
    return v2;
  }
  return 3;
}

//----- (0041C090) --------------------------------------------------------
int __cdecl pthread_getname_np(unsigned int a1, _BYTE *a2, signed int a3)
{
  int v3; // ebx
  _BYTE *v4; // esi
  int v5; // eax
  char *v6; // edi
  char v7; // dl

  v3 = 22;
  v4 = a2;
  if ( !a2 )
    return v3;
  v3 = 3;
  v5 = __pth_gpointer_locked(a1);
  if ( !v5 || *(_DWORD *)(v5 + 180) != a1 || (*(_BYTE *)(v5 + 32) & 0xC) != 0 )
    return v3;
  v3 = *(_DWORD *)(v5 + 104);
  if ( !v3 && (unsigned int)(*(_DWORD *)(v5 + 20) - 1) <= 0xFFFFFFFD )
  {
    if ( a3 )
    {
      v6 = *(char **)(v5 + 52);
      if ( !v6 )
        goto LABEL_21;
      if ( strlen(*(const char **)(v5 + 52)) < a3 && a3 > 0 )
      {
        if ( a3 != 1 )
        {
          v7 = *v6;
          if ( *v6 )
          {
            while ( 1 )
            {
              ++v4;
              ++v6;
              *(v4 - 1) = v7;
              if ( (unsigned int)(a3 - 1) <= 1 )
                break;
              v7 = *v6;
              --a3;
              if ( !*v6 )
                goto LABEL_21;
            }
            if ( a3 == 1 )
            {
              *(v4 - 1) = 0;
              return 34;
            }
          }
        }
LABEL_21:
        *v4 = 0;
        return v3;
      }
    }
    return 34;
  }
  return 3;
}

//----- (0041C1A0) --------------------------------------------------------
unsigned __int64 _pthread_time_in_ms()
{
  __int64 v0; // rax
  struct _FILETIME SystemTimeAsFileTime; // [esp+18h] [ebp-14h] BYREF

  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  LODWORD(v0) = 0;
  HIDWORD(v0) = SystemTimeAsFileTime.dwHighDateTime;
  return ((unsigned __int64)SystemTimeAsFileTime.dwLowDateTime - 116444736000000000LL + v0) / 0x2710;
}

//----- (0041C200) --------------------------------------------------------
__int64 __cdecl _pthread_time_in_ms_from_timespec(int *a1)
{
  return 1000LL * *a1 + a1[1] / 1000000;
}

//----- (0041C240) --------------------------------------------------------
unsigned __int64 __cdecl _pthread_rel_time_in_ms(int *a1)
{
  unsigned __int64 v1; // kr00_8
  __int64 v2; // rax
  unsigned __int64 v3; // rax
  struct _FILETIME SystemTimeAsFileTime; // [esp+18h] [ebp-14h] BYREF

  v1 = 1000LL * *a1 + a1[1] / 1000000;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  HIDWORD(v2) = SystemTimeAsFileTime.dwHighDateTime;
  LODWORD(v2) = 0;
  v3 = (v2 + (unsigned __int64)SystemTimeAsFileTime.dwLowDateTime - 116444736000000000LL) / 0x2710;
  if ( v3 <= v1 )
    return v1 - v3;
  else
    return 0LL;
}

//----- (0041C2F0) --------------------------------------------------------
_DWORD *__usercall mutex_impl_init@<eax>(volatile signed __int32 *a1@<eax>, signed __int32 a2@<edx>)
{
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  int v6; // eax

  v4 = malloc(0x14u);
  v5 = v4;
  if ( v4 )
  {
    *v4 = 0;
    v6 = 2;
    if ( a2 != -3 )
      v6 = a2 == -2;
    v5[1] = v6;
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = -1;
    if ( a2 != _InterlockedCompareExchange(a1, (signed __int32)v5, a2) )
    {
      free(v5);
      return (_DWORD *)*a1;
    }
  }
  return v5;
}

//----- (0041C360) --------------------------------------------------------
int __cdecl pthread_mutex_lock(volatile signed __int32 *a1)
{
  volatile __int32 *v1; // ebx
  signed __int32 v2; // edi
  int result; // eax
  DWORD v4; // eax
  bool v5; // zf
  int v6; // ebp
  HANDLE EventA; // eax

  v1 = (volatile __int32 *)*a1;
  if ( *a1 >= 0xFFFFFFFD || *a1 == 0 )
  {
    v1 = mutex_impl_init(a1, *a1);
    result = 12;
    if ( !v1 )
      return result;
  }
  v2 = _InterlockedExchange(v1, 1);
  if ( !v2 )
    goto LABEL_3;
  if ( *((_DWORD *)v1 + 1) && (v6 = *((_DWORD *)v1 + 4), v6 == GetCurrentThreadId()) )
  {
    _InterlockedCompareExchange(v1, v2, 1);
    result = 36;
    if ( *((_DWORD *)v1 + 1) == 2 )
    {
      ++*((_DWORD *)v1 + 3);
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)v1 + 2) )
      goto LABEL_11;
    EventA = CreateEventA(0, 0, 0, 0);
    if ( EventA )
    {
      if ( _InterlockedCompareExchange(v1 + 2, (signed __int32)EventA, 0) )
        CloseHandle(EventA);
LABEL_11:
      while ( _InterlockedExchange(v1, 2) )
      {
        v4 = WaitForSingleObject(*((HANDLE *)v1 + 2), 0xFFFFFFFF);
        if ( v4 )
        {
          v5 = v4 == 258;
          result = 138;
          if ( !v5 )
            return 22;
          return result;
        }
      }
LABEL_3:
      if ( *((_DWORD *)v1 + 1) )
        *((_DWORD *)v1 + 4) = GetCurrentThreadId();
      return 0;
    }
    v5 = GetLastError() == 5;
    result = 1;
    if ( !v5 )
      return 12;
  }
  return result;
}

//----- (0041C4B0) --------------------------------------------------------
int __cdecl pthread_mutex_timedlock(volatile signed __int32 *a1, int *a2)
{
  DWORD dwMilliseconds; // esi
  __int64 v3; // rax
  unsigned int v4; // edi
  unsigned int v5; // esi
  unsigned __int64 v6; // rax
  volatile __int32 *v7; // ebx
  signed __int32 v8; // ebp
  int result; // eax
  int v10; // edi
  DWORD v11; // eax
  bool v12; // zf
  HANDLE EventA; // eax
  int v14; // [esp+1Ch] [ebp-20h]

  dwMilliseconds = -1;
  if ( a2 )
  {
    v3 = _pthread_time_in_ms_from_timespec(a2);
    v4 = HIDWORD(v3);
    v5 = v3;
    v6 = _pthread_time_in_ms();
    if ( v4 >= HIDWORD(v6) )
    {
      if ( v4 > HIDWORD(v6) || v5 > (unsigned int)v6 )
      {
        v10 = (__PAIR64__(v4, v5) - v6) >> 32;
        dwMilliseconds = v5 - v6;
        if ( v10 )
        {
          v7 = (volatile __int32 *)*a1;
          dwMilliseconds = -1;
          if ( *a1 < 0xFFFFFFFD && *a1 != 0 )
            goto LABEL_5;
          goto LABEL_13;
        }
      }
      else
      {
        dwMilliseconds = 0;
      }
    }
    else
    {
      dwMilliseconds = 0;
    }
  }
  v7 = (volatile __int32 *)*a1;
  if ( *a1 < 0xFFFFFFFD && *a1 != 0 )
    goto LABEL_5;
LABEL_13:
  v7 = mutex_impl_init(a1, (signed __int32)v7);
  result = 12;
  if ( !v7 )
    return result;
LABEL_5:
  v8 = _InterlockedExchange(v7, 1);
  if ( !v8 )
  {
LABEL_6:
    if ( *((_DWORD *)v7 + 1) )
      *((_DWORD *)v7 + 4) = GetCurrentThreadId();
    return 0;
  }
  if ( *((_DWORD *)v7 + 1) && (v14 = *((_DWORD *)v7 + 4), v14 == GetCurrentThreadId()) )
  {
    _InterlockedCompareExchange(v7, v8, 1);
    result = 36;
    if ( *((_DWORD *)v7 + 1) == 2 )
    {
      ++*((_DWORD *)v7 + 3);
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)v7 + 2) )
      goto LABEL_19;
    EventA = CreateEventA(0, 0, 0, 0);
    if ( EventA )
    {
      if ( _InterlockedCompareExchange(v7 + 2, (signed __int32)EventA, 0) )
        CloseHandle(EventA);
LABEL_19:
      while ( _InterlockedExchange(v7, 2) )
      {
        v11 = WaitForSingleObject(*((HANDLE *)v7 + 2), dwMilliseconds);
        if ( v11 )
        {
          v12 = v11 == 258;
          result = 138;
          if ( !v12 )
            return 22;
          return result;
        }
      }
      goto LABEL_6;
    }
    v12 = GetLastError() == 5;
    result = 1;
    if ( !v12 )
      return 12;
  }
  return result;
}

//----- (0041C660) --------------------------------------------------------
int __cdecl pthread_mutex_unlock(volatile signed __int32 *a1)
{
  volatile __int32 *v1; // edx
  int result; // eax
  int v3; // ebx
  DWORD CurrentThreadId; // ecx
  int v5; // eax
  volatile __int32 *v6; // [esp+1Ch] [ebp-10h]

  v1 = (volatile __int32 *)*a1;
  if ( *a1 < 0xFFFFFFFD && *a1 != 0 || (v1 = mutex_impl_init(a1, (signed __int32)v1), result = 12, v1) )
  {
    if ( *((_DWORD *)v1 + 1) )
    {
      result = 22;
      if ( !*v1 )
        return result;
      v3 = *((_DWORD *)v1 + 4);
      v6 = v1;
      CurrentThreadId = GetCurrentThreadId();
      v1 = v6;
      result = 1;
      if ( v3 != CurrentThreadId )
        return result;
      v5 = *((_DWORD *)v6 + 3);
      if ( v5 )
      {
        *((_DWORD *)v6 + 3) = v5 - 1;
        return 0;
      }
      *((_DWORD *)v6 + 4) = -1;
    }
    result = 0;
    if ( _InterlockedExchange(v1, 0) == 2 )
      return !SetEvent(*((HANDLE *)v1 + 2));
  }
  return result;
}

//----- (0041C710) --------------------------------------------------------
int __cdecl pthread_mutex_trylock(volatile signed __int32 *a1)
{
  volatile signed __int32 *v1; // ebx
  int v2; // esi
  int v4; // esi

  v1 = (volatile signed __int32 *)*a1;
  if ( *a1 < 0xFFFFFFFD && *a1 != 0 || (v1 = mutex_impl_init(a1, *a1)) != 0 )
  {
    if ( _InterlockedCompareExchange(v1, 1, 0) )
    {
      if ( *((_DWORD *)v1 + 1) == 2 && (v4 = *((_DWORD *)v1 + 4), v4 == GetCurrentThreadId()) )
      {
        ++*((_DWORD *)v1 + 3);
        return 0;
      }
      else
      {
        return 16;
      }
    }
    else
    {
      v2 = 0;
      if ( *((_DWORD *)v1 + 1) )
      {
        *((_DWORD *)v1 + 4) = GetCurrentThreadId();
        return 0;
      }
    }
    return v2;
  }
  return 12;
}

//----- (0041C790) --------------------------------------------------------
int __cdecl pthread_mutex_init(int *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // edx
  int v4; // eax

  if ( a2 )
  {
    result = 40;
    if ( (*a2 & 4) != 0 )
      return result;
    v3 = *a2 & 3;
    v4 = -2;
    if ( v3 != 1 )
      v4 = 2 * (v3 != 2) - 3;
  }
  else
  {
    v4 = -1;
  }
  *a1 = v4;
  return 0;
}

//----- (0041C7E0) --------------------------------------------------------
int __cdecl pthread_mutex_destroy(HANDLE **a1)
{
  HANDLE *v1; // ebx

  v1 = *a1;
  if ( (unsigned int)*a1 < 0xFFFFFFFD && (HANDLE *)((char *)*a1 + 3) != (HANDLE *)3 )
  {
    if ( v1[2] )
      CloseHandle(v1[2]);
    free(v1);
    *a1 = 0;
  }
  return 0;
}

//----- (0041C820) --------------------------------------------------------
int __cdecl pthread_mutexattr_init(_DWORD *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0041C830) --------------------------------------------------------
int __cdecl pthread_mutexattr_destroy(int a1)
{
  return a1 == 0 ? 0x16 : 0;
}

//----- (0041C840) --------------------------------------------------------
int __cdecl pthread_mutexattr_gettype(_DWORD *a1, int *a2)
{
  if ( !a1 || !a2 )
    return 22;
  *a2 = *a1 & 3;
  return 0;
}

//----- (0041C870) --------------------------------------------------------
int __cdecl pthread_mutexattr_settype(unsigned int *a1, unsigned int a2)
{
  int result; // eax

  result = 22;
  if ( a1 )
  {
    if ( a2 <= 2 )
    {
      *a1 = a2 | *a1 & 0xFFFFFFFC;
      return 0;
    }
  }
  return result;
}

//----- (0041C8A0) --------------------------------------------------------
int __cdecl pthread_mutexattr_getpshared(_DWORD *a1, int *a2)
{
  if ( !a1 || !a2 )
    return 22;
  *a2 = (*a1 >> 2) & 1;
  return 0;
}

//----- (0041C8D0) --------------------------------------------------------
int __cdecl pthread_mutexattr_setpshared(_DWORD *a1, unsigned int a2)
{
  int result; // eax

  if ( !a1 || a2 > 1 )
    return 22;
  result = 40;
  if ( a2 != 1 )
    result = 0;
  *a1 &= ~4u;
  return result;
}

//----- (0041C900) --------------------------------------------------------
int __cdecl pthread_mutexattr_getprotocol(_DWORD *a1, int *a2)
{
  *a2 = *a1 & 0x18;
  return 0;
}

//----- (0041C920) --------------------------------------------------------
int __cdecl pthread_mutexattr_setprotocol(unsigned int *a1, int a2)
{
  int result; // eax

  result = 22;
  if ( (a2 & 0x18) == 24 )
  {
    *a1 = a2 | *a1 & 0xFFFFFFE7;
    return 0;
  }
  return result;
}

//----- (0041C950) --------------------------------------------------------
int __cdecl pthread_mutexattr_getprioceiling(_DWORD *a1, _DWORD *a2)
{
  *a2 = *a1 >> 5;
  return 0;
}

//----- (0041C970) --------------------------------------------------------
int __cdecl pthread_mutexattr_setprioceiling(_DWORD *a1, int a2)
{
  *a1 = 32 * a2 + (*a1 & 0x1F);
  return 0;
}

//----- (0041C990) --------------------------------------------------------
int __usercall rwl_ref_destroy@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>)
{
  _DWORD *v4; // eax
  int v5; // esi

  *a2 = 0;
  pthread_spin_lock(&rwl_global);
  if ( a1 && (v4 = (_DWORD *)*a1) != 0 )
  {
    if ( v4 == (_DWORD *)-1 )
    {
      *a1 = 0;
      v5 = 0;
    }
    else
    {
      v5 = 22;
      if ( *v4 == -1162743571 )
      {
        v5 = v4[1];
        if ( v5 )
        {
          v5 = 16;
        }
        else
        {
          *a2 = v4;
          *a1 = 0;
        }
      }
    }
  }
  else
  {
    v5 = 22;
  }
  pthread_spin_unlock(&rwl_global);
  return v5;
}
// 50CF34: using guessed type __int32 rwl_global;

//----- (0041CA20) --------------------------------------------------------
int __usercall rwl_ref_unlock@<eax>(_DWORD **a1@<eax>)
{
  _DWORD *v2; // eax
  int v3; // ebx

  pthread_spin_lock(&rwl_global);
  if ( a1 )
  {
    v2 = *a1;
    v3 = 22;
    if ( v2 )
    {
      if ( *v2 == -1162743571 )
      {
        v3 = 1;
        if ( v2 != (_DWORD *)-1 )
        {
          ++v2[1];
          v3 = 0;
        }
      }
    }
  }
  else
  {
    v3 = 22;
  }
  pthread_spin_unlock(&rwl_global);
  return v3;
}
// 50CF34: using guessed type __int32 rwl_global;

//----- (0041CA80) --------------------------------------------------------
int __usercall rwlock_gain_both_locks@<eax>(int a1@<eax>)
{
  volatile signed __int32 *v1; // edi
  int v3; // ebx

  v1 = (volatile signed __int32 *)(a1 + 20);
  v3 = pthread_mutex_lock((volatile signed __int32 *)(a1 + 20));
  if ( v3 )
    return v3;
  v3 = pthread_mutex_lock((volatile signed __int32 *)(a1 + 24));
  if ( !v3 )
    return v3;
  pthread_mutex_unlock(v1);
  return v3;
}

//----- (0041CAD0) --------------------------------------------------------
int __usercall rwlock_free_both_locks@<eax>(int a1@<eax>, int a2@<edx>)
{
  volatile signed __int32 *v2; // ebx
  __int64 v3; // rdi
  int result; // eax

  LODWORD(v3) = a2;
  v2 = (volatile signed __int32 *)(a1 + 20);
  HIDWORD(v3) = pthread_mutex_unlock((volatile signed __int32 *)(a1 + 24));
  result = pthread_mutex_unlock(v2);
  if ( !result || (v3 & 1) == 0 )
  {
    if ( v3 )
      return HIDWORD(v3);
  }
  return result;
}

//----- (0041CB20) --------------------------------------------------------
int __cdecl st_cancelwrite(int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12) = -v1;
  return rwlock_free_both_locks(a1, 0);
}

//----- (0041CB40) --------------------------------------------------------
int __usercall rwl_unref@<eax>(int a1@<eax>, int a2@<edx>)
{
  FILE *v5; // eax

  pthread_spin_lock(&rwl_global);
  if ( **(_DWORD **)a1 != -1162743571 || *(int *)(*(_DWORD *)a1 + 4) <= 0 )
  {
    v5 = ___acrt_iob_func(2u);
    fprintf(
      v5,
      "Assertion failed: (%s), file %s, line %d\n",
      "(((rwlock_t *)*rwl)->valid == LIFE_RWLOCK) && (((rwlock_t *)*rwl)->busy > 0)",
      "../../src/mingw-w64/mingw-w64-libraries/winpthreads/src/rwlock.c",
      40);
    exit(1);
  }
  --*(_DWORD *)(*(_DWORD *)a1 + 4);
  pthread_spin_unlock(&rwl_global);
  return a2;
}
// 50CF34: using guessed type __int32 rwl_global;

//----- (0041CBD0) --------------------------------------------------------
int __cdecl rwl_print_set(int a1)
{
  int result; // eax

  result = a1;
  print_state_0 = a1;
  return result;
}
// 536A80: using guessed type int print_state_0;

//----- (0041CBE0) --------------------------------------------------------
int __cdecl rwl_print(const void **a1, const char *a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edi
  int v5; // esi
  DWORD CurrentThreadId; // eax
  DWORD v7; // eax

  result = print_state_0;
  if ( print_state_0 )
  {
    v3 = (int *)*a1;
    if ( *a1 )
    {
      v4 = v3[1];
      v5 = *v3;
      CurrentThreadId = GetCurrentThreadId();
      return printf("RWL%p %d V=%0X B=%d r=%ld w=%ld L=%p %s\n", *a1, CurrentThreadId, v5, v4, 0, 0, 0, a2);
    }
    else
    {
      v7 = GetCurrentThreadId();
      return printf("RWL%p %d %s\n", *a1, v7, a2);
    }
  }
  return result;
}
// 536A80: using guessed type int print_state_0;

//----- (0041CC80) --------------------------------------------------------
int __cdecl pthread_rwlock_init(int **a1)
{
  int v1; // ebp
  _DWORD *v2; // eax
  int *v3; // ebx
  HANDLE **v4; // edi
  int v5; // ebp

  v1 = 22;
  if ( !a1 )
    return v1;
  *a1 = 0;
  v1 = 12;
  v2 = calloc(1u, 0x20u);
  v3 = v2;
  if ( !v2 )
    return v1;
  v4 = (HANDLE **)(v2 + 5);
  *v2 = -559042321;
  v2[4] = 0;
  v2[3] = 0;
  v2[2] = 0;
  v5 = pthread_mutex_init(v2 + 5, 0);
  if ( !v5 )
  {
    v5 = pthread_mutex_init(v3 + 6, 0);
    if ( !v5 )
    {
      v1 = pthread_cond_init(v3 + 7, 0);
      if ( v1 )
      {
        pthread_mutex_destroy(v4);
        pthread_mutex_destroy((HANDLE **)v3 + 6);
        free(v3);
      }
      else
      {
        *v3 = -1162743571;
        *a1 = v3;
      }
      return v1;
    }
    pthread_mutex_destroy(v4);
  }
  free(v3);
  return v5;
}

//----- (0041CD80) --------------------------------------------------------
int __usercall rwlock_static_init@<eax>(int **a1@<eax>)
{
  int v3; // ebx

  pthread_spin_lock(&cond_locked);
  if ( *a1 == (int *)-1 )
  {
    v3 = pthread_rwlock_init(a1);
    pthread_spin_unlock(&cond_locked);
    return v3;
  }
  else
  {
    pthread_spin_unlock(&cond_locked);
    return 22;
  }
}
// 50CF30: using guessed type __int32 cond_locked;

//----- (0041CDE0) --------------------------------------------------------
int __usercall rwl_ref_isra_0@<eax>(int **a1@<eax>)
{
  int v2; // esi
  int *v3; // eax

  if ( *a1 != (int *)-1 || (v2 = rwlock_static_init(a1), (v2 & 0xFFFFFFEF) == 0) )
  {
    v2 = 22;
    pthread_spin_lock(&rwl_global);
    v3 = *a1;
    if ( *a1 && *v3 == -1162743571 )
    {
      ++v3[1];
      v2 = 0;
    }
    pthread_spin_unlock(&rwl_global);
  }
  return v2;
}
// 50CF34: using guessed type __int32 rwl_global;

//----- (0041CE40) --------------------------------------------------------
int __cdecl pthread_rwlock_destroy(void **a1)
{
  int v1; // ebx
  void *v2; // edi
  void *Block; // eax
  void *v5; // [esp+1Ch] [ebp-10h] BYREF

  pthread_spin_lock(&cond_locked);
  v1 = rwl_ref_destroy(a1, &v5);
  pthread_spin_unlock(&cond_locked);
  if ( v1 )
    return v1;
  v2 = v5;
  if ( !v5 )
    return v1;
  v1 = rwlock_gain_both_locks((int)v5);
  if ( !v1 )
  {
    if ( *((_DWORD *)v2 + 3) > *((_DWORD *)v2 + 4) || *((int *)v2 + 2) > 0 )
    {
      *a1 = v5;
      v1 = rwlock_free_both_locks((int)v2, 1);
      if ( !v1 )
        return 16;
      return v1;
    }
    *(_DWORD *)v2 = -559042321;
    v1 = rwlock_free_both_locks((int)v2, 0);
    if ( !v1 )
    {
      pthread_cond_destroy((int *)v2 + 7);
      pthread_mutex_destroy((HANDLE **)v2 + 5);
      pthread_mutex_destroy((HANDLE **)v2 + 6);
      Block = v5;
      *(_DWORD *)v2 = -559042321;
      free(Block);
      return v1;
    }
  }
  *a1 = v5;
  return v1;
}
// 50CF30: using guessed type __int32 cond_locked;

//----- (0041CF20) --------------------------------------------------------
int __cdecl pthread_rwlock_rdlock(int **a1)
{
  int result; // eax
  int *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // eax
  int v5; // edx
  int v6; // ebp

  result = rwl_ref_isra_0(a1);
  if ( !result )
  {
    v2 = *a1;
    v3 = *a1 + 5;
    v4 = pthread_mutex_lock(v3);
    if ( !v4 )
    {
      _InterlockedAdd(v2 + 3, 1u);
      if ( v2[3] == 0x7FFFFFFF )
      {
        v6 = pthread_mutex_lock(v2 + 6);
        if ( v6 )
        {
          pthread_mutex_unlock(v3);
          v5 = v6;
          return rwl_unref((int)a1, v5);
        }
        v2[3] -= v2[4];
        v2[4] = 0;
        v4 = rwlock_free_both_locks((int)v2, 0);
      }
      else
      {
        v4 = pthread_mutex_unlock(v3);
      }
    }
    v5 = v4;
    return rwl_unref((int)a1, v5);
  }
  return result;
}

//----- (0041CFC0) --------------------------------------------------------
int __cdecl pthread_rwlock_timedrdlock(int **a1, int *a2)
{
  int result; // eax
  int *v3; // esi
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // edi

  result = rwl_ref_isra_0(a1);
  if ( !result )
  {
    v3 = *a1;
    v4 = pthread_mutex_timedlock(*a1 + 5, a2);
    if ( !v4 )
    {
      _InterlockedAdd(v3 + 3, 1u);
      if ( v3[3] == 0x7FFFFFFF )
      {
        v6 = pthread_mutex_timedlock(v3 + 6, a2);
        v7 = v6;
        if ( v6 )
        {
          if ( v6 == 138 )
            _InterlockedAdd(v3 + 4, 1u);
          pthread_mutex_unlock(v3 + 5);
          v5 = v7;
          return rwl_unref((int)a1, v5);
        }
        v3[3] -= v3[4];
        v3[4] = 0;
        v4 = rwlock_free_both_locks((int)v3, 0);
      }
      else
      {
        v4 = pthread_mutex_unlock(v3 + 5);
      }
    }
    v5 = v4;
    return rwl_unref((int)a1, v5);
  }
  return result;
}

//----- (0041D080) --------------------------------------------------------
int __cdecl pthread_rwlock_tryrdlock(int **a1)
{
  int result; // eax
  int *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // eax
  int v5; // edx
  int v6; // ebp

  result = rwl_ref_isra_0(a1);
  if ( !result )
  {
    v2 = *a1;
    v3 = *a1 + 5;
    v4 = pthread_mutex_trylock(v3);
    if ( !v4 )
    {
      _InterlockedAdd(v2 + 3, 1u);
      if ( v2[3] == 0x7FFFFFFF )
      {
        v6 = pthread_mutex_lock(v2 + 6);
        if ( v6 )
        {
          pthread_mutex_unlock(v3);
          v5 = v6;
          return rwl_unref((int)a1, v5);
        }
        v2[3] -= v2[4];
        v2[4] = 0;
        v4 = rwlock_free_both_locks((int)v2, 0);
      }
      else
      {
        v4 = pthread_mutex_unlock(v3);
      }
    }
    v5 = v4;
    return rwl_unref((int)a1, v5);
  }
  return result;
}

//----- (0041D120) --------------------------------------------------------
int __cdecl pthread_rwlock_trywrlock(int **a1)
{
  int result; // eax
  int *v2; // esi
  volatile signed __int32 *v3; // edi
  int v4; // eax
  int v5; // ebp
  int v6; // edx
  int v7; // edx
  int v8; // eax
  int v9; // eax

  result = rwl_ref_isra_0(a1);
  if ( !result )
  {
    v2 = *a1;
    v3 = *a1 + 5;
    v4 = pthread_mutex_trylock(v3);
    if ( !v4 )
    {
      v5 = pthread_mutex_trylock(v2 + 6);
      if ( !v5 )
      {
        v6 = 16;
        if ( !v2[2] )
        {
          v7 = v2[4];
          v8 = v2[3];
          if ( v7 > 0 )
          {
            v8 -= v7;
            v2[4] = 0;
            v2[3] = v8;
          }
          if ( v8 <= 0 )
          {
            v2[2] = 1;
            v6 = 0;
          }
          else
          {
            v9 = rwlock_free_both_locks((int)v2, 0);
            if ( !v9 )
              v9 = 16;
            v6 = v9;
          }
        }
        return rwl_unref((int)a1, v6);
      }
      v4 = pthread_mutex_unlock(v3);
      if ( !v4 )
        v4 = v5;
    }
    v6 = v4;
    return rwl_unref((int)a1, v6);
  }
  return result;
}

//----- (0041D1D0) --------------------------------------------------------
int __cdecl pthread_rwlock_unlock(_DWORD **a1)
{
  int result; // eax
  _DWORD *v2; // esi
  int v3; // edx
  int v4; // eax
  int v5; // [esp+1Ch] [ebp-10h]

  result = rwl_ref_unlock(a1);
  if ( !result )
  {
    v2 = *a1;
    if ( (*a1)[2] )
    {
      _InterlockedSub(v2 + 2, 1u);
      v3 = rwlock_free_both_locks((int)v2, 0);
    }
    else
    {
      v3 = pthread_mutex_lock(v2 + 6);
      if ( !v3 )
      {
        _InterlockedAdd(v2 + 4, 1u);
        if ( v2[4] )
        {
          v3 = pthread_mutex_unlock(v2 + 6);
        }
        else
        {
          v5 = pthread_cond_signal(v2 + 7);
          v4 = pthread_mutex_unlock(v2 + 6);
          v3 = v5;
          if ( !v5 )
            v3 = v4;
        }
      }
    }
    return rwl_unref((int)a1, v3);
  }
  return result;
}

//----- (0041D280) --------------------------------------------------------
int __cdecl pthread_rwlock_wrlock(int **a1)
{
  int result; // eax
  int *v2; // esi
  int v3; // ebx
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  signed __int32 v7; // [esp+0h] [ebp-4Ch] BYREF
  int v8; // [esp+1Ch] [ebp-30h]
  int (__cdecl *v9)(int); // [esp+24h] [ebp-28h] BYREF
  int *v10; // [esp+28h] [ebp-24h]
  int v11; // [esp+2Ch] [ebp-20h]

  result = rwl_ref_isra_0(a1);
  if ( !result )
  {
    v2 = *a1;
    v3 = rwlock_gain_both_locks((int)*a1);
    if ( !v3 )
    {
      if ( !v2[2] )
      {
        v4 = v2[4];
        v5 = v2[3];
        if ( v4 > 0 )
        {
          v5 -= v4;
          v2[4] = 0;
          v2[3] = v5;
        }
        if ( v5 > 0 )
        {
          v9 = st_cancelwrite;
          v10 = v2;
          v2[4] = -v5;
          v11 = *(_DWORD *)pthread_getclean();
          _InterlockedOr(&v7, 0);
          *(_DWORD *)pthread_getclean() = &v9;
          _InterlockedOr(&v7, 0);
          do
          {
            v6 = pthread_cond_wait(v2 + 7, v2 + 6);
            if ( v6 )
            {
              v8 = v6;
              *(_DWORD *)pthread_getclean() = v11;
              v9((int)v10);
              v3 = v8;
              return rwl_unref((int)a1, v3);
            }
          }
          while ( v2[4] < 0 );
          *(_DWORD *)pthread_getclean() = v11;
          v2[3] = 0;
        }
      }
      _InterlockedAdd(v2 + 2, 1u);
    }
    return rwl_unref((int)a1, v3);
  }
  return result;
}

//----- (0041D390) --------------------------------------------------------
int __cdecl pthread_rwlock_timedwrlock(int **a1, int *a2)
{
  int result; // eax
  int *v3; // esi
  volatile signed __int32 *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // edi
  char *v12; // eax
  signed __int32 v13; // [esp+0h] [ebp-4Ch] BYREF
  int v14; // [esp+18h] [ebp-34h]
  int *v15; // [esp+1Ch] [ebp-30h]
  int (__cdecl *v16)(int); // [esp+24h] [ebp-28h] BYREF
  int *v17; // [esp+28h] [ebp-24h]
  int v18; // [esp+2Ch] [ebp-20h]

  if ( !a1 || !a2 )
    return 22;
  result = rwl_ref_isra_0(a1);
  if ( !result )
  {
    v3 = *a1;
    v4 = *a1 + 5;
    v5 = pthread_mutex_timedlock(v4, a2);
    if ( v5 )
    {
      return rwl_unref((int)a1, v5);
    }
    else
    {
      v6 = pthread_mutex_timedlock(v3 + 6, a2);
      v7 = v6;
      if ( v6 )
      {
        v14 = v6;
        pthread_mutex_unlock(v4);
        return rwl_unref((int)a1, v14);
      }
      else
      {
        if ( !v3[2] )
        {
          v8 = v3[4];
          v9 = v3[3];
          if ( v8 > 0 )
          {
            v9 -= v8;
            v3[4] = 0;
            v3[3] = v9;
          }
          if ( v9 > 0 )
          {
            v14 = 0;
            v16 = st_cancelwrite;
            v3[4] = -v9;
            v17 = v3;
            v18 = *(_DWORD *)pthread_getclean();
            _InterlockedOr(&v13, 0);
            *(_DWORD *)pthread_getclean() = &v16;
            _InterlockedOr(&v13, 0);
            v15 = v3 + 7;
            v10 = v14;
            while ( 1 )
            {
              v14 = v10;
              v11 = pthread_cond_timedwait(v15, v3 + 6, (struct _RTL_CRITICAL_SECTION *)a2);
              v10 = v14;
              if ( v3[4] >= 0 )
                break;
              if ( v11 )
              {
                *(_DWORD *)pthread_getclean() = v18;
                goto LABEL_20;
              }
            }
            v12 = pthread_getclean();
            v7 = v14;
            *(_DWORD *)v12 = v18;
            if ( v11 )
            {
LABEL_20:
              v16((int)v17);
              v7 = v11;
              return rwl_unref((int)a1, v7);
            }
            v3[3] = 0;
          }
        }
        _InterlockedAdd(v3 + 2, 1u);
        return rwl_unref((int)a1, v7);
      }
    }
  }
  return result;
}

//----- (0041D520) --------------------------------------------------------
int __cdecl pthread_rwlockattr_destroy(int a1)
{
  return a1 == 0 ? 0x16 : 0;
}

//----- (0041D530) --------------------------------------------------------
int __cdecl pthread_rwlockattr_init(_DWORD *a1)
{
  if ( !a1 )
    return 22;
  *a1 = 0;
  return 0;
}

//----- (0041D550) --------------------------------------------------------
int __cdecl pthread_rwlockattr_getpshared(_DWORD *a1, _DWORD *a2)
{
  if ( !a1 || !a2 )
    return 22;
  *a2 = *a1;
  return 0;
}

//----- (0041D580) --------------------------------------------------------
int __cdecl pthread_rwlockattr_setpshared(unsigned int *a1, unsigned int a2)
{
  if ( !a1 || a2 > 1 )
    return 22;
  *a1 = a2;
  return 0;
}

//----- (0041D5B0) --------------------------------------------------------
int __cdecl pthread_spin_init(_DWORD *a1)
{
  *a1 = -1;
  return 0;
}

//----- (0041D5C0) --------------------------------------------------------
int pthread_spin_destroy()
{
  return 0;
}

//----- (0041D5D0) --------------------------------------------------------
int __cdecl pthread_spin_lock(volatile __int32 *a1)
{
  while ( !_InterlockedExchange(a1, 0) )
  {
    do
      _mm_pause();
    while ( !*a1 );
  }
  return 0;
}

//----- (0041D5F0) --------------------------------------------------------
int __cdecl pthread_spin_trylock(volatile __int32 *a1)
{
  return 16 * (_InterlockedExchange(a1, 0) == 0);
}

//----- (0041D610) --------------------------------------------------------
int __cdecl pthread_spin_unlock(_DWORD *a1)
{
  *a1 = -1;
  return 0;
}

//----- (0041D620) --------------------------------------------------------
int __usercall do_sema_b_release@<eax>(
        LPCRITICAL_SECTION lpCriticalSection@<ecx>,
        LONG lReleaseCount@<edx>,
        void *a3@<eax>,
        volatile signed __int32 *a4)
{
  LONG v6; // edi
  int v7; // ecx
  LONG v9; // ecx

  v6 = lReleaseCount >> 31;
  EnterCriticalSection(lpCriticalSection);
  v7 = *a4;
  if ( (__int64)(__PAIR64__(v6, lReleaseCount) + *(int *)a4) > 0x7FFFFFFF )
  {
    LeaveCriticalSection(lpCriticalSection);
    return 34;
  }
  else
  {
    _InterlockedAdd(a4, lReleaseCount);
    if ( v7 >= 0 )
      goto LABEL_5;
    v9 = -v7;
    if ( v9 > lReleaseCount )
      v9 = lReleaseCount;
    if ( ReleaseSemaphore(a3, v9, 0) )
    {
LABEL_5:
      LeaveCriticalSection(lpCriticalSection);
      return 0;
    }
    else
    {
      _InterlockedAdd(a4, -lReleaseCount);
      LeaveCriticalSection(lpCriticalSection);
      return 22;
    }
  }
}

//----- (0041D6F0) --------------------------------------------------------
int __cdecl cond_print_set(int a1, FILE *a2)
{
  FILE *v2; // eax
  int result; // eax

  v2 = a2;
  if ( !a2 )
  {
    if ( fo )
      goto LABEL_3;
    v2 = ___acrt_iob_func(1u);
  }
  fo = v2;
LABEL_3:
  result = a1;
  print_state_1 = a1;
  return result;
}
// 536A88: using guessed type int print_state_1;

//----- (0041D730) --------------------------------------------------------
int __cdecl cond_print(const void **a1, const char *a2)
{
  int result; // eax
  int *v3; // eax
  int v4; // edi
  int v5; // esi
  DWORD CurrentThreadId; // eax
  DWORD v7; // eax

  result = print_state_1;
  if ( print_state_1 )
  {
    v3 = (int *)*a1;
    if ( *a1 )
    {
      v4 = v3[2];
      v5 = *v3;
      CurrentThreadId = GetCurrentThreadId();
      return fprintf(fo, "C%p %d V=%0X w=%ld %s\n", *a1, CurrentThreadId, v5, v4, a2);
    }
    else
    {
      v7 = GetCurrentThreadId();
      return fprintf(fo, "C%p %d %s\n", *a1, v7, a2);
    }
  }
  return result;
}
// 536A88: using guessed type int print_state_1;

//----- (0041D7D0) --------------------------------------------------------
int __cdecl pthread_condattr_destroy(_DWORD *a1)
{
  if ( !a1 )
    return 22;
  *a1 = 0;
  return 0;
}

//----- (0041D7F0) --------------------------------------------------------
int __cdecl pthread_condattr_init(_DWORD *a1)
{
  if ( !a1 )
    return 22;
  *a1 = 0;
  return 0;
}

//----- (0041D810) --------------------------------------------------------
int __cdecl pthread_condattr_getpshared(_DWORD *a1, _DWORD *a2)
{
  if ( !a1 || !a2 )
    return 22;
  *a2 = *a1;
  return 0;
}

//----- (0041D840) --------------------------------------------------------
int __cdecl pthread_condattr_getclock(int a1, _DWORD *a2)
{
  if ( !a1 || !a2 )
    return 22;
  *a2 = 0;
  return 0;
}

//----- (0041D870) --------------------------------------------------------
int __cdecl pthread_condattr_setclock(int a1, int a2)
{
  if ( !a1 || a2 )
    return 22;
  else
    return 0;
}

//----- (0041D890) --------------------------------------------------------
int __cdecl __pthread_clock_nanosleep(unsigned int a1, char a2, int *a3, _DWORD *a4)
{
  int result; // eax
  unsigned __int64 v5; // rdi
  __int64 v6; // kr00_8
  DWORD v7; // ebp
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // kr08_8
  unsigned __int64 v10; // [esp+18h] [ebp-24h]

  result = 22;
  if ( a1 <= 2 )
  {
    if ( (a2 & 1) != 0 )
    {
      v9 = _pthread_rel_time_in_ms(a3);
      v5 = __PAIR64__(v9, HIDWORD(v9));
    }
    else
    {
      v6 = _pthread_time_in_ms_from_timespec(a3);
      v5 = __PAIR64__(v6, HIDWORD(v6));
    }
    do
    {
      if ( (_DWORD)v5 || (v7 = HIDWORD(v5), HIDWORD(v5) > 0x1869E) )
        v7 = 99999;
      v10 = _pthread_time_in_ms();
      pthread_delay_np_ms(v7);
      v8 = _pthread_time_in_ms() - v10;
      if ( __PAIR64__(v5, HIDWORD(v5)) <= v8 )
        break;
      LODWORD(v5) = (__PAIR64__(v5, HIDWORD(v5)) - v8) >> 32;
      HIDWORD(v5) -= v8;
    }
    while ( v5 );
    result = 0;
    if ( a4 )
    {
      *a4 = 0;
      a4[1] = 0;
    }
  }
  return result;
}

//----- (0041D950) --------------------------------------------------------
int __cdecl pthread_condattr_setpshared(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || a2 > 1 )
    return 22;
  *a1 = 0;
  if ( a2 == 1 )
    return 40;
  else
    return 0;
}

//----- (0041D990) --------------------------------------------------------
int __cdecl pthread_cond_init(_DWORD *a1, _DWORD *a2)
{
  char *v2; // ebx
  int result; // eax
  HANDLE SemaphoreA; // eax
  void *v5; // edx

  if ( !a1 )
    return 22;
  if ( a2 && *a2 == 1 )
    return 40;
  v2 = (char *)calloc(1u, 0x6Cu);
  result = 12;
  if ( v2 )
  {
    *(_DWORD *)v2 = -1059148353;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
    *((_DWORD *)v2 + 4) = 0;
    *((_DWORD *)v2 + 3) = 0;
    *((_DWORD *)v2 + 25) = CreateSemaphoreA(0, 0, 0x7FFFFFFF, 0);
    SemaphoreA = CreateSemaphoreA(0, 0, 0x7FFFFFFF, 0);
    v5 = (void *)*((_DWORD *)v2 + 25);
    *((_DWORD *)v2 + 26) = SemaphoreA;
    if ( v5 )
    {
      if ( SemaphoreA )
      {
        InitializeCriticalSection((LPCRITICAL_SECTION)(v2 + 20));
        InitializeCriticalSection((LPCRITICAL_SECTION)v2 + 3);
        InitializeCriticalSection((LPCRITICAL_SECTION)(v2 + 44));
        *((_DWORD *)v2 + 17) = 0;
        *((_DWORD *)v2 + 24) = 1;
        *(_DWORD *)v2 = -1061506563;
        *a1 = v2;
        return 0;
      }
      CloseHandle(v5);
      SemaphoreA = (HANDLE)*((_DWORD *)v2 + 26);
    }
    if ( SemaphoreA )
      CloseHandle(SemaphoreA);
    free(v2);
    *a1 = 0;
    return 11;
  }
  return result;
}

//----- (0041DB00) --------------------------------------------------------
int __usercall cond_static_init@<eax>(_DWORD *a1@<eax>)
{
  int v2; // esi

  pthread_spin_lock(&cond_locked_0);
  if ( a1 )
  {
    v2 = 0;
    if ( *a1 == -1 )
      v2 = pthread_cond_init(a1, 0);
  }
  else
  {
    v2 = 22;
  }
  pthread_spin_unlock(&cond_locked_0);
  return v2;
}
// 50CF38: using guessed type __int32 cond_locked_0;

//----- (0041DB60) --------------------------------------------------------
int __cdecl do_sema_b_wait_intern(HANDLE hHandle, int a2, DWORD dwMilliseconds)
{
  int v3; // edi
  DWORD v4; // ebx
  DWORD v5; // eax
  int v6; // ebx
  bool v7; // al
  DWORD v9; // eax
  DWORD v10; // eax
  bool v11; // al
  DWORD v12; // eax
  int v13; // ebx
  DWORD v14; // eax
  HANDLE Handles; // [esp+18h] [ebp-24h] BYREF
  HANDLE hEvent; // [esp+1Ch] [ebp-20h]

  v3 = a2;
  v4 = dwMilliseconds;
  if ( a2 != 1 )
  {
    Handles = hHandle;
    hEvent = (HANDLE)pthread_getevent();
    if ( !hEvent )
    {
      if ( dwMilliseconds == -1 )
      {
        while ( 1 )
        {
          v12 = WaitForSingleObject(hHandle, 0x28u);
          if ( v12 == 128 )
          {
            if ( !__pthread_shallcancel() )
              return WaitForSingleObject(hHandle, 0) != 0;
            goto LABEL_55;
          }
          if ( v12 != 258 )
            break;
          if ( __pthread_shallcancel() )
            goto LABEL_55;
        }
        v6 = 0;
        if ( !v12 )
          return v6;
        if ( !__pthread_shallcancel() )
          return 22;
LABEL_55:
        if ( a2 == 2 )
          return 22;
LABEL_56:
        pthread_testcancel();
        return 22;
      }
      else
      {
        while ( v4 > 0x13 )
        {
          v10 = WaitForSingleObject(hHandle, 0x14u);
          if ( v10 == 128 )
          {
            if ( v4 != 20 && __pthread_shallcancel() )
              return 22;
            goto LABEL_51;
          }
          if ( v10 != 258 )
          {
            if ( v10 )
            {
              if ( v4 != 20 && __pthread_shallcancel() )
                return 22;
LABEL_23:
              v6 = 22;
LABEL_24:
              v11 = v6 != 0;
              goto LABEL_25;
            }
LABEL_44:
            v6 = 0;
            goto LABEL_24;
          }
          v4 -= 20;
          if ( !v4 )
            goto LABEL_46;
          if ( __pthread_shallcancel() )
            return 22;
        }
        v14 = WaitForSingleObject(hHandle, v4);
        if ( v14 == 128 )
        {
LABEL_51:
          v6 = 1;
          goto LABEL_24;
        }
        if ( v14 != 258 )
        {
          if ( v14 )
            goto LABEL_23;
          goto LABEL_44;
        }
LABEL_46:
        if ( !WaitForSingleObject(hHandle, 0) )
          return 0;
        v11 = 1;
        v6 = 138;
LABEL_25:
        if ( a2 != 2 && v11 )
          pthread_testcancel();
      }
      return v6;
    }
    while ( 1 )
    {
      v5 = WaitForMultipleObjects(2u, &Handles, 0, dwMilliseconds);
      if ( v5 != 1 )
        break;
      ResetEvent(hEvent);
      if ( a2 != 2 )
        goto LABEL_56;
      pthread_testcancel();
    }
    v6 = 0;
    if ( v5 )
    {
      if ( v5 == 128 )
      {
        v6 = 1;
      }
      else
      {
        if ( v5 != 258 )
        {
          v6 = 22;
          v7 = a2 != 2;
LABEL_10:
          if ( !v7 || !__pthread_shallcancel() )
            return v6;
          return 22;
        }
        v6 = 138;
      }
      if ( WaitForSingleObject(Handles, 0) )
      {
        v7 = a2 != 2;
        goto LABEL_10;
      }
      return 0;
    }
    return v6;
  }
  v9 = WaitForSingleObject(hHandle, dwMilliseconds);
  if ( v9 != 128 )
  {
    if ( v9 != 258 )
      return v9 != 0 ? 0x16 : 0;
    v3 = 138;
  }
  v13 = 0;
  if ( WaitForSingleObject(hHandle, 0) )
    return v3;
  return v13;
}

//----- (0041DE80) --------------------------------------------------------
int __usercall do_sema_b_wait@<eax>(
        void *a1@<eax>,
        int a2@<edx>,
        DWORD a3@<ecx>,
        LPCRITICAL_SECTION lpCriticalSection,
        volatile signed __int32 *a5)
{
  int v5; // ebp
  int v7; // ebp

  EnterCriticalSection(lpCriticalSection);
  _InterlockedSub(a5, 1u);
  v5 = *a5;
  LeaveCriticalSection(lpCriticalSection);
  if ( v5 >= 0 )
    return 0;
  v7 = do_sema_b_wait_intern(a1, a2, a3);
  EnterCriticalSection(lpCriticalSection);
  if ( v7 )
    _InterlockedAdd(a5, 1u);
  LeaveCriticalSection(lpCriticalSection);
  return v7;
}

//----- (0041DF20) --------------------------------------------------------
int __cdecl pthread_cond_destroy(int *a1)
{
  int v1; // ebx
  int v2; // edi
  int v4; // edi
  volatile signed __int32 *v5; // [esp+18h] [ebp-24h]
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [esp+1Ch] [ebp-20h]

  if ( !a1 )
    return 22;
  v1 = *a1;
  if ( !*a1 )
    return 22;
  if ( v1 == -1 )
  {
    v4 = 16;
    pthread_spin_lock(&cond_locked_0);
    if ( *a1 == -1 )
    {
      *a1 = 0;
      v4 = 0;
    }
    pthread_spin_unlock(&cond_locked_0);
    return v4;
  }
  else
  {
    v5 = (volatile signed __int32 *)(v1 + 96);
    v2 = do_sema_b_wait(
           *(void **)(v1 + 104),
           0,
           0xFFFFFFFF,
           (LPCRITICAL_SECTION)(v1 + 72),
           (volatile signed __int32 *)(v1 + 96));
    if ( !v2 )
    {
      lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(v1 + 20);
      if ( TryEnterCriticalSection((LPCRITICAL_SECTION)(v1 + 20)) )
      {
        if ( *(_DWORD *)(v1 + 8) <= *(_DWORD *)(v1 + 16) )
        {
          *a1 = 0;
          do_sema_b_release((LPCRITICAL_SECTION)(v1 + 72), 1, *(void **)(v1 + 104), v5);
          CloseHandle(*(HANDLE *)(v1 + 100));
          CloseHandle(*(HANDLE *)(v1 + 104));
          LeaveCriticalSection(lpCriticalSection);
          DeleteCriticalSection(lpCriticalSection);
          DeleteCriticalSection((LPCRITICAL_SECTION)(v1 + 72));
          DeleteCriticalSection((LPCRITICAL_SECTION)(v1 + 44));
          free((void *)v1);
        }
        else
        {
          v2 = do_sema_b_release((LPCRITICAL_SECTION)(v1 + 72), 1, *(void **)(v1 + 104), v5);
          if ( !v2 )
            v2 = 16;
          LeaveCriticalSection(lpCriticalSection);
        }
      }
      else
      {
        v2 = 16;
        do_sema_b_release((LPCRITICAL_SECTION)(v1 + 72), 1, *(void **)(v1 + 104), v5);
      }
    }
    return v2;
  }
}
// 50CF38: using guessed type __int32 cond_locked_0;

//----- (0041E0C0) --------------------------------------------------------
int __cdecl pthread_cond_signal(int *a1)
{
  int v1; // ebx
  int result; // eax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // [esp+1Ch] [ebp-10h]

  if ( !a1 )
    return 22;
  v1 = *a1;
  if ( !*a1 )
    return 22;
  if ( v1 == -1 )
    return 0;
  result = 22;
  if ( *(_DWORD *)v1 == -1061506563 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
    v3 = *(_DWORD *)(v1 + 12);
    if ( v3 )
    {
      v4 = *(_DWORD *)(v1 + 8);
      if ( v4 )
      {
        *(_DWORD *)(v1 + 8) = v4 - 1;
        *(_DWORD *)(v1 + 12) = v3 + 1;
        goto LABEL_10;
      }
    }
    else if ( *(_DWORD *)(v1 + 8) > *(_DWORD *)(v1 + 16) )
    {
      v5 = do_sema_b_wait(
             *(void **)(v1 + 104),
             1,
             0xFFFFFFFF,
             (LPCRITICAL_SECTION)(v1 + 72),
             (volatile signed __int32 *)(v1 + 96));
      if ( v5 )
      {
        v8 = v5;
        LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
        return v8;
      }
      v6 = *(_DWORD *)(v1 + 16);
      v7 = *(_DWORD *)(v1 + 8);
      if ( v6 )
      {
        v7 -= v6;
        *(_DWORD *)(v1 + 16) = 0;
      }
      *(_DWORD *)(v1 + 12) = 1;
      *(_DWORD *)(v1 + 8) = v7 - 1;
LABEL_10:
      LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
      return do_sema_b_release(
               (LPCRITICAL_SECTION)(v1 + 44),
               1,
               *(void **)(v1 + 100),
               (volatile signed __int32 *)(v1 + 68));
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
    return 0;
  }
  return result;
}

//----- (0041E1E0) --------------------------------------------------------
int __cdecl pthread_cond_broadcast(int *a1)
{
  int v1; // ebx
  int result; // eax
  int v3; // eax
  LONG v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // [esp+1Ch] [ebp-10h]

  if ( !a1 )
    return 22;
  v1 = *a1;
  if ( !*a1 )
    return 22;
  if ( v1 == -1 )
    return 0;
  result = 22;
  if ( *(_DWORD *)v1 == -1061506563 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
    v3 = *(_DWORD *)(v1 + 12);
    if ( v3 )
    {
      v4 = *(_DWORD *)(v1 + 8);
      if ( v4 )
      {
        *(_DWORD *)(v1 + 8) = 0;
        *(_DWORD *)(v1 + 12) = v4 + v3;
        goto LABEL_10;
      }
    }
    else if ( *(_DWORD *)(v1 + 8) > *(_DWORD *)(v1 + 16) )
    {
      v5 = do_sema_b_wait(
             *(void **)(v1 + 104),
             1,
             0xFFFFFFFF,
             (LPCRITICAL_SECTION)(v1 + 72),
             (volatile signed __int32 *)(v1 + 96));
      if ( v5 )
      {
        v7 = v5;
        LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
        return v7;
      }
      v6 = *(_DWORD *)(v1 + 16);
      v4 = *(_DWORD *)(v1 + 8);
      if ( v6 )
      {
        v4 -= v6;
        *(_DWORD *)(v1 + 16) = 0;
      }
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = v4;
LABEL_10:
      LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
      return do_sema_b_release(
               (LPCRITICAL_SECTION)(v1 + 44),
               v4,
               *(void **)(v1 + 100),
               (volatile signed __int32 *)(v1 + 68));
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
    return 0;
  }
  return result;
}

//----- (0041E300) --------------------------------------------------------
int __cdecl pthread_cond_wait(int *a1, volatile signed __int32 *a2)
{
  int v2; // ebx
  int result; // eax
  LPCRITICAL_SECTION lpCriticalSection; // [esp+0h] [ebp-4Ch] BYREF
  int v5; // [esp+14h] [ebp-38h] BYREF
  int v6[3]; // [esp+18h] [ebp-34h] BYREF
  int (__cdecl *v7)(int *); // [esp+24h] [ebp-28h] BYREF
  int *v8; // [esp+28h] [ebp-24h]
  int v9; // [esp+2Ch] [ebp-20h]

  if ( !a1 )
    return 22;
  v2 = *a1;
  if ( !*a1 )
    return 22;
  if ( v2 == -1 )
  {
    result = cond_static_init(a1);
    v5 = result;
    if ( (result & 0xFFFFFFEF) != 0 )
      return result;
    v2 = *a1;
  }
  else
  {
    result = 22;
    if ( *(_DWORD *)v2 != -1061506563 )
      return result;
  }
  result = do_sema_b_wait(
             *(void **)(v2 + 104),
             0,
             0xFFFFFFFF,
             (LPCRITICAL_SECTION)(v2 + 72),
             (volatile signed __int32 *)(v2 + 96));
  v5 = result;
  if ( !result )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v2 + 20));
    ++*(_DWORD *)(v2 + 8);
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 20));
    result = do_sema_b_release(
               (LPCRITICAL_SECTION)(v2 + 72),
               1,
               *(void **)(v2 + 104),
               (volatile signed __int32 *)(v2 + 96));
    v5 = result;
    if ( !result )
    {
      v6[0] = v2;
      v7 = cleanup_wait;
      v6[2] = (int)&v5;
      v6[1] = (int)a2;
      v8 = v6;
      v9 = *(_DWORD *)pthread_getclean();
      _InterlockedOr((volatile signed __int32 *)&lpCriticalSection, 0);
      *(_DWORD *)pthread_getclean() = &v7;
      _InterlockedOr((volatile signed __int32 *)&lpCriticalSection, 0);
      v5 = pthread_mutex_unlock(a2);
      if ( !v5 )
        v5 = do_sema_b_wait(
               *(void **)(v2 + 100),
               0,
               0xFFFFFFFF,
               (LPCRITICAL_SECTION)(v2 + 44),
               (volatile signed __int32 *)(v2 + 68));
      *(_DWORD *)pthread_getclean() = v9;
      v7(v8);
      return v5;
    }
  }
  return result;
}

//----- (0041E470) --------------------------------------------------------
int __cdecl cleanup_wait(int *a1)
{
  int v1; // ebx
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // edi
  int v3; // ebp
  int result; // eax
  int v5; // eax
  int v6; // eax
  LPCRITICAL_SECTION v7; // [esp+18h] [ebp-24h]
  int v8; // [esp+1Ch] [ebp-20h]

  v1 = *a1;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(*a1 + 20);
  EnterCriticalSection(lpCriticalSection);
  v3 = *(_DWORD *)(v1 + 12);
  if ( v3 )
  {
    *(_DWORD *)(v1 + 12) = v3 - 1;
    LeaveCriticalSection(lpCriticalSection);
    if ( v3 == 1
      && (result = do_sema_b_release(
                     (LPCRITICAL_SECTION)(v1 + 72),
                     1,
                     *(void **)(v1 + 104),
                     (volatile signed __int32 *)(v1 + 96))) != 0
      || (result = pthread_mutex_lock((volatile signed __int32 *)a1[1])) != 0 )
    {
LABEL_5:
      *(_DWORD *)a1[2] = result;
    }
  }
  else
  {
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 == 1073741822 )
    {
      *(_DWORD *)(v1 + 16) = 0x3FFFFFFF;
      v8 = do_sema_b_wait(
             *(void **)(v1 + 104),
             1,
             0xFFFFFFFF,
             (LPCRITICAL_SECTION)(v1 + 72),
             (volatile signed __int32 *)(v1 + 96));
      if ( v8 )
      {
        LeaveCriticalSection(lpCriticalSection);
        result = v8;
        *(_DWORD *)a1[2] = v8;
        return result;
      }
      *(_DWORD *)(v1 + 8) -= *(_DWORD *)(v1 + 16);
      v6 = do_sema_b_release(
             (LPCRITICAL_SECTION)(v1 + 72),
             1,
             *(void **)(v1 + 104),
             (volatile signed __int32 *)(v1 + 96));
      if ( v6 )
      {
        v7 = (LPCRITICAL_SECTION)v6;
        LeaveCriticalSection(lpCriticalSection);
        result = (int)v7;
        *(_DWORD *)a1[2] = v7;
        return result;
      }
      *(_DWORD *)(v1 + 16) = 0;
    }
    else
    {
      *(_DWORD *)(v1 + 16) = v5 + 1;
    }
    LeaveCriticalSection(lpCriticalSection);
    result = pthread_mutex_lock((volatile signed __int32 *)a1[1]);
    if ( result )
      goto LABEL_5;
  }
  return result;
}

//----- (0041E5B0) --------------------------------------------------------
int __usercall pthread_cond_timedwait_impl@<eax>(
        int *a1@<eax>,
        volatile signed __int32 *a2@<edx>,
        struct _RTL_CRITICAL_SECTION *a3@<ecx>,
        int a4)
{
  int v4; // ebx
  int result; // eax
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax
  LPCRITICAL_SECTION v10; // [esp+0h] [ebp-5Ch] BYREF
  DWORD v11; // [esp+1Ch] [ebp-40h]
  int v12; // [esp+24h] [ebp-38h] BYREF
  int v13[3]; // [esp+28h] [ebp-34h] BYREF
  int (__cdecl *v14)(int *); // [esp+34h] [ebp-28h] BYREF
  int *v15; // [esp+38h] [ebp-24h]
  int v16; // [esp+3Ch] [ebp-20h]

  if ( !a1 )
    return 22;
  v4 = *a1;
  if ( !*a1 )
    return 22;
  if ( v4 == -1 )
  {
    v11 = (DWORD)a3;
    result = cond_static_init(a1);
    v12 = result;
    if ( (result & 0xFFFFFFEF) != 0 )
      return result;
    v4 = *a1;
    a3 = (struct _RTL_CRITICAL_SECTION *)v11;
  }
  else
  {
    result = 22;
    if ( *(_DWORD *)v4 != -1061506563 )
      return result;
  }
  v10 = a3;
  if ( a4 )
  {
    v9 = _pthread_time_in_ms_from_timespec((int *)v10);
    if ( v9 < 0xFFFFFFFF )
    {
      v11 = v9;
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  v8 = _pthread_rel_time_in_ms((int *)v10);
  if ( HIDWORD(v8) || (v11 = v8, (_DWORD)v8 == -1) )
LABEL_8:
    v11 = -1;
LABEL_9:
  result = do_sema_b_wait(
             *(void **)(v4 + 104),
             0,
             0xFFFFFFFF,
             (LPCRITICAL_SECTION)(v4 + 72),
             (volatile signed __int32 *)(v4 + 96));
  v12 = result;
  if ( !result )
  {
    ++*(_DWORD *)(v4 + 8);
    result = do_sema_b_release(
               (LPCRITICAL_SECTION)(v4 + 72),
               1,
               *(void **)(v4 + 104),
               (volatile signed __int32 *)(v4 + 96));
    v12 = result;
    if ( !result )
    {
      v13[0] = v4;
      v13[1] = (int)a2;
      v14 = cleanup_wait;
      v13[2] = (int)&v12;
      v15 = v13;
      v16 = *(_DWORD *)pthread_getclean();
      _InterlockedOr((volatile signed __int32 *)&v10, 0);
      *(_DWORD *)pthread_getclean() = &v14;
      _InterlockedOr((volatile signed __int32 *)&v10, 0);
      v12 = pthread_mutex_unlock(a2);
      if ( !v12 )
        v12 = do_sema_b_wait(
                *(void **)(v4 + 100),
                0,
                v11,
                (LPCRITICAL_SECTION)(v4 + 44),
                (volatile signed __int32 *)(v4 + 68));
      *(_DWORD *)pthread_getclean() = v16;
      v14(v15);
      return v12;
    }
  }
  return result;
}

//----- (0041E760) --------------------------------------------------------
int __cdecl pthread_cond_timedwait(int *a1, volatile signed __int32 *a2, struct _RTL_CRITICAL_SECTION *a3)
{
  return pthread_cond_timedwait_impl(a1, a2, a3, 0);
}

//----- (0041E780) --------------------------------------------------------
int __cdecl pthread_cond_timedwait_relative_np(int *a1, volatile signed __int32 *a2, struct _RTL_CRITICAL_SECTION *a3)
{
  return pthread_cond_timedwait_impl(a1, a2, a3, 1);
}

//----- (0041E7C0) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
  void (*v0)(void); // eax

  v0 = (void (*)(void))(*data_2)[0];
  if ( (*data_2)[0] )
  {
    do
    {
      v0();
      v0 = (void (*)(void))(*data_2)[1];
      data_2 = (int (*)[120])((char *)data_2 + 4);
    }
    while ( v0 );
  }
}
// 50CF3C: using guessed type int (*data_2)[120];

//----- (0041E800) --------------------------------------------------------
int __do_global_ctors()
{
  func_ptr i; // ebx

  i = __CTOR_LIST__[0];
  if ( __CTOR_LIST__[0] == (func_ptr)-1 )
  {
    for ( i = 0; __CTOR_LIST__[(_DWORD)i + 1]; i = (func_ptr)((char *)i + 1) )
      ;
  }
  for ( ; i; i = (func_ptr)((char *)i - 1) )
    __CTOR_LIST__[(_DWORD)i]();
  return atexit(__do_global_dtors);
}

//----- (0041E850) --------------------------------------------------------
int __main()
{
  int result; // eax

  result = bss_1;
  if ( !bss_1 )
  {
    bss_1 = 1;
    return __do_global_ctors();
  }
  return result;
}
// 536A8C: using guessed type int bss_1;

//----- (0041E880) --------------------------------------------------------
int _setargv()
{
  return 0;
}

//----- (0041E890) --------------------------------------------------------
void __cdecl __security_init_cookie()
{
  DWORD v0; // ebx
  DWORD CurrentProcessId; // ebp
  DWORD CurrentThreadId; // edi
  DWORD TickCount; // esi
  uintptr_t v4; // eax
  int v5; // edx
  struct _FILETIME SystemTimeAsFileTime; // [esp+10h] [ebp-2Ch] BYREF
  LARGE_INTEGER PerformanceCount; // [esp+18h] [ebp-24h] BYREF

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie == -1153374642 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v0 = SystemTimeAsFileTime.dwHighDateTime ^ SystemTimeAsFileTime.dwLowDateTime;
    CurrentProcessId = GetCurrentProcessId();
    CurrentThreadId = GetCurrentThreadId();
    TickCount = GetTickCount();
    QueryPerformanceCounter(&PerformanceCount);
    v4 = TickCount ^ CurrentThreadId ^ CurrentProcessId ^ PerformanceCount.HighPart ^ v0 ^ PerformanceCount.LowPart;
    if ( v4 == -1153374642 )
    {
      v5 = 1153374640;
      v4 = -1153374641;
    }
    else
    {
      v5 = ~v4;
    }
    __security_cookie = v4;
    __security_cookie_complement = v5;
  }
  else
  {
    __security_cookie_complement = ~__security_cookie;
  }
}
// 50CFA4: using guessed type int __security_cookie_complement;

//----- (0041E940) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure()
{
  HANDLE CurrentProcess; // eax
  int retaddr; // [esp+2Ch] [ebp+4h] BYREF
  int v2; // [esp+30h] [ebp+8h]

  GS_ExceptionRecord = -1073740791;
  dword_536D84 = 1;
  dword_536B64 = (int)&retaddr;
  dword_536B58 = retaddr;
  dword_536D8C = retaddr;
  dword_536B4C = v2;
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&GS_ExceptionPointers);
  CurrentProcess = GetCurrentProcess();
  TerminateProcess(CurrentProcess, 0xC0000409);
  abort();
}
// 50CFA4: using guessed type int __security_cookie_complement;
// 536B4C: using guessed type int dword_536B4C;
// 536B58: using guessed type int dword_536B58;
// 536B64: using guessed type int dword_536B64;
// 536D80: using guessed type int GS_ExceptionRecord;
// 536D84: using guessed type int dword_536D84;
// 536D8C: using guessed type int dword_536D8C;

//----- (0041E9D0) --------------------------------------------------------
int __stdcall __dyn_tls_dtor(int a1, int a2, int a3)
{
  if ( a2 != 3 && a2 )
    return 1;
  __mingw_TLScallback(a1, a2);
  return 1;
}

//----- (0041EA20) --------------------------------------------------------
int __stdcall __dyn_tls_init(int a1, int a2, int a3)
{
  if ( _CRT_MT != 2 )
    _CRT_MT = 2;
  if ( a2 == 1 )
    __mingw_TLScallback(a1, 1);
  return 1;
}
// 50CF50: using guessed type int _CRT_MT;

//----- (0041EAB0) --------------------------------------------------------
int __tlregdtor()
{
  return 0;
}

//----- (0041EAC0) --------------------------------------------------------
int (__cdecl *__cdecl __mingw_raise_matherr(int a1, int a2, double a3, double a4, double a5))(_DWORD)
{
  int (__cdecl *result)(_DWORD); // eax
  int v6[2]; // [esp+10h] [ebp-2Ch] BYREF
  double v7; // [esp+18h] [ebp-24h]
  double v8; // [esp+20h] [ebp-1Ch]
  double v9; // [esp+28h] [ebp-14h]

  result = stUserMathErr;
  if ( stUserMathErr )
  {
    v7 = a3;
    v8 = a4;
    v6[0] = a1;
    v9 = a5;
    v6[1] = a2;
    return (int (__cdecl *)(_DWORD))stUserMathErr(v6);
  }
  return result;
}
// 536DF4: using guessed type int (__cdecl *stUserMathErr)(_DWORD);

//----- (0041EB10) --------------------------------------------------------
void __cdecl __mingw_setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction)
{
  stUserMathErr = (int (__cdecl *)(_DWORD))UserMathErrorFunction;
  __setusermatherr(UserMathErrorFunction);
}
// 536DF4: using guessed type int (__cdecl *stUserMathErr)(_DWORD);

//----- (0041EB20) --------------------------------------------------------
int __cdecl _matherr(struct _exception *Except)
{
  const char *v1; // ebx
  unsigned int v2; // edx
  char *name; // esi
  FILE *v4; // eax
  double arg1; // [esp+38h] [ebp-24h]
  double arg2; // [esp+40h] [ebp-1Ch]
  double retval; // [esp+48h] [ebp-14h]

  v1 = "Unknown error";
  v2 = Except->type - 1;
  if ( v2 <= 5 )
    v1 = CSWTCH_5[v2];
  name = Except->name;
  retval = Except->retval;
  arg2 = Except->arg2;
  arg1 = Except->arg1;
  v4 = __acrt_iob_func(2u);
  fprintf(v4, "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", v1, name, arg1, arg2, retval);
  return 0;
}
// 51161C: using guessed type char *CSWTCH_5[6];

//----- (0041EBA0) --------------------------------------------------------
void __cdecl fpreset()
{
  __asm { fninit }
}

//----- (0041EBB0) --------------------------------------------------------
int __cdecl _decode_pointer(int a1)
{
  return a1;
}

//----- (0041EBC0) --------------------------------------------------------
int __cdecl _encode_pointer(int a1)
{
  return a1;
}

//----- (0041EBD0) --------------------------------------------------------
unsigned int __usercall mark_section_writable@<eax>(unsigned int result@<eax>)
{
  int v1; // esi
  int v2; // ebx
  unsigned int *v3; // edx
  const void *v4; // ebx
  int SectionForAddress; // edi
  int v6; // ebx
  _DWORD *v7; // eax
  const void *lpAddress; // eax
  DWORD *lpflOldProtect; // ebx
  PVOID BaseAddress; // eax
  SIZE_T RegionSize; // edx
  DWORD LastError; // eax
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+14h] [ebp-28h] BYREF

  v1 = maxSections;
  if ( maxSections <= 0 )
  {
    v1 = 0;
LABEL_6:
    v4 = (const void *)result;
    SectionForAddress = __mingw_GetSectionForAddress(result);
    if ( !SectionForAddress )
      __report_error("Address %p has no image-section", v4);
    v6 = 20 * v1;
    v7 = (_DWORD *)(20 * v1 + the_secs);
    v7[4] = SectionForAddress;
    *v7 = 0;
    lpAddress = (const void *)(*(_DWORD *)(SectionForAddress + 12) + _GetPEImageBase());
    *(_DWORD *)(the_secs + 20 * v1 + 12) = lpAddress;
    if ( !VirtualQuery(lpAddress, &Buffer, 0x1Cu) )
      __report_error(
        "  VirtualQuery failed for %d bytes at address %p",
        *(_DWORD *)(SectionForAddress + 8),
        *(const void **)(the_secs + v6 + 12));
    result = Buffer.Protect;
    if ( ((Buffer.Protect - 64) & 0xFFFFFFBF) != 0 )
    {
      result = (Buffer.Protect - 4) & 0xFFFFFFFB;
      if ( result )
      {
        lpflOldProtect = (DWORD *)(the_secs + v6);
        BaseAddress = Buffer.BaseAddress;
        RegionSize = Buffer.RegionSize;
        lpflOldProtect[1] = (DWORD)Buffer.BaseAddress;
        lpflOldProtect[2] = RegionSize;
        result = VirtualProtect(BaseAddress, RegionSize, 0x40u, lpflOldProtect);
        if ( !result )
        {
          LastError = GetLastError();
          __report_error("  VirtualProtect failed with code 0x%x", LastError);
        }
      }
    }
    ++maxSections;
  }
  else
  {
    v2 = 0;
    v3 = (unsigned int *)(the_secs + 12);
    while ( *v3 > result || result >= *(_DWORD *)(v3[1] + 8) + *v3 )
    {
      ++v2;
      v3 += 5;
      if ( v2 == maxSections )
        goto LABEL_6;
    }
  }
  return result;
}
// 536E00: using guessed type int maxSections;
// 536E04: using guessed type int the_secs;

//----- (0041ED20) --------------------------------------------------------
void _pei386_runtime_relocator()
{
  int v0; // eax
  void *v1; // esp
  void *v2; // esp
  int v3; // [esp+10h] [ebp-38h] BYREF

  if ( !was_init_67496 )
  {
    was_init_67496 = 1;
    v0 = (20 * __mingw_GetSectionCount() + 30) & 0xFFFFFFF0;
    v1 = alloca(v0);
    maxSections = 0;
    v2 = alloca(v0);
    the_secs = (int)&v3;
  }
}
// 516944: using guessed type int dword_516944;
// 536DFC: using guessed type int was_init_67496;
// 536E00: using guessed type int maxSections;
// 536E04: using guessed type int the_secs;

//----- (0041EFA0) --------------------------------------------------------
LONG __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  DWORD ExceptionCode; // eax
  _crt_signal_t v2; // eax
  _crt_signal_t v4; // eax
  _crt_signal_t v5; // eax

  ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
  if ( ExceptionCode > 0xC0000091 )
  {
    if ( ExceptionCode == -1073741676 )
    {
      v4 = signal(8, 0);
      if ( v4 == (_crt_signal_t)1 )
      {
        signal(8, (_crt_signal_t)1);
        return -1;
      }
LABEL_11:
      if ( v4 )
      {
        v4(8);
        return -1;
      }
      goto LABEL_12;
    }
    if ( ExceptionCode == -1073741674 )
      goto LABEL_17;
    if ( ExceptionCode != -1073741677 )
      goto LABEL_12;
LABEL_10:
    v4 = signal(8, 0);
    if ( v4 == (_crt_signal_t)1 )
    {
      signal(8, (_crt_signal_t)1);
      fpreset();
      return -1;
    }
    goto LABEL_11;
  }
  if ( ExceptionCode >= 0xC000008D )
    goto LABEL_10;
  if ( ExceptionCode != -1073741819 )
  {
    if ( ExceptionCode != -1073741795 )
      goto LABEL_12;
LABEL_17:
    v5 = signal(4, 0);
    if ( v5 == (_crt_signal_t)1 )
    {
      signal(4, (_crt_signal_t)1);
      return -1;
    }
    if ( v5 )
    {
      v5(4);
      return -1;
    }
    goto LABEL_12;
  }
  v2 = signal(11, 0);
  if ( v2 == (_crt_signal_t)1 )
  {
    signal(11, (_crt_signal_t)1);
    return -1;
  }
  if ( v2 )
  {
    v2(11);
    return -1;
  }
LABEL_12:
  if ( __mingw_oldexcpt_handler )
    return __mingw_oldexcpt_handler(ExceptionInfo);
  else
    return 0;
}
// 536E0C: using guessed type int (__stdcall *__mingw_oldexcpt_handler)(_DWORD);

//----- (0041F140) --------------------------------------------------------
void __mingwthr_run_key_dtors_part_0()
{
  DWORD *v0; // ebx
  LPVOID Value; // esi

  EnterCriticalSection(&__mingwthr_cs);
  v0 = (DWORD *)key_dtor_list;
  if ( key_dtor_list )
  {
    do
    {
      Value = TlsGetValue(*v0);
      if ( !GetLastError() && Value )
        ((void (__cdecl *)(LPVOID))v0[1])(Value);
      v0 = (DWORD *)v0[2];
    }
    while ( v0 );
  }
  LeaveCriticalSection(&__mingwthr_cs);
}

//----- (0041F1B0) --------------------------------------------------------
int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2)
{
  int v2; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  void *v6; // eax

  v2 = 0;
  if ( !__mingwthr_cs_init )
    return v2;
  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( !v4 )
    return -1;
  *v4 = a1;
  v4[1] = a2;
  EnterCriticalSection(&__mingwthr_cs);
  v6 = key_dtor_list;
  key_dtor_list = v5;
  v5[2] = v6;
  LeaveCriticalSection(&__mingwthr_cs);
  return 0;
}
// 536E14: using guessed type int __mingwthr_cs_init;

//----- (0041F240) --------------------------------------------------------
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1)
{
  _DWORD *v2; // edx
  _DWORD *v3; // eax

  if ( !__mingwthr_cs_init )
    return 0;
  EnterCriticalSection(&__mingwthr_cs);
  v2 = key_dtor_list;
  if ( key_dtor_list )
  {
    if ( a1 == *(_DWORD *)key_dtor_list )
    {
      key_dtor_list = (void *)*((_DWORD *)key_dtor_list + 2);
      v3 = v2;
LABEL_11:
      free(v3);
    }
    else
    {
      while ( 1 )
      {
        v3 = (_DWORD *)v2[2];
        if ( !v3 )
          break;
        if ( *v3 == a1 )
        {
          v2[2] = v3[2];
          goto LABEL_11;
        }
        v2 = (_DWORD *)v2[2];
      }
    }
  }
  LeaveCriticalSection(&__mingwthr_cs);
  return 0;
}
// 536E14: using guessed type int __mingwthr_cs_init;

//----- (0041F2D0) --------------------------------------------------------
int __cdecl __mingw_TLScallback(int a1, int a2)
{
  _DWORD *Block; // eax
  _DWORD *v4; // ebx

  if ( a2 == 1 )
  {
    if ( !__mingwthr_cs_init )
      InitializeCriticalSection(&__mingwthr_cs);
    __mingwthr_cs_init = 1;
    return 1;
  }
  else
  {
    if ( a2 )
    {
      if ( a2 == 2 )
      {
        fpreset();
      }
      else if ( a2 == 3 )
      {
        if ( __mingwthr_cs_init )
          __mingwthr_run_key_dtors_part_0();
      }
    }
    else
    {
      if ( __mingwthr_cs_init )
        __mingwthr_run_key_dtors_part_0();
      if ( __mingwthr_cs_init == 1 )
      {
        Block = key_dtor_list;
        if ( key_dtor_list )
        {
          do
          {
            v4 = (_DWORD *)Block[2];
            free(Block);
            Block = v4;
          }
          while ( v4 );
        }
        key_dtor_list = 0;
        __mingwthr_cs_init = 0;
        DeleteCriticalSection(&__mingwthr_cs);
      }
    }
    return 1;
  }
}
// 536E14: using guessed type int __mingwthr_cs_init;

//----- (0041F3B0) --------------------------------------------------------
BOOL __usercall _ValidateImageBase_part_0@<eax>(int a1@<eax>)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 60) + a1;
  return *(_DWORD *)v1 == 17744 && *(_WORD *)(v1 + 24) == 267;
}

//----- (0041F3D0) --------------------------------------------------------
BOOL __cdecl _ValidateImageBase(_WORD *a1)
{
  return *a1 == 23117 && _ValidateImageBase_part_0((int)a1);
}

//----- (0041F3F0) --------------------------------------------------------
int __cdecl _FindPESection(int a1, unsigned int a2)
{
  int v2; // edx
  int v3; // esi
  int result; // eax
  int v5; // ecx
  unsigned int v6; // edx

  v2 = *(_DWORD *)(a1 + 60) + a1;
  v3 = *(unsigned __int16 *)(v2 + 6);
  result = v2 + *(unsigned __int16 *)(v2 + 20) + 24;
  if ( !*(_WORD *)(v2 + 6) )
    return 0;
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)(result + 12);
    if ( v6 <= a2 && *(_DWORD *)(result + 8) + v6 > a2 )
      break;
    ++v5;
    result += 40;
    if ( v5 == v3 )
      return 0;
  }
  return result;
}

//----- (0041F430) --------------------------------------------------------
const char *__cdecl _FindPESectionByName(char *Str)
{
  int v1; // ebp
  const char *v2; // ebx
  int v3; // esi

  if ( strlen(Str) > 8 )
    return 0;
  if ( MEMORY[0x400000] != 23117 )
    return 0;
  if ( !_ValidateImageBase_part_0(0x400000) )
    return 0;
  v1 = *(unsigned __int16 *)(MEMORY[0x40003C] + 4194310);
  v2 = (const char *)(MEMORY[0x40003C] + 0x400000 + *(unsigned __int16 *)(MEMORY[0x40003C] + 4194324) + 24);
  if ( !*(_WORD *)(MEMORY[0x40003C] + 4194310) )
    return 0;
  v3 = 0;
  while ( strncmp(v2, Str, 8u) )
  {
    ++v3;
    v2 += 40;
    if ( v3 == v1 )
      return 0;
  }
  return v2;
}

//----- (0041F4C0) --------------------------------------------------------
int __cdecl __mingw_GetSectionForAddress(int a1)
{
  unsigned int v1; // ebx
  int result; // eax
  int v3; // ecx
  unsigned int v4; // edx

  if ( MEMORY[0x400000] != 23117 )
    return 0;
  if ( !_ValidateImageBase_part_0(0x400000) )
    return 0;
  v1 = a1 - 0x400000;
  result = MEMORY[0x40003C] + 0x400000 + *(unsigned __int16 *)(MEMORY[0x40003C] + 4194324) + 24;
  if ( !*(_WORD *)(MEMORY[0x40003C] + 4194310) )
    return 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_DWORD *)(result + 12);
    if ( v1 >= v4 && v1 < *(_DWORD *)(result + 8) + v4 )
      break;
    ++v3;
    result += 40;
    if ( v3 == *(unsigned __int16 *)(MEMORY[0x40003C] + 4194310) )
      return 0;
  }
  return result;
}

//----- (0041F530) --------------------------------------------------------
int __mingw_GetSectionCount()
{
  int v0; // edx

  v0 = 0;
  if ( MEMORY[0x400000] == 23117 && _ValidateImageBase_part_0(0x400000) )
    return *(unsigned __int16 *)(MEMORY[0x40003C] + 4194310);
  else
    return v0;
}
// 41F53D: variable 'v0' is possibly undefined

//----- (0041F560) --------------------------------------------------------
int _FindPESectionExec()
{
  int v0; // ecx
  int result; // eax
  int v2; // edx

  if ( MEMORY[0x400000] == 23117 )
  {
    if ( _ValidateImageBase_part_0(0x400000) )
    {
      result = MEMORY[0x40003C] + 0x400000 + *(unsigned __int16 *)(MEMORY[0x40003C] + 4194324) + 24;
      if ( *(_WORD *)(MEMORY[0x40003C] + 4194310) )
      {
        v2 = 0;
        do
        {
          if ( (*(_BYTE *)(result + 39) & 0x20) != 0 )
          {
            if ( !v0 )
              return result;
            --v0;
          }
          ++v2;
          result += 40;
        }
        while ( v2 != *(unsigned __int16 *)(MEMORY[0x40003C] + 4194310) );
      }
    }
  }
  return 0;
}
// 41F5A8: variable 'v0' is possibly undefined

//----- (0041F5C0) --------------------------------------------------------
int _GetPEImageBase()
{
  bool v0; // zf
  int result; // eax

  if ( MEMORY[0x400000] != 23117 )
    return 0;
  v0 = !_ValidateImageBase_part_0(0x400000);
  result = 0x400000;
  if ( v0 )
    return 0;
  return result;
}

//----- (0041F5F0) --------------------------------------------------------
BOOL __cdecl _IsNonwritableInCurrentImage(int a1)
{
  BOOL result; // eax
  unsigned int v2; // ebx
  _DWORD *v3; // eax
  int v4; // ecx
  unsigned int v5; // edx

  result = 0;
  if ( MEMORY[0x400000] == 23117 )
  {
    result = _ValidateImageBase_part_0(0x400000);
    if ( result )
    {
      v2 = a1 - 0x400000;
      v3 = (_DWORD *)(MEMORY[0x40003C] + 0x400000 + *(unsigned __int16 *)(MEMORY[0x40003C] + 4194324) + 24);
      if ( *(_WORD *)(MEMORY[0x40003C] + 4194310) )
      {
        v4 = 0;
        while ( 1 )
        {
          v5 = v3[3];
          if ( v2 >= v5 && v2 < v3[2] + v5 )
            break;
          ++v4;
          v3 += 10;
          if ( v4 == *(unsigned __int16 *)(MEMORY[0x40003C] + 4194310) )
            return 0;
        }
        return v3[9] >= 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (0041F670) --------------------------------------------------------
int __cdecl __mingw_enum_import_library_names(int a1)
{
  unsigned int v2; // edx
  int v3; // ecx
  int v4; // esi
  unsigned int v5; // eax
  unsigned int v7; // eax

  if ( MEMORY[0x400000] == 23117 )
  {
    if ( _ValidateImageBase_part_0(0x400000) )
    {
      v2 = *(_DWORD *)(MEMORY[0x40003C] + 4194432);
      if ( v2 )
      {
        v3 = MEMORY[0x40003C] + 0x400000 + *(unsigned __int16 *)(MEMORY[0x40003C] + 4194324) + 24;
        if ( *(_WORD *)(MEMORY[0x40003C] + 4194310) )
        {
          v4 = 0;
          while ( 1 )
          {
            v5 = *(_DWORD *)(v3 + 12);
            if ( v2 >= v5 && v2 < *(_DWORD *)(v3 + 8) + v5 )
              break;
            ++v4;
            v3 += 40;
            if ( v4 == *(unsigned __int16 *)(MEMORY[0x40003C] + 4194310) )
              return 0;
          }
          v7 = v2 + 0x400000;
          if ( v2 != -4194304 )
          {
            while ( *(_DWORD *)(v7 + 4) || *(_DWORD *)(v7 + 12) )
            {
              if ( a1 <= 0 )
                return *(_DWORD *)(v7 + 12) + 0x400000;
              --a1;
              v7 += 20;
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (0041F8A0) --------------------------------------------------------
DItype __cdecl __divmoddi4(DItype u, DItype v, DItype *rp)
{
  int v3; // edi
  unsigned __int64 v4; // rax
  unsigned int v5; // esi
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // edx
  unsigned __int64 v9; // rt2
  unsigned int v10; // edi
  int v11; // ecx
  int v12; // ebx
  unsigned int v13; // esi
  DItype result; // rax
  unsigned __int64 v15; // rtt
  unsigned int v16; // edi
  int v17; // esi
  unsigned __int64 v18; // rtt
  unsigned int v19; // ebp
  int v20; // ecx
  int v21; // ebx
  char v22; // cl
  unsigned int v23; // eax
  unsigned int v24; // edx
  SItype c2; // [esp+4h] [ebp-38h]
  unsigned int v26; // [esp+8h] [ebp-34h]
  int v27; // [esp+8h] [ebp-34h]
  unsigned int v28; // [esp+Ch] [ebp-30h]
  int v29; // [esp+Ch] [ebp-30h]
  unsigned int v30; // [esp+Ch] [ebp-30h]
  int v31; // [esp+10h] [ebp-2Ch]
  unsigned int v32; // [esp+14h] [ebp-28h]
  unsigned int v33; // [esp+18h] [ebp-24h]
  char v34; // [esp+1Ch] [ebp-20h]

  v3 = u;
  c2 = 0;
  v4 = v;
  v26 = HIDWORD(u);
  if ( u < 0 )
  {
    v3 = -(int)u;
    c2 = -1;
    v26 = (unsigned __int64)-u >> 32;
  }
  v5 = HIDWORD(v);
  v31 = c2;
  if ( v < 0 )
  {
    v31 = ~c2;
    v4 = -v;
    v5 = (unsigned __int64)-v >> 32;
  }
  v6 = v4;
  v28 = v3;
  LODWORD(v4) = v3;
  if ( v5 )
  {
    if ( v5 <= v26 )
    {
      _BitScanReverse(&v16, v5);
      v10 = v16 ^ 0x1F;
      if ( v10 )
      {
        v34 = 32 - v10;
        v17 = (v6 >> (32 - v10)) | (v5 << v10);
        v32 = v6 << v10;
        LODWORD(v18) = (v26 << v10) | (v28 >> (32 - v10));
        HIDWORD(v18) = v26 >> (32 - v10);
        v19 = v18 % (unsigned int)v17;
        v33 = v28 << v10;
        v20 = v18 / (unsigned int)v17;
        v27 = v20;
        v30 = ((v6 << v10) * (unsigned __int64)(unsigned int)v20) >> 32;
        v21 = (v6 << v10) * v20;
        if ( __PAIR64__(v19, v33) < __PAIR64__(v30, v21) )
        {
          v27 = v20 - 1;
          v30 = (__PAIR64__(v30, v21) - __PAIR64__(v17, v32)) >> 32;
          v21 -= v32;
        }
        v22 = v10;
        v10 = 0;
        v23 = (v33 - v21) >> v22;
        v24 = (unsigned int)((__PAIR64__(v19, v33) - __PAIR64__(v30, v21)) >> 32) >> v22;
        v11 = v27;
        v13 = v24;
        v12 = v23 | ((__PAIR64__(v19, v33) - __PAIR64__(v30, v21)) >> 32 << v34);
      }
      else
      {
        if ( v5 < v26 || (v11 = 0, v6 <= v28) )
        {
          v11 = 1;
          v4 = __PAIR64__(v26, v28) - __PAIR64__(v5, v6);
          v26 = (__PAIR64__(v26, v28) - __PAIR64__(v5, v6)) >> 32;
        }
        v12 = v4;
        v13 = v26;
      }
    }
    else
    {
      v12 = v3;
      v13 = v26;
      v10 = 0;
      v11 = 0;
    }
  }
  else
  {
    HIDWORD(v4) = v26;
    if ( v6 <= v26 )
    {
      if ( !v6 )
        v6 = 1 / 0u;
      v10 = v26 / v6;
      LODWORD(v15) = v28;
      HIDWORD(v15) = v26 % v6;
      v8 = v15 % v6;
      v29 = v15 / v6;
    }
    else
    {
      v9 = v4 % v6;
      v7 = v4 / v6;
      v8 = v9;
      v29 = v7;
      v10 = 0;
    }
    v11 = v29;
    v12 = v8;
    v13 = 0;
  }
  result = __PAIR64__(v10, v11);
  if ( v31 )
    result = -__SPAIR64__(v10, v11);
  if ( c2 )
  {
    v12 = -v12;
    v13 = (unsigned __int64)-__SPAIR64__(v13, v12) >> 32;
  }
  *(_DWORD *)rp = v12;
  *((_DWORD *)rp + 1) = v13;
  return result;
}

//----- (0041FCB0) --------------------------------------------------------
long double __cdecl __mingw_strtod(unsigned __int8 *a1, unsigned __int8 **a2)
{
  char v2; // al
  double v4; // [esp+28h] [ebp-24h]
  int v5; // [esp+34h] [ebp-18h] BYREF
  double v6; // [esp+38h] [ebp-14h] BYREF

  v2 = __strtodg(a1, a2, fpi_3876, &v5, (int *)&v6);
  switch ( v2 & 7 )
  {
    case 0:
    case 6:
      v4 = 0.0;
      break;
    case 1:
      LODWORD(v4) = LODWORD(v6);
      HIDWORD(v4) = HIDWORD(v6) & 0xFFEFFFFF | ((v5 + 1075) << 20);
      break;
    case 2:
      v4 = v6;
      break;
    case 3:
      v4 = INFINITY;
      break;
    case 4:
      v4 = NAN;
      break;
    case 5:
      *(_QWORD *)&v4 = *(_QWORD *)&v6 | 0x7FF0000000000000LL;
      break;
    default:
      break;
  }
  if ( (v2 & 8) != 0 )
    HIDWORD(v4) |= 0x80000000;
  return v4;
}
// 41FD14: variable 'v4' is possibly undefined
// 50CF54: using guessed type int fpi_3876[6];

//----- (0041FDB0) --------------------------------------------------------
int __cdecl __fpclassify(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = a2 & 0x7FF00000;
  result = 0x4000;
  if ( a2 & 0x7FF00000 | a1 | a2 & 0xFFFFF )
  {
    result = 17408;
    if ( v2 )
    {
      result = 1024;
      if ( v2 == 2146435072 )
        return (a1 | a2 & 0xFFFFF) == 0 ? 1280 : 256;
    }
  }
  return result;
}

//----- (0041FE10) --------------------------------------------------------
BOOL __cdecl isnan(double a1)
{
  __int16 v1; // fps

  _FST7 = a1;
  __asm { fxam }
  return (v1 & 0x4500) == 256;
}

//----- (0041FE30) --------------------------------------------------------
char *__cdecl mingw_getsp(char a1)
{
  return &a1;
}
// 41FE30: returning address of temporary local variable '%arg_0'

//----- (0041FE40) --------------------------------------------------------
char *__cdecl basename(char *Source)
{
  char *v1; // esi
  char *v2; // eax
  char *v3; // ebx
  size_t v4; // esi
  size_t v6; // edx
  void *v7; // esp
  void *v8; // esp
  wchar_t *v9; // edx
  wchar_t v10; // ax
  wchar_t v11; // ax
  __int16 v12; // ax
  wchar_t *v13; // ecx
  wchar_t *v14; // edx
  size_t v15; // eax
  size_t v16; // eax
  size_t v17; // edi
  int v18; // [esp+0h] [ebp-38h] BYREF
  wchar_t Dest[2]; // [esp+Ch] [ebp-2Ch] BYREF
  _DWORD v20[2]; // [esp+10h] [ebp-28h] BYREF
  size_t MaxCount; // [esp+18h] [ebp-20h]
  wchar_t *v22; // [esp+1Ch] [ebp-1Ch]

  v1 = Source;
  v2 = setlocale(2, 0);
  v3 = v2;
  if ( v2 )
    v3 = strdup(v2);
  setlocale(2, Locale);
  if ( !Source || !*Source )
    goto LABEL_5;
  v20[1] = &v18;
  v6 = mbstowcs(0, Source, 0);
  v7 = alloca(2 * v6 + 3);
  v8 = alloca(2 * v6 + 3);
  MaxCount = mbstowcs(Dest, Source, v6);
  v9 = Dest;
  if ( MaxCount > 1 && Dest[1] == 58 )
    v9 = (wchar_t *)v20;
  Dest[MaxCount] = 0;
  v10 = *v9;
  if ( !*v9 )
  {
LABEL_5:
    v4 = wcstombs(0, ::Source, 0) + 1;
    retfail_4182 = realloc(retfail_4182, v4);
    wcstombs((char *)retfail_4182, ::Source, v4);
    setlocale(2, v3);
    free(v3);
    return (char *)retfail_4182;
  }
  v22 = v9;
  do
  {
    if ( v10 != 47 && v10 != 92 )
    {
LABEL_12:
      v10 = v9[1];
      goto LABEL_13;
    }
    v11 = *v9;
    if ( *v9 == 92 || v11 == 47 )
    {
      do
      {
        do
          v11 = *++v9;
        while ( *v9 == 47 );
      }
      while ( v11 == 92 );
    }
    if ( v11 )
    {
      v10 = v9[1];
      v22 = v9;
    }
    else
    {
      if ( v22 >= v9 )
        goto LABEL_12;
      v12 = *(v9 - 1);
      v13 = v9 - 1;
      if ( v12 == 47 || v12 == 92 )
      {
        v14 = (wchar_t *)((char *)v9 + (~((unsigned int)v13 + 1 - (_DWORD)v22) & 0xFFFFFFFE));
        while ( 1 )
        {
          *v13 = 0;
          if ( v13 == v14 )
            break;
          if ( *--v13 != 92 && *v13 != 47 )
            goto LABEL_28;
        }
        v10 = v13[1];
        v9 = v13;
      }
      else
      {
        v10 = *v9--;
      }
    }
LABEL_13:
    ++v9;
  }
  while ( v10 );
LABEL_28:
  if ( *v22 )
  {
    v15 = wcstombs(Source, Dest, MaxCount);
    if ( v15 != -1 )
      Source[v15] = 0;
    *v22 = 0;
    v16 = wcstombs(0, Dest, 0);
    if ( v16 != -1 )
      v1 = &Source[v16];
  }
  else
  {
    v17 = wcstombs(0, L"/", 0) + 1;
    retfail_4182 = realloc(retfail_4182, v17);
    v1 = (char *)retfail_4182;
    wcstombs((char *)retfail_4182, L"/", v17);
  }
  setlocale(2, v3);
  free(v3);
  return v1;
}

//----- (00420100) --------------------------------------------------------
int __usercall permute_args@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // ebp
  __int64 v6; // rax
  int v7; // edx
  int v8; // ebx
  int v9; // eax
  int v10; // edx
  int result; // eax
  int v12; // ebp
  int v13; // edi
  int v14; // edx
  int v15; // ebx
  bool v16; // cc
  int *v17; // ebx
  int v18; // ecx
  int v19; // [esp+0h] [ebp-24h]
  int v21; // [esp+8h] [ebp-1Ch]
  int v22; // [esp+Ch] [ebp-18h]
  int v23; // [esp+10h] [ebp-14h]

  v5 = a3 - a2;
  v6 = a2 - a1;
  v22 = v6;
  v7 = v6 % v5;
  v21 = v5;
  if ( v7 )
  {
    v8 = v7;
    v9 = v5;
    while ( 1 )
    {
      v10 = v9 % v8;
      v9 = v8;
      if ( !v10 )
        break;
      v8 = v10;
    }
  }
  else
  {
    v8 = v5;
  }
  result = (a3 - a1) / v8;
  v19 = result;
  if ( v8 > 0 )
  {
    v12 = a2;
    v23 = a2 + v8;
    do
    {
      result = v12;
      if ( v19 > 0 )
      {
        v13 = *(_DWORD *)(a4 + 4 * v12);
        v14 = 0;
        do
        {
          v15 = result + v21;
          v16 = a2 <= result;
          result -= v22;
          if ( !v16 )
            result = v15;
          ++v14;
          v17 = (int *)(a4 + 4 * result);
          v18 = *v17;
          *v17 = v13;
          *(_DWORD *)(a4 + 4 * v12) = v18;
          v13 = v18;
        }
        while ( v19 != v14 );
      }
      ++v12;
    }
    while ( v23 != v12 );
  }
  return result;
}

//----- (004201B0) --------------------------------------------------------
int warnx(char *Format, ...)
{
  char *v1; // esi
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  va_list va; // [esp+24h] [ebp+8h] BYREF

  va_start(va, Format);
  v1 = **__p___argv();
  v2 = __acrt_iob_func(2u);
  fprintf(v2, "%s: ", v1);
  v3 = __acrt_iob_func(2u);
  vfprintf(v3, Format, va);
  v4 = __acrt_iob_func(2u);
  return fputc(10, v4);
}

//----- (00420230) --------------------------------------------------------
int __usercall parse_long_options@<eax>(int a1@<eax>, _BYTE *a2@<edx>, const char **a3@<ecx>, int *a4, int a5)
{
  char *v6; // ebx
  char *v7; // eax
  size_t MaxCount; // esi
  const char *Str; // ebp
  int v10; // ebx
  const char **v11; // eax
  int v12; // edx
  int result; // eax
  bool v14; // zf
  int v15; // eax
  const char **v16; // edi
  const char *v17; // eax
  int *v18; // edx
  char *v19; // edx
  int v20; // eax
  char *Str1; // [esp+1Ch] [ebp-40h]
  int v22; // [esp+20h] [ebp-3Ch]
  _BYTE v23[5]; // [esp+27h] [ebp-35h]
  char *v24; // [esp+2Ch] [ebp-30h]
  int v26; // [esp+34h] [ebp-28h]
  int v27; // [esp+38h] [ebp-24h]

  v26 = optind;
  v6 = place;
  Str1 = place;
  v27 = ++optind;
  v7 = strchr(place, 61);
  v24 = v7;
  if ( v7 )
  {
    MaxCount = v7 - v6;
    v24 = v7 + 1;
  }
  else
  {
    MaxCount = strlen(Str1);
  }
  Str = *a3;
  if ( !*a3 )
  {
LABEL_16:
    if ( a5 )
    {
      optind = v26;
      return -1;
    }
    if ( opterr )
    {
      if ( *a2 != 58 )
        warnx("unknown option -- %s", Str1);
    }
LABEL_20:
    optopt = 0;
    return 63;
  }
  v22 = -1;
  v10 = 0;
  v23[4] = 0;
  *(_DWORD *)v23 = a5 & 1;
  do
  {
    while ( 1 )
    {
      if ( !strncmp(Str1, Str, MaxCount) )
      {
        if ( strlen(Str) == MaxCount )
          goto LABEL_26;
        if ( MaxCount != 1 || !v23[0] )
          break;
      }
LABEL_7:
      ++v10;
      Str = a3[4 * v10];
      if ( !Str )
        goto LABEL_14;
    }
    if ( v22 != -1 )
    {
      v11 = &a3[4 * v22];
      v12 = 4 * v10;
      if ( a3[4 * v10 + 1] == v11[1] && a3[v12 + 2] == v11[2] )
      {
        v14 = a3[v12 + 3] == v11[3];
        v15 = 1;
        if ( v14 )
          v15 = *(_DWORD *)&v23[1];
        *(_DWORD *)&v23[1] = v15;
      }
      else
      {
        *(_DWORD *)&v23[1] = 1;
      }
      goto LABEL_7;
    }
    v22 = v10++;
    Str = a3[4 * v10];
  }
  while ( Str );
LABEL_14:
  if ( *(_DWORD *)&v23[1] )
  {
    if ( opterr && *a2 != 58 )
      warnx("ambiguous option -- %.*s", MaxCount, Str1);
    goto LABEL_20;
  }
  if ( v22 == -1 )
    goto LABEL_16;
  v10 = v22;
LABEL_26:
  v16 = &a3[4 * v10];
  v17 = v16[1];
  if ( v17 )
  {
    if ( (unsigned int)(v17 - 1) <= 1 )
    {
      if ( v24 )
      {
        optarg = v24;
      }
      else if ( v17 == (const char *)1 )
      {
        v19 = *(char **)(a1 + 4 * v27);
        v20 = v26 + 2;
        optind = v26 + 2;
        optarg = v19;
        if ( !v19 )
        {
          if ( opterr && *a2 != 58 )
          {
            warnx("option requires an argument -- %s", Str1);
            v20 = optind;
          }
          if ( v16[2] )
            optopt = 0;
          else
            optopt = (int)v16[3];
          optind = v20 - 1;
          if ( *a2 != 58 )
            return 63;
          return 58;
        }
      }
    }
    goto LABEL_36;
  }
  if ( !v24 )
  {
LABEL_36:
    if ( a4 )
      *a4 = v10;
    v18 = (int *)v16[2];
    result = (int)v16[3];
    if ( v18 )
    {
      *v18 = result;
      return 0;
    }
    return result;
  }
  if ( opterr && *a2 != 58 )
    warnx("option doesn't take an argument -- %.*s", MaxCount, Str1);
  if ( v16[2] )
    optopt = 0;
  else
    optopt = (int)v16[3];
  if ( *a2 != 58 )
    return 63;
  return 58;
}
// 50CF7C: using guessed type int optopt;
// 50CF80: using guessed type int optind;
// 50CF84: using guessed type int opterr;

//----- (00420590) --------------------------------------------------------
int __usercall getopt_internal@<eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>, const char **a4, int *a5, char a6)
{
  int v7; // edx
  char v8; // al
  int v9; // ecx
  char *v10; // ebx
  bool v11; // zf
  int v12; // ebx
  int v13; // esi
  char *v14; // esi
  int Val; // edx
  char *v16; // edi
  int v17; // ebx
  char *v18; // eax
  char v19; // dl
  int v20; // eax
  char *v21; // eax
  char *v22; // eax
  int v23; // edi
  int v24; // eax
  int v25; // edx
  int v26; // ebx
  int v27; // esi
  int v29; // ecx
  int v30; // edx
  char *v31; // eax
  int v32; // ebx
  int v33; // ecx
  int v35; // [esp+24h] [ebp-28h]
  char *Str; // [esp+2Ch] [ebp-20h]

  Str = a3;
  if ( !a3 )
    return -1;
  if ( optind )
  {
    if ( posixly_correct_67427 != -1 )
    {
      v7 = __mingw_optreset;
      if ( !__mingw_optreset )
      {
        v8 = *a3;
        if ( *a3 != 45 )
          goto LABEL_6;
LABEL_39:
        a6 |= 2u;
LABEL_40:
        ++Str;
        goto LABEL_9;
      }
    }
  }
  else
  {
    __mingw_optreset = 1;
    optind = 1;
  }
  v21 = getenv("POSIXLY_CORRECT");
  v7 = __mingw_optreset;
  posixly_correct_67427 = v21 != 0;
  v8 = *Str;
  if ( *Str == 45 )
    goto LABEL_39;
LABEL_6:
  if ( posixly_correct_67427 || v8 == 43 )
  {
    a6 &= ~1u;
    if ( v8 == 43 )
      goto LABEL_40;
  }
LABEL_9:
  optarg = 0;
  if ( v7 )
  {
    nonopt_end = -1;
    nonopt_start = -1;
  }
  while ( 1 )
  {
    if ( !v7 )
    {
LABEL_19:
      v14 = place;
      Val = *place;
      if ( (_BYTE)Val )
        goto LABEL_20;
    }
    v9 = optind;
    __mingw_optreset = 0;
    if ( optind >= a1 )
    {
      v26 = nonopt_end;
      place = (char *)&unk_511775;
      v27 = nonopt_start;
      if ( nonopt_end == -1 )
      {
        if ( nonopt_start != -1 )
          optind = nonopt_start;
      }
      else
      {
        permute_args(nonopt_start, nonopt_end, optind, a2);
        optind -= v26 - v27;
      }
      goto LABEL_59;
    }
    v10 = *(char **)(a2 + 4 * optind);
    v11 = *v10 == 45;
    place = v10;
    if ( !v11 )
      goto LABEL_14;
    Val = v10[1];
    if ( (_BYTE)Val )
    {
      v23 = nonopt_start;
      if ( nonopt_start != -1 )
      {
LABEL_44:
        if ( nonopt_end == -1 )
          nonopt_end = v9;
        if ( !(_BYTE)Val )
          goto LABEL_66;
      }
      v14 = v10 + 1;
      place = v10 + 1;
      if ( (_BYTE)Val != 45 )
      {
LABEL_20:
        if ( !a4 || *(char **)(a2 + 4 * optind) == v14 )
          goto LABEL_24;
        if ( (_BYTE)Val == 45 )
          goto LABEL_51;
        if ( (a6 & 4) == 0 )
          goto LABEL_24;
        v24 = 0;
        if ( (_BYTE)Val != 58 )
          v24 = strchr(Str, Val) != 0;
LABEL_52:
        v17 = parse_long_options(a2, Str, a4, a5, v24);
        if ( v17 == -1 )
        {
          v14 = place;
          LOBYTE(Val) = *place;
          goto LABEL_24;
        }
        goto LABEL_53;
      }
      if ( v10[2] )
      {
        if ( !a4 )
        {
          v16 = v10 + 2;
          ++v10;
          place = v16;
          goto LABEL_67;
        }
        if ( v14 != *(char **)(a2 + 4 * v9) )
        {
LABEL_51:
          v24 = 0;
          place = v14 + 1;
          goto LABEL_52;
        }
LABEL_24:
        v16 = v14 + 1;
        v17 = (char)Val;
        place = v14 + 1;
        if ( (char)Val != 58 )
        {
          if ( (char)Val == 45 )
          {
            v10 = v14;
            goto LABEL_67;
          }
          v18 = strchr(Str, (char)Val);
          if ( v18 )
          {
            v19 = v18[1];
            if ( !a4 || v17 != 87 || v19 != 59 )
            {
LABEL_70:
              if ( v19 != 58 )
              {
                if ( !v14[1] )
                  ++optind;
                return v17;
              }
              optarg = 0;
              v29 = optind;
              v30 = optind + 1;
              if ( v14[1] )
              {
                optarg = v16;
              }
              else if ( v18[2] != 58 )
              {
                ++optind;
                if ( a1 <= v30 )
                {
                  place = (char *)&unk_511775;
                  if ( opterr && *Str != 58 )
                    warnx("option requires an argument -- %c", v17);
                  optopt = v17;
                  if ( *Str != 58 )
                    return 63;
                  return 58;
                }
                v31 = *(char **)(a2 + 4 * v30);
                v30 = v29 + 2;
                optarg = v31;
              }
              place = (char *)&unk_511775;
              optind = v30;
              return v17;
            }
            if ( !v14[1] )
            {
              v20 = ++optind;
              if ( optind >= a1 )
              {
                place = (char *)&unk_511775;
                if ( opterr )
                {
                  if ( *Str != 58 )
                    warnx("option requires an argument -- %c", 87);
                }
                optopt = 87;
                if ( *Str != 58 )
                  return 63;
                return 58;
              }
              place = *(char **)(a2 + 4 * v20);
            }
            v17 = parse_long_options(a2, Str, a4, a5, 0);
LABEL_53:
            place = (char *)&unk_511775;
            return v17;
          }
        }
        if ( !v14[1] )
          ++optind;
LABEL_77:
        if ( opterr && *Str != 58 )
          warnx("unknown option -- %c", v17);
        optopt = v17;
        return 63;
      }
      v32 = nonopt_end;
      v33 = v9 + 1;
      place = (char *)&unk_511775;
      optind = v33;
      if ( nonopt_end != -1 )
      {
        permute_args(v23, nonopt_end, v33, a2);
        optind -= v32 - v23;
      }
LABEL_59:
      nonopt_end = -1;
      nonopt_start = -1;
      return -1;
    }
    v35 = optind;
    v22 = strchr(Str, 45);
    v9 = v35;
    Val = 0;
    if ( v22 )
      break;
LABEL_14:
    place = (char *)&unk_511775;
    if ( (a6 & 2) != 0 )
    {
      optarg = v10;
      optind = v9 + 1;
      return 1;
    }
    if ( (a6 & 1) == 0 )
      return -1;
    v12 = nonopt_start;
    if ( nonopt_start == -1 )
    {
      nonopt_start = v9;
      optind = v9 + 1;
      goto LABEL_19;
    }
    v13 = nonopt_end;
    if ( nonopt_end == -1 )
    {
      optind = v9 + 1;
      goto LABEL_19;
    }
    permute_args(nonopt_start, nonopt_end, v9, a2);
    nonopt_end = -1;
    v25 = optind - (v13 - v12);
    ++optind;
    nonopt_start = v25;
    v7 = __mingw_optreset;
  }
  v23 = nonopt_start;
  if ( nonopt_start != -1 )
    goto LABEL_44;
LABEL_66:
  v16 = v10 + 1;
  place = v10 + 1;
LABEL_67:
  if ( v10[1] )
  {
    v17 = 45;
    goto LABEL_77;
  }
  v18 = strchr(Str, 45);
  if ( v18 )
  {
    v19 = v18[1];
    v14 = v10;
    v17 = 45;
    goto LABEL_70;
  }
  return -1;
}
// 50CF6C: using guessed type int posixly_correct_67427;
// 50CF70: using guessed type int nonopt_end;
// 50CF74: using guessed type int nonopt_start;
// 50CF7C: using guessed type int optopt;
// 50CF80: using guessed type int optind;
// 50CF84: using guessed type int opterr;
// 537BB4: using guessed type int __mingw_optreset;

//----- (00420BC0) --------------------------------------------------------
int __cdecl getopt(int a1, int a2, char *a3)
{
  return getopt_internal(a1, a2, a3, 0, 0, 0);
}

//----- (00420BF0) --------------------------------------------------------
int __cdecl getopt_long(int a1, int a2, char *a3, const char **a4, int *a5)
{
  return getopt_internal(a1, a2, a3, a4, a5, 1);
}

//----- (00420C20) --------------------------------------------------------
int __cdecl getopt_long_only(int a1, int a2, char *a3, const char **a4, int *a5)
{
  return getopt_internal(a1, a2, a3, a4, a5, 5);
}

//----- (00420C50) --------------------------------------------------------
int *__cdecl __increment_D2A(int *a1)
{
  int *v1; // ebx
  int v2; // esi
  int *v3; // eax
  int *v5; // edi

  v1 = a1;
  v2 = a1[4];
  v3 = a1 + 5;
  do
  {
    if ( *v3 != -1 )
    {
      ++*v3;
      return a1;
    }
    *v3++ = 0;
  }
  while ( &a1[v2 + 5] > v3 );
  if ( v2 >= a1[2] )
  {
    v5 = __Balloc_D2A(a1[1] + 1);
    memcpy(v5 + 3, a1 + 3, 4 * a1[4] + 8);
    v1 = v5;
    __Bfree_D2A(a1);
    v2 = v5[4];
  }
  v1[4] = v2 + 1;
  v1[v2 + 5] = 1;
  return v1;
}

//----- (00420CF0) --------------------------------------------------------
int __usercall rvOK@<eax>(double *a1@<eax>, int *a2@<edx>, int *a3@<ecx>, _DWORD *a4, int a5, int a6, _DWORD *a7)
{
  int *v8; // eax
  int v9; // esi
  int *v10; // ebx
  int v11; // eax
  int v12; // edx
  bool v13; // zf
  int v14; // eax
  unsigned int v15; // edx
  int v16; // ebp
  int v18; // eax
  int v19; // ecx
  bool v20; // cc
  int v21; // edx
  int v22; // edi
  int v23; // edi
  int v24; // eax
  int v25; // eax
  signed int v26; // edx
  int v27; // ecx
  int v28; // eax
  int *v29; // eax
  int v30; // [esp+0h] [ebp-4Ch]
  int v31; // [esp+4h] [ebp-48h]
  int v33; // [esp+14h] [ebp-38h]
  int v34; // [esp+18h] [ebp-34h]
  int v35; // [esp+1Ch] [ebp-30h]
  int v36; // [esp+28h] [ebp-24h] BYREF
  int v37[8]; // [esp+2Ch] [ebp-20h] BYREF

  v8 = __d2b_D2A(*a1, v37, &v36);
  v9 = *a2;
  v10 = v8;
  v11 = v36 - *a2;
  v12 = v11 + v37[0];
  v13 = v36 == *a2;
  v36 = v11;
  v37[0] += v11;
  if ( v11 < 0 || v13 )
  {
    if ( !a5 )
    {
      v16 = 0;
      goto LABEL_13;
    }
    v34 = 0;
    v33 = 0;
    if ( !v11 )
      goto LABEL_16;
    v10 = __lshift_D2A(v10, -v11);
    goto LABEL_38;
  }
  if ( v9 == 53 )
  {
    v16 = 0;
    if ( !a5 || a2[3] != 1 )
      goto LABEL_13;
    goto LABEL_35;
  }
  if ( a6 == 1 )
  {
    v34 = __any_on_D2A((int)v10, v11);
    v30 = (int)v10;
    v31 = v36;
    if ( v34 )
      goto LABEL_42;
LABEL_46:
    __rshift_D2A((int)v10, v36);
    v33 = 0;
    goto LABEL_38;
  }
  if ( a6 == 2 )
  {
LABEL_5:
    v34 = __any_on_D2A((int)v10, v11);
    __rshift_D2A((int)v10, v36);
    v10 = __increment_D2A(v10);
    v14 = v9 & 0x1F;
    if ( (v9 & 0x1F) != 0 )
      v14 = 32 - v14;
    _BitScanReverse(&v15, v10[v10[4] + 4]);
    if ( v14 == (v15 ^ 0x1F) )
    {
      v12 = v37[0];
      v33 = 32;
    }
    else
    {
      if ( !v34 )
        v34 = v10[5] & 1;
      __rshift_D2A((int)v10, 1);
      v33 = 32;
      v12 = ++v37[0];
    }
    goto LABEL_16;
  }
  v26 = v11 - 1;
  if ( v11 != 1 )
  {
    v27 = v10[(v26 >> 5) + 5];
    if ( _bittest(&v27, v26) )
      goto LABEL_5;
    v34 = __any_on_D2A((int)v10, v11);
    if ( v34 )
    {
      __rshift_D2A((int)v10, v36);
      v12 = v37[0];
      v33 = 16;
      goto LABEL_16;
    }
    goto LABEL_46;
  }
  v16 = 0;
  if ( !a5 )
    goto LABEL_13;
  if ( (v10[5] & 2) != 0 )
    goto LABEL_5;
LABEL_35:
  v34 = __any_on_D2A((int)v10, v11);
  v30 = (int)v10;
  v31 = v36;
  if ( v34 )
  {
LABEL_42:
    __rshift_D2A(v30, v31);
    v33 = 16;
LABEL_38:
    v12 = v37[0];
    goto LABEL_16;
  }
  __rshift_D2A((int)v10, v36);
  v12 = v37[0];
  v33 = 0;
LABEL_16:
  v18 = a2[1];
  if ( v18 <= v12 )
  {
    v25 = a2[2];
    if ( v25 < v12 )
    {
      v37[0] = v25 + 1;
      *a7 = 163;
      v33 = 0;
      *_errno() = 34;
      v10[4] = 0;
      v12 = v37[0];
    }
    goto LABEL_28;
  }
  v37[0] = a2[1];
  v19 = v18 - v12;
  v20 = v9 < v18 - v12;
  v21 = v18 - v12;
  if ( v20 || (v16 = a2[4]) != 0 )
  {
    v10[4] = 0;
    v12 = v18;
    v33 = 0;
    *a7 = 80;
LABEL_28:
    v16 = 1;
    *a3 = v12;
    __copybits_D2A(a4, v9, (int)v10);
    *a7 |= v33;
    goto LABEL_13;
  }
  v22 = v19 - 1;
  if ( v19 - 1 > 0 && !v34 )
  {
    v35 = v21;
    v28 = __any_on_D2A((int)v10, v22);
    v21 = v35;
    v34 = v28;
  }
  if ( a5 | v34 )
  {
    v23 = v10[(v22 >> 5) + 5] & (1 << v22);
    __rshift_D2A((int)v10, v21);
    *a7 = 2;
    if ( v23 )
    {
      v29 = __increment_D2A(v10);
      v12 = v37[0];
      v10 = v29;
      v33 = 96;
    }
    else
    {
      v12 = v37[0];
      v24 = 80;
      if ( !v34 )
        v24 = v33;
      v33 = v24;
    }
    goto LABEL_28;
  }
LABEL_13:
  __Bfree_D2A(v10);
  return v16;
}
// 420CF0: using guessed type int var_20[8];

//----- (004210D0) --------------------------------------------------------
_DWORD *__cdecl __decrement_D2A(int a1)
{
  _DWORD *result; // eax
  unsigned int v2; // ecx

  result = (_DWORD *)(a1 + 20);
  v2 = a1 + 20 + 4 * *(_DWORD *)(a1 + 16);
  while ( !*result )
  {
    *result++ = -1;
    if ( v2 <= (unsigned int)result )
      return result;
  }
  --*result;
  return result;
}

//----- (00421110) --------------------------------------------------------
int *__cdecl __set_ones_D2A(int *a1, int a2)
{
  int *result; // eax
  int v3; // esi
  int *v4; // edx
  int v5; // ecx
  int v6; // ecx
  int *v7; // ecx

  result = a1;
  v3 = (a2 + 31) >> 5;
  if ( a1[1] < v3 )
  {
    __Bfree_D2A(a1);
    result = __Balloc_D2A(v3);
  }
  v4 = result + 5;
  v5 = a2 >> 5;
  if ( (a2 & 0x1F) != 0 )
  {
    v6 = v5 + 1;
    result[4] = v6;
    v7 = &v4[v6];
    if ( v7 <= v4 )
    {
LABEL_7:
      *(v4 - 1) = (unsigned int)*(v4 - 1) >> (32 - (a2 & 0x1F));
      return result;
    }
  }
  else
  {
    result[4] = v5;
    v7 = &v4[v5];
    if ( v7 <= v4 )
      return result;
  }
  do
    *v4++ = -1;
  while ( v7 > v4 );
  if ( (a2 & 0x1F) != 0 )
    goto LABEL_7;
  return result;
}

//----- (00421190) --------------------------------------------------------
int __cdecl __strtodg(unsigned __int8 *a1, unsigned __int8 **a2, int *a3, int *a4, int *a5)
{
  char *Str; // esi
  unsigned __int8 *v6; // eax
  signed __int8 v7; // dl
  int result; // eax
  int v9; // ecx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // edi
  int v12; // ebp
  int v13; // ebx
  unsigned __int8 v14; // al
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // ecx
  int v17; // ebp
  int v18; // edi
  int v19; // esi
  int v20; // eax
  unsigned __int8 *v21; // edx
  int *v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // edx
  unsigned __int8 *v25; // edi
  unsigned int v26; // ecx
  int v27; // eax
  int v28; // edi
  long double v29; // fst7
  int v31; // eax
  int v33; // edx
  int v34; // eax
  int v35; // eax
  char v36; // dl
  _BYTE *v37; // eax
  char *v38; // esi
  char v39; // dl
  _BYTE *v40; // edi
  unsigned __int8 *v41; // edx
  int v42; // esi
  int v43; // eax
  unsigned __int8 *v44; // ecx
  signed int v45; // esi
  long double v46; // fst7
  int *v47; // eax
  int v48; // edx
  int v49; // esi
  int v50; // edi
  int v51; // edi
  int v52; // eax
  int v53; // esi
  int *v54; // ecx
  int v55; // eax
  int v56; // esi
  int v57; // edi
  int v58; // ecx
  int v59; // ecx
  int v60; // edx
  long double v61; // fst6
  char v62; // cl
  int v63; // edx
  unsigned __int8 *v64; // eax
  int *v65; // eax
  int v66; // esi
  int v67; // eax
  int v68; // esi
  int v69; // edi
  int v70; // ecx
  int v71; // ecx
  int v72; // edx
  int v73; // edx
  int *v74; // ebx
  int v75; // eax
  int v76; // edx
  int *v77; // eax
  int v78; // edx
  int v79; // edx
  unsigned int v80; // ecx
  long double v81; // fst7
  long double v82; // fst5
  int *v83; // edi
  int v84; // ebx
  int v85; // esi
  int v86; // eax
  int v87; // ebx
  int v88; // edx
  int v89; // ebx
  int v90; // ebp
  int v91; // eax
  int v92; // ebx
  int *v93; // eax
  int *v94; // ebp
  int v95; // ebx
  int v96; // eax
  int v97; // eax
  int *v98; // esi
  int *v99; // ebx
  int *v100; // eax
  int v101; // edx
  int v102; // edx
  unsigned int v103; // ecx
  bool v104; // zf
  long double v105; // fst7
  int v106; // edx
  int *v107; // eax
  int v108; // esi
  int *v109; // ebx
  int v112; // eax
  int v113; // eax
  int v114; // ecx
  int *v115; // edx
  int *j; // eax
  int v117; // ecx
  long double v118; // fst6
  long double v119; // fst5
  long double v120; // fst6
  int v121; // ebx
  int *v122; // eax
  bool v123; // cc
  long double v124; // fst7
  int v125; // edx
  int *v126; // esi
  int *v127; // edx
  int *v128; // eax
  int v131; // eax
  int v132; // ebp
  int v133; // edx
  int v134; // edi
  int *v135; // eax
  int *v136; // edx
  int *v137; // ecx
  int v138; // eax
  int *v139; // eax
  int v140; // ecx
  int v141; // [esp+20h] [ebp-CCh]
  char v142; // [esp+20h] [ebp-CCh]
  char v143; // [esp+20h] [ebp-CCh]
  int *v144; // [esp+20h] [ebp-CCh]
  int v145; // [esp+2Ch] [ebp-C0h]
  unsigned __int8 *v146; // [esp+30h] [ebp-BCh]
  int *v147; // [esp+30h] [ebp-BCh]
  int v148; // [esp+34h] [ebp-B8h]
  int v149; // [esp+34h] [ebp-B8h]
  int v150; // [esp+38h] [ebp-B4h]
  int v151; // [esp+38h] [ebp-B4h]
  int i; // [esp+40h] [ebp-ACh]
  int v153; // [esp+40h] [ebp-ACh]
  double v154; // [esp+40h] [ebp-ACh]
  int v155; // [esp+48h] [ebp-A4h]
  int v156; // [esp+48h] [ebp-A4h]
  int v157; // [esp+4Ch] [ebp-A0h]
  int v158; // [esp+4Ch] [ebp-A0h]
  int *v159; // [esp+4Ch] [ebp-A0h]
  BOOL v160; // [esp+4Ch] [ebp-A0h]
  unsigned __int8 *v161; // [esp+50h] [ebp-9Ch]
  int v162; // [esp+50h] [ebp-9Ch]
  unsigned __int8 *v163; // [esp+54h] [ebp-98h]
  int v164; // [esp+54h] [ebp-98h]
  double v165; // [esp+58h] [ebp-94h]
  int v166; // [esp+60h] [ebp-8Ch]
  int v167; // [esp+64h] [ebp-88h]
  int v168; // [esp+64h] [ebp-88h]
  int v169; // [esp+68h] [ebp-84h]
  int v170; // [esp+6Ch] [ebp-80h]
  int v171; // [esp+70h] [ebp-7Ch]
  int *v172; // [esp+74h] [ebp-78h]
  int v173; // [esp+78h] [ebp-74h]
  void *Src; // [esp+7Ch] [ebp-70h]
  int v175; // [esp+80h] [ebp-6Ch]
  int v176; // [esp+84h] [ebp-68h]
  int v177; // [esp+88h] [ebp-64h]
  int v178; // [esp+ACh] [ebp-40h] BYREF
  int v179; // [esp+B0h] [ebp-3Ch] BYREF
  int v180; // [esp+B4h] [ebp-38h] BYREF
  int v181; // [esp+B8h] [ebp-34h] BYREF
  int v182; // [esp+BCh] [ebp-30h] BYREF
  unsigned __int8 *v183; // [esp+C0h] [ebp-2Ch] BYREF
  int *v184; // [esp+C4h] [ebp-28h] BYREF
  double v185[4]; // [esp+C8h] [ebp-24h] BYREF

  Str = localeconv()->decimal_point;
  v148 = strlen(Str);
  v180 = 0;
  v184 = 0;
  v185[0] = 0.0;
  v145 = *a3;
  v6 = a1;
  v183 = a1;
  v7 = *a1;
  while ( 2 )
  {
    switch ( v7 )
    {
      case 0:
        goto LABEL_3;
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
        v183 = ++v6;
        v7 = *v6;
        if ( *v6 <= 0x2Du )
          continue;
        goto LABEL_18;
      case 43:
        v166 = 0;
        goto LABEL_8;
      case 45:
        v166 = 1;
LABEL_8:
        v183 = v6 + 1;
        v7 = v6[1];
        v146 = v6 + 1;
        if ( v7 )
        {
          v150 = 0;
          if ( v7 == 48 )
          {
LABEL_19:
            v14 = v146[1];
            if ( v14 == 88 || v14 == 120 )
            {
              v180 = __gethex_D2A(&v183, a3, a4, &v184, v166);
              if ( v180 != 6 )
                goto LABEL_71;
              v183 = a1;
              v22 = v184;
              if ( a2 )
                *a2 = a1;
              goto LABEL_66;
            }
            v15 = v146 + 1;
            do
            {
              v16 = v15;
              v183 = v15++;
              v7 = *(v15 - 1);
            }
            while ( v7 == 48 );
            v146 = v16;
            if ( !v7 )
              goto LABEL_71;
            v150 = 1;
          }
LABEL_10:
          v9 = v7;
          v173 = a3[4];
          v10 = v146;
          if ( (unsigned int)(v7 - 48) > 9 )
          {
            v141 = 0;
            v155 = 0;
            v13 = 0;
          }
          else
          {
            v11 = v146 + 1;
            v141 = 0;
            v12 = 0;
            v13 = 0;
            do
            {
              if ( v13 <= 8 )
              {
                v12 = v9 + 10 * v12 - 48;
              }
              else if ( v13 <= 15 )
              {
                v141 = v9 + 10 * v141 - 48;
              }
              v183 = v11;
              v9 = (char)*v11;
              ++v13;
              v10 = v11++;
              v7 = v9;
            }
            while ( (unsigned int)(v9 - 48) <= 9 );
            v155 = v12;
          }
          if ( *Str != v7 )
            goto LABEL_28;
          v36 = Str[1];
          if ( v36 )
          {
            if ( v36 != v10[1] )
            {
LABEL_28:
              v17 = v13;
              v18 = 0;
              i = 0;
              v19 = 0;
              goto LABEL_29;
            }
            v37 = v10 + 2;
            v38 = Str + 2;
            while ( 1 )
            {
              v39 = *v38;
              v40 = v37;
              if ( !*v38 )
                break;
              ++v37;
              ++v38;
              if ( *v40 != v39 )
                goto LABEL_28;
            }
            v41 = v37;
          }
          else
          {
            v41 = v10 + 1;
          }
          v183 = v41;
          v9 = (char)*v41;
          if ( v13 )
          {
            v42 = v9 - 48;
            v18 = 0;
            v17 = v13;
            for ( i = 0; (unsigned int)(v9 - 48) <= 9; v42 = v9 - 48 )
            {
              v43 = v18 + 1;
              v158 = v42;
              v44 = v183;
              if ( v42 )
              {
                i += v43;
                v104 = v43 == 1;
                v131 = v17;
                if ( v104 )
                {
                  ++v17;
                }
                else
                {
                  v132 = v18 + v17;
                  v133 = v155;
                  v134 = v141;
                  do
                  {
                    if ( v131 <= 8 )
                    {
                      ++v131;
                      v133 *= 10;
                    }
                    else if ( ++v131 <= 16 )
                    {
                      v134 *= 10;
                    }
                  }
                  while ( v132 != v131 );
                  v131 = v132;
                  v17 = v132 + 1;
                  v155 = v133;
                  v141 = v134;
                }
                if ( v131 <= 8 )
                {
LABEL_326:
                  v18 = 0;
                  v155 = v158 + 10 * v155;
                }
                else
                {
                  v18 = 0;
                  if ( v17 <= 16 )
                    v141 = v42 + 10 * v141;
                }
              }
              else
              {
                ++v18;
              }
              v183 = v44 + 1;
              v9 = (char)v44[1];
            }
          }
          else
          {
            if ( v9 == 48 )
            {
              v64 = v41 + 1;
              do
              {
                v183 = v64;
                v9 = (char)*v64;
                v18 = v64 - v41;
                ++v64;
              }
              while ( v9 == 48 );
            }
            else
            {
              v18 = 0;
            }
            if ( (unsigned int)(v9 - 49) <= 8 )
            {
              i = v18 + 1;
              v17 = 1;
              v158 = v9 - 48;
              v146 = v183;
              v44 = v183;
              goto LABEL_326;
            }
            i = 0;
            v17 = 0;
          }
          v19 = 1;
LABEL_29:
          if ( (v9 & 0xFFFFFFDF) != 69 )
          {
            v20 = 0;
            goto LABEL_31;
          }
          if ( !(v150 | v18 | v17) )
            goto LABEL_61;
          a1 = v183++;
          v9 = (char)a1[1];
          if ( (_BYTE)v9 == 43 )
          {
            v157 = 0;
          }
          else
          {
            if ( (_BYTE)v9 != 45 )
            {
              v157 = 0;
              goto LABEL_46;
            }
            v157 = 1;
          }
          v183 = a1 + 2;
          v9 = (char)a1[2];
LABEL_46:
          if ( (unsigned int)(v9 - 48) > 9 )
          {
            v183 = a1;
            v20 = 0;
          }
          else
          {
            if ( v9 == 48 )
            {
              v23 = v183 + 1;
              do
              {
                v183 = v23;
                v9 = (char)*v23++;
              }
              while ( v9 == 48 );
            }
            v20 = 0;
            if ( (unsigned int)(v9 - 49) <= 8 )
            {
              v20 = v9 - 48;
              v163 = v183++;
              v9 = (char)v163[1];
              v161 = v183;
              if ( (unsigned int)(v9 - 48) <= 9 )
              {
                v167 = v18;
                v24 = v163 + 2;
                do
                {
                  v183 = v24;
                  v25 = v24++;
                  v20 = v9 + 10 * v20 - 48;
                  v9 = (char)*(v24 - 1);
                }
                while ( (unsigned int)(v9 - 48) <= 9 );
                v161 = v25;
                v18 = v167;
              }
              if ( v161 - v163 > 8 || v20 > 19999 )
                v20 = 19999;
              if ( v157 )
                v20 = -v20;
            }
          }
LABEL_31:
          if ( !v17 )
          {
            if ( v18 | v150 )
              goto LABEL_71;
            if ( v19 )
              goto LABEL_61;
            if ( v9 == 78 )
              goto LABEL_38;
            if ( v9 <= 78 )
            {
              if ( v9 != 73 )
                goto LABEL_61;
            }
            else if ( v9 != 105 )
            {
              if ( v9 != 110 )
                goto LABEL_61;
LABEL_38:
              if ( __match_D2A((char **)&v183, (int)"an") )
              {
                v21 = v183;
                v180 = 4;
                *a4 = a3[2] + 1;
                v22 = v184;
                if ( *v21 != 40 )
                  goto LABEL_62;
                v180 = __hexnan_D2A(&v183, a3, a5);
                goto LABEL_41;
              }
              goto LABEL_61;
            }
            if ( __match_D2A((char **)&v183, (int)"nf") )
            {
              --v183;
              if ( !__match_D2A((char **)&v183, (int)"inity") )
                ++v183;
              v180 = 3;
LABEL_41:
              *a4 = a3[2] + 1;
              v22 = v184;
              goto LABEL_62;
            }
LABEL_61:
            v180 = 6;
            v183 = a1;
            v22 = v184;
            goto LABEL_62;
          }
          v180 = 1;
          v171 = v20 - i;
          v27 = a3[3] & 3;
          v170 = v27 - v166;
          if ( v27 != 2 )
          {
            v170 = v166 + 1;
            if ( v27 != 3 )
              v170 = v27 == 0;
          }
          if ( !v13 )
            v13 = v17;
          v28 = 16;
          if ( v17 <= 16 )
            v28 = v17;
          v29 = (long double)(unsigned int)v155;
          v185[0] = v29;
          if ( v17 > 9 )
            v185[0] = v29 * dbl_5119F8[v28] + (long double)(unsigned int)v141;
          if ( v145 > 53 || v17 > 15 )
          {
            v35 = v171;
            goto LABEL_104;
          }
          if ( v171 )
          {
            if ( v171 <= 0 )
            {
              v35 = v171;
              if ( v171 < -22 )
                goto LABEL_104;
              v124 = v185[0] / __tens_D2A[-v171];
            }
            else
            {
              if ( v171 <= 22 )
              {
                _EDX = LODWORD(v185[0]);
                v31 = fivesbits[v171];
                if ( LODWORD(v185[0]) )
                {
                  __asm { tzcnt   ecx, edx }
                  v33 = 53 - _ECX;
                }
                else
                {
                  _ECX = HIDWORD(v185[0]) | 0x100000;
                  __asm { tzcnt   ecx, ecx }
                  v33 = 21 - _ECX;
                }
                v185[0] = v185[0] * __tens_D2A[v171];
                v34 = rvOK(v185, a3, a4, a5, v33 + v31 <= 53, v170, &v180);
                goto LABEL_89;
              }
              v35 = v171;
              if ( 37 - v17 < v171 )
                goto LABEL_104;
              v124 = v185[0] * __tens_D2A[15 - v17] * __tens_D2A[v171 - (15 - v17)];
            }
            v185[0] = v124;
            v34 = rvOK(v185, a3, a4, a5, 0, v170, &v180);
          }
          else
          {
            v34 = rvOK(v185, a3, a4, a5, 1, v170, &v180);
          }
LABEL_89:
          if ( v34 )
            goto LABEL_71;
          v35 = 0;
LABEL_104:
          v45 = v35 + v17 - v28;
          if ( v45 <= 0 )
          {
            if ( !v45 )
              goto LABEL_108;
            v66 = -v45;
            if ( (v66 & 0xF) != 0 )
              v185[0] = v185[0] / __tens_D2A[v66 & 0xF];
            v45 = v66 & 0xFFFFFFF0;
            if ( !v45 )
              goto LABEL_108;
            v67 = v45 >> 4;
            if ( v45 >> 4 <= 15 )
            {
              v71 = 0;
            }
            else
            {
              v68 = 0;
              v143 = v67 - 16;
              v69 = (v67 - 16) & 0xF;
              do
              {
                v67 -= 16;
                v70 = HIDWORD(v185[0]) >> 20;
                HIDWORD(v185[0]) = HIDWORD(v185[0]) & 0x800FFFFF | 0x3FF00000;
                v71 = v68 + (v70 & 0x7FF) - 1023;
                v68 = v71;
                v185[0] = v185[0] * 1.0e-256;
              }
              while ( v69 != v67 );
              v67 = v143 & 0xF;
            }
            v72 = (HIDWORD(v185[0]) >> 20) & 0x7FF;
            HIDWORD(v185[0]) = HIDWORD(v185[0]) & 0x800FFFFF | 0x3FF00000;
            v45 = v71 + v72 - 1023;
            v46 = v185[0];
            if ( v67 <= 0 )
              goto LABEL_109;
            v61 = v185[0];
            v62 = 0;
            v73 = 0;
            do
            {
              if ( (v67 & 1) != 0 )
              {
                v61 = v61 * __tinytens_D2A[v73];
                v62 = 1;
              }
              ++v73;
              v67 >>= 1;
            }
            while ( v67 );
          }
          else
          {
            if ( (v45 & 0xF) != 0 )
              v185[0] = v185[0] * __tens_D2A[v45 & 0xF];
            v45 &= 0x7FFFFFF0u;
            if ( !v45 )
            {
LABEL_108:
              v46 = v185[0];
LABEL_109:
              v47 = __d2b_D2A(v46, &v182, &v181);
              v48 = v181;
              v49 = v182 + v45;
              v184 = v47;
              v50 = v181 - v145;
              v182 = v49;
              if ( v181 - v145 > 0 )
              {
                __rshift_D2A((int)v47, v181 - v145);
                v48 = v145;
                v181 = v145;
                v49 = v182 + v50;
                v182 += v50;
              }
              v51 = v48 + v49 - v145;
              v177 = v51;
              if ( a3[2] + 1 < v51 )
              {
                v151 = 0;
                goto LABEL_160;
              }
              v52 = a3[1];
              v168 = v52;
              if ( v51 >= v52 )
              {
                v151 = 0;
              }
              else
              {
                v53 = v49 - v52;
                if ( v53 > 0 )
                {
                  v65 = __lshift_D2A(v184, v53);
                  v181 += v53;
                  v184 = v65;
                }
                else if ( v53 )
                {
                  v125 = v53 + v48;
                  v54 = v184;
                  v181 = v125;
                  if ( v125 > 0 )
                  {
                    __rshift_D2A((int)v184, -v53);
                  }
                  else
                  {
                    if ( v125 < -1 )
                    {
                      v184[4] = 0;
                      v54[5] = 0;
                      *a4 = v52;
                      if ( !v173 )
                      {
                        v26 = 80;
                        goto LABEL_70;
                      }
                      goto LABEL_118;
                    }
                    v181 = 1;
                    v184[4] = 1;
                    v54[5] = 1;
                  }
                }
                v182 = v168;
                if ( v173 && v51 + 1 < v168 )
                {
                  v54 = v184;
                  v184[4] = 0;
                  v54[5] = 0;
                  *a4 = v168;
                  goto LABEL_118;
                }
                v151 = 1;
                v177 = v168;
              }
              v74 = __s2b_D2A((int)v146, v13, v17, v155, v148);
              v172 = v74;
              v75 = 0;
              v149 = 0;
              v76 = -v171;
              if ( v171 >= 0 )
              {
                v76 = 0;
                v75 = v171;
              }
              v169 = v75;
              v156 = v76;
              Src = v74 + 3;
              v175 = v145 + 1;
              while ( 1 )
              {
                v147 = __Balloc_D2A(v172[1]);
                memcpy(v147 + 3, Src, 4 * v172[4] + 8);
                v83 = __Balloc_D2A(v184[1]);
                memcpy(v83 + 3, v184 + 3, 4 * v184[4] + 8);
                v153 = v181 - v149;
                v84 = v182 + v149;
                v144 = __i2b_D2A(1);
                if ( v84 < 0 )
                {
                  v85 = v156;
                  v86 = v169 - v84;
                }
                else
                {
                  v85 = v156 + v84;
                  v86 = v169;
                }
                v87 = v153 + v84 - v145;
                v88 = v175 - v153;
                if ( v168 > v87 )
                  v88 = v175 - v153 + v87 - v168;
                v89 = v85 + v88;
                v90 = v86 + v88;
                v123 = v85 + v88 <= v86 + v88;
                v91 = v86 + v88;
                if ( v123 )
                  v91 = v85 + v88;
                if ( v85 <= v91 )
                  v91 = v85;
                if ( v91 > 0 )
                {
                  v89 -= v91;
                  v90 -= v91;
                  v85 -= v91;
                }
                if ( v156 )
                {
                  v144 = (int *)__pow5mult_D2A(v144, v156);
                  v159 = __mult_D2A((int)v144, (int)v83);
                  __Bfree_D2A(v83);
                  v83 = v159;
                }
                v92 = v89 - v149;
                if ( v92 > 0 )
                {
                  v83 = __lshift_D2A(v83, v92);
                }
                else if ( v92 )
                {
                  __rshift_D2A((int)v83, -v92);
                }
                if ( v171 > 0 )
                  v147 = (int *)__pow5mult_D2A(v147, v169);
                if ( v90 > 0 )
                  v147 = __lshift_D2A(v147, v90);
                if ( v85 > 0 )
                  v144 = __lshift_D2A(v144, v85);
                v93 = __diff_D2A(v83, v147);
                v94 = v93;
                if ( v93[4] <= 1 && !v93[5] )
                  goto LABEL_243;
                v95 = v93[3];
                v93[3] = 0;
                v96 = __cmp_D2A((int)v93, (int)v144);
                if ( !v170 || v96 > 0 )
                {
                  if ( v96 < 0 )
                  {
                    if ( v95 )
                      goto LABEL_346;
                    v180 = 33;
                    if ( v153 > 1 || v177 == v168 || (v151 & 1) != 0 )
                      goto LABEL_243;
                    v94 = __lshift_D2A(v94, 1);
                    if ( __cmp_D2A((int)v94, (int)v144) <= 0 )
                      goto LABEL_270;
                    v180 = 17;
                    v151 = 0;
                    goto LABEL_298;
                  }
                  if ( !v96 )
                  {
                    if ( v95 )
                    {
                      if ( !v151 )
                        goto LABEL_347;
                      v126 = v184;
                      v127 = v184 + 5;
                      v128 = &v184[(v181 >> 5) + 5];
                      if ( v184 + 5 < v128 )
                      {
                        v127 = v184 + 6;
                        if ( v184[5] != -1 )
                          goto LABEL_347;
                        while ( v127 < v128 )
                        {
                          if ( *v127++ != -1 )
                            goto LABEL_347;
                        }
                      }
                      if ( (v181 & 0x1F) == 0 || (*v127 | (-1 << (v181 & 0x1F))) == -1 )
                      {
                        v184[4] = 1;
                        v126[5] = 1;
                        v181 = 1;
                        v180 = 33;
                        v182 = v145 + v168 - 1;
LABEL_271:
                        v123 = v145 - v151 <= 0;
                        v151 = v145 - v151;
                        if ( v151 )
                        {
                          if ( v123 )
                            __rshift_D2A((int)v184, -v151);
                          else
                            v184 = __lshift_D2A(v184, v151);
                          v112 = v182 - v151;
                          v151 = 0;
                          v182 = v112;
LABEL_245:
                          *a4 = v112;
                          __Bfree_D2A(v83);
                          __Bfree_D2A(v147);
                          __Bfree_D2A(v144);
                          __Bfree_D2A(v172);
                          __Bfree_D2A(v94);
                          if ( a3[2] >= v182 )
                            goto LABEL_161;
                          v113 = a3[3] & 3;
                          switch ( v113 )
                          {
                            case 2:
                              if ( !v166 )
                                goto LABEL_160;
                              break;
                            case 3:
                              if ( v166 )
                                goto LABEL_160;
                              break;
                            case 1:
LABEL_160:
                              v180 = 163;
                              v184[4] = 0;
                              *_errno() = 34;
                              *a4 = a3[2] + 1;
LABEL_161:
                              v22 = v184;
                              if ( v151 )
                              {
                                v54 = v184;
                                if ( !v173 )
                                {
                                  v26 = v180 & 0xFFFFFFF8;
                                  if ( v184[4] > 0 )
                                    v26 |= 2u;
                                  if ( (v180 & 0x30) == 0 )
                                  {
                                    v180 = v26;
                                    goto LABEL_62;
                                  }
LABEL_70:
                                  v180 = v26 | 0x40;
                                  *_errno() = 34;
LABEL_71:
                                  v22 = v184;
                                  goto LABEL_62;
                                }
LABEL_118:
                                v54[4] = 0;
                                v180 = 80;
                                *_errno() = 34;
                                v22 = v184;
                              }
LABEL_62:
                              if ( a2 )
                                *a2 = v183;
                              if ( v166 )
                                v180 |= 8u;
LABEL_66:
                              if ( v22 )
                              {
                                __copybits_D2A(a5, v145, (int)v22);
                                __Bfree_D2A(v184);
                              }
                              return v180;
                            default:
                              break;
                          }
                          __Bfree_D2A(v184);
                          v184 = 0;
                          v180 = 17;
                          *a4 = a3[2];
                          v114 = *a3;
                          v115 = &a5[(*a3 + 31) >> 5];
                          for ( j = a5; v115 > j; *(j - 1) = -1 )
                            ++j;
                          v117 = v114 & 0x1F;
                          if ( v117 )
                            *(v115 - 1) = (unsigned int)*(v115 - 1) >> (32 - v117);
                          goto LABEL_161;
                        }
LABEL_244:
                        v112 = v182;
                        goto LABEL_245;
                      }
LABEL_347:
                      v180 = 17;
LABEL_337:
                      if ( v145 <= v153 || (v151 & 1) != 0 )
                      {
                        v135 = v184;
                        if ( (v184[5] & 1) != 0 )
                        {
                          if ( v95 )
                          {
                            v139 = __increment_D2A(v184);
                            v140 = v139[4];
                            v184 = v139;
                            _BitScanReverse((unsigned int *)&v139, v139[v140 + 4]);
                            if ( (-v181 & 0x1F) != ((unsigned int)v139 ^ 0x1F) )
                              ++v181;
                            v180 = 33;
                          }
                          else if ( v153 == 1 )
                          {
LABEL_329:
                            v135[4] = 0;
                            v180 = 80;
                            v182 = v168;
                          }
                          else
                          {
                            v136 = v184 + 5;
                            v137 = &v184[v184[4] + 5];
                            while ( !*v136 )
                            {
                              *v136++ = -1;
                              if ( v137 <= v136 )
                                goto LABEL_346;
                            }
                            --*v136;
LABEL_346:
                            v180 = 17;
                          }
                        }
LABEL_243:
                        if ( v151 )
                          goto LABEL_244;
                      }
LABEL_270:
                      v151 = v181;
                      goto LABEL_271;
                    }
                    if ( v153 != 1 )
                    {
                      v180 = 33;
                      goto LABEL_337;
                    }
                    v180 = 1;
                    if ( v177 == v168 )
                    {
                      v180 = 33;
                      if ( v184[4] == 1 )
                      {
                        v138 = 1;
                        if ( v184[5] != 1 )
                          v138 = v173;
                        v173 = v138;
                      }
                      goto LABEL_243;
                    }
LABEL_298:
                    v182 -= v145;
                    v181 = v145;
                    v184 = __set_ones_D2A(v184, v145);
                    goto LABEL_243;
                  }
                  v105 = __ratio_D2A((int)v94, (int)v144);
                  if ( v105 > 2.0 )
                  {
                    v118 = v105 * 0.5;
                    v176 = v95 == 0 ? 32 : 16;
                    v160 = v95 == 0;
                    v165 = v118;
                    if ( v118 >= 2147483647.0 )
                    {
                      v162 = 0;
                      v154 = v118;
                      goto LABEL_259;
                    }
                    v162 = (int)v118;
                    v119 = (long double)(int)v118;
                    v154 = v119;
                    v120 = v118 - v119;
                    v165 = v120;
                    if ( v170 == 1 )
                    {
                      if ( v95 )
                        goto LABEL_259;
LABEL_257:
                      if ( v165 <= 0.0 )
                      {
LABEL_259:
                        v149 = 0;
                        goto LABEL_211;
                      }
                    }
                    else
                    {
                      if ( v170 == 2 )
                      {
                        if ( v95 )
                          goto LABEL_257;
                        goto LABEL_259;
                      }
                      if ( v120 < 0.5 )
                        goto LABEL_259;
                    }
                    ++v162;
                    v176 = 48 - v176;
                    v154 = (double)v162;
                    goto LABEL_259;
                  }
                  if ( v95 )
                  {
                    v162 = 0;
                    v176 = 32;
                    v149 = 0;
                    v160 = 0;
                    v154 = 1.0;
                    v165 = 1.0;
                    goto LABEL_211;
                  }
                  v149 = 0;
                  goto LABEL_227;
                }
                v97 = v170 & 1;
                v149 = v95 ^ v97;
                if ( v97 == v95 )
                {
                  v180 = v97 == 0 ? 33 : 17;
                  goto LABEL_243;
                }
                if ( v95 )
                {
                  v180 = 33;
                  v162 = 0;
                  v176 = 32;
                  v160 = 0;
                  v154 = 1.0;
                  v165 = 1.0;
                  goto LABEL_211;
                }
                v180 = 17;
                if ( v177 != v168 )
                {
                  v106 = v145;
                  v107 = v184;
                  if ( v145 <= 31 )
                  {
                    v108 = v145;
                    goto LABEL_240;
                  }
                  if ( !v184[5] )
                  {
                    v108 = v145 & 0x1F;
                    while ( 1 )
                    {
                      v106 -= 32;
                      ++v95;
                      if ( (v145 & 0x1F) == v106 )
                        break;
                      if ( v184[v95 + 5] )
                        goto LABEL_227;
                    }
LABEL_240:
                    if ( v108 <= 1 )
                      goto LABEL_242;
                    v109 = &v184[v95 + 5];
                    _EDX = *v109;
                    __asm { tzcnt   ecx, edx }
                    *v109 = (unsigned int)*v109 >> _ECX;
                    if ( v108 - 1 <= _ECX )
                    {
LABEL_242:
                      v181 = v145;
                      v182 = v177 - 1;
                      v184 = __set_ones_D2A(v107, v145);
                      goto LABEL_243;
                    }
                  }
                }
LABEL_227:
                if ( v153 <= 1 && (v151 & 1) != 0 )
                {
                  v135 = v184;
                  v151 = 1;
                  goto LABEL_329;
                }
                v162 = 0;
                v176 = 16;
                v160 = 1;
                v154 = 1.0;
                v165 = 1.0;
LABEL_211:
                v164 = v181 + v182;
                if ( v181 < v145 && (v151 & 1) == 0 )
                {
                  v121 = v145 - v181;
                  v122 = __lshift_D2A(v184, v145 - v181);
                  v182 -= v121;
                  v184 = v122;
                  v181 = v145;
                }
                v98 = __d2b_D2A(v154, &v178, &v179);
                if ( v178 < 0 )
                {
                  __rshift_D2A((int)v98, -v178);
                }
                else if ( v178 )
                {
                  v98 = __lshift_D2A(v98, v178);
                }
                v99 = v184;
                if ( v160 )
                {
                  v77 = __diff_D2A(v184, v98);
                  v184 = v77;
                  if ( !v151 )
                  {
                    v78 = v99[4];
                    if ( v77[4] <= v78 - 1
                      || (v79 = v78 + 3,
                          _BitScanReverse(&v80, v77[v79 + 1]),
                          _BitScanReverse((unsigned int *)&v79, v99[v79 + 1]),
                          (v79 ^ 0x1F) < (int)(v80 ^ 0x1F)) )
                    {
                      if ( v177 != v168 )
                      {
                        v184 = __lshift_D2A(v77, 1);
                        --v182;
                        --v177;
                        __Bfree_D2A(v98);
                        __Bfree_D2A(v99);
LABEL_233:
                        v151 = 0;
                        v149 = __trailz_D2A((int)v184);
                        goto LABEL_182;
                      }
                      --v181;
                      v151 = v160;
                    }
                  }
                }
                else
                {
                  v100 = __sum_D2A(v184, v98);
                  v101 = v100[4];
                  v184 = v100;
                  if ( v99[4] <= v101 - 1
                    || (v102 = v101 + 3,
                        _BitScanReverse(&v103, v100[v102 + 1]),
                        _BitScanReverse((unsigned int *)&v102, v99[v102 + 1]),
                        (v102 ^ 0x1F) > (int)(v103 ^ 0x1F)) )
                  {
                    if ( v151 )
                    {
                      v104 = ++v181 == v145;
                      v151 = !v104;
                    }
                    else
                    {
                      __rshift_D2A((int)v100, 1);
                      ++v182;
                      ++v177;
                      v162 = 0;
                    }
                  }
                }
                __Bfree_D2A(v98);
                __Bfree_D2A(v99);
                if ( v149 )
                  goto LABEL_243;
                if ( v182 + v181 == v164 && v162 )
                {
                  v81 = v154 * 5.0e-16;
                  v82 = v165 - 0.5;
                  if ( -v81 <= v82 )
                  {
                    if ( v82 > v81 && 1.0 - v81 > v165 )
                    {
LABEL_262:
                      v180 |= v176;
                      goto LABEL_243;
                    }
                  }
                  else if ( v165 > v81 )
                  {
                    goto LABEL_262;
                  }
                }
                if ( !v151 )
                  goto LABEL_233;
LABEL_182:
                __Bfree_D2A(v83);
                __Bfree_D2A(v147);
                __Bfree_D2A(v144);
                __Bfree_D2A(v94);
              }
            }
            v55 = v45 >> 4;
            if ( v45 >> 4 <= 15 )
            {
              v59 = 0;
            }
            else
            {
              v56 = 0;
              v142 = v55 - 16;
              v57 = (v55 - 16) & 0xF;
              do
              {
                v55 -= 16;
                v58 = HIDWORD(v185[0]) >> 20;
                HIDWORD(v185[0]) = HIDWORD(v185[0]) & 0x800FFFFF | 0x3FF00000;
                v59 = v56 + (v58 & 0x7FF) - 1023;
                v56 = v59;
                v185[0] = v185[0] * 1.0e256;
              }
              while ( v57 != v55 );
              v55 = v142 & 0xF;
            }
            v60 = (HIDWORD(v185[0]) >> 20) & 0x7FF;
            HIDWORD(v185[0]) = HIDWORD(v185[0]) & 0x800FFFFF | 0x3FF00000;
            v45 = v59 + v60 - 1023;
            v46 = v185[0];
            if ( !v55 )
              goto LABEL_109;
            v61 = v185[0];
            v62 = 0;
            v63 = 0;
            do
            {
              if ( (v55 & 1) != 0 )
              {
                v61 = v61 * __bigtens_D2A[v63];
                v62 = 1;
              }
              ++v63;
              v55 >>= 1;
            }
            while ( v55 );
          }
          if ( v62 )
          {
            v46 = v61;
            v185[0] = v61;
          }
          goto LABEL_109;
        }
LABEL_3:
        v180 = 6;
        result = 6;
        if ( !a2 )
          return result;
        *a2 = a1;
        return v180;
      default:
LABEL_18:
        v146 = v6;
        v166 = 0;
        v150 = 0;
        if ( v7 == 48 )
          goto LABEL_19;
        goto LABEL_10;
    }
  }
}
// 4218DF: mask 0xFFFFFFF0 is shortened because esi.4 <= 0x7FFFFFFF
// 511980: using guessed type int fivesbits[23];
// 5119F8: using guessed type double dbl_5119F8[];
// 511A40: using guessed type double __tens_D2A[24];
// 511B00: using guessed type double __tinytens_D2A[4];
// 511B40: using guessed type double __bigtens_D2A[4];

//----- (00422D10) --------------------------------------------------------
int *__cdecl __sum_D2A(int *a1, int *a2)
{
  int *v2; // ebx
  int *v3; // eax
  unsigned int *v4; // esi
  unsigned int v5; // ebp
  int *v6; // eax
  int *v7; // ecx
  int v8; // edi
  unsigned int *v9; // edi
  unsigned int v10; // eax
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // eax
  unsigned int i; // ebx
  unsigned int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // edx
  int *v19; // ebx
  unsigned int v20; // [esp+20h] [ebp-2Ch]
  int *v21; // [esp+24h] [ebp-28h]
  int v22; // [esp+28h] [ebp-24h]
  int v23; // [esp+2Ch] [ebp-20h]

  v2 = a1;
  if ( a1[4] >= a2[4] )
  {
    v3 = a2;
    a2 = a1;
    v2 = v3;
  }
  v4 = (unsigned int *)(v2 + 5);
  v5 = 0;
  v6 = __Balloc_D2A(a2[1]);
  v7 = v6 + 5;
  v21 = v6;
  v8 = a2[4];
  v6[4] = v8;
  v22 = v8;
  v23 = v2[4];
  v9 = (unsigned int *)(a2 + 5);
  v20 = (unsigned int)&v6[v23 + 5];
  do
  {
    v10 = *v9;
    v11 = *v4;
    ++v9;
    ++v4;
    ++v7;
    v12 = v5 + (unsigned __int16)v10 + (unsigned __int16)v11;
    *((_WORD *)v7 - 2) = v12;
    v13 = HIWORD(v12) + HIWORD(v11) + HIWORD(v10);
    *((_WORD *)v7 - 1) = v13;
    v5 = HIWORD(v13);
  }
  while ( v20 > (unsigned int)v7 );
  for ( i = v20 + 4 * (a2[4] - v23); i > (unsigned int)v7; v5 = HIWORD(v17) )
  {
    v15 = *v9;
    ++v7;
    ++v9;
    v16 = v5 + (unsigned __int16)v15;
    *((_WORD *)v7 - 2) = v16;
    v17 = HIWORD(v16) + HIWORD(v15);
    *((_WORD *)v7 - 1) = v17;
  }
  if ( v5 )
  {
    if ( v22 == v21[2] )
    {
      v19 = __Balloc_D2A(v21[1] + 1);
      memcpy(v19 + 3, v21 + 3, 4 * v21[4] + 8);
      __Bfree_D2A(v21);
      v21 = v19;
      v22 = v19[4];
    }
    v21[4] = v22 + 1;
    v21[v22 + 5] = 1;
  }
  return v21;
}

//----- (00422E70) --------------------------------------------------------
int __cdecl __gethex_D2A(unsigned __int8 **a1, int *a2, int *a3, int **a4, int a5)
{
  unsigned __int8 *v5; // eax
  unsigned __int8 v6; // bl
  unsigned __int8 *v7; // eax
  int v8; // edx
  unsigned __int8 *v9; // ecx
  char v10; // cl
  char *v11; // esi
  int v12; // ebp
  unsigned __int8 v13; // di
  unsigned __int8 *v14; // eax
  char v15; // bl
  unsigned __int8 v16; // dl
  unsigned __int8 v17; // di
  char v18; // si
  unsigned __int8 *v19; // ebx
  int v20; // edx
  unsigned __int8 v21; // cl
  int v22; // edx
  int j; // eax
  int v24; // eax
  unsigned int *v25; // edi
  int v26; // edx
  unsigned __int8 *v27; // ecx
  char v28; // cl
  int v29; // eax
  int v30; // eax
  unsigned int v31; // ebp
  int *v32; // ebx
  unsigned int v33; // eax
  int *v34; // edx
  unsigned __int8 *v35; // ecx
  int v36; // esi
  int v37; // ebx
  int v39; // eax
  unsigned __int8 *v40; // esi
  char v41; // al
  int v42; // edi
  unsigned __int8 v43; // bp
  unsigned __int8 v44; // cl
  int v45; // ebp
  int v46; // ecx
  unsigned __int8 *v47; // esi
  int v48; // esi
  unsigned int v49; // esi
  int *v50; // edx
  unsigned int v51; // eax
  unsigned int v52; // eax
  int v53; // ebx
  signed int v54; // ebx
  int v55; // edi
  int v56; // esi
  int v57; // eax
  int v58; // ebx
  int v59; // edx
  unsigned int v60; // edi
  int v61; // eax
  int v62; // ebx
  int v63; // ebx
  int v64; // esi
  int v65; // edi
  int v66; // edx
  int i; // eax
  int *v68; // eax
  int *v69; // edx
  int v70; // ebx
  int v71; // eax
  char v72; // al
  unsigned __int8 *v73; // esi
  char *v74; // edi
  char v75; // al
  int v76; // ebx
  int v77; // ecx
  int v78; // eax
  int v79; // esi
  unsigned int v80; // eax
  int v81; // edi
  int v82; // [esp+4h] [ebp-48h]
  unsigned int v83; // [esp+14h] [ebp-38h]
  unsigned __int8 *v84; // [esp+18h] [ebp-34h]
  unsigned int v85; // [esp+18h] [ebp-34h]
  unsigned __int8 *v86; // [esp+18h] [ebp-34h]
  int v87; // [esp+18h] [ebp-34h]
  char *decimal_point; // [esp+1Ch] [ebp-30h]
  char *v89; // [esp+1Ch] [ebp-30h]
  char v90; // [esp+20h] [ebp-2Ch]
  int v91; // [esp+20h] [ebp-2Ch]
  BOOL v92; // [esp+24h] [ebp-28h]
  int *v93; // [esp+24h] [ebp-28h]
  _DWORD *v94; // [esp+28h] [ebp-24h]
  unsigned __int8 v95; // [esp+28h] [ebp-24h]
  int v96; // [esp+28h] [ebp-24h]
  int v97; // [esp+2Ch] [ebp-20h]

  decimal_point = localeconv()->decimal_point;
  if ( !byte_537BF0 )
    __mingw_hexdig_init_D2A();
  *a4 = 0;
  v5 = *a1;
  v6 = (*a1)[2];
  if ( v6 == 48 )
  {
    v7 = v5 + 3;
    v8 = 0;
    do
    {
      v9 = v7++;
      v6 = *(v7 - 1);
      ++v8;
    }
    while ( v6 == 48 );
    v84 = v9;
  }
  else
  {
    v8 = 0;
    v84 = v5 + 2;
  }
  v10 = *decimal_point;
  v90 = *decimal_point;
  if ( __hexdig_D2A[v6] )
  {
    v35 = v84;
    ++v8;
    v92 = 0;
    v14 = 0;
    v83 = (unsigned int)v84;
    goto LABEL_39;
  }
  if ( v10 && v6 == v10 )
  {
    v11 = decimal_point + 1;
    v12 = v8;
    v13 = v6;
    v14 = v84 + 1;
    while ( 1 )
    {
      v15 = *v11;
      v16 = *v14;
      if ( !*v11 )
        break;
      ++v14;
      ++v11;
      if ( v15 != v16 )
      {
        v6 = v13;
        v14 = v84;
        v8 = v12;
        goto LABEL_46;
      }
    }
    v17 = *v14;
    v8 = v12;
    v18 = __hexdig_D2A[*v14];
    if ( v18 )
    {
      v19 = v14;
      if ( v17 == 48 )
      {
        do
          v20 = *++v19;
        while ( (_BYTE)v20 == 48 );
        v18 = __hexdig_D2A[v20];
        v17 = *v19;
      }
      v92 = v18 == 0;
      if ( !v18 )
      {
        v83 = (unsigned int)v19;
        v8 = 1;
        if ( v90 == v17 )
          goto LABEL_42;
        goto LABEL_19;
      }
      v35 = v19;
      v83 = (unsigned int)v19;
      v8 = 1;
LABEL_39:
      while ( 1 )
      {
        v36 = v35[1];
        if ( !__hexdig_D2A[v36] )
          break;
        ++v35;
      }
      v86 = v35;
      v19 = v35 + 1;
      if ( (_BYTE)v36 == v90 )
      {
        if ( v14 )
        {
LABEL_42:
          v21 = *v19;
          goto LABEL_20;
        }
        v72 = decimal_point[1];
        if ( !v72 )
        {
          v21 = v35[2];
          v14 = v86 + 2;
LABEL_124:
          v19 = v14;
          if ( __hexdig_D2A[v21] )
          {
            do
              v21 = *++v19;
            while ( __hexdig_D2A[*v19] );
          }
          goto LABEL_20;
        }
        if ( v35[2] == v72 )
        {
          v73 = v35 + 3;
          v74 = decimal_point + 2;
          do
          {
            v75 = *v74;
            v21 = *v73;
            if ( !*v74 )
            {
              v14 = v73;
              goto LABEL_124;
            }
            ++v73;
            ++v74;
          }
          while ( v75 == v21 );
          v21 = *v19;
          v91 = 0;
        }
        else
        {
          v21 = *decimal_point;
          v91 = 0;
        }
LABEL_21:
        if ( v21 != 80 && v21 != 112 )
        {
          *a1 = v19;
          if ( !v92 )
            goto LABEL_24;
          return 0;
        }
        goto LABEL_49;
      }
LABEL_19:
      v21 = *v19;
      v91 = 0;
      if ( v14 )
      {
LABEL_20:
        v91 = 4 * (v14 - v19);
        goto LABEL_21;
      }
      goto LABEL_21;
    }
    v6 = *v14;
  }
  else
  {
    v14 = v84;
  }
LABEL_46:
  if ( v6 != 80 && v6 != 112 )
  {
    v60 = (unsigned int)v84;
    v19 = v14;
    v92 = 1;
    v91 = 0;
    v87 = 0;
    v83 = v60;
    v42 = 0;
    goto LABEL_76;
  }
  v19 = v14;
  v91 = 0;
  v92 = 1;
  v83 = (unsigned int)v84;
LABEL_49:
  v39 = v19[1];
  if ( (_BYTE)v39 == 43 )
  {
    v87 = 0;
  }
  else
  {
    if ( (_BYTE)v39 != 45 )
    {
      v40 = v19 + 1;
      v87 = 0;
      goto LABEL_52;
    }
    v87 = 1;
  }
  v40 = v19 + 2;
  v39 = v19[2];
LABEL_52:
  v41 = __hexdig_D2A[v39];
  v42 = 0;
  v43 = v41 - 1;
  v95 = v41;
  v14 = v19;
  if ( v43 <= 0x18u )
  {
    v96 = v95 - 16;
    v14 = v40 + 1;
    v44 = __hexdig_D2A[v40[1]];
    v45 = v44;
    if ( (unsigned __int8)(v44 - 1) <= 0x18u )
    {
      v46 = v96;
      v47 = v40 + 1;
      do
      {
        if ( (v46 & 0xF8000000) != 0 )
          v42 = 1;
        ++v47;
        v46 = v45 + 10 * v46 - 16;
        v45 = (unsigned __int8)__hexdig_D2A[*v47];
      }
      while ( (unsigned __int8)(__hexdig_D2A[*v47] - 1) <= 0x18u );
      v14 = v47;
      v96 = v46;
    }
    v48 = -v96;
    if ( !v87 )
      v48 = v96;
    v91 += v48;
  }
LABEL_76:
  if ( !v8 )
    v14 = (unsigned __int8 *)(v83 - 1);
  *a1 = v14;
  if ( v92 )
    return 0;
  if ( v42 )
  {
    v61 = a2[3];
    if ( v87 )
    {
      if ( v61 == 2 )
      {
        if ( a5 )
          goto LABEL_74;
      }
      else if ( v61 != 3 || !a5 )
      {
        goto LABEL_74;
      }
      v93 = __Balloc_D2A(0);
      v93[4] = 1;
      v93[5] = 1;
      v57 = a2[1];
LABEL_85:
      v37 = 98;
      *a4 = v93;
      *a3 = v57;
      *_errno() = 34;
      return v37;
    }
    switch ( v61 )
    {
      case 2:
        if ( !a5 )
          goto LABEL_110;
        break;
      case 3:
        if ( a5 )
          goto LABEL_110;
        break;
      case 1:
LABEL_110:
        *_errno() = 34;
        return 163;
    }
    v63 = *a2 & 0x1F;
    v64 = *a2 >> 5;
    v65 = v64 - ((v63 == 0) - 1);
    v66 = 0;
    for ( i = v65 >> 1; i; i >>= 1 )
      ++v66;
    v68 = __Balloc_D2A(v66);
    *a4 = v68;
    v68[4] = v65;
    if ( v64 > 0 )
    {
      v69 = v68 + 5;
      do
        *v69++ = -1;
      while ( v69 != &v68[v64 + 5] );
      v87 = v64;
    }
    if ( v65 > v64 )
      v68[v87 + 5] = 32 >> (32 - v63);
    v37 = 17;
    *a3 = a2[1];
    return v37;
  }
LABEL_24:
  v22 = 0;
  for ( j = (int)&v19[-v83 - 1]; j > 7; ++v22 )
    j >>= 1;
  v93 = __Balloc_D2A(v22);
  v94 = v93 + 5;
  if ( decimal_point[1] )
  {
    v24 = 0;
    do
      ++v24;
    while ( decimal_point[v24 + 1] );
    v97 = v24;
  }
  else
  {
    v97 = 0;
  }
  if ( (unsigned int)v19 <= v83 )
  {
    v25 = (unsigned int *)(v93 + 5);
    v49 = 0;
    v50 = v93 + 6;
    v52 = 32;
  }
  else
  {
    v25 = (unsigned int *)(v93 + 5);
    v26 = 0;
    v85 = 0;
    v27 = v19;
    v89 = &decimal_point[v97];
    do
    {
      while ( 1 )
      {
        v30 = *(v27 - 1);
        v31 = (unsigned int)(v27 - 1);
        v32 = (int *)(v25 + 1);
        if ( (_BYTE)v30 != *v89 )
          break;
        v27 = (unsigned __int8 *)(v31 - v97);
        if ( v31 - v97 <= v83 )
          goto LABEL_63;
      }
      if ( v26 == 32 )
      {
        v33 = v85;
        v34 = (int *)(v25 + 2);
        v85 = 0;
        *v25++ = v33;
        v30 = *(v27 - 1);
        v32 = v34;
        v28 = 0;
        v26 = 4;
      }
      else
      {
        v28 = v26;
        v26 += 4;
      }
      v29 = (__hexdig_D2A[v30] & 0xF) << v28;
      v27 = (unsigned __int8 *)v31;
      v85 |= v29;
    }
    while ( v31 > v83 );
LABEL_63:
    v49 = v85;
    v50 = v32;
    _BitScanReverse(&v51, v85);
    v52 = v51 ^ 0x1F;
  }
  *v25 = v49;
  v53 = v50 - v94;
  v93[4] = v53;
  v54 = 32 * v53 - v52;
  v55 = *a2;
  if ( v54 > *a2 )
  {
    v62 = v54 - v55;
    v56 = __any_on_D2A((int)v93, v62);
    if ( v56 )
    {
      v56 = 1;
      if ( ((1 << (v62 - 1)) & v94[(v62 - 1) >> 5]) != 0 )
      {
        if ( v62 == 1 || !__any_on_D2A((int)v93, v62 - 1) )
          v56 = 2;
        else
          v56 = 3;
      }
    }
    __rshift_D2A((int)v93, v62);
    v91 += v62;
  }
  else
  {
    v56 = 0;
    if ( v54 < *a2 )
    {
      v76 = v55 - v54;
      v93 = __lshift_D2A(v93, v76);
      v91 -= v76;
      v94 = v93 + 5;
    }
  }
  if ( a2[2] < v91 )
  {
LABEL_109:
    __Bfree_D2A(v93);
    goto LABEL_110;
  }
  v57 = a2[1];
  if ( v57 <= v91 )
  {
    v70 = 1;
  }
  else
  {
    v58 = v57 - v91;
    if ( v55 <= v57 - v91 )
    {
      v59 = a2[3];
      if ( v59 == 2 )
      {
        if ( !a5 )
          goto LABEL_143;
      }
      else if ( v59 == 3 )
      {
        if ( a5 )
          goto LABEL_143;
      }
      else if ( v59 == 1 && v55 == v58 )
      {
        if ( v55 > 1 )
        {
          if ( __any_on_D2A((int)v93, v55 - 1) )
          {
            v57 = a2[1];
            goto LABEL_143;
          }
          goto LABEL_73;
        }
LABEL_143:
        v93[4] = 1;
        *v94 = 1;
        goto LABEL_85;
      }
LABEL_73:
      __Bfree_D2A(v93);
LABEL_74:
      *_errno() = 34;
      return 80;
    }
    v77 = v58 - 1;
    if ( v56 )
    {
      v56 = 1;
    }
    else if ( v58 != 1 )
    {
      v78 = __any_on_D2A((int)v93, v58 - 1);
      v77 = v58 - 1;
      v56 = v78;
    }
    v82 = v58;
    if ( ((1 << v77) & v94[v77 >> 5]) != 0 )
      v56 |= 2u;
    v55 -= v58;
    v70 = 2;
    __rshift_D2A((int)v93, v82);
    v91 = a2[1];
  }
  if ( !v56 )
    goto LABEL_117;
  v71 = a2[3];
  if ( v71 == 2 )
  {
    a5 = 1 - a5;
  }
  else if ( v71 != 3 )
  {
    if ( v71 != 1 || (v56 & 2) == 0 || ((*v94 | v56) & 1) == 0 )
      goto LABEL_116;
    goto LABEL_136;
  }
  if ( a5 )
  {
LABEL_136:
    v79 = v93[4];
    v93 = __increment_D2A(v93);
    v80 = (unsigned int)(v93 + 5);
    if ( v70 == 2 )
    {
      v70 = 34;
      if ( *a2 - 1 == v55 )
        v70 = (((1 << v55) & *(_DWORD *)(v80 + 4 * (v55 >> 5))) == 0) + 33;
      goto LABEL_117;
    }
    if ( v93[4] <= v79
      && ((v81 = v55 & 0x1F) == 0
       || (_BitScanReverse(&v80, *(_DWORD *)(v80 + 4 * v79 - 4)), 32 - v81 <= (int)(v80 ^ 0x1F)))
      || (__rshift_D2A((int)v93, 1), ++v91, a2[2] >= v91) )
    {
      v70 = 33;
      goto LABEL_117;
    }
    goto LABEL_109;
  }
LABEL_116:
  v70 |= 0x10u;
LABEL_117:
  *a4 = v93;
  *a3 = v91;
  return v70;
}
// 537BF0: using guessed type char byte_537BF0;

//----- (00423880) --------------------------------------------------------
int __cdecl __rshift_D2A(int a1, int a2)
{
  int result; // eax
  int v3; // ebx
  _DWORD *v4; // edx
  _DWORD *v5; // esi
  unsigned int v6; // ebx
  int *v7; // esi
  int v8; // eax
  int v9; // edi
  int v10; // edx
  _DWORD *v11; // edi
  signed int v12; // eax
  char v13; // [esp+0h] [ebp-24h]
  _DWORD *v14; // [esp+4h] [ebp-20h]
  unsigned int v15; // [esp+Ch] [ebp-18h]

  result = a2;
  v3 = *(_DWORD *)(a1 + 16);
  v4 = (_DWORD *)(a1 + 20);
  v14 = (_DWORD *)(a1 + 20);
  if ( v3 <= a2 >> 5 )
    goto LABEL_10;
  v5 = &v4[a2 >> 5];
  result = a2 & 0x1F;
  v6 = (unsigned int)&v4[v3];
  v13 = a2 & 0x1F;
  v15 = (unsigned int)v5;
  if ( (a2 & 0x1F) == 0 )
  {
    v11 = (_DWORD *)(a1 + 20);
    if ( v6 > (unsigned int)v5 )
    {
      do
        *v11++ = *v5++;
      while ( v6 > (unsigned int)v5 );
      v12 = 4 * ((v6 + ~v15) >> 2) + 4;
      v4 = (_DWORD *)((char *)v4 + v12);
      result = v12 >> 2;
      goto LABEL_15;
    }
LABEL_10:
    *(_DWORD *)(a1 + 16) = 0;
LABEL_11:
    *(_DWORD *)(a1 + 20) = 0;
    return result;
  }
  v7 = v5 + 1;
  v8 = *(_DWORD *)v15 >> v13;
  if ( v6 > v15 + 4 )
  {
    v9 = a1 + 20;
    do
    {
      v10 = *v7;
      v9 += 4;
      ++v7;
      *(_DWORD *)(v9 - 4) = (v10 << (32 - v13)) | v8;
      v8 = (unsigned int)*(v7 - 1) >> v13;
    }
    while ( v6 > (unsigned int)v7 );
    v4 = (_DWORD *)(a1 + 20 + 4 * ((v6 - v15 - 5) >> 2) + 4);
  }
  *v4 = v8;
  if ( v8 )
    ++v4;
  result = v4 - v14;
LABEL_15:
  *(_DWORD *)(a1 + 16) = result;
  if ( v4 == v14 )
    goto LABEL_11;
  return result;
}

//----- (00423990) --------------------------------------------------------
int __cdecl __trailz_D2A(int a1)
{
  int *v1; // edx
  unsigned int v2; // ebx
  int result; // eax

  v1 = (int *)(a1 + 20);
  v2 = a1 + 20 + 4 * *(_DWORD *)(a1 + 16);
  if ( a1 + 20 >= v2 )
    return 0;
  _ECX = *(_DWORD *)(a1 + 20);
  result = 0;
  if ( _ECX )
  {
LABEL_7:
    __asm { tzcnt   ecx, ecx }
    result += _ECX;
  }
  else
  {
    while ( 1 )
    {
      ++v1;
      result += 32;
      if ( v2 <= (unsigned int)v1 )
        break;
      _ECX = *v1;
      if ( *v1 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (004239E0) --------------------------------------------------------
int __mingw_hexdig_init_D2A()
{
  int v0; // eax
  int v1; // edx
  char v2; // cl
  int v3; // eax
  int v4; // edx
  char v5; // cl
  int result; // eax
  int v7; // edx
  char v8; // cl

  v0 = 48;
  v1 = 0;
  do
  {
    v2 = v1++ + 16;
    __hexdig_D2A[v0] = v2;
    v0 = (unsigned __int8)byte_511A0E[v1];
  }
  while ( (_BYTE)v0 );
  v3 = 97;
  v4 = 0;
  do
  {
    v5 = v4++ + 26;
    __hexdig_D2A[v3] = v5;
    v3 = (unsigned __int8)byte_511A07[v4];
  }
  while ( (_BYTE)v3 );
  result = 65;
  v7 = 0;
  do
  {
    v8 = v7++ + 26;
    __hexdig_D2A[result] = v8;
    result = (unsigned __int8)byte_511A00[v7];
  }
  while ( (_BYTE)result );
  return result;
}

//----- (00423A50) --------------------------------------------------------
int __cdecl __hexnan_D2A(unsigned __int8 **a1, int *a2, int *a3)
{
  int v3; // edx
  unsigned __int8 *v4; // edi
  int *v5; // ebp
  int v6; // edx
  unsigned int v7; // edx
  int v8; // ebx
  int *v9; // esi
  int v10; // ebp
  unsigned __int8 *i; // eax
  char v12; // cl
  unsigned __int8 *v13; // ebp
  char v14; // bl
  char v15; // dl
  int *v16; // ebx
  int v17; // edx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // edi
  int result; // eax
  int *v22; // ebp
  int v23; // edx
  unsigned __int8 j; // dl
  int v25; // eax
  int *v26; // edx
  char v27; // bl
  int v28; // eax
  unsigned int v29; // esi
  int *v30; // edi
  int v31; // eax
  unsigned __int8 *v32; // eax
  int v33; // edx
  char v34; // [esp+8h] [ebp-44h]
  char v35; // [esp+Ch] [ebp-40h]
  int *v36; // [esp+Ch] [ebp-40h]
  int v37; // [esp+10h] [ebp-3Ch]
  int *v38; // [esp+14h] [ebp-38h]
  int v39; // [esp+1Ch] [ebp-30h]
  int *v40; // [esp+24h] [ebp-28h]
  int v41; // [esp+28h] [ebp-24h]
  int v42; // [esp+2Ch] [ebp-20h]

  if ( !byte_537BF0 )
    __mingw_hexdig_init_D2A();
  v42 = *a2 & 0x1F;
  v3 = (int)&a3[(*a2 >> 5) + 1];
  v4 = *a1;
  if ( !v42 )
    v3 = (int)&a3[*a2 >> 5];
  v41 = v3;
  v5 = (int *)(v3 - 4);
  *(_DWORD *)(v3 - 4) = 0;
  while ( 1 )
  {
    v6 = v4[1];
    if ( (unsigned int)(v6 - 1) > 0x1F )
      break;
    ++v4;
  }
  if ( (_BYTE)v6 == 48 && (v4[2] & 0xDF) == 88 && (v7 = v4[3], (unsigned __int8)v7 > 0x20u) )
    v4 += 2;
  else
    v7 = v4[1];
  v8 = 0;
  v38 = v5;
  v9 = v5;
  v40 = v5;
  v37 = 0;
  v10 = 0;
  for ( i = v4 + 1; v7; v4 = i++ )
  {
    v12 = __hexdig_D2A[v7];
    if ( v12 )
    {
      ++v8;
      ++v10;
      if ( v8 > 8 )
      {
        if ( v9 <= a3 )
          goto LABEL_20;
        *(v9 - 1) = 0;
        v23 = 0;
        --v9;
        v8 = 1;
      }
      else
      {
        v23 = 16 * *v9;
      }
      *v9 = v23 | v12 & 0xF;
    }
    else
    {
      if ( v7 > 0x20 )
      {
        v25 = v10;
        v22 = v40;
        if ( v7 == 41 && v25 )
        {
          *a1 = v4 + 2;
          goto LABEL_38;
        }
        v32 = v4 + 2;
        if ( v7 != 41 )
        {
          v33 = (char)v4[2];
          if ( !v4[2] )
            return 4;
          while ( 1 )
          {
            ++v32;
            if ( v33 == 41 )
              break;
            v33 = (char)*v32;
            if ( !*v32 )
              return 4;
          }
        }
        *a1 = v32;
        return 4;
      }
      if ( v10 > v37 )
      {
        if ( v9 < v38 && v8 <= 7 )
        {
          v39 = v10;
          v13 = i;
          v14 = 4 * (8 - v8);
          v15 = 32 - v14;
          v34 = v14;
          v16 = v9;
          v35 = v15;
          v17 = *v9;
          do
          {
            v18 = v16[1];
            *v16++ = (v18 << v35) | v17;
            v19 = v18 >> v34;
            *v16 = v19;
            v17 = v19;
          }
          while ( v38 > v16 );
          i = v13;
          v10 = v39;
        }
        v8 = 8;
        if ( v9 <= a3 )
          goto LABEL_20;
        *(v9 - 1) = 0;
        v37 = v10;
        v38 = --v9;
        v8 = 0;
      }
      for ( j = v4[2]; j <= 0x20u; j = i[1] )
        ++i;
      if ( j == 48 && (i[2] & 0xDF) == 88 && i[3] > 0x20u )
        i += 2;
    }
LABEL_20:
    v7 = i[1];
  }
  v20 = v10;
  result = 4;
  v22 = v40;
  if ( v20 )
  {
LABEL_38:
    if ( v9 < v38 && v8 <= 7 )
    {
      v26 = v9;
      v36 = v9;
      v27 = 4 * (8 - v8);
      v28 = *v9;
      do
      {
        v29 = v26[1];
        *v26++ = (v29 << (32 - v27)) | v28;
        v28 = v29 >> v27;
        *v26 = v29 >> v27;
      }
      while ( v38 > v26 );
      v9 = v36;
    }
    if ( v9 <= a3 )
    {
      v31 = *(_DWORD *)(v41 - 4);
      if ( v42 )
      {
        v31 &= 0xFFFFFFFF >> (32 - v42);
        *(_DWORD *)(v41 - 4) = v31;
      }
    }
    else
    {
      v30 = a3;
      do
        *v30++ = *v9++;
      while ( v22 >= v9 );
      do
        *v30++ = 0;
      while ( v22 >= v30 );
      v31 = *(_DWORD *)(v41 - 4);
    }
    if ( !v31 )
    {
      if ( a3 == v22 )
      {
LABEL_59:
        *v22 = 1;
        return 5;
      }
      while ( !*--v22 )
      {
        if ( a3 == v22 )
          goto LABEL_59;
      }
    }
    return 5;
  }
  return result;
}
// 537BF0: using guessed type char byte_537BF0;

//----- (00423DF0) --------------------------------------------------------
void __usercall dtoa_lock(int a1@<eax>)
{
  int v2; // eax
  __int32 v3; // eax

  if ( dtoa_CS_init == 2 )
    goto LABEL_8;
  if ( dtoa_CS_init )
  {
    if ( dtoa_CS_init != 1 )
      return;
    do
    {
LABEL_4:
      Sleep(1u);
      v2 = dtoa_CS_init;
    }
    while ( dtoa_CS_init == 1 );
    goto LABEL_5;
  }
  v3 = _InterlockedExchange(&dtoa_CS_init, 1);
  if ( !v3 )
  {
    InitializeCriticalSection(&dtoa_CritSec);
    InitializeCriticalSection(&CriticalSection);
    atexit(dtoa_lock_cleanup);
    dtoa_CS_init = 2;
    goto LABEL_8;
  }
  if ( v3 == 2 )
  {
    dtoa_CS_init = 2;
    goto LABEL_8;
  }
  v2 = dtoa_CS_init;
  if ( dtoa_CS_init == 1 )
    goto LABEL_4;
LABEL_5:
  if ( v2 == 2 )
LABEL_8:
    EnterCriticalSection(&dtoa_CritSec + a1);
}
// 537788: using guessed type int dtoa_CS_init;

//----- (00423EC0) --------------------------------------------------------
void __cdecl dtoa_lock_cleanup()
{
  if ( _InterlockedExchange(&dtoa_CS_init, 3) == 2 )
  {
    DeleteCriticalSection(&dtoa_CritSec);
    DeleteCriticalSection(&CriticalSection);
  }
}
// 537788: using guessed type int dtoa_CS_init;

//----- (00423F00) --------------------------------------------------------
int *__cdecl __Balloc_D2A(int a1)
{
  int *result; // eax
  bool v2; // zf
  int v3; // ebx
  int *v4; // [esp+1Ch] [ebp-10h]

  dtoa_lock(0);
  if ( a1 > 9 )
    goto LABEL_5;
  result = (int *)freelist[a1];
  if ( !result )
  {
    result = (int *)pmem_next;
    v3 = 1 << a1;
    if ( ((unsigned int)(4 * (1 << a1) + 27) >> 3) + (((_BYTE *)pmem_next - (_BYTE *)&private_mem) >> 3) <= 0x120 )
    {
      pmem_next = (char *)pmem_next + ((4 * (1 << a1) + 27) & 0xFFFFFFF8);
      goto LABEL_6;
    }
LABEL_5:
    v3 = 1 << a1;
    result = (int *)malloc((4 * (1 << a1) + 27) & 0xFFFFFFF8);
    if ( !result )
      return result;
LABEL_6:
    v2 = dtoa_CS_init == 2;
    result[1] = a1;
    result[2] = v3;
    if ( !v2 )
      goto LABEL_7;
    goto LABEL_4;
  }
  v2 = dtoa_CS_init == 2;
  freelist[a1] = *result;
  if ( v2 )
  {
LABEL_4:
    v4 = result;
    LeaveCriticalSection(&dtoa_CritSec);
    result = v4;
  }
LABEL_7:
  result[4] = 0;
  result[3] = 0;
  return result;
}
// 50CF8C: using guessed type void *pmem_next;
// 537760: using guessed type int freelist[10];
// 537788: using guessed type int dtoa_CS_init;

//----- (00423FD0) --------------------------------------------------------
void __cdecl __Bfree_D2A(void *Block)
{
  int v1; // eax
  bool v2; // zf
  int v3; // edx

  if ( Block )
  {
    if ( *((int *)Block + 1) > 9 )
    {
      free(Block);
    }
    else
    {
      dtoa_lock(0);
      v1 = *((_DWORD *)Block + 1);
      v2 = dtoa_CS_init == 2;
      v3 = freelist[v1];
      freelist[v1] = (int)Block;
      *(_DWORD *)Block = v3;
      if ( v2 )
        LeaveCriticalSection(&dtoa_CritSec);
    }
  }
}
// 537760: using guessed type int freelist[10];
// 537788: using guessed type int dtoa_CS_init;

//----- (00424040) --------------------------------------------------------
int *__cdecl __multadd_D2A(int *a1, int a2, int a3)
{
  int v3; // ecx
  __int64 v4; // rdi
  _DWORD *v5; // ebp
  unsigned int v6; // eax
  int v7; // ebx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax
  int *v10; // ebx
  int *v12; // eax
  int v13; // [esp+1Ch] [ebp-20h]

  v3 = 0;
  HIDWORD(v4) = a3;
  LODWORD(v4) = a3 >> 31;
  v13 = a1[4];
  v5 = a1 + 5;
  do
  {
    v6 = v5[v3];
    v7 = v6 * (a2 >> 31);
    v8 = (unsigned int)a2 * (unsigned __int64)v6;
    HIDWORD(v8) += v7;
    v9 = __PAIR64__(v4, HIDWORD(v4)) + v8;
    v5[v3] = v9;
    LODWORD(v4) = 0;
    ++v3;
    HIDWORD(v4) = HIDWORD(v9);
  }
  while ( v13 > v3 );
  v10 = a1;
  if ( v4 )
  {
    if ( a1[2] <= v13 )
    {
      v12 = __Balloc_D2A(a1[1] + 1);
      v10 = v12;
      if ( !v12 )
        return v10;
      memcpy(v12 + 3, a1 + 3, 4 * a1[4] + 8);
      __Bfree_D2A(a1);
      a1 = v10;
    }
    a1[v13 + 5] = HIDWORD(v4);
    v10 = a1;
    a1[4] = v13 + 1;
  }
  return v10;
}

//----- (00424130) --------------------------------------------------------
int *__cdecl __i2b_D2A(int a1)
{
  int *result; // eax

  result = __Balloc_D2A(1);
  if ( result )
  {
    result[4] = 1;
    result[5] = a1;
  }
  return result;
}

//----- (00424160) --------------------------------------------------------
int *__cdecl __mult_D2A(int a1, int a2)
{
  int v2; // esi
  int v3; // ebp
  int v4; // edi
  int v5; // ebx
  int *v6; // eax
  unsigned int *v7; // eax
  unsigned int *v8; // edx
  unsigned int v9; // ebp
  unsigned int *v10; // esi
  unsigned int v11; // ebx
  __int64 v12; // kr08_8
  int v13; // edx
  __int64 v15; // [esp+10h] [ebp-4Ch]
  unsigned int v16; // [esp+1Ch] [ebp-40h]
  unsigned int v17; // [esp+24h] [ebp-38h]
  unsigned int *v18; // [esp+28h] [ebp-34h]
  unsigned int v19; // [esp+2Ch] [ebp-30h]
  int v20; // [esp+30h] [ebp-2Ch]
  int *v21; // [esp+34h] [ebp-28h]
  unsigned int v22; // [esp+38h] [ebp-24h]
  unsigned int *i; // [esp+3Ch] [ebp-20h]

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a2 + 16);
  if ( v4 < v5 )
  {
    v4 = *(_DWORD *)(a2 + 16);
    v5 = *(_DWORD *)(a1 + 16);
    v2 = a2;
    v3 = a1;
  }
  v20 = v4 + v5;
  v6 = __Balloc_D2A(*(_DWORD *)(v2 + 4) + (*(_DWORD *)(v2 + 8) < v4 + v5));
  v21 = v6;
  if ( v6 )
  {
    v7 = (unsigned int *)(v6 + 5);
    v18 = v7;
    v8 = &v7[v20];
    for ( i = v8; v8 > v7; ++v7 )
      *v7 = 0;
    v22 = v2 + 20;
    v17 = v2 + 20 + 4 * v4;
    v16 = v3 + 20;
    v19 = v3 + 20 + 4 * v5;
    if ( v3 + 20 < v19 )
    {
      do
      {
        while ( 1 )
        {
          v16 += 4;
          v9 = *(_DWORD *)(v16 - 4);
          if ( v9 )
            break;
          ++v18;
          if ( v19 <= v16 )
            goto LABEL_14;
        }
        v10 = v18;
        v15 = 0LL;
        v11 = v22;
        while ( 1 )
        {
          v11 += 4;
          v12 = v15 + *v10 + *(unsigned int *)(v11 - 4) * (unsigned __int64)v9;
          *v10 = v12;
          v15 = HIDWORD(v12);
          if ( v17 <= v11 )
            break;
          ++v10;
        }
        ++v18;
        v10[1] = HIDWORD(v12);
      }
      while ( v19 > v16 );
    }
LABEL_14:
    v13 = v20;
    if ( v20 > 0 && !*(i - 1) )
    {
      do
        --v13;
      while ( v13 && !i[v13 - v20 - 1] );
      v20 = v13;
    }
    v21[4] = v20;
  }
  return v21;
}

//----- (004242D0) --------------------------------------------------------
int __cdecl __pow5mult_D2A(int *a1, int a2)
{
  int *v2; // esi
  int v3; // ebx
  int v4; // ebp
  int **v5; // edi
  int *v6; // esi
  int *v7; // eax
  int *v9; // eax
  int *v10; // eax
  LPCRITICAL_SECTION lpCriticalSection; // [esp+0h] [ebp-2Ch]

  v2 = a1;
  if ( (a2 & 3) == 0 || (v2 = __multadd_D2A(a1, dword_511A1C[a2 & 3], 0)) != 0 )
  {
    v3 = a2 >> 2;
    v4 = (int)v2;
    if ( a2 >> 2 )
    {
      v5 = (int **)p5s;
      if ( !p5s )
      {
        dtoa_lock(1);
        v5 = (int **)p5s;
        if ( !p5s )
        {
          v10 = __Balloc_D2A(1);
          v5 = (int **)v10;
          if ( !v10 )
          {
            p5s = 0;
            return 0;
          }
          v10[5] = 625;
          v10[4] = 1;
          p5s = (int)v10;
          *v10 = 0;
        }
        if ( dtoa_CS_init == 2 )
          LeaveCriticalSection(&CriticalSection);
      }
      v4 = (int)v2;
      if ( (v3 & 1) != 0 )
        goto LABEL_9;
LABEL_5:
      v3 >>= 1;
      if ( v3 )
      {
        while ( 1 )
        {
          v6 = *v5;
          if ( *v5 )
            goto LABEL_7;
          dtoa_lock(1);
          v6 = *v5;
          if ( !*v5 )
          {
            v9 = __mult_D2A((int)v5, (int)v5);
            v6 = v9;
            *v5 = v9;
            if ( !v9 )
              return 0;
            *v9 = 0;
          }
          if ( dtoa_CS_init != 2 )
          {
LABEL_7:
            v5 = (int **)v6;
          }
          else
          {
            v5 = (int **)v6;
            LeaveCriticalSection(&CriticalSection);
          }
          if ( (v3 & 1) == 0 )
            goto LABEL_5;
LABEL_9:
          v7 = __mult_D2A(v4, (int)v5);
          if ( !v7 )
            return 0;
          lpCriticalSection = (LPCRITICAL_SECTION)v4;
          v4 = (int)v7;
          __Bfree_D2A(lpCriticalSection);
          v3 >>= 1;
          if ( !v3 )
            return v4;
        }
      }
    }
    return v4;
  }
  return 0;
}
// 511A1C: using guessed type int dword_511A1C[];
// 536E40: using guessed type int p5s;
// 537788: using guessed type int dtoa_CS_init;

//----- (00424450) --------------------------------------------------------
int *__cdecl __lshift_D2A(int *a1, int a2)
{
  int v2; // edx
  int v3; // esi
  int v4; // ebx
  int i; // eax
  int *v6; // eax
  int *v7; // eax
  int *v8; // edi
  int *v9; // esi
  unsigned int v10; // edx
  int v11; // eax
  int v12; // ebp
  _DWORD *v14; // edi
  _DWORD *v15; // esi
  int *v16; // [esp+24h] [ebp-28h]
  int v17; // [esp+28h] [ebp-24h]

  v2 = a1[1];
  v3 = a2 >> 5;
  v4 = (a2 >> 5) + a1[4] + 1;
  v17 = (a2 >> 5) + a1[4];
  for ( i = a1[2]; v4 > i; ++v2 )
    i *= 2;
  v6 = __Balloc_D2A(v2);
  v16 = v6;
  if ( v6 )
  {
    v7 = v6 + 5;
    if ( v3 <= 0 )
    {
      v8 = v7;
    }
    else
    {
      v8 = &v7[v3];
      do
        *v7++ = 0;
      while ( v7 != v8 );
    }
    v9 = a1 + 5;
    v10 = (unsigned int)&a1[a1[4] + 5];
    if ( (a2 & 0x1F) != 0 )
    {
      v11 = 0;
      while ( 1 )
      {
        v12 = *v9++;
        *v8 = (v12 << (a2 & 0x1F)) | v11;
        v11 = (unsigned int)*(v9 - 1) >> (32 - (a2 & 0x1F));
        if ( v10 <= (unsigned int)v9 )
          break;
        ++v8;
      }
      v8[1] = v11;
      if ( v11 )
        v4 = v17 + 2;
    }
    else
    {
      do
      {
        *v8 = *v9;
        v15 = v9 + 1;
        v14 = v8 + 1;
        if ( v10 <= (unsigned int)v15 )
          break;
        *v14 = *v15;
        v9 = v15 + 1;
        v8 = v14 + 1;
      }
      while ( v10 > (unsigned int)v9 );
    }
    v16[4] = v4 - 1;
    __Bfree_D2A(a1);
  }
  return v16;
}

//----- (00424570) --------------------------------------------------------
int __cdecl __cmp_D2A(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ecx
  _DWORD *v5; // edx
  _DWORD *v6; // ecx

  v2 = *(_DWORD *)(a2 + 16);
  result = *(_DWORD *)(a1 + 16) - v2;
  if ( !result )
  {
    v4 = 4 * v2;
    v5 = (_DWORD *)(a1 + 20 + 4 * v2);
    v6 = (_DWORD *)(a2 + v4 + 20);
    while ( *--v5 == *--v6 )
    {
      if ( a1 + 20 >= (unsigned int)v5 )
        return result;
    }
    return *v5 < *v6 ? -1 : 1;
  }
  return result;
}

//----- (004245C0) --------------------------------------------------------
int *__cdecl __diff_D2A(int *a1, int *a2)
{
  int *v2; // ebx
  int *v3; // esi
  int v4; // eax
  int v5; // edi
  int v6; // edx
  int *v7; // eax
  int *v8; // edx
  int *v9; // eax
  unsigned int v10; // ebp
  int v11; // eax
  unsigned int v12; // esi
  int v13; // ecx
  int v14; // edx
  unsigned int v15; // ebp
  _DWORD *v16; // ecx
  int *v17; // ebx
  int v18; // eax
  unsigned int v19; // ebp
  int v20; // eax
  int *v22; // [esp+10h] [ebp-3Ch]
  _DWORD *v23; // [esp+18h] [ebp-34h]
  unsigned int v24; // [esp+20h] [ebp-2Ch]
  int *v25; // [esp+24h] [ebp-28h]
  int v26; // [esp+28h] [ebp-24h]
  unsigned int v27; // [esp+2Ch] [ebp-20h]

  v2 = a1;
  v3 = a2;
  v4 = a2[4];
  v5 = a1[4] - v4;
  if ( v5 )
  {
    v5 = 0;
    if ( a1[4] - v4 < 0 )
    {
LABEL_21:
      v5 = 1;
      v2 = a2;
      v3 = a1;
    }
LABEL_6:
    v9 = __Balloc_D2A(v2[1]);
    v25 = v9;
    if ( v9 )
    {
      v9[3] = v5;
      v23 = v2 + 5;
      v26 = v2[4];
      v22 = v9 + 5;
      v10 = (unsigned int)(v3 + 5);
      v27 = (unsigned int)&v2[v26 + 5];
      v11 = v3[4];
      v12 = 0;
      v24 = v10 + 4 * v11;
      while ( 1 )
      {
        v10 += 4;
        ++v22;
        v13 = *v23 - *(_DWORD *)(v10 - 4) - v12;
        v12 = (((unsigned int)*v23 - (unsigned __int64)*(unsigned int *)(v10 - 4) - v12) >> 32) & 1;
        v14 = v13;
        *(v22 - 1) = v13;
        if ( v24 <= v10 )
          break;
        ++v23;
      }
      v15 = (unsigned int)v22;
      v16 = v23 + 1;
      if ( v27 > (unsigned int)(v23 + 1) )
      {
        v17 = v22;
        do
        {
          v18 = *v16++ - v12;
          ++v17;
          v12 = (((unsigned int)*(v16 - 1) - (unsigned __int64)v12) >> 32) & 1;
          v14 = v18;
          *(v17 - 1) = v18;
        }
        while ( v27 > (unsigned int)v16 );
        v15 = (unsigned int)&v22[((v27 - (unsigned int)v23 - 5) >> 2) + 1];
      }
      if ( !v14 )
      {
        v19 = v15 - 4 * v26;
        v20 = v26;
        do
          --v20;
        while ( !*(_DWORD *)(v19 + 4 * v20 - 4) );
        v26 = v20;
      }
      v25[4] = v26;
    }
    return v25;
  }
  else
  {
    v6 = v4;
    v7 = &a1[v4 + 5];
    v8 = &a2[v6 + 5];
    do
    {
      if ( *--v7 != *--v8 )
      {
        if ( *v7 < (unsigned int)*v8 )
          goto LABEL_21;
        goto LABEL_6;
      }
    }
    while ( a1 + 5 < v7 );
    v25 = __Balloc_D2A(0);
    if ( !v25 )
      return v25;
    v25[4] = 1;
    v25[5] = 0;
    return v25;
  }
}

//----- (004247A0) --------------------------------------------------------
long double __cdecl __b2d_D2A(int a1, _DWORD *a2)
{
  unsigned int v2; // esi
  int v3; // ebx
  unsigned int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  signed int v7; // eax
  int v8; // edi
  int v10; // eax
  unsigned int v11; // edi
  int v12; // edx
  double v13; // [esp+0h] [ebp-24h]
  double v14; // [esp+0h] [ebp-24h]

  v2 = a1 + 20;
  v3 = a1 + 20 + 4 * *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(v3 - 4);
  v5 = v3 - 4;
  _BitScanReverse(&v6, v4);
  v7 = v6 ^ 0x1F;
  *a2 = 32 - v7;
  if ( v7 > 10 )
  {
    v10 = v7 - 11;
    if ( v2 >= v5 )
    {
      v11 = 0;
      if ( v10 )
      {
        v11 = 0;
        HIDWORD(v14) = (v4 << v10) | 0x3FF00000;
        goto LABEL_11;
      }
    }
    else
    {
      v11 = *(_DWORD *)(v3 - 8);
      if ( v10 )
      {
        v12 = (v11 >> (32 - v10)) | (v4 << v10) | 0x3FF00000;
        v11 <<= v10;
        HIDWORD(v14) = v12;
        if ( v2 < v3 - 8 )
          v11 |= *(_DWORD *)(v3 - 12) >> (32 - v10);
        goto LABEL_11;
      }
    }
    HIDWORD(v14) = v4 | 0x3FF00000;
LABEL_11:
    LODWORD(v14) = v11;
    return v14;
  }
  v8 = 0;
  if ( v2 < v5 )
    v8 = *(_DWORD *)(v3 - 8) >> (11 - v7);
  LODWORD(v13) = v8 | (v4 << (v7 + 21));
  HIDWORD(v13) = (v4 >> (11 - v7)) | 0x3FF00000;
  return v13;
}

//----- (004248A0) --------------------------------------------------------
int *__cdecl __d2b_D2A(double a1, _DWORD *a2, _DWORD *a3)
{
  int *result; // eax
  int v5; // edi
  unsigned int v8; // ebp
  int v9; // edx
  unsigned int v11; // ecx

  result = __Balloc_D2A(1);
  if ( result )
  {
    _EDX = HIDWORD(a1) & 0xFFFFF;
    v5 = (HIDWORD(a1) >> 20) & 0x7FF;
    if ( v5 )
      _EDX = HIDWORD(a1) & 0xFFFFF | 0x100000;
    _EBX = LODWORD(a1);
    if ( LODWORD(a1) )
    {
      __asm { tzcnt   esi, ebx }
      if ( _ESI )
      {
        v8 = _EDX << (32 - _ESI);
        _EDX >>= _ESI;
        result[5] = (LODWORD(a1) >> _ESI) | v8;
      }
      else
      {
        result[5] = LODWORD(a1);
      }
      result[6] = _EDX;
      v9 = (_EDX != 0) + 1;
      result[4] = v9;
      if ( v5 )
        goto LABEL_8;
    }
    else
    {
      result[4] = 1;
      __asm { tzcnt   ecx, edx }
      _ESI = _ECX + 32;
      result[5] = _EDX >> _ECX;
      v9 = 1;
      if ( v5 )
      {
LABEL_8:
        *a2 = v5 + _ESI - 1075;
        *a3 = 53 - _ESI;
        return result;
      }
    }
    _BitScanReverse(&v11, result[v9 + 4]);
    *a2 = _ESI - 1074;
    *a3 = 32 * v9 - (v11 ^ 0x1F);
  }
  return result;
}

//----- (004249A0) --------------------------------------------------------
int __cdecl __strcp_D2A(__int64 a1)
{
  __int64 v1; // rax
  char v2; // cl
  char v3; // cl

  v1 = a1 + 0x100000000LL;
  v2 = *(_BYTE *)HIDWORD(a1);
  *(_BYTE *)a1 = *(_BYTE *)HIDWORD(a1);
  if ( v2 )
  {
    do
    {
      v3 = *(_BYTE *)HIDWORD(v1)++;
      LODWORD(v1) = v1 + 1;
      *(_BYTE *)v1 = v3;
    }
    while ( v3 );
  }
  return v1;
}

//----- (004249D0) --------------------------------------------------------
int *__cdecl __s2b_D2A(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int *result; // eax
  char *v10; // ebp
  char *v11; // ebx
  char *v12; // esi

  v5 = a2;
  v6 = (a3 + 8) / 9;
  if ( v6 <= 1 )
  {
    v8 = 0;
  }
  else
  {
    v7 = 1;
    v8 = 0;
    do
    {
      v7 *= 2;
      ++v8;
    }
    while ( v6 > v7 );
  }
  result = __Balloc_D2A(v8);
  result[4] = 1;
  result[5] = a4;
  if ( a2 <= 9 )
  {
    v11 = (char *)(a1 + a5 + 9);
    v5 = 9;
  }
  else
  {
    v10 = (char *)(a1 + 9);
    do
      result = __multadd_D2A(result, 10, *v10++ - 48);
    while ( v10 != (char *)(a1 + a2) );
    v11 = (char *)(a1 + a2 + a5);
  }
  if ( a3 > v5 )
  {
    v12 = &v11[a3 - v5];
    do
      result = __multadd_D2A(result, 10, *v11++ - 48);
    while ( v12 != v11 );
  }
  return result;
}

//----- (00424AB0) --------------------------------------------------------
long double __cdecl __ratio_D2A(int a1, int a2)
{
  int v2; // eax
  double v4; // [esp+10h] [ebp-3Ch]
  double v5; // [esp+18h] [ebp-34h]
  double v6; // [esp+20h] [ebp-2Ch]
  double v7; // [esp+28h] [ebp-24h]
  int v8; // [esp+38h] [ebp-14h] BYREF
  int v9[4]; // [esp+3Ch] [ebp-10h] BYREF

  v4 = __b2d_D2A(a1, &v8);
  v6 = v4;
  v5 = __b2d_D2A(a2, v9);
  v7 = v5;
  v2 = v8 + 32 * (*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16)) - v9[0];
  if ( v2 <= 0 )
  {
    HIDWORD(v7) = HIDWORD(v5) - (v2 << 20);
    return v4 / v7;
  }
  else
  {
    HIDWORD(v6) = HIDWORD(v4) + (v2 << 20);
    return v6 / v5;
  }
}
// 424AB0: using guessed type int var_10[4];

//----- (00424B70) --------------------------------------------------------
int __cdecl __match_D2A(char **a1, int a2)
{
  char *v3; // edx
  int v4; // eax

  v3 = *a1;
  do
  {
    ++a2;
    ++v3;
    if ( !*(_BYTE *)(a2 - 1) )
    {
      *a1 = v3;
      return 1;
    }
    v4 = *v3;
    if ( (unsigned int)(v4 - 65) < 0x1A )
      v4 += 32;
  }
  while ( v4 == *(char *)(a2 - 1) );
  return 0;
}

//----- (00424BC0) --------------------------------------------------------
unsigned int __cdecl __copybits_D2A(_DWORD *a1, int a2, int a3)
{
  unsigned int result; // eax
  _DWORD *v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // edx
  _DWORD *v7; // edi

  result = (unsigned int)a1;
  v4 = (_DWORD *)(a3 + 20);
  v5 = (unsigned int)&a1[((a2 - 1) >> 5) + 1];
  v6 = a3 + 20 + 4 * *(_DWORD *)(a3 + 16);
  if ( a3 + 20 >= v6 )
    goto LABEL_6;
  v7 = a1;
  do
    *v7++ = *v4++;
  while ( v6 > (unsigned int)v4 );
  result = (unsigned int)&a1[((v6 - a3 - 21) >> 2) + 1];
  while ( v5 > result )
  {
    result += 4;
    *(_DWORD *)(result - 4) = 0;
LABEL_6:
    ;
  }
  return result;
}

//----- (00424C20) --------------------------------------------------------
int __cdecl __any_on_D2A(int a1, int a2)
{
  int v2; // edx
  unsigned int v3; // esi
  int v4; // eax
  _DWORD *v5; // ebx
  int result; // eax
  _DWORD *v7; // edx
  _DWORD *v8; // ecx

  v2 = *(_DWORD *)(a1 + 16);
  v3 = a1 + 20;
  v4 = a2 >> 5;
  if ( v2 >= a2 >> 5 )
  {
    v5 = (_DWORD *)(v3 + 4 * v4);
    if ( v2 > v4 && (a2 & 0x1F) != 0 )
    {
      result = 1;
      if ( *v5 != *v5 >> (a2 & 0x1F) << (a2 & 0x1F) )
        return result;
    }
  }
  else
  {
    v5 = (_DWORD *)(v3 + 4 * v2);
  }
  if ( v3 >= (unsigned int)v5 )
    return 0;
  result = *(v5 - 1);
  v7 = v5 - 1;
  if ( result )
    return 1;
  v8 = (_DWORD *)((char *)v5 + (~((unsigned int)v7 - v3 + 3) & 0xFFFFFFFC));
  while ( v8 != v7 )
  {
    if ( *--v7 )
      return 1;
  }
  return result;
}

//----- (00424EE0) --------------------------------------------------------
FILE *__cdecl __acrt_iob_func(unsigned int Ix)
{
  return &__iob[Ix];
}

//----- (00424EF0) --------------------------------------------------------
_invalid_parameter_handler __cdecl _get_invalid_parameter_handler()
{
  return (_invalid_parameter_handler)bss_2;
}
// 5377E0: using guessed type int bss_2;

//----- (00424F00) --------------------------------------------------------
_invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler Handler)
{
  return (_invalid_parameter_handler)_InterlockedExchange(&bss_2, (__int32)Handler);
}
// 5377E0: using guessed type int bss_2;

//----- (00424F10) --------------------------------------------------------
errno_t __cdecl _stub(int *a1, const char *a2, int a3, int a4, int a5)
{
  errno_t (__cdecl *_sopen_s)(int *, const char *, int, int, int); // eax
  int v6; // edx
  HMODULE ModuleHandleW; // eax

  _sopen_s = __sopen_s;
  v6 = a5;
  if ( (char *)__sopen_s == (char *)_stub )
  {
    ModuleHandleW = GetModuleHandleW(L"msvcrt.dll");
    _sopen_s = (errno_t (__cdecl *)(int *, const char *, int, int, int))GetProcAddress(ModuleHandleW, "_sopen_s");
    if ( !_sopen_s )
      _sopen_s = (errno_t (__cdecl *)(int *, const char *, int, int, int))_int_sopen_s;
    v6 = a5;
    __sopen_s = _sopen_s;
  }
  return _sopen_s(a1, a2, a3, a4, v6);
}

//----- (00424FA0) --------------------------------------------------------
int __cdecl _int_sopen_s(int *a1, char *FileName, int OpenFlag, int ShareFlag, int a5)
{
  if ( a1 && FileName )
  {
    *a1 = _sopen(FileName, OpenFlag, ShareFlag, a5);
    return *_errno();
  }
  else
  {
    if ( a1 )
      *a1 = -1;
    *_errno() = 22;
    return 22;
  }
}

//----- (00425030) --------------------------------------------------------
int __cdecl _tr_align(int a1)
{
  int result; // eax
  int v2; // ecx
  int v3; // ebx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  char v7; // bl
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  char v14; // bl
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edx
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // edx
  char v23; // bl
  int v24; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5820);
  LOWORD(v3) = *(_WORD *)(a1 + 5816) | (2 << v2);
  *(_WORD *)(a1 + 5816) = v3;
  if ( v2 <= 13 )
  {
    v10 = v2 + 3;
    *(_DWORD *)(a1 + 5820) = v10;
    if ( v10 > 9 )
    {
LABEL_3:
      v11 = *(_DWORD *)(a1 + 20);
      v12 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v11 + 1;
      *(_BYTE *)(v12 + v11) = v3;
      v13 = *(_DWORD *)(a1 + 20);
      v14 = *(_BYTE *)(a1 + 5817);
      v15 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v13 + 1;
      *(_BYTE *)(v15 + v13) = v14;
      v16 = *(_DWORD *)(a1 + 5820);
      LOBYTE(v3) = 0;
      *(_WORD *)(a1 + 5816) = 0;
      v17 = v16 - 9;
      *(_DWORD *)(a1 + 5820) = v16 - 9;
      if ( v16 != 25 )
        goto LABEL_4;
LABEL_9:
      v20 = *(_DWORD *)(a1 + 20);
      v21 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v20 + 1;
      *(_BYTE *)(v21 + v20) = v3;
      v22 = *(_DWORD *)(a1 + 20);
      v23 = *(_BYTE *)(a1 + 5817);
      v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v22 + 1;
      *(_BYTE *)(v24 + v22) = v23;
      *(_WORD *)(a1 + 5816) = 0;
      *(_DWORD *)(a1 + 5820) = 0;
      return result;
    }
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 20);
    v5 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v4 + 1;
    *(_BYTE *)(v5 + v4) = v3;
    v6 = *(_DWORD *)(a1 + 20);
    v7 = *(_BYTE *)(a1 + 5817);
    v8 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v6 + 1;
    *(_BYTE *)(v8 + v6) = v7;
    v9 = *(_DWORD *)(a1 + 5820);
    v10 = v9 - 13;
    v3 = 2 >> (16 - v9);
    *(_WORD *)(a1 + 5816) = v3;
    *(_DWORD *)(a1 + 5820) = v9 - 13;
    if ( v9 - 13 > 9 )
      goto LABEL_3;
  }
  v17 = v10 + 7;
  *(_DWORD *)(a1 + 5820) = v17;
  if ( v17 == 16 )
    goto LABEL_9;
LABEL_4:
  if ( v17 > 7 )
  {
    v18 = *(_DWORD *)(a1 + 20);
    v19 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v18 + 1;
    *(_BYTE *)(v19 + v18) = v3;
    *(_DWORD *)(a1 + 5820) -= 8;
    *(_WORD *)(a1 + 5816) >>= 8;
  }
  return result;
}

//----- (00425170) --------------------------------------------------------
int __cdecl _tr_flush_bits(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // edx
  __int16 v4; // bx
  int v5; // ecx
  int v6; // edx
  __int16 v7; // bx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5820);
  if ( v2 == 16 )
  {
    v6 = *(_DWORD *)(a1 + 20);
    v7 = *(_WORD *)(a1 + 5816);
    v8 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v6 + 1;
    *(_BYTE *)(v8 + v6) = v7;
    v9 = *(_DWORD *)(a1 + 20);
    LOBYTE(v7) = *(_BYTE *)(a1 + 5817);
    v10 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v9 + 1;
    *(_BYTE *)(v10 + v9) = v7;
    *(_WORD *)(a1 + 5816) = 0;
    *(_DWORD *)(a1 + 5820) = 0;
  }
  else if ( v2 > 7 )
  {
    v3 = *(_DWORD *)(a1 + 20);
    v4 = *(_WORD *)(a1 + 5816);
    v5 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v3 + 1;
    *(_BYTE *)(v5 + v3) = v4;
    *(_DWORD *)(a1 + 5820) -= 8;
    *(_WORD *)(a1 + 5816) >>= 8;
  }
  return result;
}

//----- (00425200) --------------------------------------------------------
int __cdecl _tr_flush_block(int a1, void *a2, size_t a3, int a4)
{
  size_t v4; // ebp
  _WORD *v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // eax
  unsigned int v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  int v18; // esi
  int v19; // ebp
  int v20; // edx
  int v21; // ecx
  __int16 v22; // ax
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // edx
  int v27; // ecx
  int v28; // edx
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // edx
  int v34; // edx
  int v35; // ecx
  int v36; // edx
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  int v41; // edx
  int v42; // edx
  int v43; // ecx
  int v44; // eax
  unsigned __int8 v45; // si
  int v46; // ecx
  int v47; // edi
  int v48; // eax
  int v49; // edi
  int v50; // edi
  int v51; // esi
  int v52; // esi
  int v53; // eax
  unsigned int v54; // edx
  int v55; // eax
  _WORD *v56; // eax
  int v57; // esi
  int v58; // ecx
  __int16 v59; // ax
  int v60; // esi
  int v61; // eax
  int v62; // esi
  int v63; // eax
  int v64; // eax
  int v65; // eax
  int result; // eax
  int v67; // eax
  __int16 v68; // cx
  int v69; // eax
  int v70; // edx
  int v71; // eax
  int v72; // edx
  int v73; // ecx
  __int16 v74; // ax
  int v75; // edx
  int v76; // eax
  int v77; // edx
  int v78; // edx
  int v79; // edx
  int v80; // eax
  int v81; // eax
  int i; // [esp+18h] [ebp-34h]
  int v83; // [esp+1Ch] [ebp-30h]
  int v84; // [esp+20h] [ebp-2Ch]
  int v85; // [esp+24h] [ebp-28h]
  int v86; // [esp+28h] [ebp-24h]
  int v87; // [esp+2Ch] [ebp-20h]

  v4 = a3 + 4;
  if ( *(int *)(a1 + 132) <= 0 )
  {
    if ( a3 + 5 < v4 || !a2 )
    {
      v13 = *(_DWORD *)(a1 + 5820);
      LOWORD(v14) = *(_WORD *)(a1 + 5816);
      v84 = a1 + 148;
      v85 = a1 + 2440;
      goto LABEL_52;
    }
    v84 = a1 + 148;
    v85 = a1 + 2440;
LABEL_68:
    _tr_stored_block(a1, a2, a3, a4);
    goto LABEL_55;
  }
  if ( *(_DWORD *)(*(_DWORD *)a1 + 44) == 2 )
  {
    v53 = 0;
    v54 = -201342849;
    do
    {
      if ( (v54 & 1) != 0 && *(_WORD *)(a1 + 4 * v53 + 148) )
      {
LABEL_76:
        v55 = 0;
        goto LABEL_48;
      }
      ++v53;
      v54 >>= 1;
    }
    while ( v53 != 32 );
    v55 = 1;
    if ( !*(_WORD *)(a1 + 184) && !*(_WORD *)(a1 + 188) && !*(_WORD *)(a1 + 200) )
    {
      v56 = (_WORD *)(a1 + 276);
      while ( !*v56 )
      {
        v56 += 2;
        if ( v56 == (_WORD *)(a1 + 1172) )
          goto LABEL_76;
      }
      v55 = 1;
    }
LABEL_48:
    *(_DWORD *)(*(_DWORD *)a1 + 44) = v55;
  }
  build_tree(a1, a1 + 2840);
  build_tree(a1, a1 + 2852);
  v84 = a1 + 148;
  scan_tree((_WORD *)a1, a1 + 148, *(_DWORD *)(a1 + 2844));
  v85 = a1 + 2440;
  v5 = scan_tree((_WORD *)a1, a1 + 2440, *(_DWORD *)(a1 + 2856));
  build_tree((int)v5, a1 + 2864);
  if ( *(_WORD *)(a1 + 2746) )
  {
    v7 = 18;
  }
  else if ( *(_WORD *)(a1 + 2690) )
  {
    v7 = 17;
  }
  else if ( *(_WORD *)(a1 + 2742) )
  {
    v7 = 16;
  }
  else if ( *(_WORD *)(a1 + 2694) )
  {
    v7 = 15;
  }
  else if ( *(_WORD *)(a1 + 2738) )
  {
    v7 = 14;
  }
  else if ( *(_WORD *)(a1 + 2698) )
  {
    v7 = 13;
  }
  else if ( *(_WORD *)(a1 + 2734) )
  {
    v7 = 12;
  }
  else if ( *(_WORD *)(a1 + 2702) )
  {
    v7 = 11;
  }
  else if ( *(_WORD *)(a1 + 2730) )
  {
    v7 = 10;
  }
  else if ( *(_WORD *)(a1 + 2706) )
  {
    v7 = 9;
  }
  else if ( *(_WORD *)(a1 + 2726) )
  {
    v7 = 8;
  }
  else if ( *(_WORD *)(a1 + 2710) )
  {
    v7 = 7;
  }
  else if ( *(_WORD *)(a1 + 2722) )
  {
    v7 = 6;
  }
  else if ( *(_WORD *)(a1 + 2714) )
  {
    v7 = 5;
  }
  else if ( *(_WORD *)(a1 + 2718) )
  {
    v7 = 4;
  }
  else
  {
    v6 = 9;
    v7 = 2;
    if ( !*(_WORD *)(a1 + 2686) )
      goto LABEL_19;
    v7 = 3;
  }
  v6 = 3 * v7 + 3;
LABEL_19:
  v8 = v6 + *(_DWORD *)(a1 + 5800) + 14;
  v9 = v6 + *(_DWORD *)(a1 + 5800) + 24;
  *(_DWORD *)(a1 + 5800) = v8;
  v10 = v9 >> 3;
  v11 = (unsigned int)(*(_DWORD *)(a1 + 5804) + 10) >> 3;
  v12 = v11;
  if ( v10 <= v11 )
    v12 = v10;
  if ( v12 >= v4 && a2 )
    goto LABEL_68;
  v13 = *(_DWORD *)(a1 + 5820);
  v14 = *(unsigned __int16 *)(a1 + 5816);
  if ( *(_DWORD *)(a1 + 136) == 4 || v10 >= v11 )
  {
LABEL_52:
    if ( v13 <= 13 )
    {
      *(_DWORD *)(a1 + 5820) = v13 + 3;
      *(_WORD *)(a1 + 5816) = (((_WORD)a4 + 2) << v13) | v14;
    }
    else
    {
      v57 = (unsigned __int16)(a4 + 2) << v13;
      v58 = *(_DWORD *)(a1 + 20);
      v59 = v57 | v14;
      v60 = *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 5816) = v59;
      *(_DWORD *)(a1 + 20) = v58 + 1;
      *(_BYTE *)(v60 + v58) = v59;
      v61 = *(_DWORD *)(a1 + 20);
      LOBYTE(v58) = *(_BYTE *)(a1 + 5817);
      v62 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v61 + 1;
      *(_BYTE *)(v62 + v61) = v58;
      v63 = *(_DWORD *)(a1 + 5820);
      *(_DWORD *)(a1 + 5820) = v63 - 13;
      *(_WORD *)(a1 + 5816) = (int)(unsigned __int16)(a4 + 2) >> (16 - v63);
    }
    compress_block(a1, (int)&static_ltree, (int)&static_dtree);
    goto LABEL_55;
  }
  v15 = (unsigned __int16)(a4 + 4) << v13;
  if ( v13 > 13 )
  {
    v73 = *(_DWORD *)(a1 + 8);
    v74 = v15 | v14;
    v75 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5816) = v74;
    *(_DWORD *)(a1 + 20) = v75 + 1;
    *(_BYTE *)(v73 + v75) = v74;
    v76 = *(_DWORD *)(a1 + 20);
    LOBYTE(v73) = *(_BYTE *)(a1 + 5817);
    v77 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v76 + 1;
    *(_BYTE *)(v77 + v76) = v73;
    v78 = *(_DWORD *)(a1 + 5820);
    v17 = (int)(unsigned __int16)(a4 + 4) >> (16 - v78);
    v16 = v78 - 13;
    *(_WORD *)(a1 + 5816) = v17;
    *(_DWORD *)(a1 + 5820) = v78 - 13;
  }
  else
  {
    v16 = v13 + 3;
    v17 = v15 | v14;
    *(_DWORD *)(a1 + 5820) = v16;
    *(_WORD *)(a1 + 5816) = v17;
  }
  v86 = *(_DWORD *)(a1 + 2856);
  v18 = *(_DWORD *)(a1 + 2844);
  v87 = v18;
  if ( v16 > 11 )
  {
    v19 = (unsigned __int16)(v18 - 256);
    v20 = v19 << v16;
    v21 = *(_DWORD *)(a1 + 8);
    v22 = v20 | v17;
    v23 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5816) = v22;
    *(_DWORD *)(a1 + 20) = v23 + 1;
    *(_BYTE *)(v21 + v23) = v22;
    v24 = *(_DWORD *)(a1 + 20);
    LOBYTE(v21) = *(_BYTE *)(a1 + 5817);
    v25 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v24 + 1;
    *(_BYTE *)(v25 + v24) = v21;
    v26 = *(_DWORD *)(a1 + 5820);
    v27 = v26 - 11;
    *(_WORD *)(a1 + 5816) = v19 >> (16 - v26);
    v28 = v19 >> (16 - v26);
    *(_DWORD *)(a1 + 5820) = v27;
    if ( v27 > 11 )
      goto LABEL_29;
LABEL_74:
    v80 = (unsigned __int16)v86 << v27;
    v35 = v27 + 5;
    v36 = v80 | v28;
    *(_DWORD *)(a1 + 5820) = v35;
    *(_WORD *)(a1 + 5816) = v36;
    if ( v35 > 12 )
      goto LABEL_30;
    goto LABEL_75;
  }
  v79 = (unsigned __int16)(v18 - 256) << v16;
  v27 = v16 + 5;
  v28 = v17 | v79;
  *(_DWORD *)(a1 + 5820) = v27;
  *(_WORD *)(a1 + 5816) = v28;
  if ( v27 <= 11 )
    goto LABEL_74;
LABEL_29:
  v29 = (unsigned __int16)v86 << v27;
  v30 = *(_DWORD *)(a1 + 8);
  LOWORD(v29) = v28 | v29;
  v31 = *(_DWORD *)(a1 + 20);
  *(_WORD *)(a1 + 5816) = v29;
  *(_DWORD *)(a1 + 20) = v31 + 1;
  *(_BYTE *)(v30 + v31) = v29;
  v32 = *(_DWORD *)(a1 + 20);
  LOBYTE(v30) = *(_BYTE *)(a1 + 5817);
  v33 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 20) = v32 + 1;
  *(_BYTE *)(v33 + v32) = v30;
  v34 = *(_DWORD *)(a1 + 5820);
  v35 = v34 - 11;
  *(_WORD *)(a1 + 5816) = (int)(unsigned __int16)v86 >> (16 - v34);
  v36 = (int)(unsigned __int16)v86 >> (16 - v34);
  *(_DWORD *)(a1 + 5820) = v35;
  if ( v35 > 12 )
  {
LABEL_30:
    v83 = v7 + 1;
    v37 = (unsigned __int16)(v7 - 3) << v35;
    v38 = *(_DWORD *)(a1 + 8);
    LOWORD(v37) = v36 | v37;
    v39 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5816) = v37;
    *(_DWORD *)(a1 + 20) = v39 + 1;
    *(_BYTE *)(v38 + v39) = v37;
    v40 = *(_DWORD *)(a1 + 20);
    LOBYTE(v38) = *(_BYTE *)(a1 + 5817);
    v41 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v40 + 1;
    *(_BYTE *)(v41 + v40) = v38;
    v42 = *(_DWORD *)(a1 + 5820);
    v43 = v42 - 12;
    *(_WORD *)(a1 + 5816) = (int)(unsigned __int16)(v7 - 3) >> (16 - v42);
    v44 = (int)(unsigned __int16)(v7 - 3) >> (16 - v42);
    *(_DWORD *)(a1 + 5820) = v42 - 12;
    goto LABEL_31;
  }
LABEL_75:
  v83 = v7 + 1;
  v81 = (unsigned __int16)(v7 - 3) << v35;
  v43 = v35 + 4;
  v44 = v36 | v81;
  *(_DWORD *)(a1 + 5820) = v43;
  *(_WORD *)(a1 + 5816) = v44;
LABEL_31:
  v45 = 16;
  for ( i = 0; ; v45 = bl_order[i] )
  {
    v52 = *(unsigned __int16 *)(a1 + 4 * v45 + 2686);
    v44 |= v52 << v43;
    *(_WORD *)(a1 + 5816) = v44;
    if ( v43 > 13 )
    {
      v46 = *(_DWORD *)(a1 + 20);
      v47 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v46 + 1;
      *(_BYTE *)(v47 + v46) = v44;
      v48 = *(_DWORD *)(a1 + 20);
      LOBYTE(v46) = *(_BYTE *)(a1 + 5817);
      v49 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v48 + 1;
      *(_BYTE *)(v49 + v48) = v46;
      v50 = *(_DWORD *)(a1 + 5820);
      v51 = v52 >> (16 - v50);
      v43 = v50 - 13;
      *(_WORD *)(a1 + 5816) = v51;
      v44 = v51;
      *(_DWORD *)(a1 + 5820) = v50 - 13;
    }
    else
    {
      v43 += 3;
      *(_DWORD *)(a1 + 5820) = v43;
    }
    if ( ++i == v83 )
      break;
  }
  send_tree(a1, v84, v87);
  send_tree(a1, v85, v86);
  compress_block(a1, v84, v85);
LABEL_55:
  v64 = v84;
  do
  {
    v64 += 4;
    *(_WORD *)(v64 - 4) = 0;
  }
  while ( v64 != a1 + 1292 );
  v65 = v85;
  do
  {
    v65 += 4;
    *(_WORD *)(v65 - 4) = 0;
  }
  while ( v65 != a1 + 2560 );
  result = a1 + 2684;
  do
  {
    result += 4;
    *(_WORD *)(result - 4) = 0;
  }
  while ( a1 + 2760 != result );
  *(_DWORD *)(a1 + 5804) = 0;
  *(_WORD *)(a1 + 1172) = 1;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  if ( a4 )
  {
    v67 = *(_DWORD *)(a1 + 5820);
    if ( v67 > 8 )
    {
      v71 = *(_DWORD *)(a1 + 20);
      v68 = *(_WORD *)(a1 + 5816);
      v72 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v71 + 1;
      *(_BYTE *)(v72 + v71) = v68;
      LOBYTE(v68) = *(_BYTE *)(a1 + 5817);
    }
    else
    {
      if ( v67 <= 0 )
      {
LABEL_66:
        *(_DWORD *)(a1 + 5820) = 0;
        result = 0;
        *(_WORD *)(a1 + 5816) = 0;
        return result;
      }
      v68 = *(_WORD *)(a1 + 5816);
    }
    v69 = *(_DWORD *)(a1 + 20);
    v70 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v69 + 1;
    *(_BYTE *)(v70 + v69) = v68;
    goto LABEL_66;
  }
  return result;
}

//----- (004259F0) --------------------------------------------------------
int __cdecl _tr_init(int a1)
{
  _WORD *v1; // eax
  int v2; // eax
  int v3; // eax
  int result; // eax

  v1 = (_WORD *)(a1 + 148);
  *(_DWORD *)(a1 + 2848) = &static_l_desc;
  *(_DWORD *)(a1 + 2840) = a1 + 148;
  *(_DWORD *)(a1 + 2852) = a1 + 2440;
  *(_DWORD *)(a1 + 2860) = &static_d_desc;
  *(_DWORD *)(a1 + 2864) = a1 + 2684;
  *(_DWORD *)(a1 + 2872) = &static_bl_desc;
  *(_DWORD *)(a1 + 5820) = 0;
  *(_WORD *)(a1 + 5816) = 0;
  do
  {
    *v1 = 0;
    v1 += 2;
  }
  while ( v1 != (_WORD *)(a1 + 1292) );
  v2 = a1 + 2440;
  do
  {
    v2 += 4;
    *(_WORD *)(v2 - 4) = 0;
  }
  while ( v2 != a1 + 2560 );
  v3 = a1 + 2684;
  do
  {
    v3 += 4;
    *(_WORD *)(v3 - 4) = 0;
  }
  while ( a1 + 2760 != v3 );
  *(_DWORD *)(a1 + 5804) = 0;
  result = 1;
  *(_WORD *)(a1 + 1172) = 1;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  return result;
}
// 5157B4: using guessed type void *static_d_desc;
// 515860: using guessed type void *static_l_desc;

//----- (00425AD0) --------------------------------------------------------
void *__cdecl _tr_stored_block(int a1, void *Src, size_t Size, unsigned __int16 a4)
{
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // edi
  _BYTE *v8; // eax
  int v9; // eax
  char v10; // cl
  int v11; // eax
  int v12; // ebp
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  char v16; // cl
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // edx
  int v23; // edx
  int v24; // ecx
  void *result; // eax
  int v26; // eax

  v4 = *(_DWORD *)(a1 + 5820);
  v5 = *(_DWORD *)(a1 + 20);
  LOWORD(v6) = *(_WORD *)(a1 + 5816) | (a4 << v4);
  v7 = v5 + 1;
  v8 = (_BYTE *)(*(_DWORD *)(a1 + 8) + v5);
  *(_WORD *)(a1 + 5816) = v6;
  if ( v4 <= 13 )
  {
    v13 = v4 + 3;
    *(_DWORD *)(a1 + 5820) = v13;
  }
  else
  {
    *(_DWORD *)(a1 + 20) = v7;
    *v8 = v6;
    v9 = *(_DWORD *)(a1 + 20);
    v10 = *(_BYTE *)(a1 + 5817);
    v6 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v9 + 1;
    *(_BYTE *)(v6 + v9) = v10;
    v11 = *(_DWORD *)(a1 + 5820);
    v12 = (int)a4 >> (16 - v11);
    v13 = v11 - 13;
    v14 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5816) = v12;
    LOBYTE(v6) = v12;
    *(_DWORD *)(a1 + 5820) = v13;
    v7 = v14 + 1;
    v8 = (_BYTE *)(*(_DWORD *)(a1 + 8) + v14);
  }
  if ( v13 <= 8 )
  {
    if ( v13 > 0 )
    {
      *(_DWORD *)(a1 + 20) = v7;
      *v8 = v6;
      v26 = *(_DWORD *)(a1 + 20);
      v7 = v26 + 1;
      v8 = (_BYTE *)(*(_DWORD *)(a1 + 8) + v26);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 20) = v7;
    *v8 = v6;
    v15 = *(_DWORD *)(a1 + 20);
    v16 = *(_BYTE *)(a1 + 5817);
    v17 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v15 + 1;
    *(_BYTE *)(v17 + v15) = v16;
    v18 = *(_DWORD *)(a1 + 20);
    v7 = v18 + 1;
    v8 = (_BYTE *)(*(_DWORD *)(a1 + 8) + v18);
  }
  *(_DWORD *)(a1 + 20) = v7;
  *(_WORD *)(a1 + 5816) = 0;
  *(_DWORD *)(a1 + 5820) = 0;
  *v8 = Size;
  v19 = *(_DWORD *)(a1 + 20);
  v20 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 20) = v19 + 1;
  *(_BYTE *)(v20 + v19) = BYTE1(Size);
  v21 = *(_DWORD *)(a1 + 20);
  v22 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 20) = v21 + 1;
  *(_BYTE *)(v22 + v21) = ~(_BYTE)Size;
  v23 = *(_DWORD *)(a1 + 20);
  v24 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 20) = v23 + 1;
  *(_BYTE *)(v24 + v23) = (unsigned __int16)~(_WORD)Size >> 8;
  result = memcpy((void *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)), Src, Size);
  *(_DWORD *)(a1 + 20) += Size;
  return result;
}

//----- (00425C30) --------------------------------------------------------
BOOL __cdecl _tr_tally(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v5; // ebx
  int v6; // edx

  v3 = a1[1448];
  *(_WORD *)(a1[1449] + 2 * v3) = a2;
  a1[1448] = v3 + 1;
  *(_BYTE *)(a1[1446] + v3) = a3;
  if ( a2 )
  {
    v5 = (unsigned __int8)_length_code[a3];
    ++a1[1452];
    ++LOWORD(a1[v5 + 294]);
    if ( (unsigned int)(a2 - 1) > 0xFF )
      v6 = (unsigned __int8)byte_511CA0[(unsigned int)(a2 - 1) >> 7];
    else
      v6 = (unsigned __int8)byte_511B9F[a2];
    ++LOWORD(a1[v6 + 610]);
  }
  else
  {
    ++LOWORD(a1[a3 + 37]);
  }
  return a1[1447] - 1 == a1[1448];
}

//----- (00425CE0) --------------------------------------------------------
int __cdecl adler32_combine(unsigned int a1, unsigned int a2, int a3)
{
  int v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int v6; // esi
  unsigned int v7; // ecx

  if ( a3 < 0 )
    return -1;
  v3 = 65520;
  v4 = (unsigned __int16)a1 * (a3 % 0xFFF1u) % 0xFFF1 + HIWORD(a2) + HIWORD(a1) - a3 % 0xFFF1u;
  v5 = v4 + 65521;
  v6 = (unsigned __int16)a1 + (unsigned __int16)a2;
  if ( v6 )
  {
    v3 = v6 - 1;
    if ( (unsigned int)(v6 - 1) > 0xFFF0 )
      v3 = v6 - 65522;
  }
  v7 = v4 - 65521;
  if ( v5 > 0x1FFE1 )
    v5 = v7;
  if ( v5 > 0xFFF0 )
    v5 -= 65521;
  return (v5 << 16) | v3;
}

//----- (00425D90) --------------------------------------------------------
int __cdecl adler32_combine64(unsigned int a1, unsigned int a2, int a3)
{
  int v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int v6; // esi
  unsigned int v7; // ecx

  if ( a3 < 0 )
    return -1;
  v3 = 65520;
  v4 = (unsigned __int16)a1 * (a3 % 0xFFF1u) % 0xFFF1 + HIWORD(a2) + HIWORD(a1) - a3 % 0xFFF1u;
  v5 = v4 + 65521;
  v6 = (unsigned __int16)a1 + (unsigned __int16)a2;
  if ( v6 )
  {
    v3 = v6 - 1;
    if ( (unsigned int)(v6 - 1) > 0xFFF0 )
      v3 = v6 - 65522;
  }
  v7 = v4 - 65521;
  if ( v5 > 0x1FFE1 )
    v5 = v7;
  if ( v5 > 0xFFF0 )
    v5 -= 65521;
  return (v5 << 16) | v3;
}

//----- (00425E40) --------------------------------------------------------
unsigned int __cdecl adler32_z(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // ecx
  unsigned int v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  int v10; // edx
  int v11; // ebp
  unsigned int v12; // edi
  unsigned int v13; // edi
  unsigned int v14; // edi
  unsigned int v15; // edi
  unsigned int v16; // edi
  unsigned int v17; // edi
  unsigned int v18; // edi
  unsigned int v19; // edi
  unsigned int v20; // edi
  unsigned int v21; // edi
  unsigned int v22; // edi
  unsigned int v23; // edi
  unsigned int v24; // edi
  unsigned int v26; // edx
  int v27; // eax
  int v28; // eax
  int v29; // edi
  int v30; // eax
  int v31; // edi
  int v32; // esi
  int v33; // ebx
  int v34; // edx
  int v35; // eax
  unsigned int v36; // edi
  unsigned int v37; // edi
  unsigned int v38; // edi
  unsigned int v39; // edi
  unsigned int v40; // edi
  unsigned int v41; // edi
  unsigned int v42; // edi
  unsigned int v43; // edi
  unsigned int v44; // edi
  unsigned int v45; // edi
  unsigned int v46; // edi
  unsigned int v47; // edi
  unsigned int v48; // edi
  int v49; // [esp+0h] [ebp-48h]
  int v50; // [esp+0h] [ebp-48h]
  int v51; // [esp+4h] [ebp-44h]
  int v52; // [esp+4h] [ebp-44h]
  int v53; // [esp+8h] [ebp-40h]
  int v54; // [esp+8h] [ebp-40h]
  int v55; // [esp+Ch] [ebp-3Ch]
  int v56; // [esp+Ch] [ebp-3Ch]
  int v57; // [esp+10h] [ebp-38h]
  int v58; // [esp+10h] [ebp-38h]
  int v59; // [esp+14h] [ebp-34h]
  int v60; // [esp+18h] [ebp-30h]
  int v61; // [esp+18h] [ebp-30h]
  int v62; // [esp+1Ch] [ebp-2Ch]
  int v63; // [esp+1Ch] [ebp-2Ch]
  int v64; // [esp+20h] [ebp-28h]
  int v65; // [esp+24h] [ebp-24h]
  unsigned __int8 *v66; // [esp+28h] [ebp-20h]
  unsigned int v67; // [esp+2Ch] [ebp-1Ch]
  unsigned int v68; // [esp+2Ch] [ebp-1Ch]
  unsigned __int8 *v69; // [esp+30h] [ebp-18h]
  unsigned int v70; // [esp+30h] [ebp-18h]
  unsigned int v71; // [esp+34h] [ebp-14h]

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v67 = HIWORD(a1);
  if ( a3 == 1 )
  {
    v26 = (unsigned __int16)a1 + *a2;
    if ( v26 > 0xFFF0 )
      v26 -= 65521;
    v27 = v26 + v67;
    if ( v26 + v67 > 0xFFF0 )
      v27 = v26 + v67 - 65521;
    return v26 | (v27 << 16);
  }
  else if ( a2 )
  {
    if ( a3 > 0xF )
    {
      v69 = a2 + 5552;
      if ( a3 <= 0x15AF )
      {
        v71 = a3;
      }
      else
      {
        while ( 1 )
        {
          v3 = v69 - 5552;
          v71 = a3 - 5552;
          do
          {
            v5 = *v3;
            v3 += 16;
            v49 = v5 + v4;
            v51 = v5 + v4 + *(v3 - 15);
            v53 = v51 + *(v3 - 14);
            v55 = v53 + *(v3 - 13);
            v57 = v55 + *(v3 - 12);
            v59 = v57 + *(v3 - 11);
            v60 = v59 + *(v3 - 10);
            v62 = v60 + *(v3 - 9);
            v64 = v62 + *(v3 - 8);
            v65 = v64 + *(v3 - 7);
            v6 = v65 + *(v3 - 6);
            v7 = v6 + *(v3 - 5);
            v8 = v7 + *(v3 - 4);
            v9 = v8 + *(v3 - 3);
            v10 = v9 + *(v3 - 2);
            v4 = v10 + *(v3 - 1);
            v67 += v4 + v8 + v7 + v6 + v65 + v64 + v62 + v60 + v59 + v57 + v55 + v53 + v51 + v49 + v9 + v10;
          }
          while ( v3 != v69 );
          v4 %= 0xFFF1u;
          v69 = v3 + 5552;
          v67 %= 0xFFF1u;
          if ( v71 <= 0x15AF )
            break;
          a3 -= 5552;
        }
        if ( a3 == 5552 )
          return v4 | (v67 << 16);
        if ( v71 <= 0xF )
        {
          v66 = v3;
          v35 = a3 - 5553;
          goto LABEL_39;
        }
      }
      v70 = (v71 - 16) >> 4;
      v66 = &v3[16 * v70 + 16];
      do
      {
        v28 = *v3;
        v29 = v3[1];
        v3 += 16;
        v30 = v4 + v28;
        v31 = v30 + v29;
        v50 = *(v3 - 14) + v31;
        v52 = v50 + *(v3 - 13);
        v54 = v52 + *(v3 - 12);
        v56 = v54 + *(v3 - 11);
        v58 = v56 + *(v3 - 10);
        v61 = v58 + *(v3 - 9) + *(v3 - 8);
        v63 = v61 + *(v3 - 7);
        v32 = v63 + *(v3 - 6) + *(v3 - 5) + *(v3 - 4);
        v33 = v32 + *(v3 - 3);
        v34 = v33 + *(v3 - 2);
        v4 = v34 + *(v3 - 1);
        v67 += v4
             + v34
             + v33
             + v32
             + v63
             + *(v3 - 6)
             + *(v3 - 5)
             + v63
             + *(v3 - 6)
             + v63
             + v61
             + v58
             + *(v3 - 9)
             + v58
             + v56
             + v54
             + v52
             + v50
             + v31
             + v30;
      }
      while ( v3 != v66 );
      v35 = v71 - 16 * v70 - 17;
      if ( (v71 & 0xF) == 0 )
      {
LABEL_54:
        v4 %= 0xFFF1u;
        v67 %= 0xFFF1u;
        return v4 | (v67 << 16);
      }
LABEL_39:
      v4 += *v66;
      v67 += v4;
      if ( v35 )
      {
        v4 += v66[1];
        v36 = v4 + v67;
        v67 += v4;
        if ( v35 != 1 )
        {
          v4 += v66[2];
          v37 = v4 + v36;
          v67 = v37;
          if ( v35 != 2 )
          {
            v4 += v66[3];
            v38 = v4 + v37;
            v67 = v38;
            if ( v35 != 3 )
            {
              v4 += v66[4];
              v39 = v4 + v38;
              v67 = v39;
              if ( v35 != 4 )
              {
                v4 += v66[5];
                v40 = v4 + v39;
                v67 = v40;
                if ( v35 != 5 )
                {
                  v4 += v66[6];
                  v41 = v4 + v40;
                  v67 = v41;
                  if ( v35 != 6 )
                  {
                    v4 += v66[7];
                    v42 = v4 + v41;
                    v67 = v42;
                    if ( v35 != 7 )
                    {
                      v4 += v66[8];
                      v43 = v4 + v42;
                      v67 = v43;
                      if ( v35 != 8 )
                      {
                        v4 += v66[9];
                        v44 = v4 + v43;
                        v67 = v44;
                        if ( v35 != 9 )
                        {
                          v4 += v66[10];
                          v45 = v4 + v44;
                          v67 = v45;
                          if ( v35 != 10 )
                          {
                            v4 += v66[11];
                            v46 = v4 + v45;
                            v67 = v46;
                            if ( v35 != 11 )
                            {
                              v4 += v66[12];
                              v47 = v4 + v46;
                              v67 = v47;
                              if ( v35 != 12 )
                              {
                                v4 += v66[13];
                                v48 = v4 + v47;
                                v67 = v48;
                                if ( v35 != 13 )
                                {
                                  v4 += v66[14];
                                  v67 = v4 + v48;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_54;
    }
    if ( a3 )
    {
      v11 = *a2 + (unsigned __int16)a1;
      v68 = v11 + v67;
      v4 = a2[1] + v11;
      v12 = v4 + v68;
      v67 = v4 + v68;
      if ( a3 != 2 )
      {
        v4 += a2[2];
        v13 = v4 + v12;
        v67 = v13;
        if ( a3 != 3 )
        {
          v4 += a2[3];
          v14 = v4 + v13;
          v67 = v14;
          if ( a3 != 4 )
          {
            v4 += a2[4];
            v15 = v4 + v14;
            v67 = v15;
            if ( a3 != 5 )
            {
              v4 += a2[5];
              v16 = v4 + v15;
              v67 = v16;
              if ( a3 != 6 )
              {
                v4 += a2[6];
                v17 = v4 + v16;
                v67 = v17;
                if ( a3 != 7 )
                {
                  v4 += a2[7];
                  v18 = v4 + v17;
                  v67 = v18;
                  if ( a3 != 8 )
                  {
                    v4 += a2[8];
                    v19 = v4 + v18;
                    v67 = v19;
                    if ( a3 != 9 )
                    {
                      v4 += a2[9];
                      v20 = v4 + v19;
                      v67 = v20;
                      if ( a3 != 10 )
                      {
                        v4 += a2[10];
                        v21 = v4 + v20;
                        v67 = v21;
                        if ( a3 != 11 )
                        {
                          v4 += a2[11];
                          v22 = v4 + v21;
                          v67 = v22;
                          if ( a3 != 12 )
                          {
                            v4 += a2[12];
                            v23 = v4 + v22;
                            v67 = v23;
                            if ( a3 != 13 )
                            {
                              v4 += a2[13];
                              v24 = v4 + v23;
                              v67 = v24;
                              if ( a3 != 14 )
                              {
                                v4 += a2[14];
                                v67 = v4 + v24;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( v4 > 0xFFF0 )
      v4 -= 65521;
    return v4 | ((v67 % 0xFFF1) << 16);
  }
  else
  {
    return 1;
  }
}
// 426002: conditional instruction was optimized away because %arg_8.4 is in (2..F)

//----- (00426430) --------------------------------------------------------
int __usercall build_tree@<eax>(int a1@<eax>, int a2@<edx>)
{
  int *v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // esi
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // ebx
  _WORD *v12; // edi
  int v13; // esi
  int v14; // edx
  int v15; // edi
  int v16; // eax
  int v17; // esi
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  unsigned __int16 v21; // di
  int v22; // edi
  int v23; // eax
  int v24; // edx
  int v25; // eax
  int v26; // ebx
  int v27; // edx
  int v28; // eax
  int v29; // ecx
  _WORD *v30; // edx
  bool v31; // cf
  char v32; // bl
  char v33; // al
  int v34; // edi
  unsigned int v35; // edx
  unsigned int v36; // ebx
  int *v37; // eax
  int v38; // esi
  int v39; // eax
  int *v40; // esi
  int v41; // edx
  int v42; // ebx
  unsigned __int16 *v43; // ecx
  int v44; // eax
  int v45; // edi
  int v46; // edx
  int v47; // esi
  int v48; // edi
  __int16 v49; // dx
  int v50; // ebx
  int v51; // ecx
  int v52; // edx
  int v53; // eax
  int v54; // eax
  int v55; // edx
  int v56; // eax
  int v57; // edx
  int v58; // edx
  int v59; // eax
  int v60; // edx
  int v61; // eax
  int v62; // eax
  int v63; // edx
  int v64; // eax
  int v65; // edx
  int v66; // edx
  int v67; // eax
  int v68; // edx
  int v69; // eax
  int v70; // eax
  int v71; // edx
  int v72; // eax
  int v73; // edx
  int v74; // edx
  int v75; // eax
  int v76; // edx
  int v77; // eax
  int v78; // eax
  int v79; // edx
  int result; // eax
  _WORD *v81; // ebx
  int v82; // esi
  unsigned int v83; // edx
  int v84; // edi
  char v85; // cl
  int v86; // ecx
  int v87; // edi
  int v88; // esi
  int v89; // edx
  int v90; // ecx
  unsigned __int16 *v91; // ecx
  int v92; // ebx
  int *v93; // ebx
  int v94; // ecx
  unsigned __int16 *v95; // esi
  int v96; // edx
  int v97; // eax
  int v98; // edx
  int v99; // [esp+0h] [ebp-58h]
  unsigned __int16 v100; // [esp+0h] [ebp-58h]
  _WORD *v101; // [esp+0h] [ebp-58h]
  int v102; // [esp+0h] [ebp-58h]
  int v103; // [esp+4h] [ebp-54h]
  int v104; // [esp+4h] [ebp-54h]
  _WORD *v105; // [esp+4h] [ebp-54h]
  _WORD *v106; // [esp+8h] [ebp-50h]
  int v107; // [esp+Ch] [ebp-4Ch]
  int v108; // [esp+Ch] [ebp-4Ch]
  int v109; // [esp+Ch] [ebp-4Ch]
  int v110; // [esp+10h] [ebp-48h]
  int v111; // [esp+10h] [ebp-48h]
  unsigned __int16 v112; // [esp+14h] [ebp-44h]
  int v113; // [esp+14h] [ebp-44h]
  int v114; // [esp+18h] [ebp-40h]
  int v115; // [esp+18h] [ebp-40h]
  int v116; // [esp+1Ch] [ebp-3Ch]
  int v118; // [esp+20h] [ebp-38h]
  int v119; // [esp+24h] [ebp-34h]
  int v120; // [esp+24h] [ebp-34h]
  __int16 v121[24]; // [esp+28h] [ebp-30h]

  v3 = *(int **)(a2 + 8);
  v4 = v3[3];
  v106 = *(_WORD **)a2;
  v5 = *v3;
  v116 = -1;
  *(_DWORD *)(a1 + 5200) = 0;
  v99 = v5;
  v6 = 0;
  *(_DWORD *)(a1 + 5204) = 573;
  if ( v4 <= 0 )
  {
    if ( v99 )
    {
LABEL_8:
      v9 = v6 + 1;
      v10 = v116;
      v107 = v4;
      v11 = *(_DWORD *)(a1 + 5804);
      v103 = *(_DWORD *)(a1 + 5800);
      while ( 1 )
      {
        if ( v10 > 1 )
        {
          v12 = v106;
          v13 = 0;
          v14 = 0;
        }
        else
        {
          ++v10;
          v13 = 4 * v10;
          v14 = v10;
          v12 = &v106[2 * v10];
        }
        *(_DWORD *)(a1 + 5200) = v9;
        *(_DWORD *)(a1 + 4 * v9 + 2908) = v14;
        *v12 = 1;
        *(_BYTE *)(a1 + v14 + 5208) = 0;
        --v103;
        v11 -= *(unsigned __int16 *)(v99 + v13 + 2);
        if ( v9 == 2 )
          break;
        v9 = 2;
      }
      v116 = v10;
      v6 = 2;
      *(_DWORD *)(a1 + 5804) = v11;
      v4 = v107;
      *(_DWORD *)(a1 + 5800) = v103;
      goto LABEL_15;
    }
    goto LABEL_101;
  }
  v7 = 0;
  v8 = -1;
  do
  {
    while ( v106[2 * v7] )
    {
      ++v6;
      v8 = v7;
      *(_DWORD *)(a1 + 5200) = v6;
      *(_DWORD *)(a1 + 4 * v6 + 2908) = v7;
      *(_BYTE *)(a1 + v7++ + 5208) = 0;
      if ( v4 == v7 )
        goto LABEL_6;
    }
    v106[2 * v7++ + 1] = 0;
  }
  while ( v4 != v7 );
LABEL_6:
  v116 = v8;
  if ( !v99 )
  {
    if ( v6 > 1 )
      goto LABEL_15;
LABEL_101:
    v97 = *(_DWORD *)(a1 + 5800);
    ++v6;
    v98 = v116;
    while ( 1 )
    {
      if ( v98 > 1 )
      {
        *(_DWORD *)(a1 + 5200) = v6;
        --v97;
        *(_DWORD *)(a1 + 4 * v6 + 2908) = 0;
        *v106 = 1;
        *(_BYTE *)(a1 + 5208) = 0;
        if ( v6 == 2 )
          goto LABEL_106;
      }
      else
      {
        ++v98;
        *(_DWORD *)(a1 + 5200) = v6;
        --v97;
        *(_DWORD *)(a1 + 4 * v6 + 2908) = v98;
        v106[2 * v98] = 1;
        *(_BYTE *)(a1 + v98 + 5208) = 0;
        if ( v6 == 2 )
        {
LABEL_106:
          v116 = v98;
          *(_DWORD *)(a1 + 5800) = v97;
          goto LABEL_15;
        }
      }
      v6 = 2;
    }
  }
  if ( v6 <= 1 )
    goto LABEL_8;
LABEL_15:
  v104 = v6;
  v119 = v4;
  *(_DWORD *)(a2 + 4) = v116;
  v15 = v6 >> 1;
  do
  {
    v16 = 2 * v15;
    v108 = *(_DWORD *)(a1 + 4 * v15 + 2908);
    if ( 2 * v15 > v104 )
    {
      v17 = v15;
    }
    else
    {
      v114 = v15;
      v112 = v106[2 * *(_DWORD *)(a1 + 4 * v15 + 2908)];
      v17 = v15;
      while ( 1 )
      {
        v18 = a1 + 4 * v16;
        v19 = *(_DWORD *)(v18 + 2908);
        v100 = v106[2 * v19];
        if ( v16 < v104 )
        {
          v20 = *(_DWORD *)(v18 + 2912);
          v21 = v106[2 * v20];
          if ( v21 < v100 )
          {
            ++v16;
            v100 = v106[2 * v20];
            v19 = v20;
          }
          else if ( v21 == v100 && *(_BYTE *)(a1 + v20 + 5208) <= *(_BYTE *)(a1 + v19 + 5208) )
          {
            v19 = v20;
            ++v16;
          }
        }
        if ( v112 < v100 || v112 == v100 && *(_BYTE *)(a1 + v108 + 5208) <= *(_BYTE *)(a1 + v19 + 5208) )
          break;
        *(_DWORD *)(a1 + 4 * v17 + 2908) = v19;
        v17 = v16;
        if ( 2 * v16 > v104 )
          break;
        v16 *= 2;
      }
      v15 = v114;
    }
    *(_DWORD *)(a1 + 4 * v17 + 2908) = v108;
    --v15;
  }
  while ( v15 );
  v22 = v119;
  v23 = *(_DWORD *)(a1 + 5200);
  while ( 1 )
  {
    v24 = v23 - 1;
    v25 = *(_DWORD *)(a1 + 4 * v23 + 2908);
    v26 = *(_DWORD *)(a1 + 2912);
    *(_DWORD *)(a1 + 5200) = v24;
    *(_DWORD *)(a1 + 2912) = v25;
    pqdownheap_constprop_1(a1, (int)v106);
    v27 = *(_DWORD *)(a1 + 5204);
    v28 = *(_DWORD *)(a1 + 2912);
    v29 = a1 + 4 * v27;
    *(_DWORD *)(v29 + 2904) = v26;
    *(_DWORD *)(a1 + 5204) = v27 - 2;
    *(_DWORD *)(v29 + 2900) = v28;
    v30 = &v106[2 * v26];
    v101 = &v106[2 * v28];
    v106[2 * v22] = *v30 + *v101;
    LOBYTE(v26) = *(_BYTE *)(a1 + v26 + 5208);
    LOBYTE(v29) = *(_BYTE *)(a1 + v28 + 5208);
    v31 = (unsigned __int8)v26 < (unsigned __int8)v29;
    v32 = v26 + 1;
    v33 = v29 + 1;
    if ( !v31 )
      v33 = v32;
    *(_BYTE *)(a1 + v22 + 5208) = v33;
    v101[1] = v22;
    v30[1] = v22;
    *(_DWORD *)(a1 + 2912) = v22;
    pqdownheap_constprop_1(a1, (int)v106);
    v23 = *(_DWORD *)(a1 + 5200);
    if ( v23 <= 1 )
      break;
    ++v22;
  }
  v34 = *(_DWORD *)(a1 + 5204);
  v35 = 0;
  v36 = (a1 + 2880) & 0xFFFFFFFC;
  *(_DWORD *)(a1 + 5204) = v34 - 1;
  v110 = *(_DWORD *)(a1 + 2912);
  *(_DWORD *)(a1 + 4 * v34 + 2904) = v110;
  v105 = *(_WORD **)a2;
  v37 = *(int **)(a2 + 8);
  v102 = *(_DWORD *)(a2 + 4);
  v118 = *v37;
  v120 = v37[1];
  v38 = v37[2];
  v39 = v37[4];
  v109 = v38;
  *(_DWORD *)(a1 + 2876) = 0;
  *(_DWORD *)(a1 + 2904) = 0;
  do
  {
    *(_DWORD *)(v36 + v35) = 0;
    v35 += 4;
  }
  while ( v35 < ((a1 + 2876 - v36 + 32) & 0xFFFFFFFC) );
  v105[2 * v110 + 1] = 0;
  if ( v34 <= 572 )
  {
    if ( v118 )
    {
      v115 = 0;
      v40 = (int *)(a1 + 4 * v34 + 2908);
      v111 = v39;
      do
      {
        v41 = *v40;
        v42 = 2 * *v40;
        v43 = &v105[v42];
        v44 = (unsigned __int16)v105[2 * (unsigned __int16)v105[v42 + 1] + 1] + 1;
        if ( v111 < v44 )
        {
          ++v115;
          v44 = v111;
        }
        v43[1] = v44;
        if ( v102 >= v41 )
        {
          ++*(_WORD *)(a1 + 2 * v44 + 2876);
          v45 = 0;
          if ( v109 <= v41 )
          {
            v45 = *(_DWORD *)(v120 + 4 * (v41 - v109));
            v44 += v45;
          }
          v46 = *v43;
          *(_DWORD *)(a1 + 5800) += v46 * v44;
          *(_DWORD *)(a1 + 5804) += v46 * (*(unsigned __int16 *)(v118 + v42 * 2 + 2) + v45);
        }
        ++v40;
      }
      while ( (int *)(a1 + 5200) != v40 );
      v39 = v111;
    }
    else
    {
      v93 = (int *)(a1 + 4 * v34 + 2908);
      v115 = 0;
      do
      {
        v94 = *v93;
        v95 = &v105[2 * *v93];
        v96 = (unsigned __int16)v105[2 * v95[1] + 1] + 1;
        if ( v39 < v96 )
        {
          ++v115;
          v96 = v39;
        }
        v95[1] = v96;
        if ( v102 >= v94 )
        {
          ++*(_WORD *)(a1 + 2 * v96 + 2876);
          if ( v109 <= v94 )
            v96 += *(_DWORD *)(v120 + 4 * (v94 - v109));
          *(_DWORD *)(a1 + 5800) += *v95 * v96;
        }
        ++v93;
      }
      while ( (int *)(a1 + 5200) != v93 );
    }
    v47 = v115;
    if ( v115 )
    {
      v48 = a1 + 2 * v39;
      while ( 1 )
      {
        v49 = *(_WORD *)(v48 + 2874);
        if ( v49 )
        {
          v51 = v39;
          v50 = v39 - 1;
        }
        else
        {
          v49 = *(_WORD *)(a1 + 2 * v39 + 2872);
          v50 = v39 - 2;
          if ( v49 )
          {
            v51 = v39 - 1;
            goto LABEL_64;
          }
          v49 = *(_WORD *)(a1 + 2 * v39 + 2870);
          v51 = v39 - 3;
          if ( v49 )
          {
            v50 = v39 - 3;
            v51 = v39 - 2;
            goto LABEL_64;
          }
          v49 = *(_WORD *)(a1 + 2 * v39 + 2868);
          v50 = v39 - 4;
          if ( !v49 )
          {
            v49 = *(_WORD *)(a1 + 2 * v39 + 2866);
            v51 = v39 - 5;
            if ( v49 )
              goto LABEL_70;
            v49 = *(_WORD *)(a1 + 2 * v39 + 2864);
            v50 = v39 - 6;
            if ( !v49 )
            {
              v49 = *(_WORD *)(a1 + 2 * v39 + 2862);
              v51 = v39 - 7;
              if ( v49 )
                goto LABEL_70;
              v49 = *(_WORD *)(a1 + 2 * v39 + 2860);
              v50 = v39 - 8;
              if ( !v49 )
              {
                v49 = *(_WORD *)(a1 + 2 * v39 + 2858);
                v51 = v39 - 9;
                if ( v49 )
                  goto LABEL_70;
                v49 = *(_WORD *)(a1 + 2 * v39 + 2856);
                v50 = v39 - 10;
                if ( !v49 )
                {
                  v49 = *(_WORD *)(a1 + 2 * v39 + 2854);
                  v51 = v39 - 11;
                  if ( v49 )
                    goto LABEL_70;
                  v49 = *(_WORD *)(a1 + 2 * v39 + 2852);
                  v50 = v39 - 12;
                  if ( !v49 )
                  {
                    v49 = *(_WORD *)(a1 + 2 * v39 + 2850);
                    v51 = v39 - 13;
                    if ( !v49 )
                    {
                      v49 = *(_WORD *)(a1 + 2 * v39 + 2848);
                      v50 = v39 - 14;
                      if ( !v49 )
                      {
                        v49 = *(_WORD *)(a1 + 2 * v39 + 2846);
                        if ( v49 )
                        {
                          v51 = v39 - 14;
                          v50 = v39 - 15;
                        }
                        else
                        {
                          v49 = *(_WORD *)(a1 + 2 * v39 + 2844);
                          v51 = v39 - 16;
                          if ( v49 )
                          {
                            v50 = v39 - 16;
                            v51 = v39 - 15;
                          }
                          else
                          {
                            v49 = *(_WORD *)(a1 + 2 * v39 + 2842);
                            v50 = v39 - 17;
                          }
                        }
                      }
                      goto LABEL_64;
                    }
LABEL_70:
                    v113 = v50;
                    v50 = v51;
                    v51 = v113;
                  }
                }
              }
            }
          }
        }
LABEL_64:
        v47 -= 2;
        *(_WORD *)(a1 + 2 * v50 + 2876) = v49 - 1;
        *(_WORD *)(a1 + 2 * v51 + 2876) += 2;
        --*(_WORD *)(v48 + 2876);
        if ( v47 <= 0 )
        {
          if ( v39 )
          {
            v87 = v39 - 1;
            v88 = 573;
            while ( 1 )
            {
              v89 = *(unsigned __int16 *)(a1 + 2 * v39 + 2876);
              if ( *(_WORD *)(a1 + 2 * v39 + 2876) )
              {
                do
                {
                  do
                  {
                    --v88;
                    v90 = *(_DWORD *)(a1 + 4 * v88 + 2908);
                  }
                  while ( v102 < v90 );
                  v91 = &v105[2 * v90];
                  v92 = v91[1];
                  if ( v92 != v39 )
                  {
                    *(_DWORD *)(a1 + 5800) += (v39 - v92) * *v91;
                    v91[1] = v39;
                  }
                  --v89;
                }
                while ( v89 );
              }
              v39 = v87;
              if ( !v87 )
                break;
              --v87;
            }
          }
          break;
        }
      }
    }
  }
  v52 = 2 * *(unsigned __int16 *)(a1 + 2876);
  v53 = *(unsigned __int16 *)(a1 + 2878);
  v121[1] = 2 * *(_WORD *)(a1 + 2876);
  v54 = 2 * (v52 + v53);
  v55 = v54 + *(unsigned __int16 *)(a1 + 2880);
  v121[2] = v54;
  v56 = 2 * v55;
  v57 = *(unsigned __int16 *)(a1 + 2882);
  v121[3] = v56;
  v58 = 2 * (v56 + v57);
  v59 = v58 + *(unsigned __int16 *)(a1 + 2884);
  v121[4] = v58;
  v60 = 2 * v59;
  v61 = *(unsigned __int16 *)(a1 + 2886);
  v121[5] = v60;
  v62 = 2 * (v60 + v61);
  v63 = v62 + *(unsigned __int16 *)(a1 + 2888);
  v121[6] = v62;
  v64 = 2 * v63;
  v65 = *(unsigned __int16 *)(a1 + 2890);
  v121[7] = v64;
  v66 = 2 * (v64 + v65);
  v67 = v66 + *(unsigned __int16 *)(a1 + 2892);
  v121[8] = v66;
  v68 = 2 * v67;
  v69 = *(unsigned __int16 *)(a1 + 2894);
  v121[9] = v68;
  v70 = 2 * (v68 + v69);
  v71 = v70 + *(unsigned __int16 *)(a1 + 2896);
  v121[10] = v70;
  v72 = 2 * v71;
  v73 = *(unsigned __int16 *)(a1 + 2898);
  v121[11] = v72;
  v74 = 2 * (v72 + v73);
  v75 = v74 + *(unsigned __int16 *)(a1 + 2900);
  v121[12] = v74;
  v76 = 2 * v75;
  v77 = *(unsigned __int16 *)(a1 + 2902);
  v121[13] = v76;
  v78 = v76 + v77;
  v79 = *(unsigned __int16 *)(a1 + 2904);
  v78 *= 2;
  v121[14] = v78;
  result = 2 * (v79 + v78);
  v121[15] = result;
  if ( v116 != -1 )
  {
    v81 = v106;
    v82 = (int)&v106[2 * v116 + 2];
    do
    {
      while ( 1 )
      {
        result = (unsigned __int16)v81[1];
        if ( v81[1] )
          break;
        v81 += 2;
        if ( v81 == (_WORD *)v82 )
          return result;
      }
      v83 = (unsigned __int16)v121[result];
      v84 = 0;
      v121[result] = v83 + 1;
      do
      {
        v85 = v83;
        v83 >>= 1;
        v86 = v84 | v85 & 1;
        v84 = 2 * v86;
        --result;
      }
      while ( result );
      *v81 = v86;
      v81 += 2;
    }
    while ( v81 != (_WORD *)v82 );
  }
  return result;
}

//----- (00426D60) --------------------------------------------------------
int __usercall compress_block@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v7; // ebx
  unsigned int v8; // edx
  unsigned __int16 *v9; // edx
  int v10; // edi
  int v11; // ebp
  int v12; // edx
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // edx
  int v17; // ebp
  int v18; // edx
  int v19; // ebx
  int v20; // eax
  int v21; // ecx
  int v22; // edx
  int v23; // eax
  int v24; // edx
  int v25; // edi
  int v26; // ecx
  int v27; // edx
  int v28; // edi
  int v29; // ecx
  int v30; // eax
  char v31; // bl
  int v32; // ebx
  int v33; // ebx
  unsigned __int16 *v34; // edx
  int v35; // edi
  int v36; // edx
  int v37; // eax
  int v38; // ecx
  int v39; // eax
  char v40; // bl
  int v41; // ecx
  int v42; // ebp
  int v43; // edx
  int v44; // edi
  int v45; // edx
  int v46; // eax
  int v47; // ecx
  int v48; // eax
  char v49; // bl
  int v50; // ecx
  int v51; // ebp
  int v52; // ebp
  int result; // eax
  int v54; // edx
  int v55; // eax
  int v56; // ebx
  int v57; // eax
  char v58; // dl
  int v59; // ebx
  int v60; // eax
  char v61; // cl
  unsigned int v62; // [esp+0h] [ebp-28h]
  int v63; // [esp+0h] [ebp-28h]
  int v64; // [esp+4h] [ebp-24h]
  int v65; // [esp+4h] [ebp-24h]
  __int16 v67; // [esp+Ch] [ebp-1Ch]
  __int16 v68; // [esp+Ch] [ebp-1Ch]
  int v69; // [esp+10h] [ebp-18h]

  v4 = *(_DWORD *)(a1 + 5792);
  v5 = *(_DWORD *)(a1 + 5820);
  v6 = *(unsigned __int16 *)(a1 + 5816);
  v7 = v6;
  if ( v4 )
  {
    v8 = 0;
    while ( 1 )
    {
      v62 = v8 + 1;
      v17 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 5796) + 2 * v8);
      v18 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 5784) + v8);
      if ( !v17 )
        break;
      v19 = (unsigned __int8)_length_code[(unsigned __int8)v18];
      v67 = (unsigned __int8)v18;
      v64 = *(unsigned __int16 *)(a2 + 4 * v19 + 1030);
      v69 = *(unsigned __int16 *)(a2 + 4 * v19 + 1028);
      v20 = (v69 << v5) | v6;
      *(_WORD *)(a1 + 5816) = v20;
      if ( 16 - v64 >= v5 )
      {
        v26 = v64 + v5;
      }
      else
      {
        v21 = *(_DWORD *)(a1 + 20);
        v22 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v21 + 1;
        *(_BYTE *)(v22 + v21) = v20;
        v23 = *(_DWORD *)(a1 + 20);
        LOBYTE(v21) = *(_BYTE *)(a1 + 5817);
        v24 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v23 + 1;
        *(_BYTE *)(v24 + v23) = v21;
        v25 = *(_DWORD *)(a1 + 5820);
        v20 = v69 >> (16 - v25);
        *(_WORD *)(a1 + 5816) = v20;
        v26 = v25 + v64 - 16;
      }
      *(_DWORD *)(a1 + 5820) = v26;
      v27 = extra_lbits[v19];
      if ( v27 )
      {
        v28 = (unsigned __int16)(v67 - LOWORD(base_length[v19]));
        v20 |= v28 << v26;
        *(_WORD *)(a1 + 5816) = v20;
        if ( 16 - v27 >= v26 )
        {
          v26 += v27;
        }
        else
        {
          v29 = *(_DWORD *)(a1 + 20);
          *(_DWORD *)(a1 + 20) = v29 + 1;
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + v29) = v20;
          v30 = *(_DWORD *)(a1 + 20);
          v31 = *(_BYTE *)(a1 + 5817);
          *(_DWORD *)(a1 + 20) = v30 + 1;
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + v30) = v31;
          v32 = *(_DWORD *)(a1 + 5820);
          v20 = v28 >> (16 - v32);
          v26 = v32 + v27 - 16;
          *(_WORD *)(a1 + 5816) = v20;
        }
        *(_DWORD *)(a1 + 5820) = v26;
      }
      v68 = v17 - 1;
      if ( (unsigned int)(v17 - 1) > 0xFF )
        v33 = (unsigned __int8)byte_511CA0[(unsigned int)(v17 - 1) >> 7];
      else
        v33 = (unsigned __int8)byte_511B9F[v17];
      v65 = v33;
      v34 = (unsigned __int16 *)(a3 + 4 * v33);
      v35 = v34[1];
      v36 = *v34;
      v7 = v20 | (v36 << v26);
      v6 = v7;
      *(_WORD *)(a1 + 5816) = v7;
      if ( 16 - v35 >= v26 )
      {
        v5 = v35 + v26;
      }
      else
      {
        v37 = *(_DWORD *)(a1 + 20);
        v38 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v37 + 1;
        *(_BYTE *)(v38 + v37) = v7;
        v39 = *(_DWORD *)(a1 + 20);
        v40 = *(_BYTE *)(a1 + 5817);
        v41 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v39 + 1;
        *(_BYTE *)(v41 + v39) = v40;
        v42 = *(_DWORD *)(a1 + 5820);
        v43 = v36 >> (16 - v42);
        v5 = v42 + v35 - 16;
        *(_WORD *)(a1 + 5816) = v43;
        v6 = v43;
        v7 = v43;
      }
      *(_DWORD *)(a1 + 5820) = v5;
      v44 = extra_dbits[v65];
      if ( !v44 )
        goto LABEL_6;
      v45 = (unsigned __int16)(v68 - LOWORD(base_dist[v65]));
      v7 |= v45 << v5;
      v6 = v7;
      *(_WORD *)(a1 + 5816) = v7;
      if ( 16 - v44 >= v5 )
      {
        v5 += v44;
        *(_DWORD *)(a1 + 5820) = v5;
LABEL_6:
        v8 = v62;
        if ( *(_DWORD *)(a1 + 5792) <= v62 )
          goto LABEL_21;
      }
      else
      {
        v46 = *(_DWORD *)(a1 + 20);
        v47 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v46 + 1;
        *(_BYTE *)(v47 + v46) = v7;
        v48 = *(_DWORD *)(a1 + 20);
        v49 = *(_BYTE *)(a1 + 5817);
        v50 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 20) = v48 + 1;
        *(_BYTE *)(v50 + v48) = v49;
        v51 = *(_DWORD *)(a1 + 5820);
        v5 = v51 + v44 - 16;
        v6 = v45 >> (16 - v51);
        *(_WORD *)(a1 + 5816) = v6;
        v7 = v6;
        v8 = v62;
        *(_DWORD *)(a1 + 5820) = v5;
        if ( *(_DWORD *)(a1 + 5792) <= v62 )
          goto LABEL_21;
      }
    }
    v9 = (unsigned __int16 *)(a2 + 4 * v18);
    v10 = *v9;
    v11 = v9[1];
    v7 = v6 | (v10 << v5);
    v6 = v7;
    *(_WORD *)(a1 + 5816) = v7;
    if ( 16 - v11 >= v5 )
    {
      v5 += v11;
    }
    else
    {
      v12 = *(_DWORD *)(a1 + 20);
      v13 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v12 + 1;
      *(_BYTE *)(v13 + v12) = v7;
      v14 = *(_DWORD *)(a1 + 20);
      LOBYTE(v13) = *(_BYTE *)(a1 + 5817);
      v15 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 20) = v14 + 1;
      *(_BYTE *)(v15 + v14) = v13;
      v16 = *(_DWORD *)(a1 + 5820);
      v7 = v10 >> (16 - v16);
      v5 = v16 + v11 - 16;
      *(_WORD *)(a1 + 5816) = v7;
      v6 = v7;
    }
    *(_DWORD *)(a1 + 5820) = v5;
    goto LABEL_6;
  }
LABEL_21:
  v52 = *(unsigned __int16 *)(a2 + 1026);
  result = *(unsigned __int16 *)(a2 + 1024);
  v63 = result;
  v54 = v7 | (result << v5);
  *(_WORD *)(a1 + 5816) = v54;
  if ( 16 - v52 >= v5 )
  {
    *(_DWORD *)(a1 + 5820) = v5 + v52;
  }
  else
  {
    v55 = *(_DWORD *)(a1 + 20);
    v56 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v55 + 1;
    *(_BYTE *)(v56 + v55) = v54;
    v57 = *(_DWORD *)(a1 + 20);
    v58 = *(_BYTE *)(a1 + 5817);
    v59 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v57 + 1;
    *(_BYTE *)(v59 + v57) = v58;
    v60 = *(_DWORD *)(a1 + 5820);
    v61 = 16 - v60;
    result = v60 + v52 - 16;
    *(_DWORD *)(a1 + 5820) = result;
    *(_WORD *)(a1 + 5816) = v63 >> v61;
  }
  return result;
}
// 511EA0: using guessed type int base_dist[];
// 511F20: using guessed type int base_length[];
// 514260: using guessed type int extra_dbits[];
// 5142E0: using guessed type int extra_lbits[];

//----- (00427180) --------------------------------------------------------
int __cdecl crc32(int a1, _BYTE *a2, unsigned int a3)
{
  if ( a2 )
    return crc32_little(a1, a2, a3);
  else
    return 0;
}

//----- (004271A0) --------------------------------------------------------
int __cdecl crc32_combine(unsigned int a1, int a2, int a3)
{
  return crc32_combine_(a1, a2, a3);
}

//----- (004271C0) --------------------------------------------------------
int __cdecl crc32_combine64(unsigned int a1, int a2, int a3)
{
  return crc32_combine_(a1, a2, a3);
}

//----- (004271E0) --------------------------------------------------------
int __usercall crc32_combine_@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // edi
  char *v5; // eax
  int v6; // edx
  int i; // ebx
  unsigned int v8; // eax
  int v9; // ecx
  int *v10; // edx
  int j; // ebx
  unsigned int v12; // eax
  int v13; // ecx
  int *v14; // edx
  int k; // ebx
  unsigned int v16; // eax
  int v17; // ecx
  int *v18; // edx
  int m; // ebx
  unsigned int v20; // eax
  int v21; // ecx
  int *v22; // edx
  unsigned int v24; // eax
  int *v25; // edx
  unsigned int v26; // eax
  int *v27; // edx
  int v29[32]; // [esp+4h] [ebp-110h] BYREF
  int v30; // [esp+84h] [ebp-90h] BYREF
  char v31; // [esp+88h] [ebp-8Ch] BYREF
  char v32; // [esp+104h] [ebp-10h] BYREF

  if ( a3 > 0 )
  {
    v4 = a3;
    v5 = &v31;
    v30 = -306674912;
    v6 = 1;
    do
    {
      *(_DWORD *)v5 = v6;
      v5 += 4;
      v6 *= 2;
    }
    while ( &v32 != v5 );
    for ( i = 0; i != 32; ++i )
    {
      v8 = *(&v30 + i);
      v9 = 0;
      if ( v8 )
      {
        v10 = &v30;
        do
        {
          if ( (v8 & 1) != 0 )
            v9 ^= *v10;
          ++v10;
          v8 >>= 1;
        }
        while ( v8 );
      }
      v29[i] = v9;
    }
    for ( j = 0; j != 32; ++j )
    {
      v12 = v29[j];
      v13 = 0;
      if ( v12 )
      {
        v14 = v29;
        do
        {
          if ( (v12 & 1) != 0 )
            v13 ^= *v14;
          ++v14;
          v12 >>= 1;
        }
        while ( v12 );
      }
      *(&v30 + j) = v13;
    }
    do
    {
      for ( k = 0; k != 32; ++k )
      {
        v16 = *(&v30 + k);
        v17 = 0;
        if ( v16 )
        {
          v18 = &v30;
          do
          {
            if ( (v16 & 1) != 0 )
              v17 ^= *v18;
            ++v18;
            v16 >>= 1;
          }
          while ( v16 );
        }
        v29[k] = v17;
      }
      if ( (v4 & 1) != 0 && a1 )
      {
        v24 = a1;
        v25 = v29;
        a1 = 0;
        do
        {
          if ( (v24 & 1) != 0 )
            a1 ^= *v25;
          ++v25;
          v24 >>= 1;
        }
        while ( v24 );
      }
      if ( !(v4 >> 1) )
        break;
      for ( m = 0; m != 32; ++m )
      {
        v20 = v29[m];
        v21 = 0;
        if ( v20 )
        {
          v22 = v29;
          do
          {
            if ( (v20 & 1) != 0 )
              v21 ^= *v22;
            ++v22;
            v20 >>= 1;
          }
          while ( v20 );
        }
        *(&v30 + m) = v21;
      }
      if ( ((v4 >> 1) & 1) != 0 && a1 )
      {
        v26 = a1;
        v27 = &v30;
        a1 = 0;
        do
        {
          if ( (v26 & 1) != 0 )
            a1 ^= *v27;
          ++v27;
          v26 >>= 1;
        }
        while ( v26 );
      }
      v4 >>= 2;
    }
    while ( v4 );
    a1 ^= a2;
  }
  return a1;
}
// 4271E0: using guessed type int var_110[32];

//----- (00427350) --------------------------------------------------------
int __usercall crc32_little@<eax>(int result@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  unsigned int v9; // ebx
  unsigned int v10; // ebp
  unsigned int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned int v15; // ebx
  unsigned int v16; // ebx
  unsigned int v17; // ebx
  unsigned int v18; // ebx
  unsigned int v19; // edi
  unsigned int v20; // eax
  unsigned int v21; // ecx

  if ( a3 )
  {
    v3 = ~result;
    while ( ((unsigned __int8)a2 & 3) != 0 )
    {
      v3 = crc_table[(unsigned __int8)(v3 ^ *a2++)] ^ (v3 >> 8);
      if ( !--a3 )
        return ~v3;
    }
    if ( a3 > 0x1F )
    {
      v4 = (unsigned int)&a2[((a3 - 32) & 0xFFFFFFE0) + 32];
      do
      {
        v5 = *(_DWORD *)a2 ^ v3;
        v6 = dword_512440[BYTE2(v5)] ^ dword_512840[BYTE1(v5)] ^ *((_DWORD *)a2 + 1) ^ crc_table[HIBYTE(v5)] ^ dword_512C40[(unsigned __int8)v5];
        v7 = dword_512440[BYTE2(v6)] ^ dword_512840[BYTE1(v6)] ^ *((_DWORD *)a2 + 2) ^ crc_table[HIBYTE(v6)] ^ dword_512C40[(unsigned __int8)v6];
        v8 = dword_512440[BYTE2(v7)] ^ dword_512840[BYTE1(v7)] ^ *((_DWORD *)a2 + 3) ^ crc_table[HIBYTE(v7)] ^ dword_512C40[(unsigned __int8)v7];
        v9 = dword_512440[BYTE2(v8)] ^ dword_512840[BYTE1(v8)] ^ *((_DWORD *)a2 + 4) ^ crc_table[HIBYTE(v8)] ^ dword_512C40[(unsigned __int8)v8];
        v10 = dword_512440[BYTE2(v9)] ^ dword_512840[BYTE1(v9)] ^ *((_DWORD *)a2 + 5) ^ crc_table[HIBYTE(v9)] ^ dword_512C40[(unsigned __int8)v9];
        a2 += 32;
        v11 = dword_512440[BYTE2(v10)] ^ dword_512840[BYTE1(v10)] ^ *((_DWORD *)a2 - 2) ^ crc_table[HIBYTE(v10)] ^ dword_512C40[(unsigned __int8)v10];
        v12 = dword_512440[BYTE2(v11)] ^ *((_DWORD *)a2 - 1) ^ crc_table[HIBYTE(v11)] ^ dword_512C40[(unsigned __int8)(LOBYTE(dword_512440[BYTE2(v10)]) ^ LOBYTE(dword_512840[BYTE1(v10)]) ^ *(a2 - 8) ^ LOBYTE(crc_table[HIBYTE(v10)]) ^ LOBYTE(dword_512C40[(unsigned __int8)v10]))] ^ dword_512840[BYTE1(v11)];
        v3 = dword_512440[BYTE2(v12)] ^ dword_512840[BYTE1(v12)] ^ crc_table[HIBYTE(v12)] ^ dword_512C40[(unsigned __int8)v12];
      }
      while ( a2 != (_BYTE *)v4 );
      a3 &= 0x1Fu;
    }
    if ( a3 > 3 )
    {
      v3 = dword_512840[(unsigned __int8)((unsigned __int16)(*(_WORD *)a2 ^ v3) >> 8)] ^ dword_512C40[(unsigned __int8)(*a2 ^ v3)] ^ crc_table[(*(_DWORD *)a2 ^ v3) >> 24] ^ dword_512440[(unsigned __int8)((*(_DWORD *)a2 ^ v3) >> 16)];
      if ( a3 - 4 > 3 )
      {
        v13 = *((_DWORD *)a2 + 1) ^ v3;
        v3 = dword_512840[BYTE1(v13)] ^ dword_512C40[(unsigned __int8)v13] ^ crc_table[HIBYTE(v13)] ^ dword_512440[BYTE2(v13)];
        if ( a3 - 8 > 3 )
        {
          v14 = *((_DWORD *)a2 + 2) ^ v3;
          v3 = dword_512840[BYTE1(v14)] ^ dword_512C40[(unsigned __int8)v14] ^ crc_table[HIBYTE(v14)] ^ dword_512440[BYTE2(v14)];
          if ( a3 - 12 > 3 )
          {
            v15 = *((_DWORD *)a2 + 3) ^ v3;
            v3 = dword_512840[BYTE1(v15)] ^ dword_512C40[(unsigned __int8)v15] ^ crc_table[HIBYTE(v15)] ^ dword_512440[BYTE2(v15)];
            if ( a3 - 16 > 3 )
            {
              v16 = *((_DWORD *)a2 + 4) ^ v3;
              v3 = dword_512840[BYTE1(v16)] ^ dword_512C40[(unsigned __int8)v16] ^ crc_table[HIBYTE(v16)] ^ dword_512440[BYTE2(v16)];
              if ( a3 - 20 > 3 )
              {
                v17 = *((_DWORD *)a2 + 5) ^ v3;
                v3 = dword_512840[BYTE1(v17)] ^ dword_512C40[(unsigned __int8)v17] ^ crc_table[HIBYTE(v17)] ^ dword_512440[BYTE2(v17)];
                if ( a3 - 24 > 3 )
                {
                  v18 = *((_DWORD *)a2 + 6) ^ v3;
                  v3 = dword_512840[BYTE1(v18)] ^ crc_table[HIBYTE(v18)] ^ dword_512C40[(unsigned __int8)v18] ^ dword_512440[BYTE2(v18)];
                }
              }
            }
          }
        }
      }
      v19 = (a3 - 4) >> 2;
      a3 &= 3u;
      a2 += 4 * v19 + 4;
    }
    if ( !a3 )
      return ~v3;
    v20 = crc_table[(unsigned __int8)(v3 ^ *a2)] ^ (v3 >> 8);
    v21 = a3 - 1;
    if ( v21 )
    {
      v20 = crc_table[(unsigned __int8)(v20 ^ a2[1])] ^ (v20 >> 8);
      if ( v21 != 1 )
        v20 = crc_table[(unsigned __int8)(v20 ^ a2[2])] ^ (v20 >> 8);
    }
    return ~v20;
  }
  return result;
}
// 512040: using guessed type int crc_table[256];
// 512440: using guessed type int dword_512440[256];
// 512840: using guessed type int dword_512840[256];
// 512C40: using guessed type int dword_512C40[1280];

//----- (00427760) --------------------------------------------------------
int __cdecl crc32_z(int a1, _BYTE *a2, unsigned int a3)
{
  if ( a2 )
    return crc32_little(a1, a2, a3);
  else
    return 0;
}

//----- (00427780) --------------------------------------------------------
size_t __cdecl deflate(_DWORD *a1, unsigned int a2)
{
  int v2; // ecx
  int v4; // esi
  bool v5; // di

  if ( !a1 )
    return -2;
  if ( !a1[8] )
    return -2;
  if ( !a1[9] )
    return -2;
  v2 = a1[7];
  if ( !v2 || a1 != *(_DWORD **)v2 )
    return -2;
  v4 = *(_DWORD *)(v2 + 4);
  v5 = 1;
  if ( (unsigned int)(v4 - 91) <= 0x16 )
    v5 = ((0x401001u >> (v4 - 91)) & 1) == 0;
  if ( (v4 == 666 || v4 == 69 || v4 == 42 || ((v4 - 57) & 0xFFFFFFEF) == 0 || !v5) && a2 <= 5 )
    return deflate_part_3(a1, a2);
  else
    return -2;
}

//----- (00427820) --------------------------------------------------------
size_t __usercall deflate_part_3@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v2; // ebx
  int v3; // esi
  int v4; // ecx
  _DWORD *v5; // ebp
  int v6; // eax
  int v7; // edi
  unsigned int v8; // ecx
  int v9; // edx
  __int16 v10; // ax
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // edi
  unsigned int v15; // ecx
  unsigned int v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // edi
  size_t v25; // esi
  int v26; // eax
  size_t result; // eax
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int v32; // edx
  int v33; // eax
  unsigned int v34; // edx
  int v35; // ecx
  int v36; // eax
  int v37; // edx
  int v38; // esi
  _BYTE *v39; // eax
  int v40; // ecx
  int v41; // esi
  int v42; // eax
  __int16 v43; // dx
  int v44; // ecx
  int v45; // eax
  int v46; // ecx
  int v47; // edi
  size_t Size; // esi
  int v49; // eax
  size_t v50; // eax
  int v51; // eax
  int v52; // edx
  void *v53; // ecx
  size_t v54; // eax
  int v55; // edx
  int v56; // ebp
  size_t v57; // esi
  int v58; // eax
  size_t v59; // eax
  size_t v60; // esi
  int v61; // eax
  int v62; // edx
  size_t v63; // edx
  int v64; // eax
  size_t v65; // eax
  int v66; // eax
  _DWORD *v67; // ecx
  unsigned int v68; // esi
  unsigned int v69; // eax
  int v70; // edx
  int v71; // ecx
  int v72; // ecx
  int v73; // edi
  size_t v74; // esi
  int v75; // eax
  size_t v76; // eax
  unsigned int v77; // eax
  int v78; // eax
  unsigned int v79; // esi
  unsigned int v80; // eax
  int v81; // edx
  int v82; // ecx
  int v83; // ecx
  int v84; // edi
  size_t v85; // esi
  int v86; // eax
  size_t v87; // eax
  int v88; // eax
  int v89; // edx
  int v90; // eax
  int v91; // eax
  int v92; // edx
  int v93; // ecx
  int v94; // ecx
  int v95; // edx
  int v96; // edx
  void *v97; // ecx
  int v98; // edi
  int v99; // edx
  size_t v100; // esi
  int v101; // eax
  size_t v102; // eax
  int v103; // edi
  size_t v104; // esi
  int v105; // eax
  int v106; // edx
  int v107; // eax
  int v108; // eax
  int v109; // edx
  int v110; // eax
  int v111; // edx
  _DWORD *v112; // eax
  char v113; // dl
  int v114; // eax
  int v115; // ecx
  int v116; // edx
  int v117; // ecx
  int v118; // eax
  int v119; // edx
  int v120; // ecx
  int v121; // eax
  int v122; // edx
  int v123; // eax
  int v124; // edx
  int v125; // eax
  int v126; // eax
  char v127; // dl
  int v128; // eax
  int v129; // ecx
  int v130; // edx
  int v131; // ecx
  int v132; // eax
  int v133; // eax
  int v134; // ecx
  int v135; // edx
  int v136; // edx
  int v137; // ecx
  int v138; // eax
  int v139; // edx
  int v140; // eax
  unsigned int v141; // esi
  int v142; // edx
  size_t v143; // edi
  int v144; // eax
  size_t v145; // eax
  unsigned int v146; // eax
  int v147; // ecx
  unsigned int v148; // edi
  size_t v149; // esi
  int v150; // edx
  size_t v151; // eax
  int v152; // eax
  unsigned int v153; // edx
  int v154; // eax
  int v155; // edi
  size_t v156; // esi
  int v157; // ecx
  int v158; // edx
  int v159; // eax
  int v160; // ecx
  int v161; // edx
  int v162; // edi
  size_t v163; // esi
  int v164; // eax
  size_t v165; // eax
  int v166; // eax
  void *v167; // ecx
  size_t v168; // edx
  int v169; // edi
  int v170; // ebp
  size_t v171; // esi
  int v172; // eax
  size_t v173; // eax
  int v174; // eax
  int v175; // edx
  size_t v176; // edx
  unsigned int v177; // ebp
  int v178; // eax
  int v179; // edx
  unsigned __int8 *v180; // esi
  unsigned __int8 v181; // cl
  int v182; // eax
  int v183; // edx
  int v184; // ecx
  BOOL v185; // edx
  int v186; // eax
  int v187; // eax
  _WORD *v188; // edx
  int v189; // eax
  int v190; // edx
  int v191; // eax
  size_t v192; // eax
  _BYTE *v193; // esi
  unsigned int v194; // ecx
  int v195; // edx
  unsigned __int8 v196; // al
  int v197; // ecx
  int v198; // ebp
  bool v199; // zf
  int v200; // eax
  int v201; // eax
  int v202; // edx
  int v203; // eax
  int v204; // edx
  int v205; // eax
  int v206; // edx
  int v207; // eax
  int v208; // edx
  int v209; // eax
  int v210; // edx
  int v211; // eax
  char v212; // dl
  int v213; // eax
  int v214; // ecx
  int v215; // eax
  int v216; // edx
  int v217; // edi
  size_t v218; // esi
  int v219; // eax
  size_t v220; // eax
  int v221; // eax
  int v222; // ecx
  int v223; // edx
  int v224; // eax
  int v225; // edx
  int v226; // eax
  int v227; // edx
  int v228; // eax
  int v229; // ecx
  int v230; // edx
  int v231; // eax
  int v232; // ecx
  int v233; // edx
  int v234; // eax
  int v235; // edx
  int v236; // edx
  int v237; // eax
  int v238; // eax
  int v239; // edx
  void *v240; // ecx
  int v241; // edi
  int v242; // edx
  size_t v243; // esi
  int v244; // eax
  size_t v245; // eax
  int v246; // eax
  bool v247; // [esp+14h] [ebp-38h]
  int v248; // [esp+14h] [ebp-38h]
  _DWORD *v249; // [esp+14h] [ebp-38h]
  int v250; // [esp+14h] [ebp-38h]
  unsigned int v251; // [esp+14h] [ebp-38h]
  int v252; // [esp+14h] [ebp-38h]
  size_t v253; // [esp+18h] [ebp-34h]
  size_t v254; // [esp+18h] [ebp-34h]
  int v255; // [esp+1Ch] [ebp-30h]
  unsigned int v256; // [esp+1Ch] [ebp-30h]

  v2 = a1[7];
  if ( !a1[3] || (v3 = a1[1]) != 0 && !*a1 || (v4 = *(_DWORD *)(v2 + 4), v247 = a2 != 4, v4 == 666) && a2 != 4 )
  {
    a1[6] = "stream error";
    return -2;
  }
  if ( !a1[4] )
  {
    a1[6] = "buffer error";
    return -5;
  }
  v5 = a1;
  v6 = *(_DWORD *)(v2 + 20);
  v7 = *(_DWORD *)(v2 + 40);
  *(_DWORD *)(v2 + 40) = a2;
  if ( v6 )
  {
    _tr_flush_bits(v2);
    v60 = *(_DWORD *)(v2 + 20);
    result = v5[4];
    if ( v60 > result )
      v60 = v5[4];
    if ( v60 )
    {
      memcpy((void *)v5[3], *(const void **)(v2 + 16), v60);
      v61 = v5[4];
      v62 = *(_DWORD *)(v2 + 20);
      v5[3] += v60;
      result = v61 - v60;
      *(_DWORD *)(v2 + 16) += v60;
      v5[5] += v60;
      v63 = v62 - v60;
      v5[4] = result;
      *(_DWORD *)(v2 + 20) = v63;
      if ( !v63 )
        *(_DWORD *)(v2 + 16) = *(_DWORD *)(v2 + 8);
    }
    if ( !result )
    {
LABEL_144:
      *(_DWORD *)(v2 + 40) = -1;
      return result;
    }
    v4 = *(_DWORD *)(v2 + 4);
  }
  else
  {
    if ( v3 )
    {
      if ( v4 != 666 )
        goto LABEL_9;
LABEL_235:
      v5[6] = "buffer error";
      return -5;
    }
    v29 = 2 * a2;
    if ( a2 > 4 )
      v29 -= 9;
    v30 = 2 * v7;
    if ( v7 > 4 )
      v30 = 2 * v7 - 9;
    if ( v29 <= v30 && v247 )
      goto LABEL_235;
  }
  if ( v4 == 666 )
  {
    if ( !v5[1] )
      goto LABEL_36;
    goto LABEL_235;
  }
LABEL_9:
  if ( v4 == 42 )
  {
    v8 = (*(_DWORD *)(v2 + 48) << 12) - 30720;
    if ( *(int *)(v2 + 136) <= 1 )
    {
      v66 = *(_DWORD *)(v2 + 132);
      if ( v66 > 1 )
      {
        if ( v66 > 5 )
        {
          v190 = (*(_DWORD *)(v2 + 48) << 12) - 30720;
          LOBYTE(v8) = -64;
          LOBYTE(v190) = 0x80;
          if ( v66 == 6 )
            v8 = v190;
        }
        else
        {
          v8 |= 0x40u;
        }
      }
    }
    if ( *(_DWORD *)(v2 + 108) )
      v8 |= 0x20u;
    v9 = *(_DWORD *)(v2 + 20);
    *(_DWORD *)(v2 + 20) = v9 + 1;
    v10 = 31 * (v8 / 0x1F) + 31;
    *(_BYTE *)(*(_DWORD *)(v2 + 8) + v9) = HIBYTE(v10);
    v11 = *(_DWORD *)(v2 + 20);
    v12 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v11 + 1;
    *(_BYTE *)(v12 + v11) = v10;
    if ( *(_DWORD *)(v2 + 108) )
    {
      v13 = *(_DWORD *)(v2 + 20);
      v14 = *(_DWORD *)(v2 + 8);
      v15 = v5[12];
      v16 = HIWORD(v15);
      *(_DWORD *)(v2 + 20) = v13 + 1;
      *(_BYTE *)(v14 + v13) = HIBYTE(v15);
      v17 = *(_DWORD *)(v2 + 20);
      v18 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v17 + 1;
      *(_BYTE *)(v18 + v17) = v16;
      v19 = *(_DWORD *)(v2 + 20);
      LOWORD(v17) = *((_WORD *)v5 + 24);
      v20 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v19 + 1;
      *(_BYTE *)(v20 + v19) = BYTE1(v17);
      v21 = *(_DWORD *)(v2 + 20);
      v22 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v21 + 1;
      *(_BYTE *)(v22 + v21) = v17;
    }
    v23 = adler32(0, 0, 0);
    v24 = v5[7];
    v5[12] = v23;
    *(_DWORD *)(v2 + 4) = 113;
    _tr_flush_bits(v24);
    v25 = *(_DWORD *)(v24 + 20);
    if ( v5[4] <= v25 )
      v25 = v5[4];
    if ( v25 )
    {
      memcpy((void *)v5[3], *(const void **)(v24 + 16), v25);
      v64 = *(_DWORD *)(v24 + 20);
      v5[3] += v25;
      *(_DWORD *)(v24 + 16) += v25;
      v5[5] += v25;
      v5[4] -= v25;
      v65 = v64 - v25;
      *(_DWORD *)(v24 + 20) = v65;
      if ( !v65 )
        *(_DWORD *)(v24 + 16) = *(_DWORD *)(v24 + 8);
    }
    if ( *(_DWORD *)(v2 + 20) )
      goto LABEL_66;
    v4 = *(_DWORD *)(v2 + 4);
  }
  if ( v4 == 57 )
  {
    v105 = crc32(0, 0, 0);
    v106 = *(_DWORD *)(v2 + 8);
    v5[12] = v105;
    v107 = *(_DWORD *)(v2 + 20);
    *(_DWORD *)(v2 + 20) = v107 + 1;
    *(_BYTE *)(v106 + v107) = 31;
    v108 = *(_DWORD *)(v2 + 20);
    v109 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v108 + 1;
    *(_BYTE *)(v109 + v108) = -117;
    v110 = *(_DWORD *)(v2 + 20);
    v111 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v110 + 1;
    *(_BYTE *)(v111 + v110) = 8;
    v112 = *(_DWORD **)(v2 + 28);
    if ( v112 )
    {
      v113 = *v112 != 0;
      if ( v112[11] )
        v113 += 2;
      if ( v112[4] )
        v113 += 4;
      if ( v112[7] )
        v113 += 8;
      if ( v112[9] )
        v113 += 16;
      v114 = *(_DWORD *)(v2 + 20);
      v115 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v114 + 1;
      *(_BYTE *)(v115 + v114) = v113;
      v116 = *(_DWORD *)(v2 + 8);
      v117 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 4);
      v118 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v118 + 1;
      *(_BYTE *)(v116 + v118) = v117;
      v119 = *(_DWORD *)(v2 + 8);
      v120 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 4);
      v121 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v121 + 1;
      *(_BYTE *)(v119 + v121) = BYTE1(v120);
      v122 = *(_DWORD *)(v2 + 8);
      LOWORD(v120) = *(_WORD *)(*(_DWORD *)(v2 + 28) + 6);
      v123 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v123 + 1;
      *(_BYTE *)(v122 + v123) = v120;
      v124 = *(_DWORD *)(v2 + 8);
      LOBYTE(v120) = *(_BYTE *)(*(_DWORD *)(v2 + 28) + 7);
      v125 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v125 + 1;
      *(_BYTE *)(v124 + v125) = v120;
      v126 = *(_DWORD *)(v2 + 132);
      v127 = 2;
      if ( v126 != 9 )
      {
        if ( *(int *)(v2 + 136) > 1 || (v127 = 0, v126 <= 1) )
          v127 = 4;
      }
      v128 = *(_DWORD *)(v2 + 20);
      v129 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v128 + 1;
      *(_BYTE *)(v129 + v128) = v127;
      v130 = *(_DWORD *)(v2 + 8);
      v131 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 12);
      v132 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v132 + 1;
      *(_BYTE *)(v130 + v132) = v131;
      v67 = *(_DWORD **)(v2 + 28);
      if ( v67[4] )
      {
        v133 = *(_DWORD *)(v2 + 20);
        v134 = v67[5];
        v135 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 20) = v133 + 1;
        *(_BYTE *)(v135 + v133) = v134;
        v136 = *(_DWORD *)(v2 + 8);
        v137 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 20);
        v138 = *(_DWORD *)(v2 + 20);
        *(_DWORD *)(v2 + 20) = v138 + 1;
        *(_BYTE *)(v136 + v138) = BYTE1(v137);
        v67 = *(_DWORD **)(v2 + 28);
      }
      if ( v67[11] )
      {
        v238 = crc32(v5[12], *(_BYTE **)(v2 + 8), *(_DWORD *)(v2 + 20));
        v67 = *(_DWORD **)(v2 + 28);
        v5[12] = v238;
      }
      *(_DWORD *)(v2 + 32) = 0;
      *(_DWORD *)(v2 + 4) = 69;
      goto LABEL_163;
    }
    v201 = *(_DWORD *)(v2 + 20);
    v202 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v201 + 1;
    *(_BYTE *)(v202 + v201) = 0;
    v203 = *(_DWORD *)(v2 + 20);
    v204 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v203 + 1;
    *(_BYTE *)(v204 + v203) = 0;
    v205 = *(_DWORD *)(v2 + 20);
    v206 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v205 + 1;
    *(_BYTE *)(v206 + v205) = 0;
    v207 = *(_DWORD *)(v2 + 20);
    v208 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v207 + 1;
    *(_BYTE *)(v208 + v207) = 0;
    v209 = *(_DWORD *)(v2 + 20);
    v210 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v209 + 1;
    *(_BYTE *)(v210 + v209) = 0;
    v211 = *(_DWORD *)(v2 + 132);
    v212 = 2;
    if ( v211 != 9 )
    {
      if ( *(int *)(v2 + 136) > 1 || (v212 = 0, v211 <= 1) )
        v212 = 4;
    }
    v213 = *(_DWORD *)(v2 + 20);
    v214 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v213 + 1;
    *(_BYTE *)(v214 + v213) = v212;
    v215 = *(_DWORD *)(v2 + 20);
    v216 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 20) = v215 + 1;
    *(_BYTE *)(v216 + v215) = 10;
    v217 = v5[7];
    *(_DWORD *)(v2 + 4) = 113;
    _tr_flush_bits(v217);
    v218 = *(_DWORD *)(v217 + 20);
    if ( v5[4] <= v218 )
      v218 = v5[4];
    if ( v218 )
    {
      memcpy((void *)v5[3], *(const void **)(v217 + 16), v218);
      v219 = *(_DWORD *)(v217 + 20);
      v5[3] += v218;
      *(_DWORD *)(v217 + 16) += v218;
      v5[5] += v218;
      v5[4] -= v218;
      v220 = v219 - v218;
      *(_DWORD *)(v217 + 20) = v220;
      if ( !v220 )
        *(_DWORD *)(v217 + 16) = *(_DWORD *)(v217 + 8);
    }
    if ( *(_DWORD *)(v2 + 20) )
      goto LABEL_66;
    v4 = *(_DWORD *)(v2 + 4);
  }
  switch ( v4 )
  {
    case 'E':
      v67 = *(_DWORD **)(v2 + 28);
LABEL_163:
      v139 = v67[4];
      if ( v139 )
      {
        v140 = *(_DWORD *)(v2 + 32);
        v141 = *(_DWORD *)(v2 + 20);
        v251 = *(_DWORD *)(v2 + 12);
        v253 = *((unsigned __int16 *)v67 + 10) - v140;
        if ( v251 < v141 + v253 )
        {
          while ( 1 )
          {
            memcpy((void *)(v141 + *(_DWORD *)(v2 + 8)), (const void *)(v140 + v139), v251 - v141);
            v146 = *(_DWORD *)(v2 + 12);
            v147 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 44);
            *(_DWORD *)(v2 + 20) = v146;
            if ( v147 && v146 > v141 )
              v5[12] = crc32(v5[12], (_BYTE *)(v141 + *(_DWORD *)(v2 + 8)), v146 - v141);
            v142 = v5[7];
            *(_DWORD *)(v2 + 32) += v251 - v141;
            v255 = v142;
            _tr_flush_bits(v142);
            v143 = *(_DWORD *)(v255 + 20);
            if ( v5[4] <= v143 )
              v143 = v5[4];
            if ( v143 )
            {
              memcpy((void *)v5[3], *(const void **)(v255 + 16), v143);
              v5[3] += v143;
              v144 = *(_DWORD *)(v255 + 20);
              *(_DWORD *)(v255 + 16) += v143;
              v5[5] += v143;
              v5[4] -= v143;
              v145 = v144 - v143;
              *(_DWORD *)(v255 + 20) = v145;
              if ( !v145 )
                *(_DWORD *)(v255 + 16) = *(_DWORD *)(v255 + 8);
            }
            v148 = *(_DWORD *)(v2 + 20);
            if ( v148 )
              goto LABEL_66;
            v253 += v141 - v251;
            v149 = v253;
            v139 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 16);
            v251 = *(_DWORD *)(v2 + 12);
            v140 = *(_DWORD *)(v2 + 32);
            if ( v251 >= v253 )
              goto LABEL_177;
            v141 = 0;
          }
        }
        v148 = *(_DWORD *)(v2 + 20);
        v149 = *((unsigned __int16 *)v67 + 10) - v140;
LABEL_177:
        memcpy((void *)(v148 + *(_DWORD *)(v2 + 8)), (const void *)(v139 + v140), v149);
        v67 = *(_DWORD **)(v2 + 28);
        v150 = v67[11];
        v151 = v149 + *(_DWORD *)(v2 + 20);
        *(_DWORD *)(v2 + 20) = v151;
        if ( v150 && v151 > v148 )
        {
          v152 = crc32(v5[12], (_BYTE *)(*(_DWORD *)(v2 + 8) + v148), v151 - v148);
          v67 = *(_DWORD **)(v2 + 28);
          v5[12] = v152;
        }
        *(_DWORD *)(v2 + 32) = 0;
      }
      *(_DWORD *)(v2 + 4) = 73;
      goto LABEL_85;
    case 'I':
      v67 = *(_DWORD **)(v2 + 28);
LABEL_85:
      if ( v67[7] )
      {
        v68 = *(_DWORD *)(v2 + 20);
        v69 = v68;
        while ( 1 )
        {
          if ( *(_DWORD *)(v2 + 12) == v69 )
          {
            if ( v67[11] && v68 < v69 )
              v5[12] = crc32(v5[12], (_BYTE *)(*(_DWORD *)(v2 + 8) + v68), v69 - v68);
            v73 = v5[7];
            _tr_flush_bits(v73);
            v74 = *(_DWORD *)(v73 + 20);
            if ( v5[4] <= v74 )
              v74 = v5[4];
            if ( v74 )
            {
              memcpy((void *)v5[3], *(const void **)(v73 + 16), v74);
              v75 = *(_DWORD *)(v73 + 20);
              v5[3] += v74;
              *(_DWORD *)(v73 + 16) += v74;
              v5[5] += v74;
              v5[4] -= v74;
              v76 = v75 - v74;
              *(_DWORD *)(v73 + 20) = v76;
              if ( !v76 )
                *(_DWORD *)(v73 + 16) = *(_DWORD *)(v73 + 8);
            }
            v69 = *(_DWORD *)(v2 + 20);
            if ( v69 )
              goto LABEL_66;
            v67 = *(_DWORD **)(v2 + 28);
            v68 = 0;
          }
          v70 = *(_DWORD *)(v2 + 32);
          v71 = v67[7];
          *(_DWORD *)(v2 + 32) = v70 + 1;
          LOBYTE(v70) = *(_BYTE *)(v71 + v70);
          v72 = *(_DWORD *)(v2 + 8);
          *(_DWORD *)(v2 + 20) = v69 + 1;
          *(_BYTE *)(v72 + v69) = v70;
          if ( !(_BYTE)v70 )
            break;
          v69 = *(_DWORD *)(v2 + 20);
          v67 = *(_DWORD **)(v2 + 28);
        }
        v67 = *(_DWORD **)(v2 + 28);
        if ( v67[11] )
        {
          v77 = *(_DWORD *)(v2 + 20);
          if ( v77 > v68 )
          {
            v78 = crc32(v5[12], (_BYTE *)(*(_DWORD *)(v2 + 8) + v68), v77 - v68);
            v67 = *(_DWORD **)(v2 + 28);
            v5[12] = v78;
          }
        }
        *(_DWORD *)(v2 + 32) = 0;
      }
      *(_DWORD *)(v2 + 4) = 91;
      goto LABEL_105;
    case '[':
      v67 = *(_DWORD **)(v2 + 28);
LABEL_105:
      if ( v67[9] )
      {
        v79 = *(_DWORD *)(v2 + 20);
        v80 = v79;
        while ( 1 )
        {
          if ( *(_DWORD *)(v2 + 12) == v80 )
          {
            if ( v67[11] && v79 < v80 )
              v5[12] = crc32(v5[12], (_BYTE *)(*(_DWORD *)(v2 + 8) + v79), v80 - v79);
            v84 = v5[7];
            _tr_flush_bits(v84);
            v85 = *(_DWORD *)(v84 + 20);
            if ( v5[4] <= v85 )
              v85 = v5[4];
            if ( v85 )
            {
              memcpy((void *)v5[3], *(const void **)(v84 + 16), v85);
              v86 = *(_DWORD *)(v84 + 20);
              v5[3] += v85;
              *(_DWORD *)(v84 + 16) += v85;
              v5[5] += v85;
              v5[4] -= v85;
              v87 = v86 - v85;
              *(_DWORD *)(v84 + 20) = v87;
              if ( !v87 )
                *(_DWORD *)(v84 + 16) = *(_DWORD *)(v84 + 8);
            }
            v80 = *(_DWORD *)(v2 + 20);
            if ( v80 )
              goto LABEL_66;
            v67 = *(_DWORD **)(v2 + 28);
            v79 = 0;
          }
          v81 = *(_DWORD *)(v2 + 32);
          v82 = v67[9];
          *(_DWORD *)(v2 + 32) = v81 + 1;
          LOBYTE(v81) = *(_BYTE *)(v82 + v81);
          v83 = *(_DWORD *)(v2 + 8);
          *(_DWORD *)(v2 + 20) = v80 + 1;
          *(_BYTE *)(v83 + v80) = v81;
          if ( !(_BYTE)v81 )
            break;
          v80 = *(_DWORD *)(v2 + 20);
          v67 = *(_DWORD **)(v2 + 28);
        }
        v26 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 44);
        if ( !v26 )
          goto LABEL_195;
        v153 = *(_DWORD *)(v2 + 20);
        if ( v153 > v79 )
        {
          v5[12] = crc32(v5[12], (_BYTE *)(*(_DWORD *)(v2 + 8) + v79), v153 - v79);
          v26 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 44);
        }
      }
      else
      {
        v26 = v67[11];
      }
      *(_DWORD *)(v2 + 4) = 103;
LABEL_188:
      if ( v26 )
      {
        v154 = *(_DWORD *)(v2 + 20);
        if ( (unsigned int)(v154 + 2) > *(_DWORD *)(v2 + 12) )
        {
          v155 = v5[7];
          _tr_flush_bits(v155);
          v156 = *(_DWORD *)(v155 + 20);
          if ( v5[4] <= v156 )
            v156 = v5[4];
          if ( v156 )
          {
            memcpy((void *)v5[3], *(const void **)(v155 + 16), v156);
            v191 = *(_DWORD *)(v155 + 20);
            v5[3] += v156;
            *(_DWORD *)(v155 + 16) += v156;
            v5[5] += v156;
            v5[4] -= v156;
            v192 = v191 - v156;
            *(_DWORD *)(v155 + 20) = v192;
            if ( !v192 )
              *(_DWORD *)(v155 + 16) = *(_DWORD *)(v155 + 8);
          }
          v154 = *(_DWORD *)(v2 + 20);
          if ( v154 )
            goto LABEL_66;
        }
        v157 = v5[12];
        v158 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 20) = v154 + 1;
        *(_BYTE *)(v158 + v154) = v157;
        v159 = *(_DWORD *)(v2 + 20);
        v160 = v5[12];
        v161 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 20) = v159 + 1;
        *(_BYTE *)(v161 + v159) = BYTE1(v160);
        v5[12] = crc32(0, 0, 0);
      }
LABEL_195:
      v162 = v5[7];
      *(_DWORD *)(v2 + 4) = 113;
      _tr_flush_bits(v162);
      v163 = *(_DWORD *)(v162 + 20);
      if ( v5[4] <= v163 )
        v163 = v5[4];
      if ( v163 )
      {
        memcpy((void *)v5[3], *(const void **)(v162 + 16), v163);
        v164 = *(_DWORD *)(v162 + 20);
        v5[3] += v163;
        *(_DWORD *)(v162 + 16) += v163;
        v5[5] += v163;
        v5[4] -= v163;
        v165 = v164 - v163;
        *(_DWORD *)(v162 + 20) = v165;
        if ( !v165 )
          *(_DWORD *)(v162 + 16) = *(_DWORD *)(v162 + 8);
      }
      if ( *(_DWORD *)(v2 + 20) )
        goto LABEL_66;
      break;
    case 'g':
      v26 = *(_DWORD *)(*(_DWORD *)(v2 + 28) + 44);
      goto LABEL_188;
  }
LABEL_36:
  if ( !v5[1] && !*(_DWORD *)(v2 + 116) )
  {
    if ( !a2 )
      return 0;
    if ( *(_DWORD *)(v2 + 4) == 666 )
      goto LABEL_44;
  }
  v31 = *(_DWORD *)(v2 + 132);
  if ( !v31 )
  {
    v33 = deflate_stored((_DWORD *)v2, a2);
LABEL_42:
    v34 = v33 & 0xFFFFFFFD;
    if ( (unsigned int)(v33 - 2) > 1 )
      goto LABEL_136;
    *(_DWORD *)(v2 + 4) = 666;
    if ( v34 )
      goto LABEL_44;
    goto LABEL_65;
  }
  v32 = *(_DWORD *)(v2 + 136);
  if ( v32 == 2 )
  {
    v249 = v5;
    while ( 1 )
    {
      v88 = *(_DWORD *)(v2 + 116);
      do
      {
        if ( !v88 )
        {
          fill_window((int *)v2);
          if ( !*(_DWORD *)(v2 + 116) )
          {
            v5 = v249;
            if ( a2 )
              goto LABEL_126;
            goto LABEL_65;
          }
        }
        v89 = *(_DWORD *)(v2 + 56);
        v90 = *(_DWORD *)(v2 + 108);
        *(_DWORD *)(v2 + 96) = 0;
        v91 = *(unsigned __int8 *)(v89 + v90);
        v92 = *(_DWORD *)(v2 + 5792);
        *(_WORD *)(*(_DWORD *)(v2 + 5796) + 2 * v92) = 0;
        v93 = *(_DWORD *)(v2 + 5784);
        *(_DWORD *)(v2 + 5792) = v92 + 1;
        *(_BYTE *)(v93 + v92) = v91;
        ++*(_WORD *)(v2 + 4 * v91 + 148);
        v94 = *(_DWORD *)(v2 + 5788) - 1;
        v95 = *(_DWORD *)(v2 + 108) + 1;
        v88 = *(_DWORD *)(v2 + 116) - 1;
        *(_DWORD *)(v2 + 108) = v95;
        *(_DWORD *)(v2 + 116) = v88;
      }
      while ( *(_DWORD *)(v2 + 5792) != v94 );
      v166 = *(_DWORD *)(v2 + 92);
      v167 = 0;
      v168 = v95 - v166;
      if ( v166 >= 0 )
        v167 = (void *)(*(_DWORD *)(v2 + 56) + v166);
      _tr_flush_block(v2, v167, v168, 0);
      v169 = *(_DWORD *)v2;
      v170 = *(_DWORD *)(*(_DWORD *)v2 + 28);
      *(_DWORD *)(v2 + 92) = *(_DWORD *)(v2 + 108);
      _tr_flush_bits(v170);
      v171 = *(_DWORD *)(v170 + 20);
      if ( *(_DWORD *)(v169 + 16) <= v171 )
        v171 = *(_DWORD *)(v169 + 16);
      if ( v171 )
      {
        memcpy(*(void **)(v169 + 12), *(const void **)(v170 + 16), v171);
        v172 = *(_DWORD *)(v170 + 20);
        *(_DWORD *)(v169 + 12) += v171;
        *(_DWORD *)(v170 + 16) += v171;
        *(_DWORD *)(v169 + 20) += v171;
        *(_DWORD *)(v169 + 16) -= v171;
        v173 = v172 - v171;
        *(_DWORD *)(v170 + 20) = v173;
        if ( !v173 )
          *(_DWORD *)(v170 + 16) = *(_DWORD *)(v170 + 8);
      }
      if ( !*(_DWORD *)(*(_DWORD *)v2 + 16) )
      {
        v5 = v249;
        goto LABEL_65;
      }
    }
  }
  if ( v32 != 3 )
  {
    v33 = funcs_427A76[3 * v31](v2, a2);
    goto LABEL_42;
  }
  v254 = (size_t)v5;
LABEL_215:
  v177 = *(_DWORD *)(v2 + 116);
  while ( 1 )
  {
    if ( v177 <= 0x102 )
    {
      fill_window((int *)v2);
      v177 = *(_DWORD *)(v2 + 116);
      if ( v177 <= 0x102 )
        break;
    }
    v178 = *(_DWORD *)(v2 + 108);
    v179 = *(_DWORD *)(v2 + 56);
    *(_DWORD *)(v2 + 96) = 0;
LABEL_217:
    if ( v178 )
    {
      v180 = (unsigned __int8 *)(v179 + v178 - 1);
      v181 = *v180;
      if ( *v180 == *(_BYTE *)(v179 + v178) && v181 == v180[2] && v181 == v180[3] )
      {
        v256 = v179 + v178 + 258;
        v193 = v180 + 3;
        while ( 1 )
        {
          if ( v181 != v193[1] )
          {
            ++v193;
            goto LABEL_247;
          }
          if ( v181 != v193[2] )
          {
            v193 += 2;
            goto LABEL_247;
          }
          if ( v181 != v193[3] )
          {
            v193 += 3;
            goto LABEL_247;
          }
          if ( v181 != v193[4] )
          {
            v193 += 4;
            goto LABEL_247;
          }
          if ( v181 != v193[5] )
          {
            v193 += 5;
            goto LABEL_247;
          }
          if ( v181 != v193[6] )
            break;
          if ( v181 != v193[7] )
          {
            v193 += 7;
            goto LABEL_247;
          }
          v193 += 8;
          if ( v256 <= (unsigned int)v193 || *v193 != v181 )
            goto LABEL_247;
        }
        v193 += 6;
LABEL_247:
        v194 = (unsigned int)&v193[-v256 + 258];
        *(_DWORD *)(v2 + 96) = v194;
        if ( v194 > v177 )
        {
          *(_DWORD *)(v2 + 96) = v177;
          LOBYTE(v194) = v177;
LABEL_249:
          v195 = *(_DWORD *)(v2 + 5792);
          v196 = v194 - 3;
          *(_WORD *)(*(_DWORD *)(v2 + 5796) + 2 * v195) = 1;
          v197 = *(_DWORD *)(v2 + 5784);
          *(_DWORD *)(v2 + 5792) = v195 + 1;
          *(_BYTE *)(v197 + v195) = v196;
          ++*(_WORD *)(v2 + 4 * (unsigned __int8)_length_code[v196] + 1176);
          ++*(_WORD *)(v2 + 4 * (unsigned __int8)_dist_code[0] + 2440);
          v198 = *(_DWORD *)(v2 + 116);
          v199 = *(_DWORD *)(v2 + 5788) - 1 == *(_DWORD *)(v2 + 5792);
          v200 = *(_DWORD *)(v2 + 96);
          *(_DWORD *)(v2 + 96) = 0;
          v185 = v199;
          v177 = v198 - v200;
          v187 = *(_DWORD *)(v2 + 108) + v200;
          *(_DWORD *)(v2 + 116) = v177;
          *(_DWORD *)(v2 + 108) = v187;
          goto LABEL_220;
        }
        if ( v194 > 2 )
          goto LABEL_249;
      }
    }
LABEL_219:
    v182 = *(unsigned __int8 *)(v179 + v178);
    v183 = *(_DWORD *)(v2 + 5792);
    *(_WORD *)(*(_DWORD *)(v2 + 5796) + 2 * v183) = 0;
    v184 = *(_DWORD *)(v2 + 5784);
    *(_DWORD *)(v2 + 5792) = v183 + 1;
    *(_BYTE *)(v184 + v183) = v182;
    ++*(_WORD *)(v2 + 4 * v182 + 148);
    v185 = *(_DWORD *)(v2 + 5788) - 1 == *(_DWORD *)(v2 + 5792);
    v177 = *(_DWORD *)(v2 + 116) - 1;
    v186 = *(_DWORD *)(v2 + 108);
    *(_DWORD *)(v2 + 116) = v177;
    v187 = v186 + 1;
    *(_DWORD *)(v2 + 108) = v187;
LABEL_220:
    if ( v185 )
    {
      v52 = *(_DWORD *)(v2 + 92);
      v53 = 0;
      v54 = v187 - v52;
      if ( v52 >= 0 )
        v53 = (void *)(v52 + *(_DWORD *)(v2 + 56));
      _tr_flush_block(v2, v53, v54, 0);
      v55 = *(_DWORD *)v2;
      v56 = *(_DWORD *)(*(_DWORD *)v2 + 28);
      *(_DWORD *)(v2 + 92) = *(_DWORD *)(v2 + 108);
      v248 = v55;
      _tr_flush_bits(v56);
      v57 = *(_DWORD *)(v56 + 20);
      if ( *(_DWORD *)(v248 + 16) <= v57 )
        v57 = *(_DWORD *)(v248 + 16);
      if ( v57 )
      {
        memcpy(*(void **)(v248 + 12), *(const void **)(v56 + 16), v57);
        v58 = *(_DWORD *)(v56 + 20);
        *(_DWORD *)(v248 + 12) += v57;
        *(_DWORD *)(v56 + 16) += v57;
        *(_DWORD *)(v248 + 20) += v57;
        *(_DWORD *)(v248 + 16) -= v57;
        v59 = v58 - v57;
        *(_DWORD *)(v56 + 20) = v59;
        if ( !v59 )
          *(_DWORD *)(v56 + 16) = *(_DWORD *)(v56 + 8);
      }
      if ( !*(_DWORD *)(*(_DWORD *)v2 + 16) )
      {
LABEL_64:
        v5 = (_DWORD *)v254;
        goto LABEL_65;
      }
      goto LABEL_215;
    }
  }
  if ( !a2 )
    goto LABEL_64;
  if ( v177 )
  {
    v178 = *(_DWORD *)(v2 + 108);
    v179 = *(_DWORD *)(v2 + 56);
    *(_DWORD *)(v2 + 96) = 0;
    if ( v177 <= 2 )
      goto LABEL_219;
    goto LABEL_217;
  }
  v5 = (_DWORD *)v254;
LABEL_126:
  *(_DWORD *)(v2 + 5812) = 0;
  if ( a2 == 4 )
  {
    v239 = *(_DWORD *)(v2 + 92);
    v240 = 0;
    if ( v239 >= 0 )
      v240 = (void *)(v239 + *(_DWORD *)(v2 + 56));
    _tr_flush_block(v2, v240, *(_DWORD *)(v2 + 108) - v239, 1);
    v241 = *(_DWORD *)v2;
    v242 = *(_DWORD *)(*(_DWORD *)v2 + 28);
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(v2 + 108);
    v252 = v242;
    _tr_flush_bits(v242);
    v243 = *(_DWORD *)(v252 + 20);
    if ( *(_DWORD *)(v241 + 16) <= v243 )
      v243 = *(_DWORD *)(v241 + 16);
    if ( v243 )
    {
      memcpy(*(void **)(v241 + 12), *(const void **)(v252 + 16), v243);
      *(_DWORD *)(v241 + 12) += v243;
      *(_DWORD *)(v252 + 16) += v243;
      *(_DWORD *)(v241 + 20) += v243;
      v244 = *(_DWORD *)(v252 + 20);
      *(_DWORD *)(v241 + 16) -= v243;
      v245 = v244 - v243;
      *(_DWORD *)(v252 + 20) = v245;
      if ( !v245 )
        *(_DWORD *)(v252 + 16) = *(_DWORD *)(v252 + 8);
    }
    v246 = *(_DWORD *)(*(_DWORD *)v2 + 16);
    *(_DWORD *)(v2 + 4) = 666;
    if ( v246 )
      goto LABEL_45;
LABEL_65:
    if ( v5[4] )
      return 0;
LABEL_66:
    *(_DWORD *)(v2 + 40) = -1;
    return 0;
  }
  if ( !*(_DWORD *)(v2 + 5792) )
    goto LABEL_138;
  v96 = *(_DWORD *)(v2 + 92);
  v97 = 0;
  if ( v96 >= 0 )
    v97 = (void *)(v96 + *(_DWORD *)(v2 + 56));
  _tr_flush_block(v2, v97, *(_DWORD *)(v2 + 108) - v96, 0);
  v98 = *(_DWORD *)v2;
  v99 = *(_DWORD *)(*(_DWORD *)v2 + 28);
  *(_DWORD *)(v2 + 92) = *(_DWORD *)(v2 + 108);
  v250 = v99;
  _tr_flush_bits(v99);
  v100 = *(_DWORD *)(v250 + 20);
  if ( *(_DWORD *)(v98 + 16) <= v100 )
    v100 = *(_DWORD *)(v98 + 16);
  if ( v100 )
  {
    memcpy(*(void **)(v98 + 12), *(const void **)(v250 + 16), v100);
    *(_DWORD *)(v98 + 12) += v100;
    *(_DWORD *)(v250 + 16) += v100;
    *(_DWORD *)(v98 + 20) += v100;
    v101 = *(_DWORD *)(v250 + 20);
    *(_DWORD *)(v98 + 16) -= v100;
    v102 = v101 - v100;
    *(_DWORD *)(v250 + 20) = v102;
    if ( !v102 )
      *(_DWORD *)(v250 + 16) = *(_DWORD *)(v250 + 8);
  }
  v33 = *(_DWORD *)(*(_DWORD *)v2 + 16) != 0;
  v34 = v33;
LABEL_136:
  if ( !v34 )
    goto LABEL_65;
  if ( v33 == 1 )
  {
LABEL_138:
    if ( a2 == 1 )
    {
      _tr_align(v2);
    }
    else if ( a2 != 5 )
    {
      _tr_stored_block(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        v188 = *(_WORD **)(v2 + 68);
        v189 = *(_DWORD *)(v2 + 76) + 0x7FFFFFFF;
        v188[v189] = 0;
        memset(v188, 0, 2 * v189);
        if ( !*(_DWORD *)(v2 + 116) )
        {
          *(_DWORD *)(v2 + 108) = 0;
          *(_DWORD *)(v2 + 92) = 0;
          *(_DWORD *)(v2 + 5812) = 0;
        }
      }
    }
    v103 = v5[7];
    _tr_flush_bits(v103);
    v104 = *(_DWORD *)(v103 + 20);
    result = v5[4];
    if ( v104 > result )
      v104 = v5[4];
    if ( v104 )
    {
      memcpy((void *)v5[3], *(const void **)(v103 + 16), v104);
      v174 = v5[4];
      v175 = *(_DWORD *)(v103 + 20);
      v5[3] += v104;
      result = v174 - v104;
      *(_DWORD *)(v103 + 16) += v104;
      v5[5] += v104;
      v176 = v175 - v104;
      v5[4] = result;
      *(_DWORD *)(v103 + 20) = v176;
      if ( !v176 )
        *(_DWORD *)(v103 + 16) = *(_DWORD *)(v103 + 8);
    }
    if ( !result )
      goto LABEL_144;
  }
LABEL_44:
  if ( a2 != 4 )
    return 0;
LABEL_45:
  v35 = *(_DWORD *)(v2 + 24);
  result = 1;
  if ( v35 > 0 )
  {
    v36 = *(_DWORD *)(v2 + 20);
    v37 = v5[12];
    v38 = v36 + 1;
    v39 = (_BYTE *)(*(_DWORD *)(v2 + 8) + v36);
    *(_DWORD *)(v2 + 20) = v38;
    if ( v35 == 2 )
    {
      *v39 = v37;
      v221 = *(_DWORD *)(v2 + 20);
      v222 = v5[12];
      v223 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v221 + 1;
      *(_BYTE *)(v223 + v221) = BYTE1(v222);
      v224 = *(_DWORD *)(v2 + 20);
      LOWORD(v222) = *((_WORD *)v5 + 25);
      v225 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v224 + 1;
      *(_BYTE *)(v225 + v224) = v222;
      v226 = *(_DWORD *)(v2 + 20);
      LOBYTE(v222) = *((_BYTE *)v5 + 51);
      v227 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v226 + 1;
      *(_BYTE *)(v227 + v226) = v222;
      v228 = *(_DWORD *)(v2 + 20);
      v229 = v5[2];
      v230 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v228 + 1;
      *(_BYTE *)(v230 + v228) = v229;
      v231 = *(_DWORD *)(v2 + 20);
      v232 = v5[2];
      v233 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v231 + 1;
      *(_BYTE *)(v233 + v231) = BYTE1(v232);
      v234 = *(_DWORD *)(v2 + 20);
      LOWORD(v232) = *((_WORD *)v5 + 5);
      v235 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v234 + 1;
      *(_BYTE *)(v235 + v234) = v232;
      LOBYTE(v232) = *((_BYTE *)v5 + 11);
      v236 = *(_DWORD *)(v2 + 8);
      v237 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 20) = v237 + 1;
      *(_BYTE *)(v236 + v237) = v232;
    }
    else
    {
      *v39 = HIBYTE(v37);
      v40 = *(_DWORD *)(v2 + 20);
      v41 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v40 + 1;
      *(_BYTE *)(v41 + v40) = BYTE2(v37);
      v42 = *(_DWORD *)(v2 + 20);
      v43 = *((_WORD *)v5 + 24);
      v44 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v42 + 1;
      *(_BYTE *)(v44 + v42) = HIBYTE(v43);
      v45 = *(_DWORD *)(v2 + 20);
      v46 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 20) = v45 + 1;
      *(_BYTE *)(v46 + v45) = v43;
    }
    v47 = v5[7];
    _tr_flush_bits(v47);
    Size = *(_DWORD *)(v47 + 20);
    if ( v5[4] <= Size )
      Size = v5[4];
    if ( Size )
    {
      memcpy((void *)v5[3], *(const void **)(v47 + 16), Size);
      v49 = *(_DWORD *)(v47 + 20);
      v5[3] += Size;
      *(_DWORD *)(v47 + 16) += Size;
      v5[5] += Size;
      v5[4] -= Size;
      v50 = v49 - Size;
      *(_DWORD *)(v47 + 20) = v50;
      if ( !v50 )
        *(_DWORD *)(v47 + 16) = *(_DWORD *)(v47 + 8);
    }
    v51 = *(_DWORD *)(v2 + 24);
    if ( v51 > 0 )
      *(_DWORD *)(v2 + 24) = -v51;
    return *(_DWORD *)(v2 + 20) == 0;
  }
  return result;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);
// 511FC8: using guessed type int (__cdecl *funcs_427A76[3])(int, int);

//----- (00428C40) --------------------------------------------------------
int __cdecl deflateBound(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // eax
  _DWORD *v3; // ebx
  int v4; // edi
  bool v5; // bp
  int v6; // ecx
  int v7; // ecx
  _DWORD *v9; // ebp
  int v10; // edi
  int v11; // edi
  int v12; // edi
  int v13; // edi

  v2 = a2 + ((a2 + 7) >> 3) + ((a2 + 63) >> 6);
  if ( !a1 )
    return v2 + 11;
  if ( !a1[8] )
    return v2 + 11;
  if ( !a1[9] )
    return v2 + 11;
  v3 = (_DWORD *)a1[7];
  if ( !v3 || a1 != (_DWORD *)*v3 )
    return v2 + 11;
  v4 = v3[1];
  v5 = 1;
  if ( (unsigned int)(v4 - 91) <= 0x16 )
    v5 = ((0x401001u >> (v4 - 91)) & 1) == 0;
  if ( v4 != 666 && v4 != 69 && v4 != 42 && ((v4 - 57) & 0xFFFFFFEF) != 0 && v5 )
    return v2 + 11;
  v6 = v3[6];
  if ( v6 == 1 )
  {
    v7 = v3[27] == 0 ? 6 : 10;
  }
  else if ( v6 == 2 )
  {
    v9 = (_DWORD *)v3[7];
    v7 = 18;
    if ( v9 )
    {
      if ( v9[4] )
        v7 = v9[5] + 20;
      v10 = v9[7];
      if ( v10 )
      {
        v11 = v10 - v7;
        do
          ++v7;
        while ( *(_BYTE *)(v11 + v7 - 1) );
      }
      v12 = v9[9];
      if ( v12 )
      {
        v13 = v12 - v7;
        do
          ++v7;
        while ( *(_BYTE *)(v13 + v7 - 1) );
      }
      if ( v9[11] )
        v7 += 2;
    }
  }
  else
  {
    v7 = v6 != 0 ? 6 : 0;
  }
  if ( v3[12] == 15 && v3[20] == 15 )
    return v7 + (a2 >> 25) + (a2 >> 14) + a2 + 7 + (a2 >> 12);
  else
    return v2 + v7 + 5;
}

//----- (00428DC0) --------------------------------------------------------
int __cdecl deflateCopy(_DWORD *a1, _DWORD *a2)
{
  int (__cdecl *v2)(int, int, int); // esi
  int v3; // ebp
  int result; // eax
  int v5; // eax
  bool v6; // di
  int v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // edx
  int v10; // eax
  int v11; // esi
  void *v12; // ecx
  int v13; // eax
  int v14; // ebx
  _DWORD *v15; // [esp+18h] [ebp-24h]

  if ( !a2 )
    return -2;
  v2 = (int (__cdecl *)(int, int, int))a2[8];
  if ( !v2 || !a2[9] )
    return -2;
  v3 = a2[7];
  result = -2;
  if ( !v3 || a2 != *(_DWORD **)v3 )
    return result;
  v5 = *(_DWORD *)(v3 + 4);
  v6 = 1;
  if ( (unsigned int)(v5 - 91) <= 0x16 )
    v6 = ((0x401001u >> (v5 - 91)) & 1) == 0;
  if ( v5 != 666 && v5 != 69 && v5 != 42 && ((v5 - 57) & 0xFFFFFFEF) != 0 && v6 || !a1 )
    return -2;
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  a1[8] = a2[8];
  a1[9] = a2[9];
  v7 = a2[10];
  a1[10] = v7;
  a1[11] = a2[11];
  a1[12] = a2[12];
  a1[13] = a2[13];
  v8 = (_DWORD *)v2(v7, 1, 5828);
  v9 = v8;
  if ( !v8 )
    return -4;
  a1[7] = v8;
  *v8 = *(_DWORD *)v3;
  v8[1456] = *(_DWORD *)(v3 + 5824);
  qmemcpy(
    (void *)((unsigned int)(v8 + 1) & 0xFFFFFFFC),
    (const void *)(v3 - ((_DWORD)v8 - ((unsigned int)(v8 + 1) & 0xFFFFFFFC))),
    4 * (((unsigned int)v8 - ((unsigned int)(v8 + 1) & 0xFFFFFFFC) + 5828) >> 2));
  *v8 = a1;
  v15 = v8;
  v9[14] = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v8[11], 2);
  v15[16] = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v15[11], 2);
  v15[17] = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v15[19], 2);
  v10 = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v15[1447], 4);
  v11 = v10;
  v12 = (void *)v15[14];
  v15[2] = v10;
  if ( v12 && v15[16] && v15[17] && v10 )
  {
    memcpy(v12, *(const void **)(v3 + 56), 2 * v15[11]);
    memcpy((void *)v15[16], *(const void **)(v3 + 64), 2 * v15[11]);
    memcpy((void *)v15[17], *(const void **)(v3 + 68), 2 * v15[19]);
    memcpy((void *)v15[2], *(const void **)(v3 + 8), v15[3]);
    v13 = v15[2];
    v15[4] = v13 + *(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 8);
    v14 = v15[1447];
    v15[1446] = 3 * v14 + v13;
    v15[710] = v15 + 37;
    v15[1449] = (v14 & 0xFFFFFFFE) + v11;
    v15[713] = v15 + 610;
    v15[716] = v15 + 671;
    return 0;
  }
  else
  {
    deflateEnd(a1);
    return -4;
  }
}

//----- (004290C0) --------------------------------------------------------
int __cdecl deflateEnd(_DWORD *a1)
{
  void (__cdecl *v1)(int, _DWORD *); // esi
  _DWORD *v2; // edx
  int result; // eax
  int v4; // edi
  bool v5; // bp
  _DWORD *v6; // ecx
  int v7; // eax
  _DWORD *v8; // ecx
  _DWORD *v9; // ecx
  _DWORD *v10; // ecx

  if ( !a1 )
    return -2;
  if ( !a1[8] )
    return -2;
  v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
  if ( !v1 )
    return -2;
  v2 = (_DWORD *)a1[7];
  result = -2;
  if ( !v2 || a1 != (_DWORD *)*v2 )
    return result;
  v4 = v2[1];
  v5 = 1;
  if ( (unsigned int)(v4 - 91) <= 0x16 )
    v5 = ((0x401001u >> (v4 - 91)) & 1) == 0;
  if ( v4 != 666 && v4 != 69 && v4 != 42 && ((v4 - 57) & 0xFFFFFFEF) != 0 && v5 )
    return -2;
  v6 = (_DWORD *)v2[2];
  v7 = a1[10];
  if ( v6 )
  {
    v1(a1[10], v6);
    v2 = (_DWORD *)a1[7];
    v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
    v7 = a1[10];
  }
  v8 = (_DWORD *)v2[17];
  if ( v8 )
  {
    v1(v7, v8);
    v2 = (_DWORD *)a1[7];
    v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
    v7 = a1[10];
  }
  v9 = (_DWORD *)v2[16];
  if ( v9 )
  {
    v1(v7, v9);
    v2 = (_DWORD *)a1[7];
    v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
    v7 = a1[10];
  }
  v10 = (_DWORD *)v2[14];
  if ( v10 )
  {
    v1(v7, v10);
    v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
    v2 = (_DWORD *)a1[7];
    v7 = a1[10];
  }
  v1(v7, v2);
  a1[7] = 0;
  return 3 * (v4 != 113) - 3;
}

//----- (004291F0) --------------------------------------------------------
int __cdecl deflateGetDictionary(_DWORD *a1, void *a2, size_t *a3)
{
  _DWORD *v3; // ebx
  int result; // eax
  int v5; // edx
  bool v6; // si
  unsigned int v7; // eax
  size_t Size; // esi

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v3 = (_DWORD *)a1[7];
  result = -2;
  if ( !v3 || a1 != (_DWORD *)*v3 )
    return result;
  v5 = v3[1];
  v6 = 1;
  if ( (unsigned int)(v5 - 91) <= 0x16 )
    v6 = ((0x401001u >> (v5 - 91)) & 1) == 0;
  if ( ((v5 - 57) & 0xFFFFFFEF) != 0 && v5 != 666 && v5 != 69 && v5 != 42 && v6 )
    return -2;
  v7 = v3[27] + v3[29];
  Size = v7;
  if ( v3[11] <= v7 )
    Size = v3[11];
  if ( a2 && Size )
    memcpy(a2, (const void *)(v3[14] + v7 - Size), Size);
  result = 0;
  if ( a3 )
    *a3 = Size;
  return result;
}

//----- (004292E0) --------------------------------------------------------
int __cdecl deflateInit2_(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6, _BYTE *a7, int a8)
{
  int v8; // ecx
  bool v9; // al
  void *(__cdecl *v10)(size_t, int, int); // edx
  unsigned int v11; // ebx
  int v12; // edi
  int v13; // ebp
  _DWORD *v14; // eax
  _DWORD *v15; // ebx
  int v16; // ebp
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // edi
  int result; // eax
  _DWORD *v23; // ebx
  _WORD *v24; // edx
  int v25; // eax
  int v26; // eax
  char *v27; // edx
  int v28; // ecx
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // ebx
  unsigned int v33; // [esp+34h] [ebp+8h]

  v8 = a4;
  if ( !a7 )
    return -6;
  v9 = *a7 != 49 || a8 != 56;
  if ( v9 )
    return -6;
  if ( !a1 )
    return -2;
  v10 = (void *(__cdecl *)(size_t, int, int))a1[8];
  a1[6] = 0;
  if ( v10 )
  {
    if ( a1[9] )
      goto LABEL_6;
  }
  else
  {
    v32 = a1[9];
    a1[8] = zcalloc;
    v10 = zcalloc;
    a1[10] = 0;
    if ( v32 )
      goto LABEL_6;
  }
  a1[9] = zcfree;
LABEL_6:
  v11 = 6;
  if ( a2 != -1 )
    v11 = a2;
  v33 = v11;
  if ( a4 < 0 )
  {
    v8 = -a4;
    v9 = 1;
    v12 = 0;
  }
  else
  {
    v12 = 1;
    if ( a4 > 15 )
    {
      v8 = a4 - 16;
      v9 = 1;
      v12 = 2;
    }
  }
  if ( (unsigned int)(a5 - 1) > 8 || (unsigned int)(v8 - 8) > 7 || a3 != 8 || v11 > 9 || a6 > 4 || v8 == 8 && v9 )
    return -2;
  v13 = 9;
  if ( v8 != 8 )
    v13 = v8;
  v14 = (_DWORD *)v10(a1[10], 1, 5828);
  v15 = v14;
  if ( !v14 )
    return -4;
  a1[7] = v14;
  v14[6] = v12;
  v14[12] = v13;
  *v14 = a1;
  v14[1] = 42;
  v14[7] = 0;
  v14[11] = 1 << v13;
  v16 = 1 << v13;
  v14[13] = v16 - 1;
  v17 = 1 << (a5 + 7);
  v15[20] = a5 + 7;
  v15[19] = v17;
  v15[21] = v17 - 1;
  v15[22] = (a5 + 9) / 3u;
  v15[14] = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], v16, 2);
  v15[16] = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v15[11], 2);
  v18 = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v15[19], 2);
  v15[1456] = 0;
  v15[17] = v18;
  v15[1447] = 1 << (a5 + 6);
  v19 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1 << (a5 + 6), 4);
  v20 = v15[1447];
  v15[2] = v19;
  v15[3] = 4 * v20;
  if ( !v15[14] || !v15[16] || !v15[17] || !v19 )
  {
    v15[1] = 666;
    v21 = -4;
    a1[6] = "insufficient memory";
    deflateEnd(a1);
    return v21;
  }
  *((_BYTE *)v15 + 36) = 8;
  v15[1446] = 3 * v20 + v19;
  v15[1449] = v19 + (v20 & 0xFFFFFFFE);
  v15[33] = v33;
  v15[34] = a6;
  v21 = deflateResetKeep(a1);
  if ( v21 )
    return v21;
  v23 = (_DWORD *)a1[7];
  v24 = (_WORD *)v23[17];
  v23[15] = 2 * v23[11];
  v25 = v23[19] + 0x7FFFFFFF;
  v24[v25] = 0;
  memset(v24, 0, 2 * v25);
  v26 = v23[33];
  v23[27] = 0;
  v23[23] = 0;
  v23[29] = 0;
  v26 *= 12;
  v23[30] = 2;
  v27 = (char *)configuration_table + v26;
  v28 = *(unsigned __int16 *)((char *)word_511FC2 + v26);
  v29 = *(unsigned __int16 *)((char *)configuration_table + v26);
  v23[1453] = 0;
  v23[24] = 2;
  v23[35] = v29;
  v30 = *((unsigned __int16 *)v27 + 2);
  v23[32] = v28;
  v23[36] = v30;
  v31 = *((unsigned __int16 *)v27 + 3);
  v23[26] = 0;
  v23[31] = v31;
  result = 0;
  v23[18] = 0;
  return result;
}
// 511FC0: using guessed type __int16 configuration_table[];
// 511FC2: using guessed type __int16 word_511FC2[];

//----- (00429690) --------------------------------------------------------
int __cdecl deflateInit_(_DWORD *a1, unsigned int a2, _BYTE *a3, int a4)
{
  unsigned int v4; // edi
  void *(__cdecl *v5)(size_t, int, int); // eax
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edi
  int result; // eax
  _DWORD *v13; // ebx
  _WORD *v14; // edx
  int v15; // eax
  int v16; // eax
  char *v17; // edx
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // ebx

  v4 = a2;
  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v5 = (void *(__cdecl *)(size_t, int, int))a1[8];
  a1[6] = 0;
  if ( v5 )
  {
    if ( a1[9] )
      goto LABEL_7;
  }
  else
  {
    v22 = a1[9];
    a1[8] = zcalloc;
    v5 = zcalloc;
    a1[10] = 0;
    if ( v22 )
      goto LABEL_7;
  }
  a1[9] = zcfree;
LABEL_7:
  if ( a2 != -1 )
  {
    if ( a2 <= 9 )
      goto LABEL_9;
    return -2;
  }
  v4 = 6;
LABEL_9:
  v6 = (_DWORD *)v5(a1[10], 1, 5828);
  v7 = v6;
  if ( !v6 )
    return -4;
  a1[7] = v6;
  *v6 = a1;
  v6[1] = 42;
  v6[6] = 1;
  v6[7] = 0;
  v6[12] = 15;
  v6[11] = 0x8000;
  v6[13] = 0x7FFF;
  v6[20] = 15;
  v6[19] = 0x8000;
  v6[21] = 0x7FFF;
  v6[22] = 5;
  v6[14] = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 0x8000, 2);
  v7[16] = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v7[11], 2);
  v8 = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], v7[19], 2);
  v7[1456] = 0;
  v7[17] = v8;
  v7[1447] = 0x4000;
  v9 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 0x4000, 4);
  v10 = v7[1447];
  v7[2] = v9;
  v7[3] = 4 * v10;
  if ( !v7[14] || !v7[16] || !v7[17] || !v9 )
  {
    v7[1] = 666;
    v11 = -4;
    a1[6] = "insufficient memory";
    deflateEnd(a1);
    return v11;
  }
  v7[33] = v4;
  *((_BYTE *)v7 + 36) = 8;
  v7[34] = 0;
  v7[1449] = v9 + (v10 & 0xFFFFFFFE);
  v7[1446] = 3 * v10 + v9;
  v11 = deflateResetKeep(a1);
  if ( v11 )
    return v11;
  v13 = (_DWORD *)a1[7];
  v14 = (_WORD *)v13[17];
  v13[15] = 2 * v13[11];
  v15 = v13[19] + 0x7FFFFFFF;
  v14[v15] = 0;
  memset(v14, 0, 2 * v15);
  v16 = v13[33];
  v13[27] = 0;
  v13[23] = 0;
  v13[29] = 0;
  v16 *= 12;
  v13[30] = 2;
  v17 = (char *)configuration_table + v16;
  v18 = *(unsigned __int16 *)((char *)word_511FC2 + v16);
  v19 = *(unsigned __int16 *)((char *)configuration_table + v16);
  v13[1453] = 0;
  v13[24] = 2;
  v13[35] = v19;
  v20 = *((unsigned __int16 *)v17 + 2);
  v13[32] = v18;
  v13[36] = v20;
  v21 = *((unsigned __int16 *)v17 + 3);
  v13[26] = 0;
  v13[31] = v21;
  result = 0;
  v13[18] = 0;
  return result;
}
// 511FC0: using guessed type __int16 configuration_table[];
// 511FC2: using guessed type __int16 word_511FC2[];

//----- (004299A0) --------------------------------------------------------
int __cdecl deflateParams(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edi
  int v4; // ebx
  int v5; // edx
  bool v6; // bp
  bool v7; // al
  int v8; // eax
  int v9; // edx
  int v10; // eax
  _WORD *v11; // ebp
  size_t Size; // eax
  __int16 *v13; // edx
  int v14; // ecx
  int v15; // eax
  unsigned int v17; // ecx
  char *v18; // esi
  unsigned int v19; // edx
  int v20; // esi
  unsigned int v21; // eax
  unsigned int v22; // edx
  int v23; // [esp+18h] [ebp-24h]

  v3 = a2;
  if ( !a1 )
    return -2;
  if ( !a1[8] )
    return -2;
  if ( !a1[9] )
    return -2;
  v4 = a1[7];
  if ( !v4 || a1 != *(_DWORD **)v4 )
    return -2;
  v5 = *(_DWORD *)(v4 + 4);
  v6 = 1;
  if ( (unsigned int)(v5 - 91) <= 0x16 )
    v6 = ((0x401001u >> (v5 - 91)) & 1) == 0;
  v7 = v5 != 666 && v6 && v5 != 69 && ((v5 - 57) & 0xFFFFFFEF) != 0 && v5 != 42;
  if ( v7 )
    return -2;
  if ( a2 == -1 )
    v3 = 6;
  else
    v7 = a2 > 9;
  if ( a3 > 4 || v7 )
    return -2;
  v8 = *(_DWORD *)(v4 + 132);
  if ( *(_DWORD *)(v4 + 136) == a3 && funcs_427A76[3 * v3] == funcs_427A76[3 * v8] || !*(_DWORD *)(v4 + 5824) )
    goto LABEL_15;
  if ( deflate_part_3(a1, 5) == -2 )
    return -2;
  if ( !a1[4] )
    return -5;
  v8 = *(_DWORD *)(v4 + 132);
LABEL_15:
  if ( v3 != v8 )
  {
    if ( !v8 )
    {
      v9 = *(_DWORD *)(v4 + 5808);
      if ( v9 )
      {
        v10 = *(_DWORD *)(v4 + 76);
        v11 = *(_WORD **)(v4 + 68);
        v23 = 2 * (v10 + 0x7FFFFFFF);
        if ( v9 == 1 )
        {
          v17 = *(_DWORD *)(v4 + 44);
          v18 = (char *)v11 + 2 * (v10 + 0x7FFFFFFF) - 2 * v10 + 2;
          do
          {
            while ( 1 )
            {
              v19 = *(unsigned __int16 *)&v18[2 * v10 - 2];
              if ( v17 > v19 )
                break;
              *(_WORD *)&v18[2 * v10-- - 2] = v19 - v17;
              if ( !v10 )
                goto LABEL_33;
            }
            *(_WORD *)&v18[2 * v10-- - 2] = 0;
          }
          while ( v10 );
LABEL_33:
          v20 = *(_DWORD *)(v4 + 64);
          v21 = v17;
          do
          {
            while ( 1 )
            {
              v22 = *(unsigned __int16 *)(v20 + 2 * v21 - 2);
              if ( v17 > v22 )
                break;
              *(_WORD *)(v20 + 2 * v21-- - 2) = v22 - v17;
              if ( !v21 )
                goto LABEL_36;
            }
            *(_WORD *)(v20 + 2 * v21-- - 2) = 0;
          }
          while ( v21 );
LABEL_36:
          Size = v23;
        }
        else
        {
          v11[v10 - 1] = 0;
          Size = 2 * (v10 + 0x7FFFFFFF);
        }
        memset(v11, 0, Size);
        *(_DWORD *)(v4 + 5808) = 0;
      }
    }
    *(_DWORD *)(v4 + 132) = v3;
    v13 = &configuration_table[6 * v3];
    v14 = (unsigned __int16)word_511FC2[6 * v3];
    *(_DWORD *)(v4 + 140) = (unsigned __int16)*v13;
    v15 = (unsigned __int16)v13[2];
    *(_DWORD *)(v4 + 128) = v14;
    *(_DWORD *)(v4 + 144) = v15;
    *(_DWORD *)(v4 + 124) = (unsigned __int16)v13[3];
  }
  *(_DWORD *)(v4 + 136) = a3;
  return 0;
}
// 511FC0: using guessed type __int16 configuration_table[];
// 511FC2: using guessed type __int16 word_511FC2[];
// 511FC8: using guessed type int (__cdecl *funcs_427A76[3])(int, int);

//----- (00429C00) --------------------------------------------------------
int __cdecl deflatePending(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ebx
  int result; // eax
  int v5; // edx
  bool v6; // si

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v3 = (_DWORD *)a1[7];
  result = -2;
  if ( !v3 || a1 != (_DWORD *)*v3 )
    return result;
  v5 = v3[1];
  v6 = 1;
  if ( (unsigned int)(v5 - 91) <= 0x16 )
    v6 = ((0x401001u >> (v5 - 91)) & 1) == 0;
  if ( ((v5 - 57) & 0xFFFFFFEF) != 0 && v5 != 666 && v5 != 69 && v5 != 42 && v6 )
    return -2;
  if ( a2 )
    *a2 = v3[5];
  result = 0;
  if ( a3 )
    *a3 = v3[1455];
  return result;
}

//----- (00429CC0) --------------------------------------------------------
int __cdecl deflatePrime(_DWORD *a1, int a2, int a3)
{
  int v4; // ebx
  int result; // eax
  int v6; // eax
  bool v7; // dl
  int v8; // ebp
  __int16 v9; // ax
  int v10; // esi

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v4 = a1[7];
  result = -2;
  if ( !v4 || a1 != *(_DWORD **)v4 )
    return result;
  v6 = *(_DWORD *)(v4 + 4);
  v7 = 1;
  if ( (unsigned int)(v6 - 91) <= 0x16 )
    v7 = ((0x401001u >> (v6 - 91)) & 1) == 0;
  if ( v6 != 42 && v6 != 69 && v6 != 666 && ((v6 - 57) & 0xFFFFFFEF) != 0 && v7 )
    return -2;
  if ( *(_DWORD *)(v4 + 5796) < (unsigned int)(*(_DWORD *)(v4 + 16) + 2) )
    return -5;
  do
  {
    v8 = *(_DWORD *)(v4 + 5820);
    v9 = *(_WORD *)(v4 + 5816);
    v10 = 16 - v8;
    if ( a2 < 16 - v8 )
    {
      *(_DWORD *)(v4 + 5820) = v8 + a2;
      *(_WORD *)(v4 + 5816) = ((a3 & ((1 << a2) - 1)) << v8) | v9;
      _tr_flush_bits(v4);
      return 0;
    }
    *(_DWORD *)(v4 + 5820) = 16;
    *(_WORD *)(v4 + 5816) = ((a3 & ((1 << v10) - 1)) << v8) | v9;
    _tr_flush_bits(v4);
    a3 >>= v10;
    a2 -= v10;
  }
  while ( a2 );
  return 0;
}

//----- (00429E20) --------------------------------------------------------
int __cdecl deflateReset(_DWORD *a1)
{
  int v1; // esi
  int result; // eax
  int v3; // edx
  bool v4; // di
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  _DWORD *v9; // ebx
  _WORD *v10; // edx
  int v11; // eax
  int v12; // eax
  char *v13; // edx
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v1 = a1[7];
  result = -2;
  if ( v1 && a1 == *(_DWORD **)v1 )
  {
    v3 = *(_DWORD *)(v1 + 4);
    v4 = 1;
    if ( (unsigned int)(v3 - 91) <= 0x16 )
      v4 = ((0x401001u >> (v3 - 91)) & 1) == 0;
    if ( v3 == 666 || v3 == 69 || v3 == 42 || ((v3 - 57) & 0xFFFFFFEF) == 0 || !v4 )
    {
      v5 = *(_DWORD *)(v1 + 8);
      a1[5] = 0;
      a1[2] = 0;
      a1[6] = 0;
      a1[11] = 2;
      *(_DWORD *)(v1 + 16) = v5;
      v6 = *(_DWORD *)(v1 + 24);
      *(_DWORD *)(v1 + 20) = 0;
      if ( v6 < 0 )
      {
        *(_DWORD *)(v1 + 24) = -v6;
        if ( v6 != -2 )
          goto LABEL_19;
      }
      else if ( v6 != 2 )
      {
        if ( !v6 )
        {
          v7 = 113;
LABEL_14:
          *(_DWORD *)(v1 + 4) = v7;
          v8 = adler32(0, 0, 0);
LABEL_15:
          a1[12] = v8;
          *(_DWORD *)(v1 + 40) = 0;
          _tr_init(v1);
          v9 = (_DWORD *)a1[7];
          v10 = (_WORD *)v9[17];
          v9[15] = 2 * v9[11];
          v11 = v9[19] + 0x7FFFFFFF;
          v10[v11] = 0;
          memset(v10, 0, 2 * v11);
          v12 = v9[33];
          v9[27] = 0;
          v9[23] = 0;
          v9[29] = 0;
          v12 *= 12;
          v9[30] = 2;
          v13 = (char *)configuration_table + v12;
          v14 = *(unsigned __int16 *)((char *)word_511FC2 + v12);
          v15 = *(unsigned __int16 *)((char *)configuration_table + v12);
          v9[1453] = 0;
          v9[24] = 2;
          v9[35] = v15;
          v16 = *((unsigned __int16 *)v13 + 2);
          v9[32] = v14;
          v9[36] = v16;
          v17 = *((unsigned __int16 *)v13 + 3);
          v9[26] = 0;
          v9[18] = 0;
          v9[31] = v17;
          return 0;
        }
LABEL_19:
        v7 = 42;
        goto LABEL_14;
      }
      *(_DWORD *)(v1 + 4) = 57;
      v8 = crc32(0, 0, 0);
      goto LABEL_15;
    }
    return -2;
  }
  return result;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);
// 511FC0: using guessed type __int16 configuration_table[];
// 511FC2: using guessed type __int16 word_511FC2[];

//----- (0042A040) --------------------------------------------------------
int __cdecl deflateResetKeep(_DWORD *a1)
{
  _DWORD *v1; // esi
  int result; // eax
  int v3; // edx
  bool v4; // di
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v1 = (_DWORD *)a1[7];
  result = -2;
  if ( v1 && a1 == (_DWORD *)*v1 )
  {
    v3 = v1[1];
    v4 = 1;
    if ( (unsigned int)(v3 - 91) <= 0x16 )
      v4 = ((0x401001u >> (v3 - 91)) & 1) == 0;
    if ( v3 == 666 || v3 == 69 || v3 == 42 || ((v3 - 57) & 0xFFFFFFEF) == 0 || !v4 )
    {
      v5 = v1[2];
      a1[5] = 0;
      a1[2] = 0;
      a1[6] = 0;
      a1[11] = 2;
      v1[4] = v5;
      v6 = v1[6];
      v1[5] = 0;
      if ( v6 < 0 )
      {
        v1[6] = -v6;
        if ( v6 != -2 )
          goto LABEL_19;
      }
      else if ( v6 != 2 )
      {
        if ( !v6 )
        {
          v7 = 113;
LABEL_14:
          v1[1] = v7;
          v8 = adler32(0, 0, 0);
LABEL_15:
          a1[12] = v8;
          v1[10] = 0;
          _tr_init((int)v1);
          return 0;
        }
LABEL_19:
        v7 = 42;
        goto LABEL_14;
      }
      v1[1] = 57;
      v8 = crc32(0, 0, 0);
      goto LABEL_15;
    }
    return -2;
  }
  return result;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);

//----- (0042A1A0) --------------------------------------------------------
int __cdecl deflateSetDictionary(int *a1, int a2, unsigned int a3)
{
  int v3; // ebx
  int *v4; // ebp
  int result; // eax
  int v6; // eax
  bool v7; // si
  int v8; // esi
  unsigned int v9; // eax
  unsigned int i; // ebx
  int v11; // edx
  int v12; // esi
  int v13; // eax
  _WORD *v14; // ecx
  int v15; // eax
  int v16; // eax
  _WORD *v17; // edx
  int v18; // eax
  int v19; // [esp+1Ch] [ebp-40h]
  int v20; // [esp+20h] [ebp-3Ch]
  int v21; // [esp+24h] [ebp-38h]
  int v22; // [esp+28h] [ebp-34h]
  int v23; // [esp+2Ch] [ebp-30h]
  int v24; // [esp+30h] [ebp-2Ch]
  int v25; // [esp+34h] [ebp-28h]
  int v26; // [esp+38h] [ebp-24h]
  int v27; // [esp+3Ch] [ebp-20h]

  v3 = a2;
  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v4 = (int *)a1[7];
  result = -2;
  if ( !v4 || a1 != (int *)*v4 )
    return result;
  v6 = v4[1];
  v7 = 1;
  if ( (unsigned int)(v6 - 91) <= 0x16 )
    v7 = ((0x401001u >> (v6 - 91)) & 1) == 0;
  if ( v6 != 666 && v6 != 69 && v6 != 42 && ((v6 - 57) & 0xFFFFFFEF) != 0 && v7 )
    return -2;
  if ( !a2 )
    return -2;
  v8 = v4[6];
  v25 = v8;
  if ( v8 == 2 )
    return -2;
  if ( v8 == 1 )
  {
    if ( v6 == 42 )
    {
      result = -2;
      if ( v4[29] )
        return result;
      a1[12] = adler32(a1[12], a2, a3);
      v9 = v4[11];
      v4[6] = 0;
      if ( a3 >= v9 )
        goto LABEL_17;
LABEL_28:
      v9 = a3;
      goto LABEL_18;
    }
    return -2;
  }
  if ( v4[29] )
    return -2;
  v4[6] = 0;
  v9 = v4[11];
  if ( v9 > a3 )
    goto LABEL_28;
  if ( !v8 )
  {
    v17 = (_WORD *)v4[17];
    v18 = v4[19] + 0x7FFFFFFF;
    v17[v18] = 0;
    memset(v17, 0, 2 * v18);
    v4[27] = 0;
    v9 = v4[11];
    v4[23] = 0;
    v4[1453] = 0;
  }
LABEL_17:
  v3 = a3 - v9 + a2;
LABEL_18:
  v26 = a1[1];
  v27 = *a1;
  a1[1] = v9;
  *a1 = v3;
  fill_window(v4);
  for ( i = v4[29]; i > 2; i = v4[29] )
  {
    v11 = v4[27];
    v12 = v4[16];
    v19 = v4[22];
    v24 = i + v11 - 2;
    v20 = v4[14];
    v21 = v4[21];
    v22 = v4[17];
    v23 = v4[13];
    v13 = v4[18];
    do
    {
      v13 = v21 & (*(unsigned __int8 *)(v20 + v11 + 2) ^ (v13 << v19));
      v4[18] = v13;
      v14 = (_WORD *)(v22 + 2 * v13);
      *(_WORD *)(v12 + 2 * (v11 & v23)) = *v14;
      *v14 = v11++;
    }
    while ( v11 != v24 );
    v4[27] = v11;
    v4[29] = 2;
    fill_window(v4);
  }
  v15 = v4[27];
  v4[1453] = i;
  v4[29] = 0;
  v16 = i + v15;
  v4[30] = 2;
  v4[27] = v16;
  v4[23] = v16;
  v4[24] = 2;
  v4[26] = 0;
  *a1 = v27;
  a1[1] = v26;
  v4[6] = v25;
  return 0;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);

//----- (0042A450) --------------------------------------------------------
int __cdecl deflateSetHeader(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebx
  int result; // eax
  int v4; // eax
  bool v5; // dl

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v2 = (_DWORD *)a1[7];
  result = -2;
  if ( v2 && a1 == (_DWORD *)*v2 )
  {
    v4 = v2[1];
    v5 = 1;
    if ( (unsigned int)(v4 - 91) <= 0x16 )
      v5 = ((0x401001u >> (v4 - 91)) & 1) == 0;
    if ( (((v4 - 57) & 0xFFFFFFEF) == 0 || v4 == 69 || v4 == 42 || v4 == 666 || !v5) && v2[6] == 2 )
    {
      v2[7] = a2;
      return 0;
    }
    return -2;
  }
  return result;
}

//----- (0042A4F0) --------------------------------------------------------
int __cdecl deflateTune(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // ebx
  int result; // eax
  int v7; // eax
  bool v8; // dl

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v5 = (_DWORD *)a1[7];
  result = -2;
  if ( v5 && a1 == (_DWORD *)*v5 )
  {
    v7 = v5[1];
    v8 = 1;
    if ( (unsigned int)(v7 - 91) <= 0x16 )
      v8 = ((0x401001u >> (v7 - 91)) & 1) == 0;
    if ( ((v7 - 57) & 0xFFFFFFEF) == 0 || v7 == 69 || v7 == 42 || v7 == 666 || !v8 )
    {
      v5[35] = a2;
      v5[32] = a3;
      v5[36] = a4;
      v5[31] = a5;
      return 0;
    }
    return -2;
  }
  return result;
}

//----- (0042A5B0) --------------------------------------------------------
int __cdecl deflate_fast(int a1, int a2)
{
  unsigned int v2; // esi
  __int16 v3; // bx
  unsigned __int8 v4; // al
  unsigned __int16 v5; // bx
  int v6; // eax
  int v7; // edi
  unsigned int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // esi
  int v14; // edx
  int v15; // eax
  _WORD *v16; // eax
  unsigned int v17; // edx
  unsigned int v18; // eax
  int v19; // edx
  _WORD *v20; // esi
  int v21; // ecx
  unsigned __int8 *v22; // edx
  int v23; // eax
  BOOL v24; // edi
  int v25; // eax
  int v26; // eax
  void *v27; // edx
  size_t v28; // ebx
  int v29; // esi
  int v30; // edi
  size_t Size; // ebx
  int v32; // eax
  size_t v33; // eax
  int result; // eax
  unsigned int v35; // eax
  unsigned int v36; // ebx
  int v37; // eax
  int v38; // edx
  int v39; // eax
  _WORD *v40; // ecx
  unsigned int v41; // edx
  int v42; // eax
  int v43; // eax
  void *v44; // ecx
  size_t v45; // edx
  int v46; // esi
  int v47; // edi
  size_t v48; // ebx
  int v49; // eax
  void *v50; // ecx
  size_t v51; // edx
  int v52; // esi
  int v53; // edi
  size_t v54; // ebx
  int v55; // eax
  size_t v56; // eax
  int v57; // eax
  size_t v58; // eax
  BOOL v59; // [esp+14h] [ebp-48h]
  unsigned int v60; // [esp+18h] [ebp-44h]
  int v61; // [esp+1Ch] [ebp-40h]
  int v62; // [esp+20h] [ebp-3Ch]
  unsigned int v63; // [esp+24h] [ebp-38h]
  int v64; // [esp+28h] [ebp-34h]
  int v65; // [esp+2Ch] [ebp-30h]
  int v66; // [esp+30h] [ebp-2Ch]
  int v67; // [esp+34h] [ebp-28h]

LABEL_1:
  v2 = *(_DWORD *)(a1 + 116);
  while ( 1 )
  {
    if ( v2 <= 0x105 )
    {
      fill_window((int *)a1);
      v35 = *(_DWORD *)(a1 + 116);
      if ( v35 <= 0x105 )
        break;
    }
    v11 = *(_DWORD *)(a1 + 108);
LABEL_10:
    v12 = *(_DWORD *)(a1 + 64);
    v13 = v11 & *(_DWORD *)(a1 + 52);
    v14 = *(_DWORD *)(a1 + 68);
    v15 = *(_DWORD *)(a1 + 84) & ((*(_DWORD *)(a1 + 72) << *(_DWORD *)(a1 + 88)) ^ *(unsigned __int8 *)(*(_DWORD *)(a1 + 56) + v11 + 2));
    *(_DWORD *)(a1 + 72) = v15;
    v16 = (_WORD *)(v14 + 2 * v15);
    v17 = (unsigned __int16)*v16;
    *(_WORD *)(v12 + 2 * v13) = v17;
    *v16 = v11;
    if ( v17 && v11 - v17 <= *(_DWORD *)(a1 + 44) - 262 )
    {
      v18 = longest_match((_DWORD *)a1, v17);
      v11 = *(_DWORD *)(a1 + 108);
      *(_DWORD *)(a1 + 96) = v18;
      goto LABEL_13;
    }
LABEL_12:
    v18 = *(_DWORD *)(a1 + 96);
LABEL_13:
    v19 = *(_DWORD *)(a1 + 5792);
    v20 = (_WORD *)(*(_DWORD *)(a1 + 5796) + 2 * v19);
    v21 = v19 + 1;
    v22 = (unsigned __int8 *)(*(_DWORD *)(a1 + 5784) + v19);
    if ( v18 > 2 )
    {
      v3 = v11 - *(_WORD *)(a1 + 112);
      v4 = v18 - 3;
      *v20 = v3;
      v5 = v3 - 1;
      *(_DWORD *)(a1 + 5792) = v21;
      *v22 = v4;
      ++*(_WORD *)(a1 + 4 * (unsigned __int8)_length_code[v4] + 1176);
      if ( v5 > 0xFFu )
        v6 = (unsigned __int8)byte_511CA0[v5 >> 7];
      else
        v6 = (unsigned __int8)_dist_code[v5];
      ++*(_WORD *)(a1 + 4 * v6 + 2440);
      v64 = *(_DWORD *)(a1 + 108);
      v7 = *(_DWORD *)(a1 + 56);
      v61 = *(_DWORD *)(a1 + 88);
      v59 = *(_DWORD *)(a1 + 5788) - 1 == *(_DWORD *)(a1 + 5792);
      v8 = *(_DWORD *)(a1 + 96);
      v62 = *(_DWORD *)(a1 + 84);
      v2 = *(_DWORD *)(a1 + 116) - v8;
      v63 = v8;
      *(_DWORD *)(a1 + 116) = v2;
      if ( v8 <= *(_DWORD *)(a1 + 128) && v2 > 2 )
      {
        v36 = v8 - 1;
        v37 = *(_DWORD *)(a1 + 68);
        *(_DWORD *)(a1 + 96) = v36;
        v65 = v37;
        v38 = v64 + 1;
        v60 = v36;
        v66 = *(_DWORD *)(a1 + 64);
        v67 = *(_DWORD *)(a1 + 52);
        v39 = *(_DWORD *)(a1 + 72);
        do
        {
          *(_DWORD *)(a1 + 108) = v38;
          --v60;
          v39 = v62 & (*(unsigned __int8 *)(v7 + v38 + 2) ^ (v39 << v61));
          *(_DWORD *)(a1 + 72) = v39;
          v40 = (_WORD *)(v65 + 2 * v39);
          *(_WORD *)(v66 + 2 * (v38 & v67)) = *v40;
          *v40 = v38++;
          *(_DWORD *)(a1 + 96) = v60;
        }
        while ( v60 );
        v9 = v64 + v63;
        *(_DWORD *)(a1 + 108) = v64 + v63;
      }
      else
      {
        v9 = v64 + v8;
        *(_DWORD *)(a1 + 96) = 0;
        *(_DWORD *)(a1 + 108) = v64 + v8;
        v10 = *(unsigned __int8 *)(v7 + v64 + v8);
        *(_DWORD *)(a1 + 72) = v10;
        *(_DWORD *)(a1 + 72) = v62 & ((v10 << v61) ^ *(unsigned __int8 *)(v7 + v64 + v63 + 1));
      }
      if ( v59 )
      {
LABEL_15:
        v26 = *(_DWORD *)(a1 + 92);
        v27 = 0;
        v28 = v9 - v26;
        if ( v26 >= 0 )
          v27 = (void *)(*(_DWORD *)(a1 + 56) + v26);
        _tr_flush_block(a1, v27, v28, 0);
        v29 = *(_DWORD *)a1;
        v30 = *(_DWORD *)(*(_DWORD *)a1 + 28);
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 108);
        _tr_flush_bits(v30);
        Size = *(_DWORD *)(v30 + 20);
        if ( *(_DWORD *)(v29 + 16) <= Size )
          Size = *(_DWORD *)(v29 + 16);
        if ( Size )
        {
          memcpy(*(void **)(v29 + 12), *(const void **)(v30 + 16), Size);
          v32 = *(_DWORD *)(v30 + 20);
          *(_DWORD *)(v29 + 12) += Size;
          *(_DWORD *)(v30 + 16) += Size;
          *(_DWORD *)(v29 + 20) += Size;
          *(_DWORD *)(v29 + 16) -= Size;
          v33 = v32 - Size;
          *(_DWORD *)(v30 + 20) = v33;
          if ( !v33 )
            *(_DWORD *)(v30 + 16) = *(_DWORD *)(v30 + 8);
        }
        if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
          return 0;
        goto LABEL_1;
      }
    }
    else
    {
      v23 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 56) + v11);
      *v20 = 0;
      *(_DWORD *)(a1 + 5792) = v21;
      *v22 = v23;
      ++*(_WORD *)(a1 + 4 * v23 + 148);
      v24 = *(_DWORD *)(a1 + 5788) - 1 == *(_DWORD *)(a1 + 5792);
      v2 = *(_DWORD *)(a1 + 116) - 1;
      v25 = *(_DWORD *)(a1 + 108);
      *(_DWORD *)(a1 + 116) = v2;
      v9 = v25 + 1;
      *(_DWORD *)(a1 + 108) = v25 + 1;
      if ( v24 )
        goto LABEL_15;
    }
  }
  if ( !a2 )
    return 0;
  if ( v35 )
  {
    v11 = *(_DWORD *)(a1 + 108);
    if ( v35 <= 2 )
      goto LABEL_12;
    goto LABEL_10;
  }
  v41 = *(_DWORD *)(a1 + 108);
  v42 = 2;
  if ( v41 <= 2 )
    v42 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a1 + 5812) = v42;
  if ( a2 == 4 )
  {
    v49 = *(_DWORD *)(a1 + 92);
    v50 = 0;
    v51 = v41 - v49;
    if ( v49 >= 0 )
      v50 = (void *)(*(_DWORD *)(a1 + 56) + v49);
    _tr_flush_block(a1, v50, v51, 1);
    v52 = *(_DWORD *)a1;
    v53 = *(_DWORD *)(*(_DWORD *)a1 + 28);
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 108);
    _tr_flush_bits(v53);
    v54 = *(_DWORD *)(v53 + 20);
    if ( *(_DWORD *)(v52 + 16) <= v54 )
      v54 = *(_DWORD *)(v52 + 16);
    if ( v54 )
    {
      memcpy(*(void **)(v52 + 12), *(const void **)(v53 + 16), v54);
      v55 = *(_DWORD *)(v53 + 20);
      *(_DWORD *)(v52 + 12) += v54;
      *(_DWORD *)(v53 + 16) += v54;
      *(_DWORD *)(v52 + 20) += v54;
      *(_DWORD *)(v52 + 16) -= v54;
      v56 = v55 - v54;
      *(_DWORD *)(v53 + 20) = v56;
      if ( !v56 )
        *(_DWORD *)(v53 + 16) = *(_DWORD *)(v53 + 8);
    }
    return (*(_DWORD *)(*(_DWORD *)a1 + 16) != 0) + 2;
  }
  else
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 5792) )
    {
      v43 = *(_DWORD *)(a1 + 92);
      v44 = 0;
      v45 = v41 - v43;
      if ( v43 >= 0 )
        v44 = (void *)(*(_DWORD *)(a1 + 56) + v43);
      _tr_flush_block(a1, v44, v45, 0);
      v46 = *(_DWORD *)a1;
      v47 = *(_DWORD *)(*(_DWORD *)a1 + 28);
      *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 108);
      _tr_flush_bits(v47);
      v48 = *(_DWORD *)(v47 + 20);
      if ( *(_DWORD *)(v46 + 16) <= v48 )
        v48 = *(_DWORD *)(v46 + 16);
      if ( v48 )
      {
        memcpy(*(void **)(v46 + 12), *(const void **)(v47 + 16), v48);
        v57 = *(_DWORD *)(v47 + 20);
        *(_DWORD *)(v46 + 12) += v48;
        *(_DWORD *)(v47 + 16) += v48;
        *(_DWORD *)(v46 + 20) += v48;
        *(_DWORD *)(v46 + 16) -= v48;
        v58 = v57 - v48;
        *(_DWORD *)(v47 + 20) = v58;
        if ( !v58 )
          *(_DWORD *)(v47 + 16) = *(_DWORD *)(v47 + 8);
      }
      return *(_DWORD *)(*(_DWORD *)a1 + 16) != 0;
    }
  }
  return result;
}

//----- (0042AA70) --------------------------------------------------------
int __cdecl deflate_slow(int *a1, int a2)
{
  unsigned int v2; // esi
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // edi
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  _WORD *v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int result; // eax
  int v18; // eax
  unsigned int v19; // eax
  int v20; // edx
  void *v21; // ecx
  int v22; // esi
  int v23; // edi
  size_t Size; // ebx
  int v25; // eax
  size_t v26; // eax
  int v27; // edx
  int v28; // eax
  __int16 v29; // bx
  __int16 v30; // si
  unsigned __int16 v31; // bx
  int v32; // ecx
  int v33; // eax
  int v34; // eax
  int v35; // esi
  int v36; // edx
  int v37; // eax
  int v38; // ecx
  unsigned int v39; // eax
  int v40; // edi
  int v41; // esi
  int v42; // ecx
  _WORD *v43; // ecx
  int v44; // eax
  int v45; // edx
  void *v46; // ecx
  size_t v47; // eax
  int v48; // esi
  int v49; // edi
  size_t v50; // ebx
  int v51; // eax
  size_t v52; // eax
  unsigned int v53; // edx
  int v54; // eax
  int v55; // eax
  void *v56; // ecx
  size_t v57; // edx
  int v58; // esi
  int v59; // edi
  size_t v60; // ebx
  int v61; // eax
  size_t v62; // eax
  int v63; // eax
  int v64; // edx
  int v65; // ecx
  int v66; // eax
  void *v67; // ecx
  size_t v68; // edx
  int v69; // esi
  int v70; // edi
  size_t v71; // ebx
  int v72; // eax
  size_t v73; // eax
  unsigned int v74; // [esp+18h] [ebp-34h]
  int v75; // [esp+1Ch] [ebp-30h]
  int v76; // [esp+20h] [ebp-2Ch]
  int v77; // [esp+24h] [ebp-28h]
  int v78; // [esp+28h] [ebp-24h]
  unsigned int v79; // [esp+2Ch] [ebp-20h]

LABEL_1:
  v2 = a1[29];
LABEL_2:
  if ( v2 > 0x105 )
    goto LABEL_3;
  while ( 1 )
  {
    fill_window(a1);
    v19 = a1[29];
    if ( v19 > 0x105 )
    {
LABEL_3:
      v3 = a1[27];
      v4 = a1[24];
      v5 = a1[28];
      goto LABEL_4;
    }
    if ( !a2 )
      return 0;
    if ( !v19 )
      break;
    v3 = a1[27];
    v4 = a1[24];
    v5 = a1[28];
    if ( v19 > 2 )
    {
LABEL_4:
      v6 = a1[13];
      v7 = a1[17];
      v8 = a1[21] & ((a1[18] << a1[22]) ^ *(unsigned __int8 *)(a1[14] + v3 + 2));
      a1[18] = v8;
      v9 = (_WORD *)(v7 + 2 * v8);
      v10 = (unsigned __int16)*v9;
      *(_WORD *)(a1[16] + 2 * (v3 & v6)) = v10;
      *v9 = v3;
      a1[30] = v4;
      a1[25] = v5;
      a1[24] = 2;
      if ( v10 && a1[32] > v4 )
      {
        v11 = 2;
        if ( v3 - v10 <= a1[11] - 262 )
        {
          v11 = longest_match(a1, v10);
          a1[24] = v11;
          if ( v11 > 5 )
          {
            v4 = a1[30];
            v3 = a1[27];
            goto LABEL_7;
          }
          v3 = a1[27];
          v4 = a1[30];
          if ( a1[34] == 1 || v11 == 3 && (unsigned int)(v3 - a1[28]) > 0x1000 )
          {
            a1[24] = 2;
            if ( v4 > 2 )
              goto LABEL_32;
            goto LABEL_9;
          }
        }
      }
      else
      {
        v11 = 2;
      }
    }
    else
    {
      a1[30] = v4;
      v11 = 2;
      a1[25] = v5;
      a1[24] = 2;
    }
LABEL_7:
    if ( v4 > 2 && v4 >= v11 )
    {
LABEL_32:
      v27 = a1[1448];
      v28 = v3 + a1[29] - 3;
      v29 = v3 - *((_WORD *)a1 + 50);
      v74 = v28;
      LOBYTE(v28) = v4 - 3;
      v30 = v29 - 1;
      v31 = v29 - 2;
      *(_WORD *)(a1[1449] + 2 * v27) = v30;
      v32 = a1[1446];
      a1[1448] = v27 + 1;
      *(_BYTE *)(v32 + v27) = v28;
      ++LOWORD(a1[(unsigned __int8)_length_code[(unsigned __int8)v28] + 294]);
      if ( v31 > 0xFFu )
        v33 = (unsigned __int8)byte_511CA0[v31 >> 7];
      else
        v33 = (unsigned __int8)_dist_code[v31];
      ++LOWORD(a1[v33 + 610]);
      v75 = a1[1448];
      v76 = a1[1447] - 1;
      v34 = a1[30];
      v35 = a1[29] + 1 - v34;
      v36 = v34 - 2;
      v77 = v34;
      v37 = a1[27];
      a1[29] = v35;
      v38 = v37;
      v78 = v37;
      v39 = v37 + 1;
      a1[30] = v36;
      v79 = v35;
      a1[27] = v39;
      if ( v39 > v74 )
        goto LABEL_37;
      while ( 1 )
      {
        v40 = a1[13];
        v41 = a1[17];
        v42 = a1[21] & (*(unsigned __int8 *)(a1[14] + v38 + 3) ^ (a1[18] << a1[22]));
        a1[18] = v42;
        --v36;
        v43 = (_WORD *)(v41 + 2 * v42);
        *(_WORD *)(a1[16] + 2 * (v39 & v40)) = *v43;
        *v43 = v39;
        a1[30] = v36;
        if ( !v36 )
          break;
        while ( 1 )
        {
          v38 = v39++;
          a1[27] = v39;
          if ( v39 <= v74 )
            break;
LABEL_37:
          a1[30] = --v36;
          if ( !v36 )
            goto LABEL_38;
        }
      }
LABEL_38:
      a1[26] = 0;
      v2 = v79;
      a1[24] = 2;
      v44 = v77 + v78 - 1;
      a1[27] = v44;
      if ( v75 != v76 )
        goto LABEL_2;
      v45 = a1[23];
      v46 = 0;
      v47 = v44 - v45;
      if ( v45 >= 0 )
        v46 = (void *)(a1[14] + v45);
      _tr_flush_block((int)a1, v46, v47, 0);
      v48 = *a1;
      v49 = *(_DWORD *)(*a1 + 28);
      a1[23] = a1[27];
      _tr_flush_bits(v49);
      v50 = *(_DWORD *)(v49 + 20);
      if ( *(_DWORD *)(v48 + 16) <= v50 )
        v50 = *(_DWORD *)(v48 + 16);
      if ( v50 )
      {
        memcpy(*(void **)(v48 + 12), *(const void **)(v49 + 16), v50);
        v51 = *(_DWORD *)(v49 + 20);
        *(_DWORD *)(v48 + 12) += v50;
        *(_DWORD *)(v49 + 16) += v50;
        *(_DWORD *)(v48 + 20) += v50;
        *(_DWORD *)(v48 + 16) -= v50;
        v52 = v51 - v50;
        *(_DWORD *)(v49 + 20) = v52;
        if ( !v52 )
          *(_DWORD *)(v49 + 16) = *(_DWORD *)(v49 + 8);
      }
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
      goto LABEL_1;
    }
LABEL_9:
    if ( a1[26] )
    {
      v12 = a1[1448];
      v13 = *(unsigned __int8 *)(a1[14] + v3 - 1);
      *(_WORD *)(a1[1449] + 2 * v12) = 0;
      v14 = a1[1446];
      a1[1448] = v12 + 1;
      *(_BYTE *)(v14 + v12) = v13;
      ++LOWORD(a1[v13 + 37]);
      if ( a1[1448] == a1[1447] - 1 )
      {
        v20 = a1[23];
        v21 = 0;
        if ( v20 >= 0 )
          v21 = (void *)(a1[14] + v20);
        _tr_flush_block((int)a1, v21, a1[27] - v20, 0);
        v22 = *a1;
        v23 = *(_DWORD *)(*a1 + 28);
        a1[23] = a1[27];
        _tr_flush_bits(v23);
        Size = *(_DWORD *)(v23 + 20);
        if ( *(_DWORD *)(v22 + 16) <= Size )
          Size = *(_DWORD *)(v22 + 16);
        if ( Size )
        {
          memcpy(*(void **)(v22 + 12), *(const void **)(v23 + 16), Size);
          v25 = *(_DWORD *)(v23 + 20);
          *(_DWORD *)(v22 + 12) += Size;
          *(_DWORD *)(v23 + 16) += Size;
          *(_DWORD *)(v22 + 20) += Size;
          *(_DWORD *)(v22 + 16) -= Size;
          v26 = v25 - Size;
          *(_DWORD *)(v23 + 20) = v26;
          if ( !v26 )
            *(_DWORD *)(v23 + 16) = *(_DWORD *)(v23 + 8);
        }
      }
      v15 = a1[29];
      ++a1[27];
      v2 = v15 - 1;
      v16 = *a1;
      a1[29] = v2;
      if ( !*(_DWORD *)(v16 + 16) )
        return 0;
      goto LABEL_2;
    }
    v18 = a1[29];
    a1[26] = 1;
    a1[27] = v3 + 1;
    a1[29] = v18 - 1;
    if ( (unsigned int)(v18 - 1) > 0x105 )
      goto LABEL_3;
  }
  v53 = a1[27];
  if ( a1[26] )
  {
    v63 = *(unsigned __int8 *)(a1[14] + v53 - 1);
    v64 = a1[1448];
    *(_WORD *)(a1[1449] + 2 * v64) = 0;
    v65 = a1[1446];
    a1[1448] = v64 + 1;
    *(_BYTE *)(v65 + v64) = v63;
    ++LOWORD(a1[v63 + 37]);
    v53 = a1[27];
    a1[26] = 0;
  }
  v54 = 2;
  if ( v53 <= 2 )
    v54 = v53;
  a1[1453] = v54;
  if ( a2 == 4 )
  {
    v66 = a1[23];
    v67 = 0;
    v68 = v53 - v66;
    if ( v66 >= 0 )
      v67 = (void *)(a1[14] + v66);
    _tr_flush_block((int)a1, v67, v68, 1);
    v69 = *a1;
    v70 = *(_DWORD *)(*a1 + 28);
    a1[23] = a1[27];
    _tr_flush_bits(v70);
    v71 = *(_DWORD *)(v70 + 20);
    if ( *(_DWORD *)(v69 + 16) <= v71 )
      v71 = *(_DWORD *)(v69 + 16);
    if ( v71 )
    {
      memcpy(*(void **)(v69 + 12), *(const void **)(v70 + 16), v71);
      v72 = *(_DWORD *)(v70 + 20);
      *(_DWORD *)(v69 + 12) += v71;
      *(_DWORD *)(v70 + 16) += v71;
      *(_DWORD *)(v69 + 20) += v71;
      *(_DWORD *)(v69 + 16) -= v71;
      v73 = v72 - v71;
      *(_DWORD *)(v70 + 20) = v73;
      if ( !v73 )
        *(_DWORD *)(v70 + 16) = *(_DWORD *)(v70 + 8);
    }
    return (*(_DWORD *)(*a1 + 16) != 0) + 2;
  }
  else
  {
    result = 1;
    if ( a1[1448] )
    {
      v55 = a1[23];
      v56 = 0;
      v57 = v53 - v55;
      if ( v55 >= 0 )
        v56 = (void *)(a1[14] + v55);
      _tr_flush_block((int)a1, v56, v57, 0);
      v58 = *a1;
      v59 = *(_DWORD *)(*a1 + 28);
      a1[23] = a1[27];
      _tr_flush_bits(v59);
      v60 = *(_DWORD *)(v59 + 20);
      if ( *(_DWORD *)(v58 + 16) <= v60 )
        v60 = *(_DWORD *)(v58 + 16);
      if ( v60 )
      {
        memcpy(*(void **)(v58 + 12), *(const void **)(v59 + 16), v60);
        v61 = *(_DWORD *)(v59 + 20);
        *(_DWORD *)(v58 + 12) += v60;
        *(_DWORD *)(v59 + 16) += v60;
        *(_DWORD *)(v58 + 20) += v60;
        *(_DWORD *)(v58 + 16) -= v60;
        v62 = v61 - v60;
        *(_DWORD *)(v59 + 20) = v62;
        if ( !v62 )
          *(_DWORD *)(v59 + 16) = *(_DWORD *)(v59 + 8);
      }
      return *(_DWORD *)(*a1 + 16) != 0;
    }
  }
  return result;
}

//----- (0042B080) --------------------------------------------------------
int __cdecl deflate_stored(_DWORD *a1, int a2)
{
  unsigned int v2; // edx
  int v3; // edi
  unsigned int v4; // ebx
  unsigned int v5; // eax
  size_t v6; // ebx
  unsigned int v7; // edx
  char *v8; // eax
  int v9; // edi
  size_t Size; // esi
  int v11; // eax
  size_t v12; // eax
  size_t v13; // esi
  char *v14; // eax
  char *v15; // esi
  char *v16; // ecx
  int v17; // esi
  size_t v18; // ebx
  size_t v19; // edx
  int result; // eax
  int v21; // edi
  size_t v22; // esi
  size_t v23; // ebx
  char *v24; // eax
  int v25; // ecx
  unsigned int v26; // ecx
  unsigned int v27; // edx
  unsigned int v28; // ebx
  size_t v29; // edx
  size_t v30; // ecx
  const void *Src; // eax
  void *v32; // edx
  int v33; // eax
  size_t v34; // edx
  int v35; // eax
  size_t v36; // eax
  int v37; // ecx
  size_t v38; // eax
  int v39; // eax
  size_t v40; // ebx
  int v41; // esi
  int v42; // edi
  int v43; // ebp
  size_t v44; // ebx
  size_t v45; // edx
  char *v46; // eax
  unsigned int v47; // eax
  size_t v48; // eax
  _BYTE *v49; // ecx
  int v50; // eax
  size_t v51; // eax
  int v52; // eax
  int v53; // eax
  size_t v54; // eax
  size_t v55; // eax
  size_t v56; // eax
  unsigned int v57; // eax
  char *v58; // [esp+1Ch] [ebp-30h]
  void *v59; // [esp+1Ch] [ebp-30h]
  char *v60; // [esp+1Ch] [ebp-30h]
  void *v61; // [esp+1Ch] [ebp-30h]
  char *v62; // [esp+1Ch] [ebp-30h]
  _BYTE *v63; // [esp+1Ch] [ebp-30h]
  unsigned int v64; // [esp+20h] [ebp-2Ch]
  bool v65; // [esp+24h] [ebp-28h]
  char *v66; // [esp+24h] [ebp-28h]
  unsigned int v67; // [esp+28h] [ebp-24h]
  char *v68; // [esp+2Ch] [ebp-20h]

  v2 = a1[11];
  v3 = *a1;
  if ( a1[3] - 5 <= v2 )
    v2 = a1[3] - 5;
  v67 = v2;
  v68 = *(char **)(v3 + 4);
  v58 = v68;
  do
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(v3 + 16);
      v5 = (a1[1455] + 42) >> 3;
      if ( v4 < v5 )
        goto LABEL_52;
      v6 = v4 - v5;
      v7 = 0xFFFF;
      v64 = a1[27] - a1[23];
      v8 = &v58[v64];
      if ( (unsigned int)&v58[v64] <= 0xFFFE )
        v7 = (unsigned int)&v58[v64];
      if ( v7 <= v6 )
        v6 = v7;
      if ( v67 > v6 && (a2 != 4 && v6 == 0 || a2 == 0 || v8 != (char *)v6) )
      {
LABEL_52:
        v16 = v58;
        v17 = 0;
        v18 = v68 - v58;
        if ( v68 == v58 )
          goto LABEL_27;
        goto LABEL_53;
      }
      v65 = v8 == (char *)v6 && a2 == 4;
      _tr_stored_block((int)a1, 0, 0, v65);
      *(_WORD *)(a1[2] + a1[5] - 4) = v6;
      *(_WORD *)(a1[2] + a1[5] - 2) = ~(_WORD)v6;
      v9 = *a1;
      v59 = *(void **)(*a1 + 28);
      _tr_flush_bits((int)v59);
      Size = *((_DWORD *)v59 + 5);
      if ( *(_DWORD *)(v9 + 16) <= Size )
        Size = *(_DWORD *)(v9 + 16);
      if ( Size )
      {
        memcpy(*(void **)(v9 + 12), *((const void **)v59 + 4), Size);
        *(_DWORD *)(v9 + 12) += Size;
        v11 = *((_DWORD *)v59 + 5);
        *((_DWORD *)v59 + 4) += Size;
        *(_DWORD *)(v9 + 20) += Size;
        *(_DWORD *)(v9 + 16) -= Size;
        v12 = v11 - Size;
        *((_DWORD *)v59 + 5) = v12;
        if ( !v12 )
          *((_DWORD *)v59 + 4) = *((_DWORD *)v59 + 2);
      }
      v3 = *a1;
      if ( v64 )
      {
        v13 = v64;
        if ( v64 > v6 )
          v13 = v6;
        v6 -= v13;
        memcpy(*(void **)(v3 + 12), (const void *)(a1[14] + a1[23]), v13);
        v3 = *a1;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 20) += v13;
        a1[23] += v13;
      }
      v14 = *(char **)(v3 + 4);
      v58 = v14;
      if ( v6 )
        break;
      if ( v65 )
        goto LABEL_26;
    }
    v15 = *(char **)(v3 + 12);
    if ( v6 < (unsigned int)v14 )
    {
      v29 = v6;
      v30 = *(_DWORD *)(v3 + 4);
    }
    else
    {
      if ( !v14 )
        goto LABEL_25;
      v29 = *(_DWORD *)(v3 + 4);
      v30 = v29;
    }
    Src = *(const void **)v3;
    v61 = (void *)v29;
    *(_DWORD *)(v3 + 4) = v30 - v29;
    memcpy(v15, Src, v29);
    v32 = v61;
    v33 = *(_DWORD *)(*(_DWORD *)(v3 + 28) + 24);
    if ( v33 == 1 )
    {
      v39 = adler32(*(_DWORD *)(v3 + 48), v15, v61);
      v32 = v61;
      *(_DWORD *)(v3 + 48) = v39;
    }
    else if ( v33 == 2 )
    {
      v50 = crc32(*(_DWORD *)(v3 + 48), v15, (unsigned int)v61);
      v32 = v61;
      *(_DWORD *)(v3 + 48) = v50;
    }
    *(_DWORD *)v3 += v32;
    *(_DWORD *)(v3 + 8) += v32;
    v3 = *a1;
    v15 = *(char **)(*a1 + 12);
    v58 = *(char **)(*a1 + 4);
LABEL_25:
    *(_DWORD *)(v3 + 16) -= v6;
    *(_DWORD *)(v3 + 20) += v6;
    *(_DWORD *)(v3 + 12) = &v15[v6];
  }
  while ( !v65 );
LABEL_26:
  v16 = v58;
  v17 = 1;
  v18 = v68 - v58;
  if ( v68 == v58 )
  {
LABEL_27:
    v19 = a1[27];
    goto LABEL_28;
  }
LABEL_53:
  v34 = a1[11];
  v62 = (char *)a1[14];
  if ( v34 <= v18 )
  {
    a1[1452] = 2;
    memcpy(v62, (const void *)(*(_DWORD *)v3 - v34), v34);
    v19 = a1[11];
    a1[27] = v19;
    v36 = v19;
  }
  else
  {
    v35 = a1[27];
    if ( a1[15] - v35 <= v18 )
    {
      v66 = v16;
      v56 = v35 - v34;
      a1[27] = v56;
      memcpy(v62, &v62[v34], v56);
      v57 = a1[1452];
      v16 = v66;
      if ( v57 <= 1 )
        a1[1452] = v57 + 1;
      v3 = *a1;
      v62 = (char *)a1[14];
      v35 = a1[27];
    }
    memcpy(&v62[v35], (const void *)(v16 - v68 + *(_DWORD *)v3), v18);
    v36 = a1[11];
    v19 = v18 + a1[27];
    a1[27] = v19;
  }
  v37 = a1[1453];
  a1[23] = v19;
  v38 = v36 - v37;
  if ( v38 > v18 )
    v38 = v18;
  a1[1453] = v37 + v38;
LABEL_28:
  if ( a1[1456] < v19 )
    a1[1456] = v19;
  result = 3;
  if ( !v17 )
  {
    v21 = *a1;
    v22 = *(_DWORD *)(*a1 + 4);
    if ( (a2 & 0xFFFFFFFB) != 0 && !v22 )
    {
      result = 1;
      if ( v19 != a1[23] )
        goto LABEL_76;
    }
    else
    {
      v23 = a1[15] + ~v19;
      if ( v23 < v22 )
      {
        v24 = (char *)a1[23];
        v25 = a1[11];
        v60 = v24;
        if ( (int)v24 < v25 )
        {
          if ( !v23 )
            goto LABEL_36;
          v49 = (_BYTE *)(v19 + a1[14]);
LABEL_79:
          v51 = v22;
          v22 = v23;
          v48 = v51 - v23;
LABEL_80:
          *(_DWORD *)(v21 + 4) = v48;
          v63 = v49;
          memcpy(v49, *(const void **)v21, v23);
          v52 = *(_DWORD *)(*(_DWORD *)(v21 + 28) + 24);
          if ( v52 == 1 )
          {
            *(_DWORD *)(v21 + 48) = adler32(*(_DWORD *)(v21 + 48), v63, v23);
          }
          else if ( v52 == 2 )
          {
            *(_DWORD *)(v21 + 48) = crc32(*(_DWORD *)(v21 + 48), v63, v23);
          }
          v19 = a1[27];
          *(_DWORD *)v21 += v23;
          *(_DWORD *)(v21 + 8) += v23;
          v23 = v22;
          goto LABEL_84;
        }
        v45 = v19 - v25;
        a1[23] = &v24[-v25];
        v46 = (char *)a1[14];
        a1[27] = v45;
        memcpy(v46, &v46[v25], v45);
        v47 = a1[1452];
        if ( v47 <= 1 )
          a1[1452] = v47 + 1;
        v21 = *a1;
        v19 = a1[27];
        v23 += a1[11];
        v22 = *(_DWORD *)(*a1 + 4);
      }
      if ( v23 <= v22 )
      {
        if ( v23 )
        {
          v49 = (_BYTE *)(v19 + a1[14]);
          if ( v23 < v22 )
            goto LABEL_79;
          if ( v22 )
          {
            v55 = v22;
            v22 = v23;
            v23 = v55;
            v48 = 0;
            goto LABEL_80;
          }
LABEL_84:
          v19 += v23;
          a1[27] = v19;
        }
      }
      else if ( v22 )
      {
        v23 = v22;
        v48 = 0;
        v49 = (_BYTE *)(v19 + a1[14]);
        goto LABEL_80;
      }
LABEL_76:
      v60 = (char *)a1[23];
LABEL_36:
      if ( a1[1456] < v19 )
        a1[1456] = v19;
      v26 = a1[3] - ((a1[1455] + 42) >> 3);
      if ( v26 > 0xFFFF )
        v26 = 0xFFFF;
      v27 = v19 - (_DWORD)v60;
      v28 = v26;
      if ( a1[11] <= v26 )
        v28 = a1[11];
      if ( v28 <= v27 )
      {
        v40 = v27;
        if ( v26 <= v27 )
          v40 = v26;
        if ( a2 != 4 )
          goto LABEL_63;
        if ( *(_DWORD *)(*a1 + 4) )
          goto LABEL_63;
        v41 = 1;
        if ( v26 < v27 )
          goto LABEL_63;
LABEL_64:
        _tr_stored_block((int)a1, &v60[a1[14]], v40, v41);
        v42 = *a1;
        a1[23] += v40;
        v43 = *(_DWORD *)(v42 + 28);
        _tr_flush_bits(v43);
        v44 = *(_DWORD *)(v43 + 20);
        if ( *(_DWORD *)(v42 + 16) <= v44 )
          v44 = *(_DWORD *)(v42 + 16);
        if ( v44 )
        {
          memcpy(*(void **)(v42 + 12), *(const void **)(v43 + 16), v44);
          v53 = *(_DWORD *)(v43 + 20);
          *(_DWORD *)(v42 + 12) += v44;
          *(_DWORD *)(v43 + 16) += v44;
          *(_DWORD *)(v42 + 20) += v44;
          *(_DWORD *)(v42 + 16) -= v44;
          v54 = v53 - v44;
          *(_DWORD *)(v43 + 20) = v54;
          if ( !v54 )
            *(_DWORD *)(v43 + 16) = *(_DWORD *)(v43 + 8);
        }
        if ( !v41 )
          return 0;
        return 2;
      }
      else
      {
        if ( (a2 == 4 || v27 != 0) && a2 && !*(_DWORD *)(*a1 + 4) && v26 >= v27 )
        {
          v40 = v27;
          v41 = 1;
          if ( v26 <= v27 )
            v40 = v26;
          if ( a2 == 4 )
            goto LABEL_64;
LABEL_63:
          v41 = 0;
          goto LABEL_64;
        }
        return 0;
      }
    }
  }
  return result;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);

//----- (0042B700) --------------------------------------------------------
char *__usercall fill_window@<eax>(int *a1@<eax>)
{
  int v2; // eax
  unsigned int v3; // ebx
  int v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // esi
  int v7; // edi
  size_t Size; // edx
  size_t v9; // eax
  _BYTE *v10; // ebx
  unsigned int v11; // edx
  int v12; // eax
  int v13; // ebx
  int v14; // ecx
  unsigned int v15; // ebx
  int v16; // eax
  int v17; // edi
  unsigned int v18; // edx
  int v19; // edi
  unsigned int v20; // eax
  unsigned int v21; // edx
  unsigned int v22; // edx
  char *result; // eax
  unsigned int v24; // ebx
  unsigned int v25; // eax
  unsigned int v26; // edx
  int v27; // eax
  int v28; // ecx
  int v29; // edx
  int v30; // eax
  int v31; // esi
  int v32; // edx
  _WORD *v33; // ecx
  int v34; // ecx
  int v35; // eax
  int v36; // eax
  char *v37; // eax
  size_t v38; // ebx
  _BYTE *v39; // edi
  unsigned int v40; // ecx
  size_t v41; // eax
  unsigned int v42; // [esp+14h] [ebp-48h]
  int v43; // [esp+14h] [ebp-48h]
  int v44; // [esp+18h] [ebp-44h]
  int v45; // [esp+1Ch] [ebp-40h]
  int v46; // [esp+20h] [ebp-3Ch]
  int v47; // [esp+24h] [ebp-38h]
  unsigned int v48; // [esp+24h] [ebp-38h]
  int v49; // [esp+28h] [ebp-34h]
  int v50; // [esp+2Ch] [ebp-30h]
  int v51; // [esp+30h] [ebp-2Ch]
  int v52; // [esp+34h] [ebp-28h]
  int v53; // [esp+38h] [ebp-24h]

  v2 = a1[11];
  v3 = a1[29];
  v52 = v2;
  v51 = v2 - 262;
  while ( 1 )
  {
    v5 = a1[27];
    v6 = a1[15] - v5 - v3;
    if ( v5 >= v51 + v2 )
      break;
    v7 = *a1;
    Size = *(_DWORD *)(*a1 + 4);
    if ( !Size )
      goto LABEL_23;
LABEL_9:
    v3 = a1[29];
    if ( v6 < Size )
    {
      if ( !v6 )
        goto LABEL_3;
      v41 = Size;
      Size = v6;
      v9 = v41 - v6;
    }
    else
    {
      v9 = 0;
    }
    v10 = (_BYTE *)(a1[14] + v5 + v3);
    *(_DWORD *)(v7 + 4) = v9;
    v42 = Size;
    memcpy(v10, *(const void **)v7, Size);
    v11 = v42;
    v12 = *(_DWORD *)(*(_DWORD *)(v7 + 28) + 24);
    if ( v12 == 1 )
    {
      v35 = adler32(*(_DWORD *)(v7 + 48), v10, v42);
      v11 = v42;
      *(_DWORD *)(v7 + 48) = v35;
    }
    else if ( v12 == 2 )
    {
      v36 = crc32(*(_DWORD *)(v7 + 48), v10, v42);
      v11 = v42;
      *(_DWORD *)(v7 + 48) = v36;
    }
    v13 = a1[29];
    *(_DWORD *)v7 += v11;
    *(_DWORD *)(v7 + 8) += v11;
    v3 = v11 + v13;
LABEL_3:
    v4 = a1[1453];
    a1[29] = v3;
    if ( v4 + v3 > 2 )
    {
      v47 = a1[27];
      v27 = a1[14];
      v28 = *(unsigned __int8 *)(v27 + v47 - v4);
      v29 = a1[21];
      v43 = v27;
      v53 = v47 - v4;
      a1[18] = v28;
      v45 = v29;
      v44 = a1[22];
      v30 = v29 & ((v28 << v44) ^ *(unsigned __int8 *)(v27 + v47 - v4 + 1));
      a1[18] = v30;
      if ( v4 )
      {
        v31 = a1[16];
        v32 = v53;
        v46 = a1[13];
        v50 = a1[17];
        v49 = v47 - 1;
        v48 = v3 + v47 - 1;
        do
        {
          v30 = v45 & (*(unsigned __int8 *)(v43 + v32 + 2) ^ (v30 << v44));
          v33 = (_WORD *)(v50 + 2 * v30);
          a1[18] = v30;
          *(_WORD *)(v31 + 2 * (v32 & v46)) = *v33;
          *v33 = v32;
          v34 = v49 - v32;
          a1[1453] = v49 - v32;
          if ( v48 - v32 <= 2 )
            break;
          ++v32;
        }
        while ( v34 );
      }
    }
    if ( v3 > 0x105 || !*(_DWORD *)(*a1 + 4) )
      goto LABEL_23;
    v2 = a1[11];
  }
  memcpy((void *)a1[14], (const void *)(a1[14] + v52), v52 + v5 - a1[15] + v3);
  v14 = a1[27];
  a1[28] -= v52;
  a1[23] -= v52;
  v15 = a1[11];
  v5 = v14 - v52;
  v16 = a1[19];
  v17 = a1[17];
  a1[27] = v5;
  do
  {
    while ( 1 )
    {
      v18 = *(unsigned __int16 *)(v17 + 2 * v16 - 2);
      if ( v15 > v18 )
        break;
      *(_WORD *)(v17 + 2 * v16-- - 2) = v18 - v15;
      if ( !v16 )
        goto LABEL_18;
    }
    *(_WORD *)(v17 + 2 * v16-- - 2) = 0;
  }
  while ( v16 );
LABEL_18:
  v19 = a1[16];
  v20 = v15;
  do
  {
    while ( 1 )
    {
      v21 = *(unsigned __int16 *)(v19 + 2 * v20 - 2);
      if ( v15 > v21 )
        break;
      *(_WORD *)(v19 + 2 * v20-- - 2) = v21 - v15;
      if ( !v20 )
      {
        v6 += v52;
        goto LABEL_22;
      }
    }
    *(_WORD *)(v19 + 2 * v20-- - 2) = 0;
  }
  while ( v20 );
  v6 += v52;
LABEL_22:
  v7 = *a1;
  Size = *(_DWORD *)(*a1 + 4);
  if ( Size )
    goto LABEL_9;
LABEL_23:
  v22 = a1[1456];
  result = (char *)a1[15];
  if ( v22 < (unsigned int)result )
  {
    v24 = a1[27] + a1[29];
    if ( v22 >= v24 )
    {
      if ( v22 < v24 + 258 )
      {
        v37 = &result[-v22];
        v38 = v24 - v22 + 258;
        if ( (unsigned int)v37 <= v38 )
          v38 = (size_t)v37;
        result = (char *)memset((void *)(v22 + a1[14]), 0, v38);
        a1[1456] += v38;
      }
    }
    else
    {
      v25 = (unsigned int)&result[-v24];
      v26 = 258;
      if ( v25 <= 0x102 )
        v26 = v25;
      result = (char *)(v24 + a1[14]);
      if ( v26 >= 4 )
      {
        *(_DWORD *)result = 0;
        v39 = (_BYTE *)((unsigned int)(result + 4) & 0xFFFFFFFC);
        *(_DWORD *)&result[v26 - 4] = 0;
        v40 = v26 + result - v39;
        result = 0;
        memset(v39, 0, 4 * (v40 >> 2));
      }
      else if ( v26 )
      {
        *result = 0;
        if ( (v26 & 2) != 0 )
          *(_WORD *)&result[v26 - 2] = 0;
      }
      a1[1456] = v24 + v26;
    }
  }
  return result;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);

//----- (0042BAA0) --------------------------------------------------------
int *get_crc_table()
{
  return crc_table;
}
// 512040: using guessed type int crc_table[256];

//----- (0042BAB0) --------------------------------------------------------
int __cdecl inflate(int a1, int a2)
{
  _DWORD *v2; // ebp
  int v3; // ecx
  int v4; // eax
  unsigned __int8 *v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // ebx
  unsigned __int8 *v9; // ebp
  int v10; // eax
  _DWORD *v11; // eax
  unsigned __int8 *v12; // edx
  _DWORD *v13; // ebp
  char v14; // cl
  int v15; // eax
  unsigned int v16; // edi
  unsigned int v17; // ecx
  int v18; // esi
  int v19; // esi
  unsigned int v20; // edx
  int v21; // ecx
  int v22; // edx
  _BYTE *v23; // edx
  int v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // eax
  unsigned int v27; // edx
  size_t v28; // eax
  __int64 v29; // rdi
  unsigned int v30; // edx
  int v31; // eax
  char *v32; // eax
  unsigned __int8 v33; // dl
  char v34; // cl
  unsigned __int16 v35; // si
  int v36; // eax
  int v37; // edi
  unsigned int v38; // ecx
  unsigned int v39; // esi
  unsigned int v40; // ebx
  int v41; // eax
  char *v42; // eax
  int v43; // ecx
  int v44; // eax
  unsigned __int8 *v45; // esi
  unsigned int v46; // edx
  unsigned int v47; // ecx
  unsigned int v48; // edi
  int v49; // eax
  unsigned int v50; // ebx
  int v51; // eax
  int v52; // eax
  int v53; // ebx
  unsigned int v54; // eax
  int v55; // eax
  int v56; // edx
  int v57; // eax
  unsigned int v58; // ecx
  size_t Size; // eax
  size_t v60; // esi
  char *v61; // edi
  int v62; // eax
  int v63; // edx
  int v64; // edx
  int v65; // edx
  int v66; // eax
  unsigned int v67; // edx
  unsigned int v68; // ebx
  int v69; // eax
  int v70; // eax
  int v71; // eax
  int v72; // eax
  int v73; // edx
  int v74; // ecx
  int v75; // edx
  unsigned int v76; // esi
  unsigned int v77; // edx
  _DWORD *v78; // ecx
  int v79; // edi
  unsigned int v80; // eax
  int v81; // ecx
  size_t v82; // edx
  int v83; // eax
  unsigned int v84; // ebx
  int v85; // eax
  _DWORD *v86; // eax
  unsigned int v87; // ecx
  unsigned int v88; // esi
  unsigned __int8 *v89; // eax
  int v90; // edi
  int v91; // edi
  unsigned int v92; // edx
  unsigned int v93; // edx
  unsigned int v94; // eax
  int v95; // esi
  unsigned __int8 v96; // cl
  unsigned __int16 v97; // di
  int v98; // esi
  unsigned __int8 *v99; // ebp
  int v100; // ebx
  int v101; // esi
  unsigned __int8 v102; // bl
  unsigned __int8 v103; // bp
  unsigned int v104; // esi
  unsigned int v105; // ecx
  unsigned int v106; // edx
  unsigned int v107; // edi
  unsigned int v108; // ebx
  unsigned int v109; // edi
  unsigned __int8 *v110; // eax
  int v111; // esi
  int v112; // esi
  char v113; // bp
  unsigned int v114; // ecx
  unsigned int v115; // eax
  char v116; // cl
  unsigned __int8 *v117; // eax
  unsigned int v118; // ebp
  unsigned int v119; // ecx
  unsigned int v120; // edx
  _DWORD *v121; // eax
  char v122; // cl
  unsigned __int8 *v123; // eax
  int v124; // edx
  char v125; // cl
  unsigned int v126; // ecx
  unsigned int v127; // esi
  unsigned __int8 *v128; // eax
  unsigned int v129; // edi
  int v130; // edx
  int v131; // edx
  unsigned int v132; // edx
  int v133; // ecx
  int v134; // edi
  char *v135; // eax
  unsigned __int8 v136; // cl
  char v137; // dl
  int v138; // esi
  unsigned int v139; // eax
  int v140; // eax
  int v141; // esi
  unsigned int v142; // edi
  size_t v143; // ecx
  unsigned int v144; // edx
  int v145; // esi
  char *v146; // esi
  size_t v147; // edx
  unsigned int v148; // ecx
  unsigned int v149; // edx
  int v150; // edx
  char *v151; // esi
  char *v152; // ecx
  size_t v153; // edi
  char v154; // cl
  unsigned __int8 *v155; // esi
  unsigned int v156; // edi
  int v157; // eax
  unsigned __int8 v158; // dl
  int v159; // ebx
  unsigned int v160; // esi
  unsigned int v161; // edi
  int v162; // eax
  unsigned __int8 v163; // dl
  int v164; // ebx
  unsigned int v165; // esi
  int v166; // eax
  int v167; // ebx
  unsigned int v168; // esi
  int v169; // edi
  unsigned int v170; // ecx
  int *v171; // ecx
  int *v172; // edi
  unsigned int v173; // edi
  unsigned int v174; // esi
  int v175; // esi
  int v176; // eax
  int v177; // edx
  _BYTE *v178; // edi
  char *v179; // edx
  char *v180; // edx
  unsigned int v181; // esi
  unsigned int v182; // eax
  char v183; // cl
  char *v184; // edx
  int v185; // eax
  int v186; // eax
  int v187; // eax
  int v188; // ebx
  unsigned int v189; // esi
  int v190; // edi
  unsigned __int16 *v191; // eax
  int v192; // edx
  int v193; // edi
  char v194; // cl
  int v195; // eax
  char *v196; // ecx
  int v197; // esi
  unsigned int v198; // edi
  char v199; // cl
  char *v200; // ecx
  unsigned int *v201; // edx
  unsigned __int8 *v202; // edx
  _DWORD *v203; // ebp
  int v204; // eax
  int v205; // eax
  unsigned int v206; // eax
  unsigned int v207; // ecx
  int v208; // eax
  bool v209; // zf
  int v210; // eax
  void *v211; // [esp+0h] [ebp-9Ch]
  void *v212; // [esp+0h] [ebp-9Ch]
  _BYTE *Src; // [esp+4h] [ebp-98h]
  unsigned __int8 *Srcb; // [esp+4h] [ebp-98h]
  char *Srca; // [esp+4h] [ebp-98h]
  unsigned int v216; // [esp+2Ch] [ebp-70h]
  int v217; // [esp+2Ch] [ebp-70h]
  unsigned int v218; // [esp+2Ch] [ebp-70h]
  int v219; // [esp+30h] [ebp-6Ch]
  _DWORD *v220; // [esp+30h] [ebp-6Ch]
  unsigned __int8 *v221; // [esp+30h] [ebp-6Ch]
  unsigned int v222; // [esp+34h] [ebp-68h]
  char v223; // [esp+34h] [ebp-68h]
  unsigned __int16 v224; // [esp+34h] [ebp-68h]
  size_t v225; // [esp+38h] [ebp-64h]
  int v226; // [esp+3Ch] [ebp-60h]
  unsigned int v227; // [esp+40h] [ebp-5Ch]
  char *v228; // [esp+44h] [ebp-58h]
  char v229; // [esp+48h] [ebp-54h]
  int v230; // [esp+48h] [ebp-54h]
  int v231; // [esp+48h] [ebp-54h]
  unsigned int v232; // [esp+48h] [ebp-54h]
  int v233; // [esp+48h] [ebp-54h]
  int v234; // [esp+48h] [ebp-54h]
  unsigned int v235; // [esp+48h] [ebp-54h]
  unsigned int v236; // [esp+48h] [ebp-54h]
  unsigned __int8 v237; // [esp+48h] [ebp-54h]
  unsigned __int8 v238; // [esp+48h] [ebp-54h]
  int v239; // [esp+4Ch] [ebp-50h]
  int v240; // [esp+4Ch] [ebp-50h]
  int v241; // [esp+4Ch] [ebp-50h]
  unsigned int v242; // [esp+4Ch] [ebp-50h]
  int v243; // [esp+4Ch] [ebp-50h]
  unsigned int v244; // [esp+4Ch] [ebp-50h]
  int v245; // [esp+50h] [ebp-4Ch]
  unsigned __int8 *v246; // [esp+50h] [ebp-4Ch]
  int v247; // [esp+50h] [ebp-4Ch]
  unsigned __int16 v248; // [esp+50h] [ebp-4Ch]
  unsigned __int16 v249; // [esp+58h] [ebp-44h]
  unsigned int v250; // [esp+58h] [ebp-44h]
  unsigned int v251; // [esp+58h] [ebp-44h]
  int v252; // [esp+58h] [ebp-44h]
  int v253; // [esp+58h] [ebp-44h]
  unsigned int v254; // [esp+5Ch] [ebp-40h]
  int v255; // [esp+5Ch] [ebp-40h]
  int v256; // [esp+5Ch] [ebp-40h]
  int v257; // [esp+5Ch] [ebp-40h]
  int v258; // [esp+60h] [ebp-3Ch]
  int v259; // [esp+64h] [ebp-38h]
  unsigned int v260; // [esp+68h] [ebp-34h]
  unsigned int v261; // [esp+6Ch] [ebp-30h]
  int v262[8]; // [esp+7Ch] [ebp-20h] BYREF

  if ( !a1 || !*(_DWORD *)(a1 + 32) || !*(_DWORD *)(a1 + 36) )
    return -2;
  v2 = *(_DWORD **)(a1 + 28);
  v219 = -2;
  if ( !v2 )
    return v219;
  if ( a1 != *v2 )
    return v219;
  v3 = v2[1];
  v4 = v3 - 16180;
  if ( (unsigned int)(v3 - 16180) > 0x1F )
    return v219;
  v228 = *(char **)(a1 + 12);
  if ( !v228 )
    return v219;
  v6 = *(unsigned __int8 **)a1;
  v227 = *(_DWORD *)(a1 + 4);
  if ( !*(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return v219;
  }
  if ( v3 == 16191 )
  {
    v2[1] = 16192;
    v4 = 12;
  }
  v7 = v2[15];
  v220 = v2;
  v8 = v2[16];
  v9 = v6;
  v222 = v7;
  v225 = *(_DWORD *)(a1 + 16);
  v226 = v225;
  v216 = v227;
  while ( 2 )
  {
    switch ( v4 )
    {
      case 0:
        v10 = v220[3];
        if ( !v10 )
        {
          v220[1] = 16192;
          goto LABEL_17;
        }
        if ( v8 > 0xF )
        {
          LODWORD(v29) = v9;
        }
        else
        {
          if ( !v216 )
            goto LABEL_79;
          LODWORD(v29) = v9 + 1;
          v114 = v8 + 8;
          v222 += *v9 << v8;
          if ( v8 + 8 > 0xF )
          {
            v8 += 8;
            --v216;
          }
          else
          {
            if ( v216 == 1 )
              goto LABEL_336;
            v216 -= 2;
            LODWORD(v29) = v9 + 2;
            v8 += 16;
            v222 += v9[1] << v114;
          }
        }
        if ( (v10 & 2) != 0 && v222 == 35615 )
        {
          if ( !v220[10] )
            v220[10] = 15;
          v9 = (unsigned __int8 *)v29;
          v204 = crc32(0, 0, 0);
          LOWORD(v262[0]) = -29921;
          v220[7] = v204;
          v205 = crc32(v204, v262, 2u);
          v220[1] = 16181;
          v220[7] = v205;
          v8 = 0;
          v222 = 0;
LABEL_230:
          if ( v216 )
          {
            LODWORD(v29) = v9 + 1;
            v114 = v8 + 8;
            v222 += *v9 << v8;
            if ( v8 + 8 > 0xF )
            {
              v8 += 8;
              --v216;
              v115 = v222;
            }
            else
            {
              if ( v216 == 1 )
              {
LABEL_336:
                v13 = v220;
                v8 = v114;
                v12 = (unsigned __int8 *)v29;
                HIDWORD(v29) = v226 - v225;
                v216 = 0;
                v219 = 0;
                goto LABEL_85;
              }
              v216 -= 2;
              LODWORD(v29) = v9 + 2;
              v8 += 16;
              v222 += v9[1] << v114;
              v115 = v222;
            }
LABEL_234:
            v13 = v220;
            v220[5] = v115;
            if ( (_BYTE)v115 != 8 )
            {
              v12 = (unsigned __int8 *)v29;
              *(_DWORD *)(a1 + 24) = "unknown compression method";
              v220[1] = 16209;
              goto LABEL_51;
            }
            if ( (v222 & 0xE000) != 0 )
            {
              v12 = (unsigned __int8 *)v29;
              *(_DWORD *)(a1 + 24) = "unknown header flags set";
              v220[1] = 16209;
              goto LABEL_51;
            }
            v201 = (unsigned int *)v220[9];
            if ( v201 )
              *v201 = (v222 >> 8) & 1;
            if ( (v222 & 0x200) != 0 && (v220[3] & 4) != 0 )
            {
              LOWORD(v262[0]) = v222;
              v220[7] = crc32(v220[7], v262, 2u);
            }
            v9 = (unsigned __int8 *)v29;
            v222 = 0;
            v8 = 0;
            v220[1] = 16182;
LABEL_133:
            if ( v216 )
            {
              v38 = v8;
              v67 = v216;
              v68 = v222;
              while ( 1 )
              {
                ++v9;
                --v67;
                v69 = *(v9 - 1) << v38;
                v38 += 8;
                v68 += v69;
                if ( v38 > 0x1F )
                  break;
                if ( !v67 )
                {
LABEL_297:
                  v216 = v67;
                  v12 = v9;
                  v222 = v68;
                  goto LABEL_83;
                }
              }
              v216 = v67;
              v222 = v68;
LABEL_138:
              v70 = v220[9];
              if ( v70 )
                *(_DWORD *)(v70 + 4) = v222;
              if ( (*((_BYTE *)v220 + 21) & 2) != 0 && (v220[3] & 4) != 0 )
              {
                v262[0] = v222;
                v220[7] = crc32(v220[7], v262, 4u);
              }
              v222 = 0;
              v8 = 0;
              v220[1] = 16183;
LABEL_145:
              if ( v216 )
              {
                v38 = v8;
                v67 = v216;
                v68 = v222;
                while ( 1 )
                {
                  ++v9;
                  --v67;
                  v71 = *(v9 - 1) << v38;
                  v38 += 8;
                  v68 += v71;
                  if ( v38 > 0xF )
                    break;
                  if ( !v67 )
                    goto LABEL_297;
                }
                v216 = v67;
                v222 = v68;
LABEL_150:
                v72 = v220[9];
                if ( v72 )
                {
                  *(_DWORD *)(v72 + 8) = (unsigned __int8)v222;
                  *(_DWORD *)(v72 + 12) = v222 >> 8;
                }
                v73 = v220[5];
                v62 = v73;
                if ( (v73 & 0x200) != 0 && (v220[3] & 4) != 0 )
                {
                  LOWORD(v262[0]) = v222;
                  v187 = crc32(v220[7], v262, 2u);
                  v73 = v220[5];
                  v220[7] = v187;
                  v62 = v73;
                }
                v222 = 0;
                v220[1] = 16184;
                v8 = 0;
                if ( (v73 & 0x400) == 0 )
                {
LABEL_156:
                  v74 = v220[9];
                  v75 = 0;
                  if ( v74 )
                    *(_DWORD *)(v74 + 16) = 0;
                  goto LABEL_158;
                }
LABEL_177:
                if ( v216 )
                {
                  v38 = v8;
                  v39 = v222;
                  v40 = v216;
                  while ( 1 )
                  {
                    ++v9;
                    --v40;
                    v83 = *(v9 - 1) << v38;
                    v38 += 8;
                    v39 += v83;
                    if ( v38 > 0xF )
                      break;
                    if ( !v40 )
                    {
LABEL_82:
                      v216 = v40;
                      v12 = v9;
                      v222 = v39;
                      goto LABEL_83;
                    }
                  }
                  LOWORD(v222) = v39;
                  v216 = v40;
                  v84 = v39;
LABEL_182:
                  v220[17] = v84;
                  v85 = v220[9];
                  if ( v85 )
                    *(_DWORD *)(v85 + 20) = v84;
                  if ( (v73 & 0x200) != 0 && (v220[3] & 4) != 0 )
                  {
                    LOWORD(v262[0]) = v222;
                    v222 = 0;
                    v220[7] = crc32(v220[7], v262, 2u);
                    v62 = v220[5];
                    v8 = 0;
                    v75 = v62 & 0x400;
                  }
                  else
                  {
                    v62 = v73;
                    v8 = 0;
                    v75 = v73 & 0x400;
                    v222 = 0;
                  }
LABEL_158:
                  v220[1] = 16185;
LABEL_159:
                  if ( !v75 )
                  {
LABEL_174:
                    v220[17] = 0;
                    v220[1] = 16186;
LABEL_118:
                    if ( (v62 & 0x800) != 0 )
                    {
                      if ( !v216 )
                        goto LABEL_79;
                      v236 = v8;
                      v161 = 0;
                      do
                      {
                        v162 = v220[9];
                        v163 = v9[v161++];
                        if ( v162 )
                        {
                          v164 = *(_DWORD *)(v162 + 28);
                          if ( v164 )
                          {
                            v165 = v220[17];
                            if ( v165 < *(_DWORD *)(v162 + 32) )
                            {
                              v220[17] = v165 + 1;
                              *(_BYTE *)(v164 + v165) = v163;
                            }
                          }
                        }
                      }
                      while ( v163 && v216 > v161 );
                      v8 = v236;
                      if ( (*((_BYTE *)v220 + 21) & 2) != 0 && (v220[3] & 4) != 0 )
                      {
                        v238 = v163;
                        v186 = crc32(v220[7], v9, v161);
                        v163 = v238;
                        v220[7] = v186;
                      }
                      v9 += v161;
                      v216 -= v161;
                      if ( v163 )
                        goto LABEL_79;
                      v62 = v220[5];
                    }
                    else
                    {
                      v63 = v220[9];
                      if ( v63 )
                        *(_DWORD *)(v63 + 28) = 0;
                    }
                    v220[17] = 0;
                    v220[1] = 16187;
LABEL_122:
                    if ( (v62 & 0x1000) != 0 )
                    {
                      if ( !v216 )
                        goto LABEL_79;
                      v235 = v8;
                      v156 = 0;
                      do
                      {
                        v157 = v220[9];
                        v158 = v9[v156++];
                        if ( v157 )
                        {
                          v159 = *(_DWORD *)(v157 + 36);
                          if ( v159 )
                          {
                            v160 = v220[17];
                            if ( v160 < *(_DWORD *)(v157 + 40) )
                            {
                              v220[17] = v160 + 1;
                              *(_BYTE *)(v159 + v160) = v158;
                            }
                          }
                        }
                      }
                      while ( v158 && v216 > v156 );
                      v8 = v235;
                      if ( (*((_BYTE *)v220 + 21) & 2) != 0 && (v220[3] & 4) != 0 )
                      {
                        v237 = v158;
                        v185 = crc32(v220[7], v9, v156);
                        v158 = v237;
                        v220[7] = v185;
                      }
                      v9 += v156;
                      v216 -= v156;
                      if ( v158 )
                        goto LABEL_79;
                      v62 = v220[5];
                    }
                    else
                    {
                      v64 = v220[9];
                      if ( v64 )
                        *(_DWORD *)(v64 + 36) = 0;
                    }
                    v220[1] = 16188;
LABEL_126:
                    if ( (v62 & 0x200) != 0 )
                    {
                      if ( v8 > 0xF )
                      {
                        v155 = v9;
                      }
                      else
                      {
                        if ( !v216 )
                          goto LABEL_79;
                        v154 = v8 + 8;
                        v222 += *v9 << v8;
                        v155 = v9 + 1;
                        if ( v8 + 8 > 0xF )
                        {
                          v8 += 8;
                          --v216;
                        }
                        else
                        {
                          if ( v216 == 1 )
                          {
                            v12 = v9 + 1;
                            v8 += 8;
                            v13 = v220;
                            HIDWORD(v29) = v226 - v225;
                            v216 = 0;
                            v219 = 0;
                            goto LABEL_85;
                          }
                          v216 -= 2;
                          v155 = v9 + 2;
                          v8 += 16;
                          v222 += v9[1] << v154;
                        }
                      }
                      v13 = v220;
                      if ( (v220[3] & 4) != 0 && *((unsigned __int16 *)v220 + 14) != v222 )
                      {
                        v12 = v155;
                        *(_DWORD *)(a1 + 24) = "header crc mismatch";
                        v220[1] = 16209;
                        goto LABEL_51;
                      }
                      v9 = v155;
                      v8 = 0;
                      v222 = 0;
                    }
                    v65 = v220[9];
                    if ( v65 )
                    {
                      *(_DWORD *)(v65 + 48) = 1;
                      *(_DWORD *)(v65 + 44) = (v62 >> 9) & 1;
                    }
                    v66 = crc32(0, 0, 0);
                    v220[7] = v66;
                    *(_DWORD *)(a1 + 48) = v66;
                    v220[1] = 16191;
                    goto LABEL_78;
                  }
                  v76 = v216;
                  v77 = v220[17];
                  if ( v216 > v77 )
                    v76 = v220[17];
                  if ( v76 )
                  {
                    v78 = (_DWORD *)v220[9];
                    if ( v78 )
                    {
                      v79 = v78[4];
                      if ( v79 )
                      {
                        v240 = v78[5];
                        v230 = v240 - v77;
                        v80 = v78[6];
                        v81 = v240 - v77;
                        v82 = v80 + v77 - v240;
                        if ( v76 + v81 <= v80 )
                          v82 = v76;
                        memcpy((void *)(v230 + v79), v9, v82);
                        v62 = v220[5];
                      }
                    }
                    if ( (v62 & 0x200) != 0 && (v220[3] & 4) != 0 )
                      v220[7] = crc32(v220[7], v9, v76);
                    v216 -= v76;
                    v9 += v76;
                    v77 = v220[17] - v76;
                    v220[17] = v77;
                  }
                  if ( !v77 )
                  {
                    v62 = v220[5];
                    goto LABEL_174;
                  }
                }
              }
            }
          }
LABEL_79:
          v12 = v9;
          v13 = v220;
          v219 = 0;
          HIDWORD(v29) = v226 - v225;
          goto LABEL_85;
        }
        v220[5] = 0;
        v177 = v220[9];
        if ( v177 )
          *(_DWORD *)(v177 + 48) = -1;
        if ( (v10 & 1) == 0
          || (v222 >> 8) + (unsigned __int16)((_WORD)v222 << 8) != 31
                                                                 * (((v222 >> 8) + (unsigned __int16)((_WORD)v222 << 8))
                                                                  / 0x1F) )
        {
          v13 = v220;
          v12 = (unsigned __int8 *)v29;
          *(_DWORD *)(a1 + 24) = "incorrect header check";
          v220[1] = 16209;
          goto LABEL_51;
        }
        if ( (v222 & 0xF) != 8 )
        {
          v13 = v220;
          v12 = (unsigned __int8 *)v29;
          *(_DWORD *)(a1 + 24) = "unknown compression method";
          v220[1] = 16209;
          goto LABEL_51;
        }
        v222 >>= 4;
        v8 -= 4;
        v206 = v220[10];
        v207 = (v222 & 0xF) + 8;
        if ( v206 )
        {
          if ( v207 > 0xF || v206 < v207 )
          {
LABEL_498:
            v13 = v220;
            v12 = (unsigned __int8 *)v29;
            *(_DWORD *)(a1 + 24) = "invalid window size";
            v220[1] = 16209;
            goto LABEL_51;
          }
        }
        else
        {
          v220[10] = v207;
          if ( v207 > 0xF )
            goto LABEL_498;
        }
        v220[6] = 1 << v207;
        v208 = adler32(0, 0, 0);
        v209 = (v222 & 0x200) == 0;
        v222 &= 0x200u;
        v220[7] = v208;
        *(_DWORD *)(a1 + 48) = v208;
        if ( v209 )
        {
          v220[1] = 16191;
          v9 = (unsigned __int8 *)v29;
          v8 = 0;
          goto LABEL_78;
        }
        v222 = 0;
        v8 = 0;
        v9 = (unsigned __int8 *)v29;
        v220[1] = 16189;
LABEL_67:
        if ( !v216 )
          goto LABEL_79;
        v45 = v9 + 1;
        v46 = v216 - 1;
        v47 = v8 + 8;
        v222 += *v9 << v8;
        v48 = v222;
        if ( v8 + 8 > 0x1F )
          goto LABEL_410;
        if ( v216 == 1 )
          goto LABEL_434;
        v45 = v9 + 2;
        v46 = v216 - 2;
        v49 = v9[1] << v47;
        v47 = v8 + 16;
        v48 = v49 + v222;
        v222 += v49;
        if ( v8 + 16 > 0x1F )
          goto LABEL_410;
        if ( v216 == 2 )
        {
LABEL_434:
          v13 = v220;
          v8 = v47;
          v12 = v45;
          goto LABEL_403;
        }
        v8 += 24;
        v45 = v9 + 3;
        v46 = v216 - 3;
        v48 += v9[2] << v47;
        v222 = v48;
        if ( v8 > 0x1F )
        {
LABEL_410:
          v216 = v46;
          v50 = v48;
        }
        else
        {
          if ( v216 == 3 )
          {
            v13 = v220;
            v12 = v45;
            goto LABEL_403;
          }
          v216 -= 4;
          v45 = v9 + 4;
          v50 = (v9[3] << v8) + v48;
        }
LABEL_75:
        v222 = 0;
        v9 = v45;
        v51 = HIBYTE(v50) + (v50 << 24) + ((v50 >> 8) & 0xFF00) + ((v50 << 8) & 0xFF0000);
        v220[7] = v51;
        *(_DWORD *)(a1 + 48) = v51;
        v220[1] = 16190;
        v8 = 0;
LABEL_76:
        if ( !v220[4] )
        {
          v202 = v9;
          v203 = v220;
          v219 = 2;
          *(_DWORD *)(a1 + 12) = v228;
          *(_DWORD *)a1 = v202;
          *(_DWORD *)(a1 + 16) = v225;
          *(_DWORD *)(a1 + 4) = v216;
          v203[16] = v8;
          v203[15] = v222;
          return v219;
        }
        v52 = adler32(0, 0, 0);
        v220[7] = v52;
        *(_DWORD *)(a1 + 48) = v52;
        v220[1] = 16191;
        break;
      case 1:
        if ( v8 <= 0xF )
          goto LABEL_230;
        LODWORD(v29) = v9;
        v115 = v222;
        goto LABEL_234;
      case 2:
        if ( v8 <= 0x1F )
          goto LABEL_133;
        goto LABEL_138;
      case 3:
        if ( v8 <= 0xF )
          goto LABEL_145;
        goto LABEL_150;
      case 4:
        v73 = v220[5];
        v62 = v73;
        if ( (v73 & 0x400) == 0 )
          goto LABEL_156;
        if ( v8 <= 0xF )
          goto LABEL_177;
        v84 = v222;
        goto LABEL_182;
      case 5:
        v62 = v220[5];
        v75 = v62 & 0x400;
        goto LABEL_159;
      case 6:
        v62 = v220[5];
        goto LABEL_118;
      case 7:
        v62 = v220[5];
        goto LABEL_122;
      case 8:
        v62 = v220[5];
        goto LABEL_126;
      case 9:
        if ( v8 <= 0x1F )
          goto LABEL_67;
        v45 = v9;
        v50 = v222;
        goto LABEL_75;
      case 10:
        goto LABEL_76;
      case 11:
        goto LABEL_78;
      case 12:
        goto LABEL_17;
      case 13:
        goto LABEL_256;
      case 14:
        v86 = v220;
        v58 = v220[17];
        goto LABEL_190;
      case 15:
        v58 = v220[17];
        goto LABEL_110;
      case 16:
        goto LABEL_237;
      case 17:
        v106 = v220[27];
        v107 = v220[24];
        if ( v107 > v106 )
          goto LABEL_222;
        goto LABEL_420;
      case 18:
        v250 = v220[27];
        goto LABEL_206;
      case 19:
        goto LABEL_247;
      case 20:
        goto LABEL_39;
      case 21:
        v30 = v220[19];
        goto LABEL_53;
      case 22:
        goto LABEL_56;
      case 23:
        v25 = v220[19];
        goto LABEL_44;
      case 24:
        goto LABEL_46;
      case 25:
        v23 = v228;
        goto LABEL_37;
      case 26:
        v12 = v9;
        v13 = v220;
        goto LABEL_19;
      case 27:
        v12 = v9;
        v13 = v220;
        v15 = v220[3];
        goto LABEL_192;
      case 28:
        v12 = v9;
        v13 = v220;
        v219 = 1;
        HIDWORD(v29) = v226 - v225;
        goto LABEL_85;
      case 29:
        goto LABEL_495;
      case 30:
        return -4;
      default:
        return -2;
    }
    while ( 1 )
    {
LABEL_78:
      if ( (unsigned int)(a2 - 5) <= 1 )
        goto LABEL_79;
LABEL_17:
      v11 = v220;
      if ( v220[2] )
      {
        v12 = v9;
        v13 = v220;
        v14 = v8;
        v8 &= 0xFFFFFFF8;
        v222 >>= v14 & 7;
        v220[1] = 16206;
LABEL_19:
        v15 = v13[3];
        if ( !v15 )
          goto LABEL_268;
        if ( v8 > 0x1F )
        {
          v221 = v12;
        }
        else
        {
          if ( !v216 )
            goto LABEL_84;
          v16 = v216 - 1;
          v221 = v12 + 1;
          v17 = v8 + 8;
          v222 += *v12 << v8;
          if ( v8 + 8 <= 0x1F )
          {
            if ( v216 == 1 )
              goto LABEL_451;
            v221 = v12 + 2;
            v16 = v216 - 2;
            v18 = v12[1] << v17;
            v17 = v8 + 16;
            v222 += v18;
            if ( v8 + 16 <= 0x1F )
            {
              if ( v216 == 2 )
                goto LABEL_451;
              v221 = v12 + 3;
              v16 = v216 - 3;
              v19 = v12[2] << v17;
              v17 = v8 + 24;
              v222 += v19;
              if ( v8 + 24 <= 0x1F )
              {
                if ( v216 != 3 )
                {
                  v216 -= 4;
                  v8 += 32;
                  v221 = v12 + 4;
                  v222 += v12[3] << v17;
                  goto LABEL_29;
                }
LABEL_451:
                v8 = v17;
                v12 = v221;
                goto LABEL_403;
              }
            }
          }
          v8 = v17;
          v216 = v16;
        }
LABEL_29:
        v20 = v226 - v225;
        *(_DWORD *)(a1 + 20) += v226 - v225;
        v13[8] += v226 - v225;
        v21 = v15 & 4;
        if ( v226 != v225 && (v15 & 4) != 0 )
        {
          Srca = &v228[v225 - v226];
          v212 = (void *)v13[7];
          if ( v13[5] )
            v195 = crc32((int)v212, Srca, v20);
          else
            v195 = adler32(v212, Srca, v20);
          v13[7] = v195;
          *(_DWORD *)(a1 + 48) = v195;
          v15 = v13[3];
          v21 = v15 & 4;
        }
        if ( v21 )
        {
          v22 = v222;
          if ( !v13[5] )
            v22 = ((v222 << 8) & 0xFF0000) + ((v222 >> 8) & 0xFF00) + (v222 << 24) + HIBYTE(v222);
          if ( v13[7] != v22 )
          {
            v12 = v221;
            *(_DWORD *)(a1 + 24) = "incorrect data check";
            v13[1] = 16209;
            v226 = v225;
LABEL_51:
            HIDWORD(v29) = v226 - v225;
            v219 = -3;
            goto LABEL_85;
          }
        }
        v12 = v221;
        v222 = 0;
        v226 = v225;
        v8 = 0;
LABEL_268:
        v13[1] = 16207;
LABEL_192:
        if ( !v15 || !v13[5] )
          goto LABEL_437;
        if ( v8 > 0x1F )
        {
          v89 = v12;
          v92 = v222;
          goto LABEL_203;
        }
        if ( !v216 )
          goto LABEL_84;
        v87 = v8 + 8;
        v88 = v216 - 1;
        v222 += *v12 << v8;
        v89 = v12 + 1;
        if ( v8 + 8 <= 0x1F )
        {
          if ( v216 == 1 )
          {
LABEL_402:
            v8 = v87;
            v12 = v89;
LABEL_403:
            v219 = 0;
            HIDWORD(v29) = v226 - v225;
            v216 = 0;
            goto LABEL_85;
          }
          v90 = v12[1] << v87;
          v87 = v8 + 16;
          v88 = v216 - 2;
          v222 += v90;
          v89 = v12 + 2;
          if ( v8 + 16 <= 0x1F )
          {
            if ( v216 != 2 )
            {
              v91 = v12[2] << v87;
              v87 = v8 + 24;
              v222 += v91;
              v89 = v12 + 3;
              if ( v8 + 24 > 0x1F )
              {
                v8 += 24;
                v216 -= 3;
                v92 = v222;
                goto LABEL_203;
              }
              if ( v216 != 3 )
              {
                v89 = v12 + 4;
                v216 -= 4;
                v8 += 32;
                v222 += v12[3] << v87;
                v92 = v222;
LABEL_203:
                if ( v92 != v13[8] )
                {
                  *(_DWORD *)(a1 + 24) = "incorrect length check";
                  v12 = v89;
                  v13[1] = 16209;
                  goto LABEL_51;
                }
                v222 = 0;
                v12 = v89;
                v8 = 0;
LABEL_437:
                v13[1] = 16208;
                HIDWORD(v29) = v226 - v225;
                v219 = 1;
                goto LABEL_85;
              }
            }
            goto LABEL_402;
          }
        }
        v8 = v87;
        v216 = v88;
        v92 = v222;
        goto LABEL_203;
      }
      if ( v8 > 2 )
      {
        v123 = v9;
      }
      else
      {
        if ( !v216 )
          goto LABEL_473;
        v122 = v8;
        --v216;
        v123 = v9 + 1;
        v8 += 8;
        v222 += *v9 << v122;
      }
      v220[2] = v222 & 1;
      v124 = (v222 >> 1) & 3;
      if ( v124 == 2 )
      {
        v220[1] = 16196;
        v8 -= 3;
        v9 = v123;
        v222 >>= 3;
LABEL_237:
        if ( v8 > 0xD )
        {
          v117 = v9;
          v118 = v222;
        }
        else
        {
          if ( !v216 )
            goto LABEL_79;
          v116 = v8 + 8;
          v222 += *v9 << v8;
          v117 = v9 + 1;
          if ( v8 + 8 > 0xD )
          {
            v8 += 8;
            --v216;
            v118 = v222;
          }
          else
          {
            if ( v216 == 1 )
            {
              v13 = v220;
              v8 += 8;
              v12 = v117;
              HIDWORD(v29) = v226 - v225;
              v216 = 0;
              v219 = 0;
              goto LABEL_85;
            }
            v216 -= 2;
            v117 = v9 + 2;
            v8 += 16;
            v118 = (v9[1] << v116) + v222;
          }
        }
        v8 -= 14;
        v119 = (v118 & 0x1F) + 257;
        v120 = ((v118 >> 5) & 0x1F) + 1;
        v220[25] = v119;
        v220[26] = v120;
        v222 = v118 >> 14;
        v107 = ((v118 >> 10) & 0xF) + 4;
        v220[24] = v107;
        if ( v120 > 0x1E || v119 > 0x11E )
        {
          v13 = v220;
          *(_DWORD *)(a1 + 24) = "too many length or distance symbols";
          v12 = v117;
          v220[1] = 16209;
          goto LABEL_51;
        }
        v220[27] = 0;
        v9 = v117;
        v106 = 0;
        v220[1] = 16197;
LABEL_222:
        v38 = v8;
        v242 = v107;
        v108 = v222;
        v232 = v106;
        v109 = v216;
        if ( v38 <= 2 )
        {
LABEL_223:
          if ( v109 )
          {
            --v109;
            v110 = v9 + 1;
            v111 = *v9 << v38;
            v38 += 8;
            v108 += v111;
            goto LABEL_225;
          }
          v12 = v9;
          v216 = 0;
          v222 = v108;
LABEL_83:
          v13 = v220;
          v8 = v38;
LABEL_84:
          v219 = 0;
          HIDWORD(v29) = v226 - v225;
          goto LABEL_85;
        }
        while ( 1 )
        {
          v110 = v9;
LABEL_225:
          ++v232;
          v38 -= 3;
          v112 = (unsigned __int16)word_514C1E[v232];
          v220[27] = v232;
          v113 = v108;
          v108 >>= 3;
          *((_WORD *)v220 + v112 + 58) = v113 & 7;
          if ( v232 >= v242 )
            break;
          v9 = v110;
          if ( v38 <= 2 )
            goto LABEL_223;
        }
        v216 = v109;
        v106 = v232;
        v9 = v110;
        v222 = v108;
        v8 = v38;
LABEL_420:
        if ( v106 <= 0x12 )
        {
          v191 = (unsigned __int16 *)((char *)&order_3632 + 2 * v106);
          do
          {
            v192 = *v191++;
            *((_WORD *)v220 + v192 + 58) = 0;
          }
          while ( &unk_514C46 != (_UNKNOWN *)v191 );
          v220[27] = 19;
        }
        v220[22] = 7;
        v220[28] = v220 + 333;
        v220[20] = v220 + 333;
        if ( inflate_table(0, (unsigned __int16 *)v220 + 58, 19, v220 + 28, v220 + 22, (unsigned __int16 *)v220 + 378) )
        {
          v12 = v9;
          v13 = v220;
          *(_DWORD *)(a1 + 24) = "invalid code lengths set";
          v220[1] = 16209;
          goto LABEL_51;
        }
        v250 = 0;
        v220[27] = 0;
        v220[1] = 16198;
LABEL_206:
        v258 = v220[25];
        v254 = v220[26] + v258;
        if ( v254 <= v250 )
        {
LABEL_218:
          if ( v220[1] == 16209 )
          {
LABEL_495:
            v12 = v9;
            v13 = v220;
            goto LABEL_51;
          }
          if ( !*((_WORD *)v220 + 314) )
          {
            v12 = v9;
            v13 = v220;
            *(_DWORD *)(a1 + 24) = "invalid code -- missing end-of-block";
            v220[1] = 16209;
            goto LABEL_51;
          }
          v220[22] = 9;
          v220[28] = v220 + 333;
          v220[20] = v220 + 333;
          if ( inflate_table(
                 1,
                 (unsigned __int16 *)v220 + 58,
                 v258,
                 v220 + 28,
                 v220 + 22,
                 (unsigned __int16 *)v220 + 378) )
          {
            v12 = v9;
            v13 = v220;
            *(_DWORD *)(a1 + 24) = "invalid literal/lengths set";
            v220[1] = 16209;
            goto LABEL_51;
          }
          v210 = v220[28];
          v220[23] = 6;
          v220[21] = v210;
          if ( inflate_table(
                 2,
                 (unsigned __int16 *)v220 + v220[25] + 58,
                 v220[26],
                 v220 + 28,
                 v220 + 23,
                 (unsigned __int16 *)v220 + 378) )
          {
            v12 = v9;
            v13 = v220;
            *(_DWORD *)(a1 + 24) = "invalid distances set";
            v220[1] = 16209;
            goto LABEL_51;
          }
          v11 = v220;
          v220[1] = 16199;
          if ( a2 == 6 )
          {
LABEL_473:
            v12 = v9;
            v219 = 0;
            v13 = v11;
            HIDWORD(v29) = v226 - v225;
            goto LABEL_85;
          }
          goto LABEL_247;
        }
        v93 = v222;
        v246 = v9;
        v241 = v220[20];
        v231 = ~(-1 << v220[22]);
        v94 = v216;
        while ( 1 )
        {
          v95 = v241 + 4 * (v93 & v231);
          v96 = *(_BYTE *)(v95 + 1);
          v97 = *(_WORD *)(v95 + 2);
          v98 = v96;
          if ( v96 > v8 )
          {
            if ( !v94 )
              goto LABEL_428;
            v99 = v246;
            v38 = v8;
            while ( 1 )
            {
              ++v99;
              --v94;
              v100 = *(v99 - 1) << v38;
              v38 += 8;
              v93 += v100;
              v101 = v241 + 4 * (v93 & v231);
              v102 = *(_BYTE *)(v101 + 1);
              v97 = *(_WORD *)(v101 + 2);
              v98 = v102;
              if ( v102 <= v38 )
                break;
              if ( !v94 )
              {
LABEL_333:
                v222 = v93;
                v12 = v99;
                v216 = v94;
                goto LABEL_83;
              }
            }
            v246 = v99;
            v103 = v102;
            v8 = v38;
            v96 = v103;
          }
          if ( v97 > 0xFu )
            break;
          v8 -= v98;
          v104 = v250;
          v93 >>= v96;
          v105 = v250 + 1;
          v220[27] = ++v250;
          *((_WORD *)v220 + v104 + 58) = v97;
LABEL_216:
          if ( v254 <= v105 )
          {
            v216 = v94;
            v9 = v246;
            v222 = v93;
            goto LABEL_218;
          }
        }
        if ( v97 == 16 )
        {
          if ( v98 + 2 > v8 )
          {
            if ( !v94 )
            {
LABEL_428:
              v13 = v220;
              v222 = v93;
              HIDWORD(v29) = v226 - v225;
              v12 = v246;
              v216 = v94;
              v219 = 0;
              goto LABEL_85;
            }
            v38 = v8;
            v99 = v246;
            while ( 1 )
            {
              ++v99;
              --v94;
              v193 = *(v99 - 1) << v38;
              v38 += 8;
              v93 += v193;
              if ( v98 + 2 <= v38 )
                break;
              if ( !v94 )
                goto LABEL_333;
            }
            v246 = v99;
            v8 = v38;
          }
          v8 -= v98;
          v93 >>= v98;
          if ( !v250 )
          {
LABEL_501:
            v216 = v94;
            v13 = v220;
            v222 = v93;
            v12 = v246;
            *(_DWORD *)(a1 + 24) = "invalid bit length repeat";
            v220[1] = 16209;
            goto LABEL_51;
          }
          v8 -= 2;
          v194 = v93;
          v93 >>= 2;
          v224 = *((_WORD *)v220 + v250 + 57);
          v217 = (v194 & 3) + 3;
        }
        else if ( v97 == 17 )
        {
          if ( v98 + 3 > v8 )
          {
            if ( !v94 )
              goto LABEL_428;
            v38 = v8;
            v99 = v246;
            v188 = v98;
            v189 = v98 + 3;
            while ( 1 )
            {
              ++v99;
              --v94;
              v190 = *(v99 - 1) << v38;
              v38 += 8;
              v93 += v190;
              if ( v38 >= v189 )
                break;
              if ( !v94 )
                goto LABEL_333;
            }
            v246 = v99;
            v98 = v188;
            v8 = v38;
          }
          v224 = 0;
          v217 = ((v93 >> v98) & 7) + 3;
          v93 = v93 >> v98 >> 3;
          v8 += -3 - v98;
        }
        else
        {
          if ( v98 + 7 > v8 )
          {
            if ( !v94 )
              goto LABEL_428;
            v38 = v8;
            v99 = v246;
            v167 = v98;
            v168 = v98 + 7;
            while ( 1 )
            {
              ++v99;
              --v94;
              v169 = *(v99 - 1) << v38;
              v38 += 8;
              v93 += v169;
              if ( v38 >= v168 )
                break;
              if ( !v94 )
                goto LABEL_333;
            }
            v246 = v99;
            v98 = v167;
            v8 = v38;
          }
          v224 = 0;
          v8 = v8 - v98 - 7;
          v217 = ((v93 >> v98) & 0x7F) + 11;
          v93 = v93 >> v98 >> 7;
        }
        v260 = v217 + v250;
        if ( v217 + v250 > v254 )
          goto LABEL_501;
        v261 = v250 + 58;
        v259 = v217 - 1;
        v170 = (((unsigned int)v220 + 2 * v250 + 116) >> 1) & 1;
        if ( (unsigned int)(v217 - 1) <= 3 )
        {
          *((_WORD *)v220 + v250 + 58) = v224;
          *((_WORD *)v220 + v250 + 59) = v224;
          v251 = v250 + 2;
          v175 = v217 - 3;
        }
        else
        {
          if ( v170 )
          {
            *((_WORD *)v220 + v250 + 58) = v224;
            v259 = v217 - 2;
            ++v250;
          }
          v218 = v217 - v170;
          v171 = (_DWORD *)((char *)v220 + 2 * v261 + 2 * v170);
          v172 = &v171[v218 >> 1];
          do
            *v171++ = (v224 << 16) | v224;
          while ( v172 != v171 );
          v173 = v259 - (v218 & 0xFFFFFFFE);
          v174 = (v218 & 0xFFFFFFFE) + v250;
          if ( (v218 & 0xFFFFFFFE) == v218 )
            goto LABEL_366;
          *((_WORD *)v220 + v174 + 58) = v224;
          if ( !v173 )
            goto LABEL_366;
          v251 = v174 + 2;
          *((_WORD *)v220 + v174 + 59) = v224;
          v175 = v173 - 2;
          if ( v173 == 1 )
            goto LABEL_366;
        }
        *((_WORD *)v220 + v251 + 58) = v224;
        if ( v175 )
          *((_WORD *)v220 + v251 + 59) = v224;
LABEL_366:
        v105 = v260;
        v250 = v260;
        v220[27] = v260;
        goto LABEL_216;
      }
      if ( v124 == 3 )
      {
        v13 = v220;
        v222 >>= 3;
        v8 -= 3;
        *(_DWORD *)(a1 + 24) = "invalid block type";
        v12 = v123;
        v220[1] = 16209;
        goto LABEL_51;
      }
      if ( v124 == 1 )
        break;
      v220[1] = 16193;
      v8 -= 3;
      v9 = v123;
      v222 >>= 3;
LABEL_256:
      v125 = v8;
      v8 &= 0xFFFFFFF8;
      v222 >>= v125 & 7;
      if ( v8 > 0x1F )
      {
        v128 = v9;
        v132 = v222;
      }
      else
      {
        if ( !v216 )
          goto LABEL_79;
        v126 = v8 + 8;
        v127 = v216 - 1;
        v222 += *v9 << v8;
        v128 = v9 + 1;
        v129 = v222;
        if ( v8 + 8 > 0x1F )
          goto LABEL_409;
        if ( v216 == 1 )
          goto LABEL_411;
        v130 = v9[1] << v126;
        v126 = v8 + 16;
        v127 = v216 - 2;
        v129 = v130 + v222;
        v128 = v9 + 2;
        v222 += v130;
        if ( v8 + 16 > 0x1F )
          goto LABEL_409;
        if ( v216 == 2 )
          goto LABEL_411;
        v131 = v9[2] << v126;
        v126 = v8 + 24;
        v127 = v216 - 3;
        v129 += v131;
        v128 = v9 + 3;
        v222 = v129;
        if ( v8 + 24 > 0x1F )
        {
LABEL_409:
          v8 = v126;
          v216 = v127;
          v132 = v129;
        }
        else
        {
          if ( v216 == 3 )
          {
LABEL_411:
            v13 = v220;
            v8 = v126;
            v12 = v128;
            goto LABEL_403;
          }
          v216 -= 4;
          v128 = v9 + 4;
          v8 += 32;
          v222 = (v9[3] << v126) + v129;
          v132 = v222;
        }
      }
      v58 = (unsigned __int16)v132;
      if ( (unsigned __int16)v132 != (HIWORD(v132) ^ 0xFFFF) )
      {
        v13 = v220;
        *(_DWORD *)(a1 + 24) = "invalid stored block lengths";
        v12 = v128;
        v220[1] = 16209;
        goto LABEL_51;
      }
      v220[17] = (unsigned __int16)v132;
      v220[1] = 16194;
      if ( a2 == 6 )
      {
        v13 = v220;
        v12 = v128;
        HIDWORD(v29) = v226 - v225;
        v219 = 0;
        v8 = 0;
        v222 = 0;
        goto LABEL_85;
      }
      v9 = v128;
      v8 = 0;
      v222 = 0;
      v86 = v220;
LABEL_190:
      v86[1] = 16195;
LABEL_110:
      if ( v58 )
      {
        Size = v58;
        if ( v216 <= v58 )
          Size = v216;
        if ( Size > v225 )
          Size = v225;
        v60 = Size;
        if ( Size )
        {
          Srcb = v9;
          v9 += Size;
          v61 = &v228[Size];
          memcpy(v228, Srcb, Size);
          v216 -= v60;
          v225 -= v60;
          v220[17] -= v60;
          v24 = v220[1];
          v228 = v61;
          goto LABEL_42;
        }
        goto LABEL_79;
      }
      v220[1] = 16191;
    }
    v220[20] = &lenfix_3603;
    v220[22] = 9;
    v220[21] = &distfix_3604;
    v220[23] = 5;
    v220[1] = 16199;
    if ( a2 == 6 )
    {
      v13 = v220;
      v222 >>= 3;
      v8 -= 3;
      v12 = v123;
      v219 = 0;
      HIDWORD(v29) = v226 - v225;
      goto LABEL_85;
    }
    v222 >>= 3;
    v8 -= 3;
    v9 = v123;
LABEL_247:
    v121 = v220;
LABEL_248:
    v121[1] = 16200;
LABEL_39:
    while ( 2 )
    {
      if ( v216 > 5 && v225 > 0x101 )
      {
        *(_DWORD *)(a1 + 16) = v225;
        *(_DWORD *)(a1 + 4) = v216;
        *(_DWORD *)a1 = v9;
        *(_DWORD *)(a1 + 12) = v228;
        v220[15] = v222;
        v220[16] = v8;
        inflate_fast((unsigned __int8 **)a1, v226);
        v8 = v220[16];
        v228 = *(char **)(a1 + 12);
        v225 = *(_DWORD *)(a1 + 16);
        v9 = *(unsigned __int8 **)a1;
        v216 = *(_DWORD *)(a1 + 4);
        v222 = v220[15];
        v24 = v220[1];
        if ( v24 != 16191 )
          goto LABEL_42;
        v220[1778] = -1;
        goto LABEL_78;
      }
      v133 = v220[22];
      v134 = v220[20];
      v220[1778] = 0;
      v243 = ~(-1 << v133);
      v135 = (char *)(v134 + 4 * (v243 & v222));
      v136 = v135[1];
      v137 = *v135;
      v138 = *((unsigned __int16 *)v135 + 1);
      v139 = v136;
      if ( v8 < v136 )
      {
        if ( !v216 )
          goto LABEL_79;
        v38 = v8;
        v67 = v216;
        v68 = v222;
        v233 = v134;
        while ( 1 )
        {
          ++v9;
          --v67;
          v140 = *(v9 - 1) << v38;
          v38 += 8;
          v68 += v140;
          v141 = v233 + 4 * (v68 & v243);
          LOBYTE(v140) = *(_BYTE *)v141;
          v142 = *(unsigned __int8 *)(v141 + 1);
          v138 = *(unsigned __int16 *)(v141 + 2);
          v223 = v140;
          v139 = v142;
          if ( v142 <= v38 )
            break;
          if ( !v67 )
            goto LABEL_297;
        }
        v216 = v67;
        v137 = v223;
        v222 = v68;
        v8 = v38;
        v136 = v142;
        v134 = v233;
      }
      v234 = v138;
      if ( !v137 )
      {
        v8 -= v139;
        v222 >>= v136;
        v220[1778] = v139;
        v220[17] = v138;
LABEL_401:
        v23 = v228;
        v220[1] = 16205;
LABEL_37:
        if ( !v225 )
          goto LABEL_453;
        ++v228;
        --v225;
        *v23 = v220[17];
        v220[1] = 16200;
        continue;
      }
      break;
    }
    if ( (v137 & 0xF0) != 0 )
    {
      v222 >>= v139;
      v8 -= v139;
      v220[1778] = v139;
      v220[17] = v138;
LABEL_278:
      if ( (v137 & 0x20) != 0 )
      {
        v220[1778] = -1;
        v220[1] = 16191;
        goto LABEL_78;
      }
      if ( (v137 & 0x40) != 0 )
      {
        v12 = v9;
        v13 = v220;
        *(_DWORD *)(a1 + 24) = "invalid literal/length code";
        v220[1] = 16209;
        goto LABEL_51;
      }
      v30 = v137 & 0xF;
      v220[19] = v30;
      v220[1] = 16201;
LABEL_53:
      if ( v30 )
      {
        if ( v8 < v30 )
        {
          if ( !v216 )
            goto LABEL_79;
          v38 = v8;
          v39 = v222;
          v40 = v216;
          while ( 1 )
          {
            ++v9;
            --v40;
            v166 = *(v9 - 1) << v38;
            v38 += 8;
            v39 += v166;
            if ( v38 >= v30 )
              break;
            if ( !v40 )
              goto LABEL_82;
          }
          v222 = v39;
          v216 = v40;
          v8 = v38;
        }
        v8 -= v30;
        v220[1778] += v30;
        v31 = v220[17] + (v222 & ~(-1 << v30));
        v220[17] = v31;
        v222 >>= v30;
      }
      else
      {
        v31 = v220[17];
      }
      v220[1779] = v31;
      v220[1] = 16202;
LABEL_56:
      v239 = v220[21];
      v245 = ~(-1 << v220[23]);
      v32 = (char *)(v239 + 4 * (v222 & v245));
      v33 = v32[1];
      v34 = *v32;
      v35 = *((_WORD *)v32 + 1);
      v36 = v33;
      v229 = v34;
      v37 = v33;
      if ( v8 < v33 )
      {
        if ( !v216 )
          goto LABEL_79;
        v38 = v8;
        v39 = v222;
        v40 = v216;
        while ( 1 )
        {
          ++v9;
          --v40;
          v41 = *(v9 - 1) << v38;
          v38 += 8;
          v39 += v41;
          v42 = (char *)(v239 + 4 * (v39 & v245));
          v229 = *v42;
          v33 = v42[1];
          v249 = *((_WORD *)v42 + 1);
          v36 = v33;
          v37 = v33;
          if ( v33 <= v38 )
            break;
          if ( !v40 )
            goto LABEL_82;
        }
        v222 = v39;
        v35 = v249;
        v216 = v40;
        v8 = v38;
      }
      v43 = v36;
      if ( (v229 & 0xF0) != 0 )
      {
        v44 = v220[1778];
      }
      else
      {
        v255 = v35;
        v252 = ~(-1 << (v36 + v229));
        v180 = (char *)(v239 + 4 * (v35 + ((v222 & v252) >> v33)));
        v37 = (unsigned __int8)v180[1];
        v35 = *((_WORD *)v180 + 1);
        v229 = *v180;
        if ( v8 < v37 + v36 )
        {
          if ( !v216 )
            goto LABEL_79;
          v247 = v36;
          v181 = v216;
          v182 = v222;
          while ( 1 )
          {
            ++v9;
            v183 = v8;
            v8 += 8;
            --v181;
            v182 += *(v9 - 1) << v183;
            v184 = (char *)(v239 + 4 * (v255 + ((v182 & v252) >> v247)));
            v37 = (unsigned __int8)v184[1];
            v229 = *v184;
            if ( v37 + v247 <= v8 )
              break;
            if ( !v181 )
            {
              v216 = 0;
              v12 = v9;
              goto LABEL_427;
            }
          }
          v222 = v182;
          v36 = v247;
          v216 = v181;
          v35 = *((_WORD *)v184 + 1);
        }
        v8 -= v36;
        v222 >>= v36;
        v43 = v37;
        v44 = v220[1778] + v36;
      }
      v222 >>= v43;
      v8 -= v37;
      v220[1778] = v43 + v44;
      if ( (v229 & 0x40) != 0 )
      {
        v12 = v9;
        v13 = v220;
        *(_DWORD *)(a1 + 24) = "invalid distance code";
        v220[1] = 16209;
        goto LABEL_51;
      }
      v220[1] = 16203;
      v220[18] = v35;
      v25 = v229 & 0xF;
      v220[19] = v25;
LABEL_44:
      if ( v25 )
      {
        if ( v8 < v25 )
        {
          if ( !v216 )
            goto LABEL_79;
          v38 = v8;
          v39 = v222;
          v40 = v216;
          while ( 1 )
          {
            ++v9;
            --v40;
            v176 = *(v9 - 1) << v38;
            v38 += 8;
            v39 += v176;
            if ( v38 >= v25 )
              break;
            if ( !v40 )
              goto LABEL_82;
          }
          v222 = v39;
          v216 = v40;
          v8 = v38;
        }
        v8 -= v25;
        v220[1778] += v25;
        v220[18] += v222 & ~(-1 << v25);
        v222 >>= v25;
      }
      v220[1] = 16204;
LABEL_46:
      if ( !v225 )
      {
LABEL_453:
        v12 = v9;
        HIDWORD(v29) = v226;
        v13 = v220;
        v219 = 0;
        goto LABEL_85;
      }
      v26 = v220[18];
      if ( v26 <= v226 - v225 )
      {
        v146 = &v228[-v26];
        v28 = v220[17];
        v147 = v28;
      }
      else
      {
        v27 = v26 + v225;
        v28 = v26 + v225 - v226;
        if ( v220[12] < v28 && v220[1777] )
        {
          v12 = v9;
          v13 = v220;
          *(_DWORD *)(a1 + 24) = "invalid distance too far back";
          v220[1] = 16209;
          goto LABEL_51;
        }
        v143 = v220[13];
        v144 = v226 - v27;
        v145 = v220[14];
        if ( v143 >= v28 )
        {
          v146 = (char *)(v144 + v143 + v145);
        }
        else
        {
          v28 -= v143;
          v146 = (char *)(v220[11] + v143 + v144 + v145);
        }
        v147 = v220[17];
        if ( v147 <= v28 )
          v28 = v220[17];
      }
      if ( v28 > v225 )
        v28 = v225;
      v225 -= v28;
      v220[17] = v147 - v28;
      if ( v28 - 1 <= 3
        || v146 < v228 + 4 && v228 < v146 + 4
        || (((unsigned __int8)v146 | (unsigned __int8)v228) & 3) != 0 )
      {
        v178 = v228;
        v179 = &v146[v28];
        do
          *v178++ = *v146++;
        while ( v146 != v179 );
      }
      else
      {
        v148 = 0;
        v149 = ((v28 - 4) >> 2) + 1;
        do
        {
          *(_DWORD *)&v228[4 * v148] = *(_DWORD *)&v146[4 * v148];
          ++v148;
        }
        while ( v148 < v149 );
        v150 = 4 * v149;
        v151 = &v146[v150];
        v152 = &v228[v150];
        v153 = v28 - v150;
        if ( v28 != v150 )
        {
          *v152 = *v151;
          if ( v153 != 1 )
          {
            v152[1] = v151[1];
            if ( v153 != 2 )
              v152[2] = v151[2];
          }
        }
      }
      v228 += v28;
      v121 = v220;
      if ( v220[17] )
      {
        v24 = v220[1];
LABEL_42:
        v4 = v24 - 16180;
        continue;
      }
      goto LABEL_248;
    }
    break;
  }
  v253 = ~(-1 << (v137 + v139));
  v196 = (char *)(v134 + 4 * (v138 + ((v222 & v253) >> v139)));
  v137 = *v196;
  v248 = *((_WORD *)v196 + 1);
  v197 = (unsigned __int8)v196[1];
  v256 = v139 + v197;
  if ( v8 >= v139 + v197 )
  {
LABEL_463:
    v8 = v8 - v139 - v197;
    v222 = v222 >> v139 >> v197;
    v220[1778] = v256;
    v220[17] = v248;
    if ( v137 )
      goto LABEL_278;
    goto LABEL_401;
  }
  if ( !v216 )
    goto LABEL_79;
  v257 = v134;
  v198 = v216;
  v244 = v139;
  v182 = v222;
  do
  {
    ++v9;
    v199 = v8;
    v8 += 8;
    --v198;
    v182 += *(v9 - 1) << v199;
    v200 = (char *)(v257 + 4 * (v234 + ((v182 & v253) >> v244)));
    v137 = *v200;
    v248 = *((_WORD *)v200 + 1);
    v197 = (unsigned __int8)v200[1];
    if ( v197 + v244 <= v8 )
    {
      v256 = v197 + v244;
      v216 = v198;
      v222 = v182;
      v139 = v244;
      goto LABEL_463;
    }
  }
  while ( v198 );
  v12 = v9;
  v216 = 0;
LABEL_427:
  v13 = v220;
  v222 = v182;
  HIDWORD(v29) = v226 - v225;
  v219 = 0;
LABEL_85:
  *(_DWORD *)(a1 + 12) = v228;
  *(_DWORD *)a1 = v12;
  *(_DWORD *)(a1 + 16) = v225;
  *(_DWORD *)(a1 + 4) = v216;
  v13[16] = v8;
  v53 = v13[11];
  v13[15] = v222;
  if ( !v53 && (v226 == v225 || (v54 = v13[1], v54 > 0x3F50) || a2 == 4 && v54 > 0x3F4D) )
  {
LABEL_92:
    *(_DWORD *)(a1 + 20) += HIDWORD(v29);
    *(_DWORD *)(a1 + 8) += v227 - v216;
    v13[8] += HIDWORD(v29);
    if ( (v13[3] & 4) != 0 && HIDWORD(v29) )
    {
      Src = (_BYTE *)(*(_DWORD *)(a1 + 12) + v225 - v226);
      v211 = (void *)v13[7];
      if ( v13[5] )
        v57 = crc32((int)v211, Src, HIDWORD(v29));
      else
        v57 = adler32(v211, Src, HIDWORD(v29));
      v13[7] = v57;
      *(_DWORD *)(a1 + 48) = v57;
    }
    v55 = v13[16];
    if ( v13[2] )
      v55 += 64;
    v56 = v13[1];
    if ( v56 == 16191 )
    {
      v55 += 128;
    }
    else if ( v56 == 16199 || v56 == 16194 )
    {
      v55 += 256;
    }
    *(_DWORD *)(a1 + 44) = v55;
    LODWORD(v29) = v227 - v216;
    if ( (!v29 || a2 == 4) && !v219 )
      return -5;
  }
  else
  {
    if ( !updatewindow(HIDWORD(v29), a1, (size_t)v228) )
    {
      v216 = *(_DWORD *)(a1 + 4);
      v225 = *(_DWORD *)(a1 + 16);
      HIDWORD(v29) = v226 - v225;
      goto LABEL_92;
    }
    v13[1] = 16210;
    return -4;
  }
  return v219;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);
// 514C1E: using guessed type __int16 word_514C1E[];

//----- (0042E0C0) --------------------------------------------------------
int __cdecl inflateCodesUsed(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int result; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -1;
  v1 = (_DWORD *)a1[7];
  result = -1;
  if ( v1 && a1 == (_DWORD *)*v1 && (unsigned int)(v1[1] - 16180) <= 0x1F )
    return (v1[28] - (int)(v1 + 333)) >> 2;
  return result;
}

//----- (0042E110) --------------------------------------------------------
int __cdecl inflateCopy(_DWORD *a1, _DWORD *a2)
{
  int (__cdecl *v2)(_DWORD, int, int); // edx
  int v3; // ebp
  int result; // eax
  _DWORD *v5; // edx
  int v6; // eax
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  int v9; // esi
  void *v10; // [esp+18h] [ebp-24h]
  _DWORD *v11; // [esp+1Ch] [ebp-20h]
  _DWORD *v12; // [esp+1Ch] [ebp-20h]

  if ( !a2 )
    return -2;
  v2 = (int (__cdecl *)(_DWORD, int, int))a2[8];
  if ( !v2 || !a2[9] )
    return -2;
  v3 = a2[7];
  result = -2;
  if ( v3 && a2 == *(_DWORD **)v3 )
  {
    if ( (unsigned int)(*(_DWORD *)(v3 + 4) - 16180) <= 0x1F && a1 )
    {
      v5 = (_DWORD *)v2(a2[10], 1, 7120);
      if ( !v5 )
        return -4;
      v10 = *(void **)(v3 + 56);
      if ( v10 )
      {
        v11 = v5;
        v6 = ((int (__cdecl *)(_DWORD, int, int))a2[8])(a2[10], 1 << *(_DWORD *)(v3 + 40), 1);
        v5 = v11;
        v10 = (void *)v6;
        if ( !v6 )
        {
          ((void (__cdecl *)(_DWORD, _DWORD *))a2[9])(a2[10], v11);
          return -4;
        }
        *a1 = *a2;
        a1[1] = a2[1];
        a1[2] = a2[2];
        a1[3] = a2[3];
        a1[4] = a2[4];
        a1[5] = a2[5];
        a1[6] = a2[6];
        a1[7] = a2[7];
        a1[8] = a2[8];
        a1[9] = a2[9];
        a1[10] = a2[10];
        a1[11] = a2[11];
        a1[12] = a2[12];
        a1[13] = a2[13];
        *v11 = *(_DWORD *)v3;
        v11[1779] = *(_DWORD *)(v3 + 7116);
        v7 = v11 + 333;
        qmemcpy(
          (void *)((unsigned int)(v11 + 1) & 0xFFFFFFFC),
          (const void *)(v3 - ((_DWORD)v11 - ((unsigned int)(v11 + 1) & 0xFFFFFFFC))),
          4 * (((unsigned int)v11 - ((unsigned int)(v11 + 1) & 0xFFFFFFFC) + 7120) >> 2));
        v8 = *(_DWORD *)(v3 + 80);
        v9 = v3 + 1332;
        *v11 = a1;
        if ( v3 + 1332 > v8 )
        {
          v11[28] = (char *)v7 + *(_DWORD *)(v3 + 112) - v9;
LABEL_13:
          v12 = v5;
          memcpy(v10, *(const void **)(v3 + 56), 1 << *(_DWORD *)(v3 + 40));
          v5 = v12;
LABEL_14:
          v5[14] = v10;
          result = 0;
          a1[7] = v5;
          return result;
        }
      }
      else
      {
        *a1 = *a2;
        a1[1] = a2[1];
        a1[2] = a2[2];
        a1[3] = a2[3];
        a1[4] = a2[4];
        a1[5] = a2[5];
        a1[6] = a2[6];
        a1[7] = a2[7];
        a1[8] = a2[8];
        a1[9] = a2[9];
        a1[10] = a2[10];
        a1[11] = a2[11];
        a1[12] = a2[12];
        a1[13] = a2[13];
        *v5 = *(_DWORD *)v3;
        v5[1779] = *(_DWORD *)(v3 + 7116);
        v7 = v5 + 333;
        qmemcpy(
          (void *)((unsigned int)(v5 + 1) & 0xFFFFFFFC),
          (const void *)(v3 - ((_DWORD)v5 - ((unsigned int)(v5 + 1) & 0xFFFFFFFC))),
          4 * (((unsigned int)v5 - ((unsigned int)(v5 + 1) & 0xFFFFFFFC) + 7120) >> 2));
        v8 = *(_DWORD *)(v3 + 80);
        v9 = v3 + 1332;
        *v5 = a1;
        if ( v8 < v3 + 1332 )
        {
          v5[28] = (char *)v7 + *(_DWORD *)(v3 + 112) - v9;
          goto LABEL_14;
        }
      }
      if ( v8 <= v3 + 7104 )
      {
        v5[20] = (char *)v7 + v8 - v9;
        v5[21] = (char *)v7 + *(_DWORD *)(v3 + 84) - v9;
      }
      v5[28] = (char *)v7 + *(_DWORD *)(v3 + 112) - v9;
      if ( !v10 )
        goto LABEL_14;
      goto LABEL_13;
    }
    return -2;
  }
  return result;
}

//----- (0042E3C0) --------------------------------------------------------
int __cdecl inflateEnd(_DWORD *a1)
{
  void (__cdecl *v1)(int, _DWORD *); // ecx
  _DWORD *v2; // edx
  int result; // eax
  _DWORD *v4; // esi
  int v5; // eax

  if ( !a1 )
    return -2;
  if ( !a1[8] )
    return -2;
  v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
  if ( !v1 )
    return -2;
  v2 = (_DWORD *)a1[7];
  result = -2;
  if ( v2 && a1 == (_DWORD *)*v2 && (unsigned int)(v2[1] - 16180) <= 0x1F )
  {
    v4 = (_DWORD *)v2[14];
    v5 = a1[10];
    if ( v4 )
    {
      v1(a1[10], v4);
      v1 = (void (__cdecl *)(int, _DWORD *))a1[9];
      v2 = (_DWORD *)a1[7];
      v5 = a1[10];
    }
    v1(v5, v2);
    a1[7] = 0;
    return 0;
  }
  return result;
}

//----- (0042E440) --------------------------------------------------------
int __cdecl inflateGetDictionary(_DWORD *a1, char *a2, _DWORD *a3)
{
  int v3; // ebx
  int result; // eax
  int v5; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v3 = a1[7];
  result = -2;
  if ( v3 && a1 == *(_DWORD **)v3 && (unsigned int)(*(_DWORD *)(v3 + 4) - 16180) <= 0x1F )
  {
    v5 = *(_DWORD *)(v3 + 48);
    if ( v5 && a2 )
    {
      memcpy(a2, (const void *)(*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 52)), v5 - *(_DWORD *)(v3 + 52));
      memcpy(&a2[*(_DWORD *)(v3 + 48) - *(_DWORD *)(v3 + 52)], *(const void **)(v3 + 56), *(_DWORD *)(v3 + 52));
    }
    result = 0;
    if ( a3 )
      *a3 = *(_DWORD *)(v3 + 48);
  }
  return result;
}

//----- (0042E500) --------------------------------------------------------
int __cdecl inflateGetHeader(_DWORD *a1, int a2)
{
  int v2; // ecx
  int result; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v2 = a1[7];
  result = -2;
  if ( v2
    && a1 == *(_DWORD **)v2
    && (unsigned int)(*(_DWORD *)(v2 + 4) - 16180) <= 0x1F
    && (*(_BYTE *)(v2 + 12) & 2) != 0 )
  {
    *(_DWORD *)(v2 + 36) = a2;
    result = 0;
    *(_DWORD *)(a2 + 48) = 0;
  }
  return result;
}

//----- (0042E560) --------------------------------------------------------
int __cdecl inflateInit2_(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  void *(__cdecl *v4)(size_t, int, int); // eax
  size_t v5; // edx
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  int result; // eax
  int v9; // [esp+1Ch] [ebp-10h]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v4 = (void *(__cdecl *)(size_t, int, int))a1[8];
  a1[6] = 0;
  if ( v4 )
  {
    v5 = a1[10];
  }
  else
  {
    a1[8] = zcalloc;
    v5 = 0;
    v4 = zcalloc;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = zcfree;
  v6 = (_DWORD *)v4(v5, 1, 7120);
  v7 = v6;
  if ( !v6 )
    return -4;
  a1[7] = v6;
  *v6 = a1;
  v6[14] = 0;
  v6[1] = 16180;
  result = inflateReset2(a1, a2);
  if ( result )
  {
    v9 = result;
    ((void (__cdecl *)(_DWORD, _DWORD *))a1[9])(a1[10], v7);
    a1[7] = 0;
    return v9;
  }
  return result;
}

//----- (0042E660) --------------------------------------------------------
int __cdecl inflateInit_(_DWORD *a1, _BYTE *a2, int a3)
{
  void *(__cdecl *v3)(size_t, int, int); // eax
  size_t v4; // edx
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  int v7; // edx
  void (__cdecl *v8)(_DWORD, _DWORD *); // eax
  int v9; // edi
  int v11; // ecx

  if ( !a2 || *a2 != 49 || a3 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v3 = (void *(__cdecl *)(size_t, int, int))a1[8];
  a1[6] = 0;
  if ( v3 )
  {
    v4 = a1[10];
    if ( a1[9] )
      goto LABEL_7;
  }
  else
  {
    v11 = a1[9];
    a1[8] = zcalloc;
    v4 = 0;
    v3 = zcalloc;
    a1[10] = 0;
    if ( v11 )
      goto LABEL_7;
  }
  a1[9] = zcfree;
LABEL_7:
  v5 = (_DWORD *)v3(v4, 1, 7120);
  v6 = v5;
  if ( !v5 )
    return -4;
  v7 = a1[8];
  a1[7] = v5;
  *v5 = a1;
  v5[14] = 0;
  v5[1] = 16180;
  v8 = (void (__cdecl *)(_DWORD, _DWORD *))a1[9];
  if ( v7 && v8 )
  {
    v6[3] = 5;
    v6[10] = 15;
    v9 = inflateReset(a1);
    if ( !v9 )
      return v9;
    ((void (__cdecl *)(_DWORD, _DWORD *))a1[9])(a1[10], v6);
  }
  else
  {
    v9 = -2;
    v8(a1[10], v6);
  }
  a1[7] = 0;
  return v9;
}

//----- (0042E790) --------------------------------------------------------
int __cdecl inflateMark(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int result; // eax
  int v3; // edx

  if ( !a1 || !a1[8] || !a1[9] )
    return -65536;
  v1 = (_DWORD *)a1[7];
  result = -65536;
  if ( v1 )
  {
    if ( a1 == (_DWORD *)*v1 )
    {
      v3 = v1[1];
      if ( (unsigned int)(v3 - 16180) <= 0x1F )
      {
        result = v1[1778] << 16;
        if ( v3 == 16195 )
        {
          result += v1[17];
        }
        else if ( v3 == 16204 )
        {
          return v1[1779] + result - v1[17];
        }
      }
    }
  }
  return result;
}

//----- (0042E810) --------------------------------------------------------
int __cdecl inflatePrime(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // ebx
  int result; // eax
  int v5; // esi

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v3 = (_DWORD *)a1[7];
  result = -2;
  if ( v3 && a1 == (_DWORD *)*v3 && (unsigned int)(v3[1] - 16180) <= 0x1F )
  {
    if ( a2 < 0 )
    {
      v3[15] = 0;
      result = 0;
      v3[16] = 0;
    }
    else if ( a2 <= 16 )
    {
      v5 = v3[16];
      if ( (unsigned int)(a2 + v5) <= 0x20 )
      {
        v3[16] = a2 + v5;
        v3[15] += (a3 & ((1 << a2) - 1)) << v5;
        return 0;
      }
    }
  }
  return result;
}

//----- (0042E8B0) --------------------------------------------------------
int __cdecl inflateReset(_DWORD *a1)
{
  _DWORD *v1; // edx
  int result; // eax
  int v3; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v1 = (_DWORD *)a1[7];
  result = -2;
  if ( v1 && a1 == (_DWORD *)*v1 && (unsigned int)(v1[1] - 16180) <= 0x1F )
  {
    v3 = v1[3];
    v1[11] = 0;
    v1[12] = 0;
    v1[13] = 0;
    v1[8] = 0;
    a1[5] = 0;
    a1[2] = 0;
    a1[6] = 0;
    if ( v3 )
      a1[12] = v3 & 1;
    v1[1] = 16180;
    v1[28] = v1 + 333;
    v1[21] = v1 + 333;
    v1[20] = v1 + 333;
    result = 0;
    v1[2] = 0;
    v1[4] = 0;
    v1[6] = 0x8000;
    v1[9] = 0;
    v1[15] = 0;
    v1[16] = 0;
    v1[1777] = 1;
    v1[1778] = -1;
  }
  return result;
}

//----- (0042E9A0) --------------------------------------------------------
int __cdecl inflateReset2(_DWORD *a1, int a2)
{
  int v2; // ebx
  void (__cdecl *v3)(_DWORD, _DWORD); // eax
  _DWORD *v4; // edi
  int v6; // ebp

  v2 = a2;
  if ( !a1 )
    return -2;
  if ( !a1[8] )
    return -2;
  v3 = (void (__cdecl *)(_DWORD, _DWORD))a1[9];
  if ( !v3 )
    return -2;
  v4 = (_DWORD *)a1[7];
  if ( !v4 || a1 != (_DWORD *)*v4 || (unsigned int)(v4[1] - 16180) > 0x1F )
    return -2;
  if ( a2 < 0 )
  {
    v2 = -a2;
    v6 = 0;
  }
  else
  {
    v6 = (a2 >> 4) + 5;
    if ( a2 < 48 )
      v2 = a2 & 0xF;
  }
  if ( (unsigned int)(v2 - 8) > 7 && v2 )
    return -2;
  if ( v4[14] )
  {
    if ( v2 != v4[10] )
    {
      v3(a1[10], v4[14]);
      v4[14] = 0;
    }
  }
  v4[3] = v6;
  v4[10] = v2;
  return inflateReset(a1);
}

//----- (0042EA60) --------------------------------------------------------
int __cdecl inflateResetKeep(_DWORD *a1)
{
  _DWORD *v1; // edx
  int result; // eax
  int v3; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v1 = (_DWORD *)a1[7];
  result = -2;
  if ( v1 && a1 == (_DWORD *)*v1 && (unsigned int)(v1[1] - 16180) <= 0x1F )
  {
    v3 = v1[3];
    v1[8] = 0;
    a1[5] = 0;
    a1[2] = 0;
    a1[6] = 0;
    if ( v3 )
      a1[12] = v3 & 1;
    v1[1] = 16180;
    v1[28] = v1 + 333;
    v1[21] = v1 + 333;
    v1[20] = v1 + 333;
    result = 0;
    v1[2] = 0;
    v1[4] = 0;
    v1[6] = 0x8000;
    v1[9] = 0;
    v1[15] = 0;
    v1[16] = 0;
    v1[1777] = 1;
    v1[1778] = -1;
  }
  return result;
}

//----- (0042EB30) --------------------------------------------------------
int __cdecl inflateSetDictionary(_DWORD *a1, int a2, size_t Size)
{
  _DWORD *v3; // esi
  int result; // eax
  int v5; // edx
  int v6; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v3 = (_DWORD *)a1[7];
  result = -2;
  if ( v3 )
  {
    if ( a1 == (_DWORD *)*v3 )
    {
      v5 = v3[1];
      if ( (unsigned int)(v5 - 16180) <= 0x1F )
      {
        if ( v3[3] )
        {
          if ( v5 != 16190 )
            return result;
        }
        else if ( v5 != 16190 )
        {
LABEL_11:
          result = updatewindow(Size, (int)a1, Size + a2);
          if ( result )
          {
            v3[1] = 16210;
            return -4;
          }
          else
          {
            v3[4] = 1;
          }
          return result;
        }
        v6 = adler32(0, 0, 0);
        if ( v3[7] != adler32(v6, a2, Size) )
          return -3;
        goto LABEL_11;
      }
    }
  }
  return result;
}
// 425CD0: using guessed type int __cdecl adler32(_DWORD, _DWORD, _DWORD);

//----- (0042EC30) --------------------------------------------------------
int __cdecl inflateSync(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // edi
  int result; // eax
  int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  int v7; // esi
  int v8; // edx
  char v9; // cl
  unsigned int v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // edx
  unsigned int v15; // ebp
  unsigned int v16; // eax
  bool v17; // cf
  bool v18; // zf
  char v19; // cl
  char v20; // bl
  int v21; // edx
  _DWORD *v22; // edi
  bool v23; // cl
  char v24; // bl
  int v25; // esi
  int v26; // esi
  int v27; // edi
  int v28; // eax
  int v29; // edx
  char v30; // cl
  _DWORD *v31; // [esp+4h] [ebp-28h]
  bool v32; // [esp+8h] [ebp-24h]
  char v33[20]; // [esp+18h] [ebp-14h]

  v1 = a1;
  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v2 = (_DWORD *)a1[7];
  result = -2;
  v31 = v2;
  if ( v2 )
  {
    if ( a1 == (_DWORD *)*v2 )
    {
      v4 = v2[1];
      if ( (unsigned int)(v4 - 16180) <= 0x1F )
      {
        v5 = a1[1];
        if ( !v5 )
        {
          v6 = v2[16];
          if ( v6 <= 7 )
            return -5;
          v7 = *a1;
          if ( v4 == 16211 )
          {
            v16 = v2[27];
            v21 = 0;
            goto LABEL_34;
          }
          v8 = v2[15];
          v9 = v2[16];
          v10 = v6 & 0xFFFFFFF8;
          v2[1] = 16211;
          v2[16] = v10;
          v11 = v8 << (v9 & 7);
          v2[15] = v11;
LABEL_12:
          v33[0] = v11;
          v12 = v11 >> 8;
          if ( v10 - 8 > 7 )
          {
            v33[1] = BYTE1(v11);
            v12 = HIWORD(v11);
            if ( v10 - 16 > 7 )
            {
              v13 = HIBYTE(v11);
              v33[2] = v12;
              v12 = v13;
              if ( v10 - 24 > 7 )
              {
                v33[3] = v13;
                v12 = 0;
              }
            }
          }
          v14 = 0;
          v15 = ((v10 - 8) >> 3) + 1;
          v2[15] = v12;
          v2[16] = 0;
          v16 = 0;
          while ( 1 )
          {
            v20 = v33[v14];
            if ( v20 == -(v16 >= 2) )
            {
              v19 = ++v16 <= 3;
              if ( v15 <= ++v14 )
                goto LABEL_23;
            }
            else
            {
              if ( v20 )
              {
                v19 = 1;
                v16 = 0;
              }
              else
              {
                v17 = 4 - v16 < 3;
                v18 = v16 == 1;
                v16 = 4 - v16;
                v19 = v17 || v18;
              }
              if ( v15 <= ++v14 )
              {
LABEL_23:
                v1 = a1;
                goto LABEL_24;
              }
            }
            if ( !v19 )
              goto LABEL_23;
          }
        }
        v7 = *a1;
        if ( v4 == 16211 )
        {
          v16 = v2[27];
          v19 = v16 <= 3;
        }
        else
        {
          v28 = v2[16];
          v29 = v2[15];
          v2[1] = 16211;
          v30 = v28;
          v10 = v28 & 0xFFFFFFF8;
          v2[16] = v10;
          v11 = v29 << (v30 & 7);
          v2[15] = v11;
          if ( v10 > 7 )
            goto LABEL_12;
          v19 = 1;
          v16 = 0;
LABEL_24:
          v2[27] = v16;
          v5 = v1[1];
        }
        v32 = v19 & (v5 != 0);
        v21 = 0;
        if ( v32 )
        {
          v22 = v1;
          while ( 1 )
          {
            v24 = *(_BYTE *)(v7 + v21);
            if ( v24 == -(v16 >= 2) )
            {
              v23 = ++v16 <= 3;
              if ( v5 <= ++v21 )
                goto LABEL_33;
            }
            else
            {
              if ( v24 )
              {
                v23 = v32;
                v16 = 0;
              }
              else
              {
                v17 = 4 - v16 < 3;
                v18 = v16 == 1;
                v16 = 4 - v16;
                v23 = v17 || v18;
              }
              if ( v5 <= ++v21 )
              {
LABEL_33:
                v1 = v22;
                v7 += v21;
                break;
              }
            }
            if ( !v23 )
              goto LABEL_33;
          }
        }
LABEL_34:
        v31[27] = v16;
        *v1 = v7;
        v25 = v1[2];
        v1[1] -= v21;
        v26 = v21 + v25;
        v1[2] = v26;
        if ( v16 == 4 )
        {
          v27 = v1[5];
          inflateReset(v1);
          v1[2] = v26;
          result = 0;
          v1[5] = v27;
          v31[1] = 16191;
        }
        else
        {
          return -3;
        }
      }
    }
  }
  return result;
}

//----- (0042EEB0) --------------------------------------------------------
int __cdecl inflateSyncPoint(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int result; // eax
  int v3; // edx

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v1 = (_DWORD *)a1[7];
  result = -2;
  if ( v1 )
  {
    if ( a1 == (_DWORD *)*v1 )
    {
      v3 = v1[1];
      if ( (unsigned int)(v3 - 16180) <= 0x1F )
      {
        result = 0;
        if ( v3 == 16193 )
          return v1[16] == 0;
      }
    }
  }
  return result;
}

//----- (0042EF20) --------------------------------------------------------
int __cdecl inflateUndermine(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int result; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v1 = (_DWORD *)a1[7];
  result = -2;
  if ( v1 && a1 == (_DWORD *)*v1 && (unsigned int)(v1[1] - 16180) <= 0x1F )
  {
    v1[1777] = 1;
    return -3;
  }
  return result;
}

//----- (0042EF70) --------------------------------------------------------
int __cdecl inflateValidate(_DWORD *a1, int a2)
{
  _DWORD *v2; // ecx
  int result; // eax
  int v4; // eax

  if ( !a1 || !a1[8] || !a1[9] )
    return -2;
  v2 = (_DWORD *)a1[7];
  result = -2;
  if ( v2 && a1 == (_DWORD *)*v2 && (unsigned int)(v2[1] - 16180) <= 0x1F )
  {
    v4 = v2[3];
    if ( a2 )
      v2[3] = v4 | 4;
    else
      v2[3] = v4 & 0xFFFFFFFB;
    return 0;
  }
  return result;
}

//----- (0042EFE0) --------------------------------------------------------
int __cdecl inflate_fast(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // edi
  unsigned int v3; // ebp
  unsigned __int8 *v4; // edx
  int v5; // edx
  unsigned int v6; // ebx
  int v7; // eax
  char v8; // cl
  char *v9; // ecx
  char v10; // si
  unsigned int v11; // eax
  int v12; // ecx
  char v13; // cl
  unsigned __int16 v14; // si
  char *v15; // ecx
  char v16; // al
  int v17; // ecx
  unsigned __int16 v18; // di
  unsigned __int8 v19; // al
  char v20; // cl
  char *v21; // ecx
  char v22; // al
  int v23; // esi
  int v24; // ecx
  unsigned int v25; // ebx
  char v26; // cl
  char *v27; // ecx
  int v28; // ecx
  unsigned __int8 v29; // al
  char v30; // cl
  int v31; // esi
  unsigned int v32; // esi
  _BYTE *v33; // edi
  unsigned __int8 *v34; // esi
  unsigned int v35; // edi
  unsigned int v36; // ecx
  unsigned __int8 *v37; // eax
  int v38; // edi
  unsigned __int8 v39; // dl
  char v40; // dl
  unsigned __int8 *v41; // edx
  int result; // eax
  int v43; // eax
  char v44; // cl
  unsigned __int8 *v45; // edi
  int *v46; // eax
  int v47; // edx
  unsigned __int8 *v48; // edi
  int v49; // ecx
  unsigned __int8 *v50; // esi
  unsigned __int8 *v51; // edi
  unsigned int v52; // esi
  unsigned __int8 *v53; // edx
  unsigned __int8 *i; // ecx
  unsigned __int8 *v55; // eax
  unsigned __int8 *v56; // edi
  unsigned int v57; // ecx
  unsigned int v58; // edi
  int v59; // edi
  unsigned __int8 *v60; // esi
  unsigned int v61; // eax
  int v62; // ecx
  unsigned int v63; // eax
  unsigned int v64; // ecx
  int v65; // ecx
  unsigned __int8 *v66; // eax
  unsigned __int8 *v67; // esi
  unsigned int v68; // edi
  unsigned __int8 *v69; // edi
  unsigned __int8 *v70; // eax
  unsigned __int8 *v71; // edi
  unsigned __int8 *v72; // eax
  unsigned __int8 *v73; // edi
  unsigned __int8 *v74; // eax
  unsigned int v75; // esi
  int *v76; // ecx
  int v77; // eax
  unsigned int v78; // esi
  int v79; // edx
  unsigned __int8 *v80; // edi
  unsigned __int8 *v81; // esi
  unsigned __int8 *v82; // [esp+0h] [ebp-80h]
  unsigned __int8 *v83; // [esp+4h] [ebp-7Ch]
  unsigned int v84; // [esp+8h] [ebp-78h]
  unsigned int v85; // [esp+8h] [ebp-78h]
  int v86; // [esp+8h] [ebp-78h]
  unsigned int v87; // [esp+Ch] [ebp-74h]
  unsigned int v88; // [esp+10h] [ebp-70h]
  unsigned __int8 *v89; // [esp+14h] [ebp-6Ch]
  int v90; // [esp+18h] [ebp-68h]
  unsigned int v91; // [esp+1Ch] [ebp-64h]
  int v92; // [esp+20h] [ebp-60h]
  _BYTE *v93; // [esp+24h] [ebp-5Ch]
  unsigned __int8 *v94; // [esp+24h] [ebp-5Ch]
  int v95; // [esp+24h] [ebp-5Ch]
  int v96; // [esp+28h] [ebp-58h]
  unsigned int v97; // [esp+2Ch] [ebp-54h]
  unsigned __int8 *v98; // [esp+30h] [ebp-50h]
  unsigned int v99; // [esp+34h] [ebp-4Ch]
  int v100; // [esp+38h] [ebp-48h]
  int v101; // [esp+3Ch] [ebp-44h]
  unsigned __int8 *v102; // [esp+44h] [ebp-3Ch]
  int v103; // [esp+48h] [ebp-38h]
  unsigned int v104; // [esp+4Ch] [ebp-34h]
  int v105; // [esp+54h] [ebp-2Ch]
  unsigned int v106; // [esp+54h] [ebp-2Ch]
  unsigned int v107; // [esp+58h] [ebp-28h]
  unsigned int v108; // [esp+5Ch] [ebp-24h]
  int v109; // [esp+60h] [ebp-20h]
  int v110; // [esp+64h] [ebp-1Ch]
  unsigned int v111; // [esp+64h] [ebp-1Ch]
  unsigned int v112; // [esp+6Ch] [ebp-14h]
  int v113; // [esp+6Ch] [ebp-14h]

  v2 = a1[7];
  v83 = *a1;
  v89 = v2;
  v3 = *((_DWORD *)v2 + 15);
  v87 = (unsigned int)&a1[1][(_DWORD)*a1 - 5];
  v97 = *((_DWORD *)v2 + 13);
  v4 = a1[4];
  v82 = a1[3];
  v88 = (unsigned int)&v4[(_DWORD)v82 - 257];
  v98 = &v4[(_DWORD)v82 - a2];
  v99 = *((_DWORD *)v2 + 12);
  v100 = *((_DWORD *)v2 + 11);
  v91 = *((_DWORD *)v2 + 14);
  v92 = *((_DWORD *)v2 + 21);
  v90 = ~(-1 << *((_DWORD *)v2 + 22));
  v5 = *((_DWORD *)v2 + 20);
  v96 = ~(-1 << *((_DWORD *)v2 + 23));
  v104 = v97 & 0xFFFFFFFC;
  v101 = v97 + v100;
  v6 = *((_DWORD *)v2 + 16);
  v103 = v97 - (v97 & 0xFFFFFFFC);
  v102 = (unsigned __int8 *)((v97 & 0xFFFFFFFC) + v91);
  while ( 1 )
  {
    if ( v6 <= 0xE )
    {
      v7 = v83[1] << (v6 + 8);
      v8 = v6;
      v6 += 16;
      v3 += (*v83 << v8) + v7;
      v83 += 2;
    }
    v9 = (char *)(v5 + 4 * (v3 & v90));
    v10 = *v9;
    v11 = *((unsigned __int16 *)v9 + 1);
    v12 = (unsigned __int8)v9[1];
    v3 >>= v12;
    v6 -= v12;
    v13 = v10;
    if ( !v10 )
    {
LABEL_12:
      *v82++ = v11;
      goto LABEL_13;
    }
    if ( (v10 & 0x10) == 0 )
      break;
LABEL_17:
    v85 = v11;
    v19 = v10 & 0xF;
    if ( (v10 & 0xF) != 0 )
    {
      if ( v19 > v6 )
      {
        v20 = v6;
        v6 += 8;
        v3 += *v83++ << v20;
      }
      v6 -= v19;
      v85 += v3 & ~(-1 << v19);
      v3 >>= v19;
    }
    if ( v6 <= 0xE )
    {
      v43 = v83[1] << (v6 + 8);
      v44 = v6;
      v6 += 16;
      v3 += (*v83 << v44) + v43;
      v83 += 2;
    }
    v21 = (char *)(v92 + 4 * (v3 & v96));
    v22 = *v21;
    v23 = *((unsigned __int16 *)v21 + 1);
    v24 = (unsigned __int8)v21[1];
    v3 >>= v24;
    v25 = v6 - v24;
    v26 = v22;
    if ( (v22 & 0x10) == 0 )
    {
      if ( (v22 & 0x40) != 0 )
      {
LABEL_48:
        v84 = v25;
        a1[6] = "invalid distance code";
        *((_DWORD *)v89 + 1) = 16209;
        goto LABEL_46;
      }
      while ( 1 )
      {
        v27 = (char *)(v92 + 4 * ((v3 & ~(-1 << v26)) + v23));
        v22 = *v27;
        v23 = *((unsigned __int16 *)v27 + 1);
        v28 = (unsigned __int8)v27[1];
        v3 >>= v28;
        v25 -= v28;
        v26 = v22;
        if ( (v22 & 0x10) != 0 )
          break;
        if ( (v22 & 0x40) != 0 )
          goto LABEL_48;
      }
    }
    v29 = v22 & 0xF;
    v105 = (unsigned __int16)v23;
    if ( v29 > v25 )
    {
      v30 = v25 + 8;
      v3 += *v83 << v25;
      if ( v29 > v25 + 8 )
      {
        v25 += 16;
        v3 += v83[1] << v30;
        v83 += 2;
      }
      else
      {
        ++v83;
        v25 += 8;
      }
    }
    v6 = v25 - v29;
    v31 = v3 & ~(-1 << v29);
    v3 >>= v29;
    v109 = v31;
    v32 = v105 + v31;
    v108 = v32;
    v93 = (_BYTE *)(v82 - v98);
    if ( v32 > v82 - v98 )
    {
      v107 = v32 - (v82 - v98);
      if ( v99 < v107 && *((_DWORD *)v89 + 1777) )
      {
        v84 = v6;
        a1[6] = "invalid distance too far back";
        *((_DWORD *)v89 + 1) = 16209;
        goto LABEL_46;
      }
      v33 = &v93[-v32];
      if ( v97 )
      {
        if ( v97 >= v107 )
        {
          v34 = &v33[v97 + v91];
          if ( v85 <= v107 )
            goto LABEL_36;
          v85 += (unsigned int)v33;
          v111 = (unsigned int)&v93[v97 - v105 - v109 + v91];
          if ( v107 - 1 <= 3
            || v111 < (unsigned int)(v82 + 4) && v82 < &v93[v97 + 4 - v105 - v109 + v91]
            || (((unsigned __int8)v111 | (unsigned __int8)v82) & 3) != 0 )
          {
            v73 = v82;
            v74 = &v34[v107];
            do
              *v73++ = *v34++;
            while ( v74 != v34 );
          }
          else
          {
            v57 = 0;
            v58 = ((v107 - 4) >> 2) + 1;
            do
            {
              *(_DWORD *)&v82[4 * v57] = *(_DWORD *)(v111 + 4 * v57);
              ++v57;
            }
            while ( v57 < v58 );
            v59 = 4 * v58;
            v60 = &v34[v59];
            v94 = &v82[v59];
            v61 = v107 - v59;
            if ( v107 != v59 )
            {
              *v94 = *v60;
              if ( v61 != 1 )
              {
                v94[1] = v60[1];
                if ( v61 != 2 )
                  v94[2] = v60[2];
              }
            }
          }
        }
        else
        {
          v110 = v107 - v97;
          v34 = &v33[v101 + v91];
          if ( v85 <= v107 - v97 )
            goto LABEL_36;
          v85 += (unsigned int)&v33[v97];
          v112 = (unsigned int)&v93[v101 - v105 - v109 + v91];
          if ( (unsigned int)(v110 - 1) <= 3
            || v112 < (unsigned int)(v82 + 4) && v82 < &v93[v97 + 4 + v100 - v105 - v109 + v91]
            || (v45 = v82, (((unsigned __int8)v82 | (unsigned __int8)v112) & 3) != 0) )
          {
            v71 = v82;
            v72 = &v34[v110];
            do
              *v71++ = *v34++;
            while ( v72 != v34 );
          }
          else
          {
            v46 = (int *)&v93[v101 - v105 - v109 + v91];
            v113 = v5;
            do
            {
              v47 = *v46;
              v45 += 4;
              ++v46;
              *((_DWORD *)v45 - 1) = v47;
            }
            while ( &v82[v110 & 0xFFFFFFFC] != v45 );
            v5 = v113;
            v48 = &v82[v110 & 0xFFFFFFFC];
            v49 = v110 - (v110 & 0xFFFFFFFC);
            v50 = &v34[v110 & 0xFFFFFFFC];
            if ( v110 != (v110 & 0xFFFFFFFC) )
            {
              *v48 = *v50;
              if ( v49 != 1 )
              {
                v48[1] = v50[1];
                if ( v49 != 2 )
                  v48[2] = v50[2];
              }
            }
          }
          v51 = &v82[v110];
          if ( v97 >= v85 )
          {
            v34 = (unsigned __int8 *)v91;
            v82 += v110;
            goto LABEL_36;
          }
          v85 -= v97;
          v75 = v105 - (v97 - (_DWORD)v98) + v109;
          if ( v97 - 1 <= 3
            || v91 < (unsigned int)&v98[4 - v97 + v105 + v109] && v75 < v91 + 4
            || (v76 = (int *)v91, (((unsigned __int8)v75 | (unsigned __int8)v91) & 3) != 0) )
          {
            v81 = (unsigned __int8 *)v91;
            do
              *v51++ = *v81++;
            while ( (unsigned __int8 *)(v91 + v97) != v81 );
          }
          else
          {
            v77 = v105 - (v97 - (_DWORD)v98) + v109;
            v95 = v5;
            v78 = v75 + (v97 & 0xFFFFFFFC);
            do
            {
              v79 = *v76;
              v77 += 4;
              ++v76;
              *(_DWORD *)(v77 - 4) = v79;
            }
            while ( v78 != v77 );
            v5 = v95;
            v80 = &v51[v104];
            if ( v97 != v104 )
            {
              *v80 = *v102;
              if ( v103 != 1 )
              {
                v80[1] = v102[1];
                if ( v103 != 2 )
                  v80[2] = v102[2];
              }
            }
          }
        }
      }
      else
      {
        v34 = &v33[v100 + v91];
        if ( v85 <= v107 )
        {
LABEL_36:
          v35 = v85;
          if ( v85 > 2 )
          {
            v36 = v85;
            v37 = v82;
            v38 = v5;
            do
            {
              v39 = *v34;
              v34 += 3;
              v37 += 3;
              v36 -= 3;
              *(v37 - 3) = v39;
              *(v37 - 2) = *(v34 - 2);
              *(v37 - 1) = *(v34 - 1);
            }
            while ( v36 > 2 );
            v5 = v38;
            v35 = v36;
            v82 = v37;
          }
          if ( v35 )
          {
            *v82 = *v34;
            if ( v35 == 2 )
            {
              v82[1] = v34[1];
              v82 += 2;
            }
            else
            {
              ++v82;
            }
          }
          goto LABEL_13;
        }
        v85 += (unsigned int)v33;
        v62 = v105;
        v106 = (unsigned int)&v93[v100 - v105 - v109 + v91];
        if ( v107 - 1 <= 3
          || v82 < &v93[v100 + 4 - v62 - v109 + v91] && v106 < (unsigned int)(v82 + 4)
          || (((unsigned __int8)v106 | (unsigned __int8)v82) & 3) != 0 )
        {
          v69 = v82;
          v70 = &v34[v107];
          do
            *v69++ = *v34++;
          while ( v70 != v34 );
        }
        else
        {
          v63 = 0;
          v64 = ((v107 - 4) >> 2) + 1;
          do
          {
            *(_DWORD *)&v82[4 * v63] = *(_DWORD *)(v106 + 4 * v63);
            ++v63;
          }
          while ( v63 < v64 );
          v65 = 4 * v64;
          v66 = &v82[v65];
          v67 = &v34[v65];
          v68 = v107 - v65;
          if ( v107 != v65 )
          {
            *v66 = *v67;
            if ( v68 != 1 )
            {
              v66[1] = v67[1];
              if ( v68 != 2 )
                v66[2] = v67[2];
            }
          }
        }
      }
      v82 += v107;
      v34 = &v82[-v108];
      goto LABEL_36;
    }
    v52 = v85;
    v86 = v5;
    v53 = v82;
    for ( i = &v82[-v108]; ; i += 3 )
    {
      v52 -= 3;
      *v53 = *i;
      v53[1] = i[1];
      v55 = v53 + 3;
      v53[2] = i[2];
      if ( v52 <= 2 )
        break;
      v53 += 3;
    }
    v56 = v53;
    v5 = v86;
    if ( v52 )
    {
      v56[3] = i[3];
      if ( v52 == 2 )
      {
        v56[4] = i[4];
        v82 = v56 + 5;
      }
      else
      {
        v82 = v56 + 4;
      }
    }
    else
    {
      v82 = v55;
    }
LABEL_13:
    if ( (unsigned int)v83 >= v87 || (unsigned int)v82 >= v88 )
    {
      v84 = v6;
      goto LABEL_46;
    }
  }
  if ( (v10 & 0x40) != 0 )
  {
    v84 = v6;
    v40 = v10;
  }
  else
  {
    v14 = v11;
    do
    {
      v15 = (char *)(v5 + 4 * ((v3 & ~(-1 << v13)) + v14));
      v16 = *v15;
      v14 = *((_WORD *)v15 + 1);
      v17 = (unsigned __int8)v15[1];
      v3 >>= v17;
      v6 -= v17;
      v13 = v16;
      if ( !v16 )
      {
        LOBYTE(v11) = v14;
        goto LABEL_12;
      }
      if ( (v16 & 0x10) != 0 )
      {
        v18 = v14;
        v10 = v16;
        v11 = v18;
        goto LABEL_17;
      }
    }
    while ( (v16 & 0x40) == 0 );
    v84 = v6;
    v40 = v16;
  }
  if ( (v40 & 0x20) != 0 )
  {
    *((_DWORD *)v89 + 1) = 16191;
  }
  else
  {
    a1[6] = "invalid literal/length code";
    *((_DWORD *)v89 + 1) = 16209;
  }
LABEL_46:
  v41 = &v83[-(v84 >> 3)];
  *a1 = v41;
  a1[3] = v82;
  result = v3 & ~(-1 << (v84 & 7));
  a1[1] = (unsigned __int8 *)(v87 - (_DWORD)v41 + 5);
  a1[4] = (unsigned __int8 *)(v88 - (_DWORD)v82 + 257);
  *((_DWORD *)v89 + 15) = result;
  *((_DWORD *)v89 + 16) = v84 & 7;
  return result;
}

//----- (0042F990) --------------------------------------------------------
int __cdecl inflate_table(int a1, unsigned __int16 *a2, int a3, int *a4, unsigned int *a5, unsigned __int16 *a6)
{
  unsigned int i; // eax
  unsigned __int16 *v7; // eax
  int v8; // edx
  _DWORD *v9; // eax
  int v10; // edx
  unsigned int v12; // ebp
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // esi
  unsigned int v27; // eax
  int j; // eax
  int v29; // edx
  int v30; // ebx
  unsigned int v31; // eax
  unsigned int v32; // ebp
  char v33; // di
  unsigned int v34; // eax
  __int16 v35; // si
  int v36; // eax
  int v37; // edx
  _DWORD *v38; // ecx
  int v39; // eax
  unsigned int k; // eax
  __int16 v41; // si
  int v42; // edi
  unsigned int v43; // ebx
  unsigned int v44; // ebx
  int v45; // edx
  unsigned int v46; // ecx
  unsigned int v47; // esi
  int v48; // edx
  unsigned int v49; // ebx
  int v50; // edx
  int v51; // edx
  unsigned int v52; // ebx
  int v53; // edx
  int v54; // edx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // edx
  unsigned int v58; // ebx
  int v59; // edx
  int v60; // edx
  unsigned int v61; // ebx
  int v62; // edx
  int v63; // edx
  unsigned int v64; // ebx
  int v65; // edx
  int v66; // edx
  unsigned int v67; // ebx
  int v68; // edx
  int v69; // edx
  unsigned int v70; // ebx
  int v71; // edx
  int v72; // edx
  unsigned int v73; // ebx
  int v74; // edx
  int v75; // edx
  unsigned int v76; // ebx
  int v77; // edx
  char v78; // bl
  int v79; // edx
  unsigned int v80; // ecx
  int v81; // edx
  int v82; // edx
  unsigned int v83; // ecx
  int v84; // edx
  int v85; // ebx
  unsigned int v86; // edx
  int v87; // edx
  unsigned int v88; // ebx
  unsigned int v89; // esi
  int v90; // edx
  int v91; // edx
  _DWORD *v92; // edx
  _DWORD *v93; // eax
  unsigned int v94; // [esp+4h] [ebp-94h]
  unsigned int v95; // [esp+8h] [ebp-90h]
  unsigned int v96; // [esp+Ch] [ebp-8Ch]
  unsigned __int16 *v97; // [esp+10h] [ebp-88h]
  char v98; // [esp+14h] [ebp-84h]
  _DWORD *v99; // [esp+20h] [ebp-78h]
  unsigned int v100; // [esp+24h] [ebp-74h]
  unsigned int v101; // [esp+28h] [ebp-70h]
  unsigned int v102; // [esp+2Ch] [ebp-6Ch]
  unsigned int v103; // [esp+30h] [ebp-68h]
  int v104; // [esp+30h] [ebp-68h]
  unsigned int v105; // [esp+34h] [ebp-64h]
  _BYTE *v106; // [esp+38h] [ebp-60h]
  _WORD *v107; // [esp+3Ch] [ebp-5Ch]
  _DWORD *v108; // [esp+40h] [ebp-58h]
  char v109; // [esp+44h] [ebp-54h]
  bool v110; // [esp+46h] [ebp-52h]
  bool v111; // [esp+47h] [ebp-51h]
  int v112; // [esp+48h] [ebp-50h]
  unsigned __int16 v113; // [esp+4Ch] [ebp-4Ch]
  unsigned __int16 v114; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v115; // [esp+50h] [ebp-48h]
  unsigned __int16 v116; // [esp+52h] [ebp-46h]
  unsigned __int16 v117; // [esp+54h] [ebp-44h]
  unsigned __int16 v118; // [esp+56h] [ebp-42h]
  unsigned __int16 v119; // [esp+58h] [ebp-40h]
  unsigned __int16 v120; // [esp+5Ah] [ebp-3Eh]
  unsigned __int16 v121; // [esp+5Ch] [ebp-3Ch]
  unsigned __int16 v122; // [esp+5Eh] [ebp-3Ah]
  unsigned __int16 v123; // [esp+60h] [ebp-38h]
  unsigned __int16 v124; // [esp+62h] [ebp-36h]
  unsigned __int16 v125; // [esp+64h] [ebp-34h]
  unsigned __int16 v126; // [esp+66h] [ebp-32h]
  __int16 v127[4]; // [esp+68h] [ebp-30h]
  __int16 v128; // [esp+70h] [ebp-28h]
  __int16 v129; // [esp+72h] [ebp-26h]
  __int16 v130; // [esp+74h] [ebp-24h]
  __int16 v131; // [esp+76h] [ebp-22h]
  __int16 v132; // [esp+78h] [ebp-20h]
  __int16 v133; // [esp+7Ah] [ebp-1Eh]
  __int16 v134; // [esp+7Ch] [ebp-1Ch]
  __int16 v135; // [esp+7Eh] [ebp-1Ah]
  __int16 v136; // [esp+80h] [ebp-18h]
  __int16 v137; // [esp+82h] [ebp-16h]
  __int16 v138; // [esp+84h] [ebp-14h]
  __int16 v139; // [esp+86h] [ebp-12h]

  for ( i = 0; i < 0x20; i += 4 )
    *(int *)((char *)&v112 + i) = 0;
  v7 = a2;
  if ( a3 )
  {
    do
    {
      v8 = *v7++;
      ++*((_WORD *)&v112 + v8);
    }
    while ( &a2[a3] != v7 );
  }
  if ( v126 )
  {
    if ( HIWORD(v112) )
    {
      v96 = 15;
      v12 = 1;
      goto LABEL_47;
    }
    v12 = 15;
  }
  else
  {
    if ( v125 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 14;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 14;
      if ( !v113 )
      {
        if ( !v114 )
          goto LABEL_26;
LABEL_83:
        v13 = 3;
LABEL_84:
        v96 = v12;
        v12 = v13;
        goto LABEL_47;
      }
LABEL_205:
      v13 = 2;
      goto LABEL_84;
    }
    if ( v124 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 13;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 13;
    }
    else if ( v123 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 12;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 12;
    }
    else if ( v122 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 11;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 11;
    }
    else if ( v121 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 10;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 10;
    }
    else if ( v120 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 9;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 9;
    }
    else if ( v119 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 8;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 8;
    }
    else if ( v118 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 7;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 7;
    }
    else if ( v117 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 6;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 6;
    }
    else if ( v116 )
    {
      if ( HIWORD(v112) )
      {
        v96 = 5;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 5;
    }
    else
    {
      if ( !v115 )
      {
        if ( !v114 )
        {
          if ( v113 )
          {
            v96 = 2;
            v12 = 2 - (HIWORD(v112) != 0);
          }
          else
          {
            if ( !HIWORD(v112) )
            {
              v9 = (_DWORD *)*a4;
              v10 = *a4 + 8;
              *v9 = 320;
              *a4 = v10;
              v9[1] = 320;
              *a5 = 1;
              return 0;
            }
            v96 = 1;
            v12 = 1;
          }
          goto LABEL_47;
        }
        if ( HIWORD(v112) )
        {
          v96 = 3;
          v12 = 1;
          goto LABEL_47;
        }
        if ( !v113 )
        {
          v96 = 3;
          v12 = 3;
          goto LABEL_47;
        }
        v12 = 3;
        goto LABEL_205;
      }
      if ( HIWORD(v112) )
      {
        v96 = 4;
        v12 = 1;
        goto LABEL_47;
      }
      v12 = 4;
    }
  }
  if ( v113 )
    goto LABEL_205;
  if ( v114 )
    goto LABEL_83;
  if ( v12 == 4 )
  {
    v96 = 4;
    goto LABEL_47;
  }
LABEL_26:
  if ( v115 )
  {
    v13 = 4;
    goto LABEL_84;
  }
  if ( v12 == 5 )
  {
    v96 = 5;
    goto LABEL_47;
  }
  if ( v116 )
  {
    v13 = 5;
    goto LABEL_84;
  }
  if ( v12 == 6 )
  {
    v96 = 6;
    goto LABEL_47;
  }
  if ( v117 )
  {
    v13 = 6;
    goto LABEL_84;
  }
  if ( v12 == 7 )
  {
    v96 = 7;
    goto LABEL_47;
  }
  if ( v118 )
  {
    v13 = 7;
    goto LABEL_84;
  }
  if ( v12 == 8 )
  {
    v96 = 8;
    goto LABEL_47;
  }
  if ( v119 )
  {
    v13 = 8;
    goto LABEL_84;
  }
  if ( v12 == 9 )
  {
    v96 = 9;
    goto LABEL_47;
  }
  if ( v120 )
  {
    v13 = 9;
    goto LABEL_84;
  }
  if ( v12 == 10 )
  {
    v96 = 10;
    goto LABEL_47;
  }
  if ( v121 )
  {
    v13 = 10;
    goto LABEL_84;
  }
  if ( v12 == 11 )
  {
    v96 = 11;
    goto LABEL_47;
  }
  if ( v122 )
  {
    v13 = 11;
    goto LABEL_84;
  }
  if ( v12 == 12 )
  {
    v96 = 12;
    goto LABEL_47;
  }
  if ( v123 )
  {
    v13 = 12;
    goto LABEL_84;
  }
  if ( v12 == 13 )
  {
    v96 = 13;
    goto LABEL_47;
  }
  if ( v124 )
  {
    v13 = 13;
    goto LABEL_84;
  }
  if ( v12 != 15 )
  {
    v96 = 14;
    v12 = 14;
    goto LABEL_47;
  }
  v96 = 15;
  v13 = 14;
  if ( v125 )
    goto LABEL_84;
LABEL_47:
  if ( 2 - HIWORD(v112) < 0 )
    return -1;
  v14 = 2 * (2 - HIWORD(v112)) - v113;
  if ( v14 < 0 )
    return -1;
  v15 = 2 * v14 - v114;
  if ( v15 < 0 )
    return -1;
  v16 = 2 * v15 - v115;
  if ( v16 < 0 )
    return -1;
  v17 = 2 * v16 - v116;
  if ( v17 < 0 )
    return -1;
  v18 = 2 * v17 - v117;
  if ( v18 < 0 )
    return -1;
  v19 = 2 * v18 - v118;
  if ( v19 < 0 )
    return -1;
  v20 = 2 * v19 - v119;
  if ( v20 < 0 )
    return -1;
  v21 = 2 * v20 - v120;
  if ( v21 < 0 )
    return -1;
  v22 = 2 * v21 - v121;
  if ( v22 < 0 )
    return -1;
  v23 = 2 * v22 - v122;
  if ( v23 < 0 )
    return -1;
  v24 = 2 * v23 - v123;
  if ( v24 < 0 )
    return -1;
  v25 = 2 * v24 - v124;
  if ( v25 < 0 )
    return -1;
  v26 = 2 * v25 - v125;
  if ( v26 < 0 || 2 * v26 - v126 < 0 || 2 * v26 != v126 && (!a1 || v96 != 1) )
    return -1;
  v127[2] = HIWORD(v112);
  v127[3] = v113 + HIWORD(v112);
  v128 = v114 + v113 + HIWORD(v112);
  v129 = v115 + v128;
  v130 = v116 + v115 + v128;
  v131 = v117 + v130;
  v132 = v118 + v117 + v130;
  v133 = v119 + v132;
  v134 = v120 + v119 + v132;
  v135 = v121 + v134;
  v136 = v122 + v121 + v134;
  v27 = *a5;
  v137 = v123 + v136;
  v127[1] = 0;
  v138 = v124 + v123 + v136;
  v103 = v27;
  v139 = v125 + v138;
  if ( a3 )
  {
    for ( j = 0; j != a3; ++j )
    {
      v29 = a2[j];
      if ( (_WORD)v29 )
      {
        v30 = (unsigned __int16)v127[v29];
        a6[v30] = j;
        v127[v29] = v30 + 1;
      }
    }
  }
  v31 = v103;
  if ( v103 > v96 )
    v31 = v96;
  if ( v12 >= v31 )
    v31 = v12;
  v100 = v31;
  v105 = 1 << v31;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      if ( v105 > 0x354 )
        return 1;
      v101 = 257;
      v106 = &lext_3509;
      v107 = &lbase_3508;
      v111 = 1;
      v110 = 0;
      goto LABEL_89;
    }
    v110 = a1 == 2;
    if ( v105 > 0x250 && a1 == 2 )
      return 1;
    v101 = 0;
    v106 = &dext_3511;
    v107 = &dbase_3510;
  }
  else
  {
    v101 = 20;
    v110 = 0;
    v106 = a6;
    v107 = a6;
  }
  v111 = a1 == 1;
LABEL_89:
  v94 = v12;
  v104 = -1;
  v95 = 0;
  v97 = a6;
  v108 = (_DWORD *)*a4;
  v32 = 0;
  v99 = (_DWORD *)*a4;
  v102 = 1 << v31;
  v98 = v31;
  while ( 1 )
  {
    v33 = 0;
    v109 = v94 - v95;
    v34 = *v97;
    v35 = *v97;
    if ( v34 + 1 >= v101 )
    {
      if ( v34 < v101 )
      {
        v35 = 0;
        v33 = 96;
      }
      else
      {
        v36 = v34 - v101;
        v33 = v106[2 * v36];
        v35 = v107[v36];
      }
    }
    v37 = 1 << (v94 - v95);
    v38 = &v99[(v32 >> v95) + (1 << v98) - v37];
    v39 = 1 << v98;
    do
    {
      *((_WORD *)v38 + 1) = v35;
      *(_BYTE *)v38 = v33;
      *((_BYTE *)v38 + 1) = v109;
      v38 = (_DWORD *)((char *)v38 + (-4 << (v94 - v95)));
      v39 -= v37;
    }
    while ( v39 );
    for ( k = 1 << (v94 - 1); (k & v32) != 0; k >>= 1 )
      ;
    if ( k )
      k += v32 & (k - 1);
    v41 = *((_WORD *)&v112 + v94);
    *((_WORD *)&v112 + v94) = v41 - 1;
    if ( v41 == 1 )
      break;
LABEL_102:
    if ( v94 <= v100 )
      goto LABEL_104;
    v42 = k & (v105 - 1);
    if ( v42 == v104 )
      goto LABEL_104;
    v43 = v95;
    if ( !v95 )
      v43 = v100;
    v99 = (_DWORD *)((char *)v99 + (4 << v98));
    v95 = v43;
    v44 = v94 - v43;
    v98 = v44;
    if ( v94 < v96 )
    {
      v45 = (1 << v44) - *((unsigned __int16 *)&v112 + v94);
      if ( v45 > 0 )
      {
        LOBYTE(v46) = v44 + 1;
        v47 = v44;
        v48 = 2 * v45;
        v49 = v95 + v44 + 1;
        if ( v49 < v96 )
        {
          v50 = v48 - *((unsigned __int16 *)&v112 + v49);
          if ( v50 > 0 )
          {
            LOBYTE(v46) = v47 + 2;
            v51 = 2 * v50;
            v52 = v95 + v47 + 2;
            if ( v52 < v96 )
            {
              v53 = v51 - *((unsigned __int16 *)&v112 + v52);
              if ( v53 > 0 )
              {
                LOBYTE(v46) = v47 + 3;
                v54 = 2 * v53;
                v55 = v95 + v47 + 3;
                if ( v55 < v96 )
                {
                  v56 = v54 - *((unsigned __int16 *)&v112 + v55);
                  if ( v56 > 0 )
                  {
                    LOBYTE(v46) = v47 + 4;
                    v57 = 2 * v56;
                    v58 = v95 + v47 + 4;
                    if ( v58 < v96 )
                    {
                      v59 = v57 - *((unsigned __int16 *)&v112 + v58);
                      if ( v59 > 0 )
                      {
                        LOBYTE(v46) = v47 + 5;
                        v60 = 2 * v59;
                        v61 = v95 + v47 + 5;
                        if ( v61 < v96 )
                        {
                          v62 = v60 - *((unsigned __int16 *)&v112 + v61);
                          if ( v62 > 0 )
                          {
                            LOBYTE(v46) = v47 + 6;
                            v63 = 2 * v62;
                            v64 = v95 + v47 + 6;
                            if ( v64 < v96 )
                            {
                              v65 = v63 - *((unsigned __int16 *)&v112 + v64);
                              if ( v65 > 0 )
                              {
                                LOBYTE(v46) = v47 + 7;
                                v66 = 2 * v65;
                                v67 = v95 + v47 + 7;
                                if ( v67 < v96 )
                                {
                                  v68 = v66 - *((unsigned __int16 *)&v112 + v67);
                                  if ( v68 > 0 )
                                  {
                                    LOBYTE(v46) = v47 + 8;
                                    v69 = 2 * v68;
                                    v70 = v95 + v47 + 8;
                                    if ( v70 < v96 )
                                    {
                                      v71 = v69 - *((unsigned __int16 *)&v112 + v70);
                                      if ( v71 > 0 )
                                      {
                                        LOBYTE(v46) = v47 + 9;
                                        v72 = 2 * v71;
                                        v73 = v95 + v47 + 9;
                                        if ( v73 < v96 )
                                        {
                                          v74 = v72 - *((unsigned __int16 *)&v112 + v73);
                                          if ( v74 > 0 )
                                          {
                                            LOBYTE(v46) = v47 + 10;
                                            v75 = 2 * v74;
                                            v76 = v95 + v47 + 10;
                                            if ( v76 < v96 )
                                            {
                                              v77 = v75 - *((unsigned __int16 *)&v112 + v76);
                                              if ( v77 > 0 )
                                              {
                                                v78 = v47 + 11;
                                                v79 = 2 * v77;
                                                v80 = v95 + v47 + 11;
                                                if ( v80 >= v96
                                                  || (v81 = v79 - *((unsigned __int16 *)&v112 + v80), v81 <= 0)
                                                  || (v78 = v47 + 12, v82 = 2 * v81, v83 = v95 + v47 + 12, v83 >= v96)
                                                  || (v84 = v82 - *((unsigned __int16 *)&v112 + v83), v84 <= 0) )
                                                {
                                                  v98 = v78;
                                                  goto LABEL_142;
                                                }
                                                LOBYTE(v46) = v47 + 13;
                                                v85 = 2 * v84;
                                                v86 = v95 + v47 + 13;
                                                if ( v86 < v96 )
                                                {
                                                  v87 = v85 - *((unsigned __int16 *)&v112 + v86);
                                                  if ( v87 > 0 )
                                                  {
                                                    v88 = v47;
                                                    v89 = v47 + 14;
                                                    v90 = 2 * v87;
                                                    if ( v95 + v89 >= v96
                                                      || (v91 = v90 - *((unsigned __int16 *)&v112 + v95 + v89), v91 <= 0) )
                                                    {
                                                      v98 = v89;
                                                      goto LABEL_142;
                                                    }
                                                    v46 = v88 + 15;
                                                    if ( v95 + v88 + 15 < v96 )
                                                    {
                                                      if ( 2 * v91 - *((unsigned __int16 *)&v112 + v95 + v46) > 0 )
                                                        LOBYTE(v46) = v88 + 16;
                                                      v98 = v46;
                                                      goto LABEL_142;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v98 = v46;
      }
    }
LABEL_142:
    v102 += 1 << v98;
    if ( v102 > 0x354 && v111 || v102 > 0x250 && v110 )
      return 1;
    v104 = k & (v105 - 1);
    v92 = &v108[v42];
    *(_BYTE *)v92 = v98;
    *((_BYTE *)v92 + 1) = v100;
    *((_WORD *)v92 + 1) = v99 - v108;
LABEL_104:
    ++v97;
    v32 = k;
  }
  if ( v94 != v96 )
  {
    v94 = a2[v97[1]];
    goto LABEL_102;
  }
  if ( k )
  {
    v93 = &v99[k];
    *(_BYTE *)v93 = 64;
    *((_BYTE *)v93 + 1) = v109;
    *((_WORD *)v93 + 1) = 0;
  }
  *a4 = (int)&v108[v102];
  *a5 = v100;
  return 0;
}

//----- (00430740) --------------------------------------------------------
unsigned int __usercall longest_match@<eax>(_DWORD *a1@<eax>, unsigned int a2@<edx>)
{
  int v3; // ebp
  unsigned int v4; // ecx
  unsigned int v5; // eax
  int v6; // ebx
  int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // esi
  bool v10; // cc
  unsigned int v11; // edi
  int v12; // eax
  int v13; // esi
  int v14; // edi
  _BYTE *v15; // eax
  unsigned int v16; // ebp
  _BYTE *v17; // esi
  _BYTE *v18; // eax
  int v19; // esi
  unsigned int result; // eax
  unsigned int v21; // [esp+0h] [ebp-40h]
  unsigned int v22; // [esp+4h] [ebp-3Ch]
  int v23; // [esp+8h] [ebp-38h]
  int v24; // [esp+Ch] [ebp-34h]
  char v25; // [esp+12h] [ebp-2Eh]
  char v26; // [esp+13h] [ebp-2Dh]
  _BYTE *v27; // [esp+14h] [ebp-2Ch]
  unsigned int v28; // [esp+18h] [ebp-28h]
  unsigned int v29; // [esp+1Ch] [ebp-24h]
  int v30; // [esp+1Ch] [ebp-24h]
  _DWORD *v31; // [esp+20h] [ebp-20h]
  unsigned int v32; // [esp+24h] [ebp-1Ch]

  v3 = a1[14];
  v4 = a1[31];
  v5 = a1[27];
  v6 = a1[30];
  v31 = a1;
  v27 = (_BYTE *)(v3 + v5);
  v29 = a1[36];
  v7 = a1[11];
  v8 = v7 - 262;
  v9 = v5 + 262 - v7;
  v10 = v5 <= v8;
  v11 = 0;
  v12 = v3 + v5 + 258;
  if ( !v10 )
    v11 = v9;
  v28 = v12;
  v22 = v11;
  v23 = v31[16];
  v24 = v31[13];
  v26 = v27[v6 - 1];
  v25 = v27[v6];
  if ( (unsigned int)v6 >= v31[35] )
    v4 >>= 2;
  v13 = v29;
  v14 = v3;
  v21 = v4;
  v32 = v31[29];
  if ( v32 < v29 )
    v13 = v31[29];
  v30 = v13;
  do
  {
    v15 = (_BYTE *)(v14 + a2);
    v16 = v6;
    if ( *(_BYTE *)(v14 + a2 + v6) == v25 && v15[v6 - 1] == v26 && *v15 == *v27 && v15[1] == v27[1] )
    {
      v17 = v27 + 2;
      v18 = v15 + 2;
      while ( 1 )
      {
        if ( v17[1] != v18[1] )
        {
          ++v17;
          v16 = v6;
          goto LABEL_24;
        }
        if ( v17[2] != v18[2] )
        {
          v17 += 2;
          v16 = v6;
          goto LABEL_24;
        }
        if ( v17[3] != v18[3] )
        {
          v17 += 3;
          v16 = v6;
          goto LABEL_24;
        }
        if ( v17[4] != v18[4] )
        {
          v17 += 4;
          v16 = v6;
          goto LABEL_24;
        }
        if ( v17[5] != v18[5] )
        {
          v17 += 5;
          v16 = v6;
          goto LABEL_24;
        }
        if ( v17[6] != v18[6] )
        {
          v17 += 6;
          v16 = v6;
          goto LABEL_24;
        }
        if ( v17[7] != v18[7] )
          break;
        v17 += 8;
        v18 += 8;
        if ( v28 <= (unsigned int)v17 || *v17 != *v18 )
        {
          v16 = v6;
          goto LABEL_24;
        }
      }
      v17 += 7;
      v16 = v6;
LABEL_24:
      v19 = 258 - (v28 - (_DWORD)v17);
      if ( v6 < v19 )
      {
        v16 = v19;
        v31[28] = a2;
        if ( v19 >= v30 )
          break;
        v26 = v27[v19 - 1];
        v6 = v19;
        v25 = v27[v19];
      }
    }
    a2 = *(unsigned __int16 *)(v23 + 2 * (v24 & a2));
    if ( v22 >= a2 )
      break;
    --v21;
  }
  while ( v21 );
  result = v32;
  if ( v32 > v16 )
    return v16;
  return result;
}

//----- (004309C0) --------------------------------------------------------
int __usercall make_ga_colormap@<eax>(int *a1@<eax>)
{
  unsigned int i; // ebx
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // ebp
  unsigned int v7; // edx
  unsigned int k; // ebx
  unsigned int v9; // edi
  unsigned int v10; // ecx
  unsigned int v12; // [esp+0h] [ebp-3Ch]
  unsigned int v13; // [esp+4h] [ebp-38h]
  int j; // [esp+1Ch] [ebp-20h]

  for ( i = 0; i != 231; ++i )
  {
    v3 = (464823301 * (unsigned __int64)((i << 8) + 115)) >> 32;
    v4 = v3 + (((i << 8) + 115 - v3) >> 1);
    v5 = i;
    png_create_colormap_entry_constprop_5(a1, v5, v4 >> 7, v4 >> 7, v4 >> 7, 1);
  }
  v6 = 51;
  png_create_colormap_entry(a1, 0xE7u, 0xFFu, 0xFFu, 0xFFu, 0, 1);
  for ( j = 232; j != 256; j += 6 )
  {
    v7 = j;
    for ( k = 0; k != 306; k += 51 )
    {
      v13 = k;
      v9 = v7 + 1;
      v10 = k;
      v12 = k;
      png_create_colormap_entry(a1, v7, v10, v12, v13, v6, 1);
      v7 = v9;
    }
    v6 += 51;
  }
  return 256;
}

//----- (00430AA0) --------------------------------------------------------
int __usercall png_XYZ_from_xy@<eax>(int *a1@<eax>, int *a2@<edx>)
{
  int v2; // ebx
  int v3; // ecx
  unsigned int v4; // edi
  int v5; // ecx
  int v7; // ebx
  int v8; // edi
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // edi
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // edi
  int v23; // ebx
  int v24; // ecx
  int v25; // eax
  int v26; // ebx
  int v27; // eax
  int v28; // ebx
  int v29; // edx
  int *v30; // eax
  int v31; // edx
  int *v32; // eax
  int v33; // ecx
  int v34; // edx
  int v35; // edx
  int *v36; // eax
  int v37; // edx
  int *v38; // eax
  int v39; // edx
  int v40; // edx
  int v42; // [esp+4h] [ebp-34h]
  int v43; // [esp+4h] [ebp-34h]
  int v44; // [esp+4h] [ebp-34h]
  unsigned int v45; // [esp+8h] [ebp-30h]
  int v46; // [esp+Ch] [ebp-2Ch]
  unsigned int v47; // [esp+10h] [ebp-28h]
  int v49; // [esp+14h] [ebp-24h]
  int v50; // [esp+18h] [ebp-20h] BYREF
  int v51; // [esp+1Ch] [ebp-1Ch] BYREF
  int v52; // [esp+20h] [ebp-18h] BYREF
  int v53[5]; // [esp+24h] [ebp-14h] BYREF

  v2 = *a2;
  if ( (unsigned int)*a2 > 0x186A0 )
    return 1;
  v3 = a2[1];
  if ( v3 < 0 )
    return 1;
  if ( v3 > 100000 - v2 )
    return 1;
  v4 = a2[2];
  if ( v4 > 0x186A0 )
    return 1;
  v42 = a2[3];
  if ( v42 < 0 )
    return 1;
  if ( v42 > (int)(100000 - v4) )
    return 1;
  v45 = a2[4];
  if ( v45 > 0x186A0 )
    return 1;
  v46 = a2[5];
  if ( v46 < 0 )
    return 1;
  if ( v46 > (int)(100000 - v45) )
    return 1;
  v47 = a2[6];
  if ( v47 > 0x186A0 )
    return 1;
  v49 = a2[7];
  if ( v49 <= 4 || v49 > (int)(100000 - v47) )
    return 1;
  v5 = v3 - v46;
  if ( v4 == v45 || !v5 )
  {
    v52 = 0;
  }
  else
  {
    if ( !png_muldiv_part_3(&v52, v4 - v45, v5, 7) )
      return 2;
    v2 = *a2;
    v45 = a2[4];
    v42 = a2[3];
    v46 = a2[5];
  }
  v7 = v2 - v45;
  if ( v42 == v46 || !v7 )
  {
    v53[0] = 0;
    v8 = 0;
  }
  else
  {
    if ( !png_muldiv_part_3(v53, v42 - v46, v7, 7) )
      return 2;
    v8 = v53[0];
    v46 = a2[5];
    v45 = a2[4];
  }
  v9 = v52;
  v10 = a2[7] - v46;
  v11 = a2[2] - v45;
  if ( v11 && v10 )
  {
    if ( !png_muldiv_part_3(&v52, v11, v10, 7) )
      return 2;
    v45 = a2[4];
    v46 = a2[5];
  }
  else
  {
    v52 = 0;
  }
  v12 = a2[6] - v45;
  v13 = a2[3] - v46;
  if ( v13 && v12 )
  {
    if ( !png_muldiv_part_3(v53, v13, v12, 7) )
      return 2;
    v14 = v53[0];
  }
  else
  {
    v53[0] = 0;
    v14 = 0;
  }
  v15 = v52 - v14;
  if ( v52 == v14 )
    return 1;
  v16 = a2[7];
  v17 = v9 - v8;
  if ( v16 && v17 )
  {
    if ( !png_muldiv_part_3(&v50, v16, v17, v15) )
      return 1;
    v16 = a2[7];
  }
  else
  {
    v50 = 0;
  }
  if ( v16 >= v50 )
    return 1;
  v18 = a2[6] - a2[4];
  v19 = a2[1] - a2[5];
  if ( v19 && v18 )
  {
    if ( !png_muldiv_part_3(&v52, v19, v18, 7) )
      return 2;
    v16 = a2[7];
  }
  else
  {
    v52 = 0;
  }
  v20 = v16 - a2[5];
  if ( *a2 != a2[4] && v20 )
  {
    if ( png_muldiv_part_3(v53, *a2 - a2[4], v20, 7) )
      goto LABEL_42;
    return 2;
  }
  v53[0] = 0;
LABEL_42:
  if ( v52 == v53[0] )
    return 1;
  v21 = a2[7];
  if ( v21 && v17 )
  {
    if ( !png_muldiv_part_3(&v51, v21, v17, v52 - v53[0]) )
      return 1;
    v21 = a2[7];
  }
  else
  {
    v51 = 0;
  }
  v22 = v51;
  if ( v21 >= v51 )
    return 1;
  v23 = 0;
  if ( v21 )
    v23 = png_reciprocal_part_4(v21);
  v24 = v50;
  v25 = 0;
  if ( v50 )
  {
    v43 = v50;
    v25 = png_reciprocal_part_4(v50);
    v24 = v43;
  }
  v26 = v23 - v25;
  v27 = 0;
  if ( v22 )
  {
    v44 = v24;
    v27 = png_reciprocal_part_4(v22);
    v24 = v44;
  }
  v28 = v26 - v27;
  if ( v28 <= 0 || !v24 )
    return 1;
  if ( *a2 )
  {
    if ( !png_muldiv_part_3(a1, *a2, 100000, v24) )
      return 1;
    v24 = v50;
    if ( !v50 )
      return 1;
    v29 = a2[1];
    v30 = a1 + 1;
  }
  else
  {
    *a1 = 0;
    v30 = a1 + 1;
    v29 = a2[1];
  }
  if ( v29 )
  {
    if ( !png_muldiv_part_3(v30, v29, 100000, v24) )
      return 1;
    v24 = v50;
    if ( !v50 )
      return 1;
    v31 = 100000 - *a2 - a2[1];
    v32 = a1 + 2;
  }
  else
  {
    a1[1] = 0;
    v32 = a1 + 2;
    v31 = 100000 - *a2 - a2[1];
  }
  if ( v31 )
  {
    if ( !png_muldiv_part_3(v32, v31, 100000, v24) )
      return 1;
  }
  else
  {
    a1[2] = 0;
  }
  v33 = v51;
  if ( !v51 )
    return 1;
  v34 = a2[2];
  if ( v34 )
  {
    if ( !png_muldiv_part_3(a1 + 3, v34, 100000, v51) )
      return 1;
    v33 = v51;
    if ( !v51 )
      return 1;
    v35 = a2[3];
    v36 = a1 + 4;
  }
  else
  {
    a1[3] = 0;
    v36 = a1 + 4;
    v35 = a2[3];
  }
  if ( v35 )
  {
    if ( !png_muldiv_part_3(v36, v35, 100000, v33) )
      return 1;
    v33 = v51;
    if ( !v51 )
      return 1;
    v37 = 100000 - a2[2] - a2[3];
    v38 = a1 + 5;
  }
  else
  {
    a1[4] = 0;
    v38 = a1 + 5;
    v37 = 100000 - a2[2] - a2[3];
  }
  if ( v37 )
  {
    if ( !png_muldiv_part_3(v38, v37, 100000, v33) )
      return 1;
  }
  else
  {
    a1[5] = 0;
  }
  v39 = a2[4];
  if ( v39 )
  {
    if ( !png_muldiv_part_3(a1 + 6, v39, v28, 100000) )
      return 1;
  }
  else
  {
    a1[6] = 0;
  }
  v40 = a2[5];
  if ( v40 )
  {
    if ( png_muldiv_part_3(a1 + 7, v40, v28, 100000) )
      goto LABEL_81;
    return 1;
  }
  a1[7] = 0;
LABEL_81:
  if ( 100000 - a2[4] != a2[5] )
    return png_muldiv_part_3(a1 + 8, 100000 - a2[4] - a2[5], v28, 100000) == 0;
  a1[8] = 0;
  return 0;
}

//----- (00431090) --------------------------------------------------------
int png_access_version_number()
{
  return 10634;
}

//----- (004310A0) --------------------------------------------------------
int __cdecl png_app_error(int a1)
{
  int result; // eax

  result = a1;
  if ( (*(_BYTE *)(a1 + 102) & 0x40) == 0 )
    png_err(a1);
  return result;
}

//----- (004310C0) --------------------------------------------------------
int __cdecl png_app_warning(int a1)
{
  int result; // eax

  result = a1;
  if ( (*(_BYTE *)(a1 + 102) & 0x20) == 0 )
    png_err(a1);
  return result;
}

//----- (004310E0) --------------------------------------------------------
int __cdecl png_benign_error(int a1)
{
  int result; // eax

  result = a1;
  if ( (*(_BYTE *)(a1 + 102) & 0x10) == 0 )
    png_err(a1);
  return result;
}

//----- (00431100) --------------------------------------------------------
unsigned int __usercall png_build_16bit_table@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // ebp
  unsigned int result; // eax
  int v7; // esi
  _WORD *v8; // edi
  int v9; // ebx
  __int16 v10; // dx
  int v11; // edx
  int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // ecx
  int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // edx
  int i; // ebx
  char v21; // [esp+20h] [ebp-4Ch]
  unsigned int v22; // [esp+24h] [ebp-48h]
  int v23; // [esp+28h] [ebp-44h]
  _DWORD *v25; // [esp+30h] [ebp-3Ch]
  int v27[8]; // [esp+4Ch] [ebp-20h] BYREF

  v21 = 8 - a3;
  v5 = 1 << (8 - a3);
  v22 = (1 << (16 - a3)) - 1;
  v23 = 1 << (15 - a3);
  v25 = png_calloc(a1, 4 << (8 - a3));
  *a2 = v25;
  result = a4 - 95000;
  if ( v5 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = png_malloc(a1, 0x200u);
      v25[v7] = v8;
      if ( (unsigned int)(a4 - 95000) > 0x2710 )
        break;
      if ( a3 )
      {
        for ( i = 0; i != 256; ++i )
        {
          result = (v23 + 0xFFFF * (v7 + (i << v21))) / v22;
          v8[i] = result;
        }
      }
      else
      {
        for ( result = 0; result != 256; ++result )
          v8[result] = v7 + ((_WORD)result << 8);
      }
LABEL_25:
      if ( v5 == ++v7 )
        return result;
    }
    v9 = 0;
    while ( 1 )
    {
      result = v7 + (v9 << v21);
      if ( a3 )
        result = (0xFFFF * result + v23) / v22;
      if ( result - 1 > 0xFFFD )
        break;
      if ( BYTE1(result) )
      {
        v11 = 4;
        v12 = 0;
      }
      else
      {
        result <<= 8;
        v11 = 12;
        v12 = 8;
      }
      if ( (result & 0xF000) == 0 )
      {
        result *= 16;
        v12 = v11;
      }
      if ( (result & 0xC000) == 0 )
      {
        v12 += 2;
        result *= 4;
      }
      if ( (result & 0x8000) == 0 )
      {
        ++v12;
        result *= 2;
      }
      v13 = (v12 << 28) + ((unsigned int)(dword_514AA0[result >> 8] + 8) >> 4);
      v14 = ((result << 16) + (result >> 9)) / (result >> 8) - 0x1000000;
      if ( v14 > 0x10000 )
        v15 = v13 - ((23499 * v14 - 1540029952) >> 10);
      else
        v15 = ((-23591 * v14 + 1546060288) >> 10) + v13;
      v16 = (v15 + 2048) >> 12;
      if ( !a4 || !v16 )
      {
        v17 = 0;
        goto LABEL_24;
      }
      result = png_muldiv_part_3(v27, a4, v16, 100000);
      v10 = 0;
      if ( result )
      {
        v17 = v27[0];
LABEL_24:
        v18 = png_exp(v17);
        v19 = v18 + 0x7FFF;
        result = HIWORD(v18);
        v8[v9++] = (v19 - result) >> 16;
        if ( v9 == 256 )
          goto LABEL_25;
      }
      else
      {
LABEL_6:
        v8[v9++] = v10;
        if ( v9 == 256 )
          goto LABEL_25;
      }
    }
    v10 = result;
    goto LABEL_6;
  }
  return result;
}
// 514AA0: using guessed type int dword_514AA0[80];
// 431100: using guessed type int var_20[8];

//----- (00431390) --------------------------------------------------------
int __usercall png_build_8bit_table@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  _BYTE *v5; // esi
  int result; // eax
  int i; // ebx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // eax
  int v14[4]; // [esp+1Ch] [ebp-10h] BYREF

  v5 = png_malloc(a1, 0x100u);
  *a2 = v5;
  if ( (unsigned int)(a3 - 95000) > 0x2710 )
  {
    for ( i = 0; ; ++i )
    {
      result = i - 1;
      if ( (unsigned int)(i - 1) > 0xFD )
      {
        v5[i] = i;
        if ( i == 255 )
          return result;
      }
      else
      {
        v8 = i;
        if ( (i & 0xF0) != 0 )
        {
          v9 = 2;
          v10 = 0;
        }
        else
        {
          v8 = 16 * i;
          v9 = 6;
          v10 = 4;
        }
        if ( (v8 & 0xC0) == 0 )
        {
          v8 *= 4;
          v10 = v9;
        }
        if ( (v8 & 0x80u) == 0 )
        {
          ++v10;
          v8 *= 2;
        }
        v11 = ((unsigned int)(dword_514AA0[v8] + 0x8000) >> 16) + (v10 << 16);
        if ( a3 && v11 )
        {
          if ( !png_muldiv_part_3(v14, a3, v11, 100000) )
          {
            v5[i] = 0;
            continue;
          }
          v12 = v14[0];
        }
        else
        {
          v12 = 0;
        }
        v13 = png_exp(v12);
        v5[i] = (v13 + 0x7FFFFF - (v13 >> 8)) >> 24;
      }
    }
  }
  for ( result = 0; result != 256; ++result )
    v5[result] = result;
  return result;
}
// 514AA0: using guessed type int dword_514AA0[80];
// 431390: using guessed type int var_10[4];

//----- (004314A0) --------------------------------------------------------
int __cdecl png_build_gamma_table(void **a1, int a2)
{
  void **v2; // ebx
  int v3; // ebp
  int v4; // eax
  int result; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  unsigned __int8 v10; // dl
  int v11; // ecx
  int v12; // edi
  unsigned int v13; // esi
  unsigned int v14; // edi
  int v15; // edi
  unsigned int v16; // esi
  unsigned int v17; // edx
  int v18; // eax
  int v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // ecx
  int v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // ebp
  int v27; // eax
  unsigned int v28; // edi
  unsigned int v29; // eax
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // eax
  unsigned __int8 v34; // al
  int v35; // eax
  bool v36; // zf
  unsigned __int8 v37; // dl
  int v38; // eax
  unsigned int v39; // eax
  int v40; // edx
  size_t v41; // [esp+4h] [ebp-58h]
  char v42; // [esp+10h] [ebp-4Ch]
  int v43; // [esp+14h] [ebp-48h]
  void *v44; // [esp+18h] [ebp-44h]
  int v45; // [esp+1Ch] [ebp-40h]
  bool v46; // [esp+23h] [ebp-39h]
  int v47; // [esp+24h] [ebp-38h]
  unsigned int v48; // [esp+28h] [ebp-34h]
  unsigned int v49; // [esp+2Ch] [ebp-30h]
  int v50[8]; // [esp+3Ch] [ebp-20h] BYREF

  v2 = a1;
  if ( a1[82] || a1[83] )
    png_destroy_gamma_table(a1);
  v3 = (int)a1[81];
  if ( a2 <= 8 )
  {
    v4 = 100000;
    if ( v3 > 0 )
    {
      v4 = (int)a1[115];
      if ( v4 )
      {
        v4 = png_muldiv_part_3(v50, v4, v3, 100000);
        if ( v4 )
        {
          v4 = v50[0];
          if ( v50[0] )
          {
            v36 = png_muldiv_part_3(v50, 100000, 100000, v50[0]) == 0;
            v4 = 0;
            if ( !v36 )
              v4 = v50[0];
          }
        }
      }
    }
    result = png_build_8bit_table((int)a1, a1 + 82, v4);
    if ( ((unsigned int)a1[26] & 0x600080) != 0 )
    {
      v6 = (int)a1[115];
      v7 = 0;
      if ( v6 )
        v7 = png_reciprocal_part_4(v6);
      png_build_8bit_table((int)a1, a1 + 85, v7);
      v8 = (int)a1[81];
      if ( v8 > 0 )
        v9 = png_reciprocal_part_4(v8);
      else
        v9 = (int)a1[115];
      return png_build_8bit_table((int)a1, a1 + 84, v9);
    }
    return result;
  }
  if ( (*((_BYTE *)a1 + 281) & 2) != 0 )
  {
    v10 = *((_BYTE *)a1 + 353);
    if ( v10 < *((_BYTE *)a1 + 352) )
      v10 = *((_BYTE *)a1 + 352);
    if ( v10 < *((_BYTE *)a1 + 354) )
      v10 = *((_BYTE *)a1 + 354);
    v11 = (unsigned int)a1[26] & 0x4000400;
    if ( (unsigned __int8)(v10 - 1) > 0xEu )
    {
LABEL_14:
      if ( v11 )
        goto LABEL_15;
      a1[80] = 0;
      v35 = 100000;
      v43 = 0;
      if ( v3 <= 0 )
      {
LABEL_54:
        result = png_build_16bit_table((int)a1, a1 + 83, v43, v35);
        goto LABEL_39;
      }
LABEL_68:
      v35 = (int)a1[115];
      if ( v35 )
      {
        v35 = png_muldiv_part_3(v50, v35, v3, 100000);
        if ( v35 )
        {
          v35 = v50[0];
          if ( v50[0] )
          {
            v36 = png_muldiv_part_3(v50, 100000, 100000, v50[0]) == 0;
            v35 = 0;
            if ( !v36 )
              v35 = v50[0];
          }
        }
      }
      goto LABEL_54;
    }
  }
  else
  {
    v10 = *((_BYTE *)a1 + 355);
    v11 = (unsigned int)a1[26] & 0x4000400;
    if ( (unsigned __int8)(v10 - 1) > 0xEu )
      goto LABEL_14;
  }
  v34 = 16 - v10;
  if ( !v11 )
  {
    if ( v34 > 8u )
      v34 = 8;
    a1[80] = (void *)v34;
    v43 = v34;
    v35 = 100000;
    if ( v3 <= 0 )
      goto LABEL_54;
    goto LABEL_68;
  }
  if ( v34 > 4u )
  {
    v37 = 8;
    if ( v34 <= 8u )
      v37 = v34;
    a1[80] = (void *)v37;
    v43 = v37;
    v42 = 8 - v37;
    v13 = 1 << (8 - v37);
    v49 = v13 << 8;
    v12 = 4 << (8 - v37);
    v47 = (1 << (16 - v37)) - 1;
    v48 = 0xFFu >> v37;
    goto LABEL_16;
  }
LABEL_15:
  a1[80] = (void *)5;
  v12 = 32;
  v13 = 8;
  v48 = 7;
  v47 = 2047;
  v42 = 3;
  v49 = 2048;
  v43 = 5;
LABEL_16:
  v46 = 0;
  v45 = 100000;
  if ( v3 > 0 )
  {
    v40 = (int)a1[115];
    if ( v40 )
    {
      v46 = 1;
      v45 = 0;
      if ( png_muldiv_part_3(v50, v40, v3, 100000) )
      {
        v45 = v50[0];
        v46 = v50[0] == 0;
      }
    }
    else
    {
      v46 = 1;
      v45 = 0;
    }
  }
  v41 = v12;
  v14 = 0;
  v44 = png_calloc((int)a1, v41);
  a1[83] = v44;
  do
    *((_DWORD *)v44 + v14++) = png_malloc((int)a1, 0x200u);
  while ( v14 < v13 );
  v15 = 128;
  v16 = 0;
  do
  {
    v17 = v15;
    if ( (v15 & 0xFF00) != 0 )
    {
      v18 = 4;
      v19 = 0;
    }
    else
    {
      v17 = v15 << 8;
      v18 = 12;
      v19 = 8;
    }
    if ( (v17 & 0xF000) == 0 )
    {
      v17 *= 16;
      v19 = v18;
    }
    if ( (v17 & 0xC000) == 0 )
    {
      v19 += 2;
      v17 *= 4;
    }
    if ( (v17 & 0x8000) == 0 )
    {
      ++v19;
      v17 *= 2;
    }
    v20 = (v19 << 28) + ((unsigned int)(dword_514AA0[v17 >> 8] + 8) >> 4);
    v21 = ((v17 >> 9) + (v17 << 16)) / (v17 >> 8) - 0x1000000;
    if ( v21 > 0x10000 )
      v22 = v20 - ((23499 * v21 - 1540029952) >> 10);
    else
      v22 = ((-23591 * v21 + 1546060288) >> 10) + v20;
    v23 = (v22 + 2048) >> 12;
    if ( !v23 || v46 )
    {
      v38 = 0;
    }
    else
    {
      v24 = png_muldiv_part_3(v50, v45, v23, 100000);
      v25 = 1;
      if ( !v24 )
        goto LABEL_33;
      v38 = v50[0];
    }
    v39 = png_exp(v38);
    v25 = (v47 * ((v39 + 0x7FFF - HIWORD(v39)) >> 16) + 0x8000) / 0xFFFF + 1;
LABEL_33:
    if ( v16 < v25 )
    {
      do
      {
        v26 = v16 >> v42;
        v27 = v16++ & v48;
        *(_WORD *)(*((_DWORD *)v44 + v27) + 2 * v26) = v15 - 128;
      }
      while ( v16 != v25 );
    }
    v15 += 257;
  }
  while ( v15 != 65663 );
  result = v49;
  v2 = a1;
  if ( v16 < v49 )
  {
    do
    {
      v28 = v16;
      v29 = v16++;
      result = v29 >> v42;
      *(_WORD *)(*((_DWORD *)v44 + ((255 >> v43) & v28)) + 2 * result) = -1;
    }
    while ( v16 != v49 );
    v2 = a1;
  }
LABEL_39:
  if ( ((unsigned int)v2[26] & 0x600080) != 0 )
  {
    v30 = (int)v2[115];
    v31 = 0;
    if ( v30 )
      v31 = png_reciprocal_part_4(v30);
    png_build_16bit_table((int)v2, v2 + 87, v43, v31);
    v32 = (int)v2[81];
    if ( v32 > 0 )
      v33 = png_reciprocal_part_4(v32);
    else
      v33 = (int)v2[115];
    return png_build_16bit_table((int)v2, v2 + 86, v43, v33);
  }
  return result;
}
// 514AA0: using guessed type int dword_514AA0[80];

//----- (00431A90) --------------------------------------------------------
int __cdecl png_calculate_crc(int a1, _BYTE *a2, unsigned int a3)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 100);
  if ( (*(_BYTE *)(a1 + 247) & 0x20) != 0 )
  {
    result = *(_DWORD *)(a1 + 100) & 0x300;
    if ( result == 768 )
      return result;
  }
  else if ( (result & 0x800) != 0 )
  {
    return result;
  }
  if ( a3 )
  {
    result = crc32(*(_DWORD *)(a1 + 264), a2, a3);
    *(_DWORD *)(a1 + 264) = result;
  }
  return result;
}

//----- (00431AF0) --------------------------------------------------------
void *__cdecl png_calloc(int a1, size_t Count)
{
  void *result; // eax

  if ( !a1 )
    return 0;
  if ( !Count || (result = calloc(Count, 1u)) == 0 )
    png_err(a1);
  return result;
}

//----- (00431B40) --------------------------------------------------------
bool __cdecl png_check_IHDR(int a1, unsigned int a2, int a3, int a4, unsigned int a5, int a6, __int64 a7)
{
  bool result; // al
  unsigned int v8; // edx

  result = (int)a2 <= 0;
  if ( ((a2 + 7) & 0xFFFFFFF8) >= 0x1FFFFFF9 )
    result = 1;
  if ( a2 >= 0xF4241 )
    result = 1;
  if ( (unsigned int)(a3 - 1) >= 0xF4240 )
    result = 1;
  if ( (unsigned int)a4 > 0x10 )
  {
    result = 1;
  }
  else if ( ((0x10116u >> a4) & 1) == 0 )
  {
    result = 1;
  }
  v8 = a5 & 0xFFFFFFFB;
  if ( (a5 & 0xFFFFFFFB) == 1 )
  {
    result = 1;
    if ( a5 != 3 )
      goto LABEL_16;
    goto LABEL_13;
  }
  if ( a5 > 6 )
  {
    result = v8 == 2 || a5 == 4;
    if ( result && a4 > 7 )
      goto LABEL_19;
LABEL_14:
    png_err(a1);
  }
  if ( a5 == 3 )
  {
LABEL_13:
    if ( a4 > 8 )
      goto LABEL_14;
  }
LABEL_16:
  if ( (a5 == 4 || v8 == 2) && a4 <= 7 )
    goto LABEL_14;
LABEL_19:
  if ( a6 > 1 || a7 != 0 || result )
    goto LABEL_14;
  return result;
}

//----- (00431C30) --------------------------------------------------------
int __cdecl png_check_chunk_length(int a1, unsigned int a2)
{
  int result; // eax
  int v3; // edx
  unsigned int v4; // ebx
  unsigned int v5; // eax
  int v6; // esi

  result = 8000000;
  if ( *(_DWORD *)(a1 + 244) == 1229209940 )
  {
    v3 = *(_DWORD *)(a1 + 216) * *(unsigned __int8 *)(a1 + 285);
    if ( *(_BYTE *)(a1 + 282) > 8u )
      v3 *= 2;
    v4 = v3 + (*(_BYTE *)(a1 + 278) != 0 ? 6 : 0) + 1;
    v5 = *(_DWORD *)(a1 + 220) * v4;
    if ( is_mul_ok(*(_DWORD *)(a1 + 220), v4) )
    {
      v6 = v5 + 6;
    }
    else
    {
      v6 = -2147483643;
      v5 = 0x7FFFFFFF;
    }
    if ( v4 > 0x7F36 )
      v4 = 32566;
    result = v6 + 5 * (v5 / v4) + 5;
    if ( result < 0 )
      result = 0x7FFFFFFF;
    if ( (unsigned int)result < 0x7A1200 )
      result = 8000000;
  }
  if ( result < a2 )
    png_err(a1);
  return result;
}

//----- (00431CE0) --------------------------------------------------------
unsigned int __cdecl png_check_chunk_name(int a1, unsigned int a2)
{
  unsigned int result; // eax

  if ( (unsigned int)(unsigned __int8)a2 - 91 <= 5
    || (unsigned int)(unsigned __int8)a2 - 65 > 0x39
    || (unsigned int)BYTE1(a2) - 91 <= 5
    || (unsigned int)BYTE1(a2) - 65 > 0x39
    || (unsigned int)BYTE2(a2) - 65 > 0x39
    || (unsigned int)BYTE2(a2) - 91 <= 5
    || HIBYTE(a2) - 65 > 0x39u
    || (result = HIBYTE(a2) - 91, result <= 5) )
  {
    png_err(a1);
  }
  return result;
}

//----- (00431D50) --------------------------------------------------------
int __cdecl png_chunk_benign_error(int a1)
{
  int result; // eax

  result = a1;
  if ( (*(_BYTE *)(a1 + 102) & 0x10) == 0 )
    png_err(a1);
  return result;
}

//----- (00431D70) --------------------------------------------------------
int __cdecl png_chunk_report(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx

  result = a1;
  if ( *(char *)(a1 + 97) >= 0 )
  {
    v4 = *(_DWORD *)(a1 + 100);
    if ( a3 <= 0 )
    {
      if ( (v4 & 0x200000) != 0 )
        return result;
    }
    else if ( (v4 & 0x400000) != 0 )
    {
      return result;
    }
LABEL_7:
    png_err(a1);
  }
  if ( a3 > 1 && (*(_BYTE *)(a1 + 102) & 0x10) == 0 )
    goto LABEL_7;
  return result;
}

//----- (00431DC0) --------------------------------------------------------
int __usercall png_colormap_compose@<eax>(int ***a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5, int a6)
{
  int v8; // eax
  int v9; // ebx
  unsigned int v10; // edx
  int v12; // ebp
  int v13; // eax

  if ( a3 != 3 )
    goto LABEL_2;
  a3 = (int)a1[8];
  if ( a3 )
    goto LABEL_2;
  v12 = *(_DWORD *)(***a1 + 460);
  if ( png_gamma_significant(v12) )
  {
    if ( v12 <= 99999 && (!v12 || !png_gamma_significant((11 * v12 + 2) / 5)) )
    {
      a1[8] = (int **)1;
      goto LABEL_9;
    }
    a1[8] = (int **)3;
    v13 = png_reciprocal(v12);
    a3 = (int)a1[8];
    a1[9] = (int **)v13;
LABEL_2:
    if ( a3 == 2 )
      goto LABEL_6;
    if ( a3 > 2 )
    {
      if ( a3 == 3 )
      {
        a2 = (unsigned __int16)png_gamma_16bit_correct(257 * a2, (int)a1[9]);
        goto LABEL_6;
      }
      if ( a3 == 4 )
        goto LABEL_11;
LABEL_21:
      png_err(***a1);
    }
    if ( a3 != 1 )
      goto LABEL_21;
LABEL_9:
    a2 = (unsigned __int16)png_sRGB_table[a2];
    goto LABEL_6;
  }
  a1[8] = (int **)4;
LABEL_11:
  a2 *= 257;
LABEL_6:
  v8 = 255 - a4;
  v9 = a2 * a4;
  if ( a6 == 2 )
    return (257 * (v8 * a5 + v9) + ((unsigned int)(257 * (v8 * a5 + v9)) >> 16) + 0x8000) >> 16;
  v10 = v9 + v8 * (unsigned __int16)png_sRGB_table[a5];
  return (unsigned __int16)(png_sRGB_base[v10 >> 15]
                          + (((unsigned __int8)png_sRGB_delta[v10 >> 15] * (v10 & 0x7FFF)) >> 12)) >> 8;
}
// 514EE0: using guessed type __int16 png_sRGB_base[512];
// 5154E0: using guessed type __int16 png_sRGB_table[256];

//----- (00431F40) --------------------------------------------------------
BOOL __usercall png_colorspace_endpoints_match@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int v4; // edi
  BOOL result; // eax
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // edi
  int v10; // edi
  int v11; // edx
  int v12; // ebx

  v4 = a1[6];
  if ( v4 < a2[6] - a3 )
    return 0;
  result = 0;
  if ( v4 <= a3 + a2[6] )
  {
    v6 = a1[7];
    if ( v6 >= a2[7] - a3 && v6 <= a3 + a2[7] && *a1 >= *a2 - a3 && *a1 <= a3 + *a2 )
    {
      v7 = a1[1];
      if ( v7 >= a2[1] - a3 && v7 <= a3 + a2[1] )
      {
        v8 = a1[2];
        if ( v8 >= a2[2] - a3 && v8 <= a3 + a2[2] )
        {
          v9 = a1[3];
          if ( v9 >= a2[3] - a3 && v9 <= a3 + a2[3] )
          {
            v10 = a1[4];
            if ( v10 >= a2[4] - a3 && v10 <= a3 + a2[4] )
            {
              v11 = a2[5];
              v12 = a1[5];
              if ( v12 >= v11 - a3 )
                return v12 <= a3 + v11;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00432010) --------------------------------------------------------
int __cdecl png_colorspace_set_chromaticities(int a1, int a2, int *a3, int a4)
{
  int v4; // esi
  __int16 v5; // di
  int result; // eax
  BOOL v7; // eax
  __int16 v8; // di
  int v9[8]; // [esp+1Ch] [ebp-60h] BYREF
  int v10[16]; // [esp+3Ch] [ebp-40h] BYREF

  v4 = png_XYZ_from_xy(v10, a3);
  if ( v4 || (v4 = png_xy_from_XYZ(v9, v10)) != 0 )
  {
    v5 = *(_WORD *)(a2 + 74) | 0x8000;
    if ( v4 != 1 )
    {
      *(_WORD *)(a2 + 74) = v5;
      png_err(a1);
    }
    goto LABEL_3;
  }
  v7 = png_colorspace_endpoints_match(a3, v9, 5);
  v8 = *(_WORD *)(a2 + 74);
  if ( !v7 )
  {
    v5 = v8 | 0x8000;
LABEL_3:
    *(_WORD *)(a2 + 74) = v5;
    v4 = 0;
    png_benign_error(a1);
    return v4;
  }
  if ( v8 < 0 )
    return v4;
  if ( a4 <= 1 && (v8 & 2) != 0 )
  {
    v4 = png_colorspace_endpoints_match(a3, (_DWORD *)(a2 + 4), 100);
    if ( !v4 )
    {
      *(_WORD *)(a2 + 74) = v8 | 0x8000;
      png_benign_error(a1);
      return v4;
    }
    v4 = 1;
    if ( !a4 )
      return v4;
  }
  *(_DWORD *)(a2 + 4) = *a3;
  *(_DWORD *)(a2 + 8) = a3[1];
  *(_DWORD *)(a2 + 12) = a3[2];
  *(_DWORD *)(a2 + 16) = a3[3];
  *(_DWORD *)(a2 + 20) = a3[4];
  *(_DWORD *)(a2 + 24) = a3[5];
  *(_DWORD *)(a2 + 28) = a3[6];
  *(_DWORD *)(a2 + 32) = a3[7];
  *(_DWORD *)(a2 + 36) = v10[0];
  *(_DWORD *)(a2 + 40) = v10[1];
  *(_DWORD *)(a2 + 44) = v10[2];
  *(_DWORD *)(a2 + 48) = v10[3];
  *(_DWORD *)(a2 + 52) = v10[4];
  *(_DWORD *)(a2 + 56) = v10[5];
  *(_DWORD *)(a2 + 60) = v10[6];
  *(_DWORD *)(a2 + 64) = v10[7];
  *(_DWORD *)(a2 + 68) = v10[8];
  *(_WORD *)(a2 + 74) = v8 | 2;
  if ( png_colorspace_endpoints_match(a3, sRGB_xy, 1000) )
  {
    *(_WORD *)(a2 + 74) = v8 | 0x42;
    return 2;
  }
  else
  {
    result = 2;
    *(_WORD *)(a2 + 74) = v8 & 0xFFBD | 2;
  }
  return result;
}
// 515780: using guessed type _DWORD sRGB_xy[8];
// 432010: using guessed type int var_60[8];

//----- (00432200) --------------------------------------------------------
int __cdecl png_colorspace_set_endpoints(int a1, int a2, int *a3, int a4)
{
  int v4; // esi
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // ebp
  int v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // edi
  int v15; // ebp
  BOOL v16; // eax
  __int16 v17; // si
  __int16 v18; // di
  int v19; // edx
  int v20; // ecx
  int v21; // edi
  int v22; // ebp
  int v23; // eax
  int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v32; // [esp+14h] [ebp-B8h]
  int v33; // [esp+14h] [ebp-B8h]
  int v34; // [esp+18h] [ebp-B4h]
  int v35; // [esp+18h] [ebp-B4h]
  int v36; // [esp+1Ch] [ebp-B0h]
  int v37[3]; // [esp+28h] [ebp-A4h] BYREF
  int v38; // [esp+34h] [ebp-98h]
  int v39; // [esp+38h] [ebp-94h]
  int v40; // [esp+3Ch] [ebp-90h]
  int v41; // [esp+40h] [ebp-8Ch]
  int v42; // [esp+44h] [ebp-88h]
  int v43[8]; // [esp+48h] [ebp-84h] BYREF
  int v44; // [esp+68h] [ebp-64h] BYREF
  int v45; // [esp+6Ch] [ebp-60h] BYREF
  int v46; // [esp+70h] [ebp-5Ch] BYREF
  int v47; // [esp+74h] [ebp-58h] BYREF
  int v48; // [esp+78h] [ebp-54h] BYREF
  int v49; // [esp+7Ch] [ebp-50h] BYREF
  int v50; // [esp+80h] [ebp-4Ch] BYREF
  int v51; // [esp+84h] [ebp-48h] BYREF
  int v52; // [esp+88h] [ebp-44h] BYREF
  int v53[16]; // [esp+8Ch] [ebp-40h] BYREF

  v4 = a3[2];
  v5 = *a3;
  v6 = a3[1];
  v49 = a3[5];
  v7 = a3[6];
  v8 = a3[3];
  v46 = v4;
  v32 = v7;
  v9 = a3[4];
  v50 = v7;
  v10 = a3[7];
  v11 = a3[8];
  v44 = v5;
  v45 = v6;
  v47 = v8;
  v48 = v9;
  v51 = v10;
  v52 = v11;
  if ( v6 < 0 )
    goto LABEL_42;
  if ( v9 < 0 )
    goto LABEL_42;
  v34 = v10;
  if ( v10 < 0 )
    goto LABEL_42;
  if ( v5 < 0 )
    goto LABEL_42;
  if ( v8 < 0 )
    goto LABEL_42;
  if ( v32 < 0 )
    goto LABEL_42;
  if ( v46 < 0 )
    goto LABEL_42;
  if ( v49 < 0 )
    goto LABEL_42;
  if ( v52 < 0 )
    goto LABEL_42;
  if ( v8 > 0x7FFFFFFF - v6 )
    goto LABEL_42;
  v12 = v6;
  v13 = v9 + v6;
  if ( v32 > 0x7FFFFFFF - v13 )
    goto LABEL_42;
  v14 = v13 + v10;
  if ( v13 + v34 == 100000 )
    goto LABEL_33;
  if ( !v14 )
    goto LABEL_42;
  if ( !v5 )
    goto LABEL_17;
  if ( !png_muldiv_part_3(&v44, v5, 100000, v13 + v34) )
  {
LABEL_42:
    v18 = *(_WORD *)(a2 + 74) | 0x8000;
    goto LABEL_43;
  }
  v12 = v45;
LABEL_17:
  if ( v12 && !png_muldiv_part_3(&v45, v12, 100000, v14)
    || v46 && !png_muldiv_part_3(&v46, v46, 100000, v14)
    || v47 && !png_muldiv_part_3(&v47, v47, 100000, v14)
    || v48 && !png_muldiv_part_3(&v48, v48, 100000, v14)
    || v49 && !png_muldiv_part_3(&v49, v49, 100000, v14)
    || v50 && !png_muldiv_part_3(&v50, v50, 100000, v14)
    || v51 && !png_muldiv_part_3(&v51, v51, 100000, v14)
    || v52 && !png_muldiv_part_3(&v52, v52, 100000, v14) )
  {
    goto LABEL_42;
  }
LABEL_33:
  v15 = png_xy_from_XYZ(v37, &v44);
  if ( v15 )
    goto LABEL_44;
  v53[0] = v44;
  v53[1] = v45;
  v53[2] = v46;
  v53[3] = v47;
  v53[4] = v48;
  v53[5] = v49;
  v53[6] = v50;
  v53[7] = v51;
  v53[8] = v52;
  v15 = png_XYZ_from_xy(v53, v37);
  if ( v15 || (v15 = png_xy_from_XYZ(v43, v53)) != 0 )
  {
LABEL_44:
    v18 = *(_WORD *)(a2 + 74) | 0x8000;
    if ( v15 != 1 )
    {
      *(_WORD *)(a2 + 74) = v18;
      png_err(a1);
    }
    goto LABEL_43;
  }
  v16 = png_colorspace_endpoints_match(v37, v43, 5);
  v17 = *(_WORD *)(a2 + 74);
  v18 = v17 | 0x8000;
  if ( !v16 )
  {
LABEL_43:
    *(_WORD *)(a2 + 74) = v18;
    png_benign_error(a1);
    return 0;
  }
  if ( v17 < 0 )
    return v15;
  if ( a4 <= 1 && (v17 & 2) != 0 )
  {
    v15 = png_colorspace_endpoints_match(v37, (_DWORD *)(a2 + 4), 100);
    if ( !v15 )
    {
      *(_WORD *)(a2 + 74) = v18;
      png_benign_error(a1);
      return v15;
    }
    v15 = 1;
    if ( !a4 )
      return v15;
  }
  v19 = v39;
  v20 = v37[0];
  v21 = v37[1];
  v33 = v38;
  v22 = v37[2];
  *(_DWORD *)(a2 + 16) = v38;
  v35 = v19;
  *(_DWORD *)(a2 + 28) = v41;
  v23 = v44;
  *(_DWORD *)(a2 + 20) = v19;
  v24 = v40;
  *(_DWORD *)(a2 + 36) = v23;
  v36 = v24;
  *(_DWORD *)(a2 + 40) = v45;
  v25 = v46;
  *(_DWORD *)(a2 + 24) = v24;
  v26 = v42;
  *(_DWORD *)(a2 + 44) = v25;
  v27 = v47;
  *(_DWORD *)(a2 + 4) = v20;
  *(_DWORD *)(a2 + 48) = v27;
  v28 = v48;
  *(_DWORD *)(a2 + 8) = v21;
  *(_DWORD *)(a2 + 52) = v28;
  v29 = v49;
  *(_DWORD *)(a2 + 12) = v22;
  *(_DWORD *)(a2 + 56) = v29;
  v30 = v50;
  *(_DWORD *)(a2 + 32) = v26;
  *(_DWORD *)(a2 + 60) = v30;
  *(_DWORD *)(a2 + 64) = v51;
  *(_DWORD *)(a2 + 68) = v52;
  *(_WORD *)(a2 + 74) = v17 | 2;
  if ( (unsigned int)(v41 - 30270) > 0x7D0
    || (unsigned int)(v26 - 31900) > 0x7D0
    || (unsigned int)(v20 - 63000) > 0x7D0
    || (unsigned int)(v21 - 32000) > 0x7D0
    || (unsigned int)(v22 - 29000) > 0x7D0
    || (unsigned int)(v33 - 59000) > 0x7D0
    || (unsigned int)(v35 - 14000) > 0x7D0
    || (unsigned int)(v36 - 5000) > 0x7D0 )
  {
    v15 = 2;
    *(_WORD *)(a2 + 74) = v17 & 0xFFBD | 2;
    return v15;
  }
  *(_WORD *)(a2 + 74) = v17 | 0x42;
  return 2;
}
// 432200: using guessed type int var_84[8];

//----- (00432760) --------------------------------------------------------
int __cdecl png_colorspace_set_gamma(int a1, int a2, int a3)
{
  int result; // eax
  const char *v4; // edx
  int v5[4]; // [esp+1Ch] [ebp-10h] BYREF

  result = *(unsigned __int16 *)(a2 + 74);
  if ( (unsigned int)(a3 - 16) > 0x2540BE30 )
  {
    v4 = "gamma value out of range";
    goto LABEL_14;
  }
  if ( *(char *)(a1 + 97) < 0 && (result & 8) != 0 )
  {
    v4 = "duplicate";
LABEL_14:
    *(_WORD *)(a2 + 74) = result | 0x8000;
    return png_chunk_report(a1, (int)v4, 1);
  }
  if ( (result & 0x8000u) != 0 )
    return result;
  if ( (result & 1) == 0 )
  {
LABEL_12:
    result |= 9u;
    *(_DWORD *)a2 = a3;
    *(_WORD *)(a2 + 74) = result;
    return result;
  }
  if ( *(_DWORD *)a2 )
  {
    if ( png_muldiv_part_3(v5, *(_DWORD *)a2, 100000, a3) && (unsigned int)(v5[0] - 95000) <= 0x2710 )
    {
      result = *(unsigned __int16 *)(a2 + 74);
      goto LABEL_12;
    }
    LOWORD(result) = *(_WORD *)(a2 + 74);
  }
  else
  {
    v5[0] = 0;
  }
  if ( (result & 0x20) == 0 )
  {
    png_chunk_report(a1, (int)"gamma value does not match libpng estimate", 0);
    result = *(unsigned __int16 *)(a2 + 74);
    goto LABEL_12;
  }
  return png_chunk_report(a1, (int)"gamma value does not match sRGB", 2);
}
// 432760: using guessed type int var_10[4];

//----- (00432880) --------------------------------------------------------
void __cdecl png_colorspace_set_rgb_coefficients(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // edi
  int v9; // [esp+14h] [ebp-18h] BYREF
  unsigned int v10; // [esp+18h] [ebp-14h] BYREF
  unsigned int v11[4]; // [esp+1Ch] [ebp-10h] BYREF

  if ( !*(_BYTE *)(a1 + 393) && (*(_BYTE *)(a1 + 534) & 2) != 0 )
  {
    v1 = *(_DWORD *)(a1 + 512);
    v2 = *(_DWORD *)(a1 + 524);
    v9 = *(_DWORD *)(a1 + 500);
    v10 = v1;
    v3 = v2 + v9 + v1;
    v11[0] = v2;
    if ( v9 < 0 || v3 <= 0 )
      goto LABEL_32;
    if ( v9 )
    {
      if ( !png_muldiv_part_3(&v9, v9, 0x8000, v2 + v9 + v1) || (unsigned int)v9 > 0x8000 )
        goto LABEL_32;
      v1 = v10;
    }
    if ( v1 < 0
      || v1 && (!png_muldiv_part_3((int *)&v10, v1, 0x8000, v3) || (v1 = v10, v10 > 0x8000))
      || (v4 = v11[0], (v11[0] & 0x80000000) != 0) )
    {
LABEL_32:
      png_err(a1);
    }
    if ( v11[0] )
    {
      if ( !png_muldiv_part_3((int *)v11, v11[0], 0x8000, v3) )
        goto LABEL_32;
      v4 = v11[0];
      if ( v11[0] > 0x8000 )
        goto LABEL_32;
      v1 = v10;
    }
    LOWORD(v5) = v9;
    v6 = v9 + v1;
    v7 = v9 + v1 + v4;
    if ( v7 > 32769 )
      goto LABEL_32;
    if ( v7 == 32769 )
    {
      v8 = -1;
    }
    else
    {
      if ( v7 == 0x8000 )
      {
LABEL_26:
        *(_WORD *)(a1 + 394) = v5;
        *(_WORD *)(a1 + 396) = v1;
        return;
      }
      v8 = 1;
    }
    if ( v9 <= v1 )
    {
      if ( v4 > v1 )
        goto LABEL_24;
      v1 += v8;
      v10 = v1;
      v6 = v9 + v1;
    }
    else
    {
      if ( v9 < v4 )
      {
LABEL_24:
        v4 += v8;
        v11[0] = v4;
        goto LABEL_25;
      }
      v5 = v8 + v9;
      v9 = v5;
      v6 = v5 + v1;
    }
LABEL_25:
    if ( v6 + v4 == 0x8000 )
      goto LABEL_26;
    goto LABEL_32;
  }
}
// 432880: using guessed type unsigned int var_10[4];

//----- (00432A00) --------------------------------------------------------
int __cdecl png_colorspace_set_sRGB(int a1, int a2, unsigned int a3)
{
  int result; // eax
  __int16 v4; // si
  int v5[4]; // [esp+1Ch] [ebp-10h] BYREF

  result = 0;
  v4 = *(_WORD *)(a2 + 74);
  if ( v4 >= 0 )
  {
    if ( a3 > 3 )
      return png_icc_profile_error_constprop_9(a1, a2, a3, "invalid sRGB rendering intent");
    if ( (v4 & 4) != 0 && *(unsigned __int16 *)(a2 + 72) != a3 )
      return png_icc_profile_error_constprop_9(a1, a2, a3, "inconsistent rendering intents");
    if ( (v4 & 0x20) != 0 )
    {
      png_benign_error(a1);
      return 0;
    }
    if ( (v4 & 2) != 0 && !png_colorspace_endpoints_match(sRGB_xy, (_DWORD *)(a2 + 4), 100) )
    {
      png_chunk_report(a1, (int)"cHRM chunk does not match sRGB", 2);
      v4 = *(_WORD *)(a2 + 74);
    }
    if ( (v4 & 1) == 0 )
      goto LABEL_13;
    if ( *(_DWORD *)a2 )
    {
      if ( png_muldiv_part_3(v5, *(_DWORD *)a2, 100000, 45455) && (unsigned int)(v5[0] - 95000) <= 0x2710 )
        goto LABEL_12;
    }
    else
    {
      v5[0] = 0;
    }
    png_chunk_report(a1, (int)"gamma value does not match sRGB", 2);
LABEL_12:
    v4 = *(_WORD *)(a2 + 74);
LABEL_13:
    *(_WORD *)(a2 + 72) = a3;
    result = 1;
    *(_DWORD *)(a2 + 4) = 64000;
    *(_DWORD *)(a2 + 8) = 33000;
    *(_DWORD *)(a2 + 12) = 30000;
    *(_DWORD *)(a2 + 16) = 60000;
    *(_DWORD *)(a2 + 20) = 15000;
    *(_DWORD *)(a2 + 24) = 6000;
    *(_DWORD *)(a2 + 28) = 31270;
    *(_DWORD *)(a2 + 32) = 32900;
    *(_DWORD *)(a2 + 36) = 41239;
    *(_DWORD *)(a2 + 40) = 21264;
    *(_DWORD *)(a2 + 44) = 1933;
    *(_DWORD *)(a2 + 48) = 35758;
    *(_DWORD *)(a2 + 52) = 71517;
    *(_DWORD *)(a2 + 56) = 11919;
    *(_DWORD *)(a2 + 60) = 18048;
    *(_DWORD *)(a2 + 64) = 7219;
    *(_DWORD *)(a2 + 68) = 95053;
    *(_DWORD *)a2 = 45455;
    *(_WORD *)(a2 + 74) = v4 | 0xE7;
  }
  return result;
}
// 515780: using guessed type _DWORD sRGB_xy[8];
// 432A00: using guessed type int var_10[4];

//----- (00432BF0) --------------------------------------------------------
void __cdecl png_colorspace_sync(int a1, int a2)
{
  int v2; // eax
  __int16 v3; // cx
  int v4; // esi
  int v5; // esi
  int v6; // esi
  unsigned int v7; // eax
  int v8; // esi
  unsigned int v9; // esi
  int v10; // eax
  unsigned int v11; // esi

  if ( a2 )
  {
    v2 = *(_DWORD *)(a2 + 8);
    qmemcpy((void *)(a2 + 40), (const void *)(a1 + 460), 0x4Cu);
    v3 = *(_WORD *)(a2 + 114);
    if ( v3 < 0 )
    {
      *(_DWORD *)(a2 + 148) &= ~0x10u;
      *(_DWORD *)(a2 + 8) = v2 & 0xFFFFE7FA;
    }
    else
    {
      v4 = v2;
      BYTE1(v2) &= ~8u;
      v5 = v4 | 0x800;
      if ( (v3 & 0x80u) != 0 )
        v2 = v5;
      v6 = v2;
      v7 = v2 & 0xFFFFFFFB;
      v8 = v6 | 4;
      if ( (v3 & 2) != 0 )
        v7 = v8;
      v9 = v7;
      v10 = v7 | 1;
      v11 = v9 & 0xFFFFFFFE;
      if ( (v3 & 1) == 0 )
        v10 = v11;
      *(_DWORD *)(a2 + 8) = v10;
    }
  }
}

//----- (00432C70) --------------------------------------------------------
int __cdecl png_colorspace_sync_info(int a1, int a2)
{
  __int16 v2; // cx
  int v3; // eax
  int v4; // ebx
  int v5; // ebx
  unsigned int v6; // eax
  int v7; // ebx
  unsigned int v8; // ebx
  int result; // eax
  unsigned int v10; // ebx

  v2 = *(_WORD *)(a2 + 114);
  v3 = *(_DWORD *)(a2 + 8);
  if ( v2 < 0 )
  {
    *(_DWORD *)(a2 + 8) = v3 & 0xFFFFE7FA;
    result = a1;
    if ( a1 )
      *(_DWORD *)(a2 + 148) &= ~0x10u;
  }
  else
  {
    v4 = *(_DWORD *)(a2 + 8);
    BYTE1(v3) &= ~8u;
    BYTE1(v4) |= 8u;
    if ( (v2 & 0x80u) != 0 )
      v3 = v4;
    v5 = v3;
    v6 = v3 & 0xFFFFFFFB;
    v7 = v5 | 4;
    if ( (v2 & 2) != 0 )
      v6 = v7;
    v8 = v6;
    result = v6 | 1;
    v10 = v8 & 0xFFFFFFFE;
    if ( (v2 & 1) == 0 )
      result = v10;
    *(_DWORD *)(a2 + 8) = result;
  }
  return result;
}

//----- (00432CD0) --------------------------------------------------------
char __cdecl png_combine_row(int a1, char *a2, int a3)
{
  unsigned int v3; // ebp
  int v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  char *v7; // edi
  unsigned __int8 v8; // dl
  unsigned int Size; // ebp
  unsigned int v10; // eax
  unsigned int v11; // edi
  int v12; // edx
  unsigned int v13; // edx
  unsigned int v14; // esi
  int v15; // eax
  char *v16; // ebx
  _BYTE *v17; // ecx
  unsigned int v18; // edi
  char v19; // dl
  int v20; // eax
  int v21; // edx
  unsigned int v22; // ebx
  unsigned int v23; // ebp
  char *v24; // edx
  unsigned int v25; // ecx
  unsigned int v26; // esi
  _WORD *v27; // edi
  unsigned int v28; // ecx
  unsigned int v29; // eax
  _BYTE *v30; // ebx
  _BYTE *v31; // edx
  unsigned int v32; // ecx
  char *v33; // esi
  _DWORD *v34; // edi
  _BYTE *v35; // ebp
  _BYTE *v36; // edi
  unsigned int v37; // ebp
  _BYTE *v38; // edi
  int v40; // [esp+1Ch] [ebp-30h]
  unsigned int v41; // [esp+1Ch] [ebp-30h]
  char *Src; // [esp+20h] [ebp-2Ch]
  unsigned int v43; // [esp+20h] [ebp-2Ch]
  unsigned int v44; // [esp+20h] [ebp-2Ch]
  unsigned int v45; // [esp+20h] [ebp-2Ch]
  char v46; // [esp+27h] [ebp-25h]
  unsigned __int8 v47; // [esp+28h] [ebp-24h]
  char *v48; // [esp+28h] [ebp-24h]
  unsigned int v49; // [esp+2Ch] [ebp-20h]

  v3 = *(_DWORD *)(a1 + 216);
  v47 = *(_BYTE *)(a1 + 289);
  Src = (char *)(*(_DWORD *)(a1 + 252) + 1);
  if ( !v47 )
    goto LABEL_41;
  v4 = *(_DWORD *)(a1 + 256);
  if ( v4 )
  {
    v5 = v47 <= 7u ? (v3 * v47 + 7) >> 3 : v3 * (v47 >> 3);
    if ( v4 != v5 )
      goto LABEL_41;
  }
  if ( !v3 )
    goto LABEL_41;
  v6 = v3 * v47;
  LOBYTE(v40) = (v3 * v47) & 7;
  if ( (_BYTE)v40 )
  {
    if ( v47 <= 7u )
      v11 = (unsigned int)(v6 + 7) >> 3;
    else
      v11 = v3 * (v47 >> 3);
    v7 = &a2[v11 - 1];
    v46 = *v7;
    v40 = 255 >> v40;
  }
  else
  {
    v46 = 0;
    v7 = 0;
  }
  if ( !*(_BYTE *)(a1 + 278) )
    goto LABEL_12;
  v8 = *(_BYTE *)(a1 + 279);
  v49 = v8;
  if ( (*(_BYTE *)(a1 + 104) & 2) == 0 || *(unsigned __int8 *)(a1 + 279) > 5u )
    goto LABEL_12;
  if ( a3 )
  {
    if ( a3 != 1 || (v12 = v8 & 1) == 0 )
    {
LABEL_12:
      if ( v47 <= 7u )
        Size = (unsigned int)(v6 + 7) >> 3;
      else
        Size = (v47 >> 3) * v3;
      LOBYTE(v10) = (unsigned __int8)memcpy(a2, Src, Size);
LABEL_15:
      if ( v7 )
      {
        LOBYTE(v10) = *v7 ^ v40 & (*v7 ^ v46);
        *v7 = v10;
      }
      return v10;
    }
  }
  else
  {
    LOBYTE(v12) = v8 & 1;
  }
  v10 = (v49 + 1) >> 1;
  v13 = ((unsigned __int8)v12 << (3 - v10)) & 7;
  if ( v13 >= v3 )
    return v10;
  if ( v47 <= 7u )
  {
    v14 = 8u / v47;
    if ( a3 )
    {
      v15 = 0;
      if ( v47 != 1 )
        v15 = (v47 != 2) + 1;
      v16 = (char *)(*(_DWORD *)(a1 + 252) + 1);
      v48 = v7;
      v17 = a2;
      v10 = display_mask_63785[3 * v15 + 9 + (v49 >> 1)];
    }
    else
    {
      if ( v47 != 1 )
        a3 = (v47 != 2) + 1;
      v48 = v7;
      v17 = a2;
      v16 = (char *)(*(_DWORD *)(a1 + 252) + 1);
      v10 = row_mask_63784[6 * a3 + 18 + v49];
    }
    while ( 1 )
    {
      v18 = __ROR4__(v10, 8);
      if ( (_BYTE)v10 )
      {
        v19 = *v16;
        if ( (unsigned __int8)v10 != 255 )
          v19 = *v17 ^ v10 & (*v17 ^ v19);
        *v17 = v19;
      }
      if ( v3 <= v14 )
        break;
      v3 -= v14;
      ++v17;
      ++v16;
      v10 = v18;
    }
    v7 = v48;
    goto LABEL_15;
  }
  if ( (v47 & 7) != 0 )
LABEL_41:
    png_err(a1);
  v20 = v47 >> 3;
  v21 = v20 * v13;
  v41 = v20;
  v22 = (unsigned int)&a2[v21];
  v23 = v20 * v3 - v21;
  v24 = &Src[v21];
  if ( a3 )
  {
    v25 = v20 << ((6 - v49) >> 1);
    if ( v25 > v23 )
      v25 = v23;
    v41 = v25;
  }
  v10 = v20 << ((7 - v49) >> 1);
  switch ( v41 )
  {
    case 2u:
      while ( 1 )
      {
        *(_BYTE *)v22 = *v24;
        *(_BYTE *)(v22 + 1) = v24[1];
        if ( v23 <= v10 )
          break;
        v23 -= v10;
        v24 += v10;
        v22 += v10;
        if ( v23 <= 1 )
        {
          LOBYTE(v10) = *v24;
          *(_BYTE *)v22 = *v24;
          return v10;
        }
      }
      break;
    case 3u:
      *(_BYTE *)v22 = *v24;
      *(_BYTE *)(v22 + 1) = v24[1];
      for ( *(_BYTE *)(v22 + 2) = v24[2]; v10 < v23; *(_BYTE *)(v22 + 2) = v24[2] )
      {
        v24 += v10;
        v22 += v10;
        v23 -= v10;
        *(_BYTE *)v22 = *v24;
        *(_BYTE *)(v22 + 1) = v24[1];
      }
      break;
    case 1u:
      for ( *(_BYTE *)v22 = *v24; v10 < v23; *(_BYTE *)v22 = *v24 )
      {
        v24 += v10;
        v22 += v10;
        v23 -= v10;
      }
      break;
    default:
      if ( v41 > 0xF || (((unsigned __int8)v24 | (unsigned __int8)v22) & 1) != 0 || ((v10 | v41) & 1) != 0 )
      {
        v43 = v10;
        v10 = v41;
        while ( 1 )
        {
          if ( v10 < 4 )
          {
            if ( v10 )
            {
              *(_BYTE *)v22 = *v24;
              if ( (v10 & 2) != 0 )
                *(_WORD *)(v22 + v10 - 2) = *(_WORD *)&v24[v10 - 2];
            }
          }
          else
          {
            *(_DWORD *)v22 = *(_DWORD *)v24;
            *(_DWORD *)(v22 + v10 - 4) = *(_DWORD *)&v24[v10 - 4];
            qmemcpy(
              (void *)((v22 + 4) & 0xFFFFFFFC),
              &v24[-(v22 - ((v22 + 4) & 0xFFFFFFFC))],
              4 * ((v10 + v22 - ((v22 + 4) & 0xFFFFFFFC)) >> 2));
          }
          if ( v23 <= v43 )
            break;
          v23 -= v43;
          v24 += v43;
          v22 += v43;
          if ( v10 > v23 )
            v10 = v23;
        }
      }
      else
      {
        v44 = (v10 - v41) & 0xFFFFFFFE;
        if ( (((unsigned __int8)(v10 | v41) | (unsigned __int8)((unsigned __int8)v24 | v22)) & 3) != 0 )
        {
          v26 = (unsigned int)v24;
          while ( 1 )
          {
            v27 = (_WORD *)v22;
            do
            {
              *v27 = *(_WORD *)v26;
              v26 += 2;
              ++v27;
            }
            while ( v22 + v41 - (_DWORD)v27 );
            if ( v23 <= v10 )
              break;
            v23 -= v10;
            v22 = (unsigned int)v27 + v44;
            v26 += v44;
            if ( v41 > v23 )
            {
              LOBYTE(v10) = v22 >= v26 + 4 || v26 >= v22 + 4;
              if ( ((v23 - 1 > 3) & (unsigned __int8)v10) == 0
                || (LOBYTE(v10) = v22 | v26, (((unsigned __int8)v22 | (unsigned __int8)v26) & 3) != 0) )
              {
                v37 = v26 + v23;
                v38 = (char *)v27 + v44;
                do
                  *v38++ = *(_BYTE *)v26++;
                while ( v26 != v37 );
              }
              else
              {
                v28 = 0;
                v29 = ((v23 - 4) >> 2) + 1;
                do
                {
                  *(_DWORD *)(v22 + 4 * v28) = *(_DWORD *)(v26 + 4 * v28);
                  ++v28;
                }
                while ( v29 > v28 );
                v10 = 4 * v29;
                v30 = (_BYTE *)(v10 + v22);
                v31 = (_BYTE *)(v10 + v26);
                v32 = v23 - v10;
                if ( v10 != v23 )
                {
                  LOBYTE(v10) = *v31;
                  *v30 = *v31;
                  if ( v32 != 1 )
                  {
                    LOBYTE(v10) = v31[1];
                    v30[1] = v10;
                    if ( v32 != 2 )
                    {
                      LOBYTE(v10) = v31[2];
                      v30[2] = v10;
                    }
                  }
                }
              }
              return v10;
            }
          }
        }
        else
        {
          v33 = v24;
          v45 = (v10 - v41) & 0xFFFFFFFC;
          while ( 1 )
          {
            v34 = (_DWORD *)v22;
            do
            {
              *v34 = *(_DWORD *)v33;
              v33 += 4;
              ++v34;
            }
            while ( v22 + v41 - (_DWORD)v34 );
            if ( v23 <= v10 )
              break;
            v23 -= v10;
            v22 = (unsigned int)v34 + v45;
            v33 += v45;
            if ( v41 > v23 )
            {
              v35 = (_BYTE *)(v22 + v23);
              v36 = (char *)v34 + v45;
              do
                *v36++ = *v33++;
              while ( v36 != v35 );
              return v10;
            }
          }
        }
      }
      break;
  }
  return v10;
}
// 514120: using guessed type int display_mask_63785[24];
// 5156E0: using guessed type int row_mask_63784[25];

//----- (004331F0) --------------------------------------------------------
int __cdecl png_compress_IDAT(_DWORD *Block, int a2, int a3, int a4)
{
  int v5; // eax
  _DWORD **v6; // ecx
  _DWORD *v7; // edx
  _DWORD *v8; // esi
  unsigned int v9; // edx
  unsigned int v10; // edi
  unsigned int v11; // ecx
  unsigned int v12; // esi
  unsigned int v13; // edx
  unsigned int v14; // edx
  int v15; // edi
  int v16; // esi
  int v17; // ecx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // eax
  int result; // eax
  signed int v22; // esi
  int v23; // edi
  unsigned int v24; // edx
  unsigned int v25; // edx
  _DWORD *v26; // eax
  unsigned int v27; // [esp+28h] [ebp-34h]
  int v28; // [esp+28h] [ebp-34h]
  _DWORD *v29; // [esp+2Ch] [ebp-30h]
  unsigned int v30; // [esp+30h] [ebp-2Ch]
  unsigned int v31; // [esp+30h] [ebp-2Ch]
  int v32; // [esp+34h] [ebp-28h]
  int v33; // [esp+38h] [ebp-24h]
  unsigned int v34; // [esp+3Ch] [ebp-20h]

  v5 = Block[27];
  if ( v5 == 1229209940 )
  {
    v29 = Block + 28;
    goto LABEL_49;
  }
  v6 = (_DWORD **)Block[42];
  if ( v6 )
  {
    v7 = *v6;
    if ( *v6 )
    {
      *v6 = 0;
      do
      {
        v8 = (_DWORD *)*v7;
        png_free(Block, v7);
        v7 = v8;
      }
      while ( v8 );
      v5 = Block[27];
    }
  }
  else
  {
    v26 = png_malloc((int)Block, Block[43] + 4);
    Block[42] = v26;
    *v26 = 0;
    v5 = Block[27];
  }
  v9 = Block[58];
  v10 = Block[55];
  if ( v9 > 0x7FFF || v10 > 0x7FFF )
  {
    v27 = -1;
    goto LABEL_25;
  }
  if ( !*((_BYTE *)Block + 278) )
  {
    v27 = v10 * (v9 + 1);
    goto LABEL_25;
  }
  v11 = *((unsigned __int8 *)Block + 284);
  v12 = Block[54];
  v30 = v11 >> 3;
  if ( v11 > 7 )
  {
    v27 = 0;
    if ( (v12 + 7) >> 3 )
      v27 = ((v10 + 7) >> 3) * (v30 * ((v12 + 7) >> 3) + 1);
    if ( (v12 + 3) >> 3 )
      v27 += ((v10 + 7) >> 3) * (v30 * ((v12 + 3) >> 3) + 1);
    v24 = (v12 + 3) >> 2;
    if ( v24 )
      v27 += ((v10 + 3) >> 3) * (v30 * v24 + 1);
    if ( (v12 + 1) >> 2 )
      v27 += ((v10 + 3) >> 2) * (v30 * ((v12 + 1) >> 2) + 1);
    v25 = (v12 + 1) >> 1;
    if ( v25 )
      v27 += ((v10 + 1) >> 2) * (v30 * v25 + 1);
    if ( v12 >> 1 )
    {
      v27 += ((v10 + 1) >> 1) * (v30 * (v12 >> 1) + 1);
    }
    else if ( !v12 )
    {
      goto LABEL_25;
    }
    v27 += (v10 >> 1) * (v12 * v30 + 1);
    goto LABEL_25;
  }
  v27 = 0;
  if ( (v12 + 7) >> 3 )
    v27 = ((v10 + 7) >> 3) * (((v11 * ((v12 + 7) >> 3) + 7) >> 3) + 1);
  if ( (v12 + 3) >> 3 )
    v27 += ((v10 + 7) >> 3) * (((v11 * ((v12 + 3) >> 3) + 7) >> 3) + 1);
  v13 = (v12 + 3) >> 2;
  if ( v13 )
    v27 += ((v10 + 3) >> 3) * (((v11 * v13 + 7) >> 3) + 1);
  if ( (v12 + 1) >> 2 )
    v27 += ((v10 + 3) >> 2) * (((v11 * ((v12 + 1) >> 2) + 7) >> 3) + 1);
  v14 = (v12 + 1) >> 1;
  if ( v14 )
    v27 += ((v10 + 1) >> 2) * (((v11 * v14 + 7) >> 3) + 1);
  if ( v12 >> 1 )
  {
    v27 += ((v10 + 1) >> 1) * (((v11 * (v12 >> 1) + 7) >> 3) + 1);
LABEL_23:
    v27 += (v10 >> 1) * (((v12 * v11 + 7) >> 3) + 1);
    goto LABEL_25;
  }
  if ( v12 )
    goto LABEL_23;
LABEL_25:
  if ( v5 )
  {
    if ( v5 == 1229209940 )
    {
      Block[34] = "in use by IDAT";
      goto LABEL_47;
    }
    Block[27] = 0;
  }
  v15 = Block[25];
  v16 = Block[46];
  v31 = Block[44];
  v32 = Block[45];
  v33 = Block[47];
  if ( (v15 & 1) != 0 )
    v34 = Block[48];
  else
    v34 = *((_BYTE *)Block + 280) != 8;
  if ( v27 <= 0x4000 )
  {
    v17 = v16 - 1;
    v18 = 1 << (v16 - 1);
    if ( v18 >= v27 + 262 )
    {
      while ( 1 )
      {
        v18 >>= 1;
        v16 = v17;
        if ( v18 < v27 + 262 )
          break;
        --v17;
      }
    }
  }
  v29 = Block + 28;
  if ( (v15 & 2) == 0 )
    goto LABEL_40;
  if ( v31 != Block[49] || v32 != Block[50] || Block[51] != v16 || v33 != Block[52] || Block[53] != v34 )
  {
    deflateEnd(Block + 28);
    Block[25] &= ~2u;
LABEL_40:
    Block[28] = 0;
    Block[29] = 0;
    Block[31] = 0;
    Block[32] = 0;
    v19 = deflateInit2_(Block + 28, v31, v32, v16, v33, v34, "1.2.11", 56);
    if ( v19 )
    {
LABEL_46:
      png_zstream_error((int)Block, v19);
      goto LABEL_47;
    }
    Block[25] |= 2u;
    goto LABEL_42;
  }
  Block[28] = 0;
  Block[29] = 0;
  Block[31] = 0;
  Block[32] = 0;
  v19 = deflateReset(Block + 28);
  if ( v19 )
    goto LABEL_46;
LABEL_42:
  v20 = Block[42];
  Block[27] = 1229209940;
  Block[31] = v20 + 4;
  Block[32] = Block[43];
LABEL_49:
  Block[28] = a2;
  while ( 1 )
  {
    do
    {
      Block[29] = a3;
      result = deflate(v29, a4);
      v22 = Block[32];
      a3 = Block[29];
      Block[29] = 0;
      v23 = result;
      if ( v22 )
        break;
      v22 = Block[43];
      v28 = Block[42] + 4;
      if ( v22 )
        png_write_complete_chunk((int)Block, 0x49444154u, (_BYTE *)(Block[42] + 4), v22);
      result = v28;
      Block[24] |= 4u;
      Block[32] = v22;
      Block[31] = v28;
      if ( v23 )
        break;
      result = a4;
    }
    while ( a4 );
    if ( v23 )
      break;
    if ( !a3 )
    {
      if ( a4 != 4 )
        return result;
LABEL_47:
      png_err((int)Block);
    }
  }
  if ( v23 != 1 || a4 != 4 )
  {
    png_zstream_error((int)Block, v23);
    png_err((int)Block);
  }
  result = Block[43] - v22;
  if ( result )
    result = png_write_complete_chunk((int)Block, 0x49444154u, (_BYTE *)(Block[42] + 4), result);
  Block[32] = 0;
  Block[31] = 0;
  Block[24] |= 0xCu;
  Block[27] = 0;
  return result;
}

//----- (004337F0) --------------------------------------------------------
BOOL __cdecl png_crc_error(int a1)
{
  unsigned __int8 v2; // [esp+1Ch] [ebp-10h]
  unsigned __int8 v3; // [esp+1Dh] [ebp-Fh]
  unsigned __int8 v4; // [esp+1Eh] [ebp-Eh]
  unsigned __int8 v5; // [esp+1Fh] [ebp-Dh]

  if ( (*(_BYTE *)(a1 + 247) & 0x20) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 100) & 0x300) != 768 )
    {
LABEL_3:
      png_read_data(a1);
      return (v2 << 24) + (v3 << 16) + v5 + (v4 << 8) != *(_DWORD *)(a1 + 264);
    }
  }
  else if ( (*(_DWORD *)(a1 + 100) & 0x800) == 0 )
  {
    goto LABEL_3;
  }
  png_read_data(a1);
  return 0;
}
// 433828: variable 'v2' is possibly undefined
// 433837: variable 'v3' is possibly undefined
// 43382D: variable 'v5' is possibly undefined
// 433843: variable 'v4' is possibly undefined

//----- (00433890) --------------------------------------------------------
int __cdecl png_crc_finish(int a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  char v5[1036]; // [esp+10h] [ebp-40Ch] BYREF

  v2 = a2;
  if ( a2 && a1 )
  {
    while ( v2 > 0x3FF )
    {
      v2 -= 1024;
      png_read_data(a1);
      png_calculate_crc(a1, v5, 0x400u);
      if ( !v2 )
        goto LABEL_5;
    }
    png_read_data(a1);
    png_calculate_crc(a1, v5, v2);
  }
LABEL_5:
  if ( (*(_BYTE *)(a1 + 247) & 0x20) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 100) & 0x300) != 768 )
      goto LABEL_7;
LABEL_13:
    png_read_data(a1);
    return 0;
  }
  if ( (*(_DWORD *)(a1 + 100) & 0x800) != 0 )
    goto LABEL_13;
LABEL_7:
  png_read_data(a1);
  if ( ((unsigned __int8)v5[0] << 24)
     + ((unsigned __int8)v5[1] << 16)
     + (unsigned __int8)v5[3]
     + ((unsigned __int8)v5[2] << 8) == *(_DWORD *)(a1 + 264) )
    return 0;
  v3 = *(_DWORD *)(a1 + 100);
  if ( (*(_BYTE *)(a1 + 247) & 0x20) != 0 )
    LOBYTE(v3) = ((v3 >> 9) ^ 1) & 1;
  else
    v3 = (v3 >> 10) & 1;
  if ( !(_BYTE)v3 )
    png_err(a1);
  return 1;
}

//----- (004339D0) --------------------------------------------------------
int __usercall png_crc_finish_constprop_7@<eax>(int a1@<eax>)
{
  int v2; // eax
  unsigned int v3; // eax
  unsigned __int8 v5; // [esp+1Ch] [ebp-10h]
  unsigned __int8 v6; // [esp+1Dh] [ebp-Fh]
  unsigned __int8 v7; // [esp+1Eh] [ebp-Eh]
  unsigned __int8 v8; // [esp+1Fh] [ebp-Dh]

  v2 = *(_DWORD *)(a1 + 100);
  if ( (*(_BYTE *)(a1 + 247) & 0x20) != 0 )
  {
    if ( (v2 & 0x300) != 768 )
      goto LABEL_3;
LABEL_9:
    png_read_data(a1);
    return 0;
  }
  if ( (v2 & 0x800) != 0 )
    goto LABEL_9;
LABEL_3:
  png_read_data(a1);
  if ( (v5 << 24) + (v6 << 16) + v8 + (v7 << 8) == *(_DWORD *)(a1 + 264) )
    return 0;
  v3 = *(_DWORD *)(a1 + 100);
  if ( (*(_BYTE *)(a1 + 247) & 0x20) != 0 )
    LOBYTE(v3) = ((v3 >> 9) ^ 1) & 1;
  else
    v3 = (v3 >> 10) & 1;
  if ( !(_BYTE)v3 )
    png_err(a1);
  return 1;
}
// 433A06: variable 'v5' is possibly undefined
// 433A15: variable 'v6' is possibly undefined
// 433A0B: variable 'v8' is possibly undefined
// 433A21: variable 'v7' is possibly undefined

//----- (00433AA0) --------------------------------------------------------
int __cdecl png_crc_read(int a1, _BYTE *a2, unsigned int a3)
{
  int result; // eax

  if ( a1 )
  {
    png_read_data(a1);
    return png_calculate_crc(a1, a2, a3);
  }
  return result;
}

//----- (00433AF0) --------------------------------------------------------
int __usercall png_create_colormap_entry@<eax>(
        int *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ecx>,
        unsigned int a4,
        unsigned int a5,
        unsigned int a6,
        int a7)
{
  int v9; // ebp
  int v10; // eax
  bool v11; // si
  int v12; // ecx
  unsigned int v13; // edx
  int result; // eax
  BOOL v15; // ebp
  int v16; // ecx
  int v17; // edx
  int v18; // esi
  unsigned int v19; // edx
  unsigned __int16 v20; // ax
  BOOL v21; // eax
  int v22; // edx
  int v23; // edi
  _BYTE *v24; // edx
  int v25; // ecx
  _WORD *v26; // eax
  unsigned int v27; // edi
  unsigned int v28; // ecx
  BOOL v29; // eax
  int v30; // eax
  bool v32; // [esp+18h] [ebp-34h]
  int v33; // [esp+18h] [ebp-34h]
  int v34; // [esp+18h] [ebp-34h]
  BOOL v35; // [esp+1Ch] [ebp-30h]
  bool v36; // [esp+23h] [ebp-29h]
  int v37; // [esp+24h] [ebp-28h]
  int v38; // [esp+24h] [ebp-28h]
  int v39; // [esp+24h] [ebp-28h]
  int v40; // [esp+24h] [ebp-28h]
  unsigned int v41; // [esp+28h] [ebp-24h]
  int v42; // [esp+2Ch] [ebp-20h]

  v9 = *a1;
  v10 = a7;
  v11 = (*(_DWORD *)(v9 + 16) & 4) != 0;
  v12 = 2 - ((*(_DWORD *)(v9 + 16) & 4) == 0);
  if ( (*(_DWORD *)(v9 + 16) & 2) != 0 )
  {
    v36 = 0;
    v35 = 0;
  }
  else
  {
    v36 = a3 != a4 || a4 != a5;
    v35 = v36;
  }
  if ( a2 > 0xFF )
LABEL_7:
    png_err(**(_DWORD **)v9);
  if ( a7 == 3 )
  {
    v10 = a1[8];
    if ( !v10 )
    {
      v39 = 2 - ((*(_DWORD *)(v9 + 16) & 4) == 0);
      v34 = *(_DWORD *)(**(_DWORD **)v9 + 460);
      v21 = png_gamma_significant(v34);
      v12 = v39;
      if ( !v21 )
      {
        a1[8] = 4;
        goto LABEL_10;
      }
      if ( v34 <= 99999 )
      {
        if ( !v34 || (v29 = png_gamma_significant((11 * v34 + 2) / 5), v12 = v39, !v29) )
        {
          a1[8] = 1;
          goto LABEL_31;
        }
      }
      a1[8] = 3;
      v40 = v12;
      v30 = png_reciprocal(v34);
      v12 = v40;
      a1[9] = v30;
      v10 = a1[8];
    }
    if ( v10 == 3 )
    {
      v38 = v12;
      v33 = a1[9];
      a3 = (unsigned __int16)png_gamma_16bit_correct(257 * a3, v33);
      a4 = (unsigned __int16)png_gamma_16bit_correct(257 * a4, v33);
      v20 = png_gamma_16bit_correct(257 * a5, v33);
      v12 = v38;
      a5 = v20;
      if ( !v11 && !v36 )
      {
        LOBYTE(a3) = (unsigned __int16)(png_sRGB_base[(255 * a3) >> 15]
                                      + (((unsigned __int8)png_sRGB_delta[(255 * a3) >> 15]
                                        * ((255 * (_WORD)a3) & 0x7FFFu)) >> 12)) >> 8;
        LOBYTE(a4) = (unsigned __int16)(((((255 * a4) & 0x7FFF) * (unsigned __int8)png_sRGB_delta[(255 * a4) >> 15]) >> 12)
                                      + png_sRGB_base[(255 * a4) >> 15]) >> 8;
        v13 = *(_DWORD *)(v9 + 16);
        LOBYTE(a5) = (unsigned __int16)(png_sRGB_base[(255 * (unsigned int)v20) >> 15]
                                      + (((unsigned __int8)png_sRGB_delta[(255 * (unsigned int)v20) >> 15]
                                        * ((255 * v20) & 0x7FFFu)) >> 12)) >> 8;
        v42 = v13 & 0x21;
        v32 = v42 == 33;
        v15 = v42 == 33;
        v41 = v13 >> 3;
        v37 = (v13 >> 3) & 2;
        goto LABEL_33;
      }
      goto LABEL_11;
    }
    if ( v10 != 4 )
      goto LABEL_5;
LABEL_10:
    a3 *= 257;
    a4 *= 257;
    a5 *= 257;
LABEL_11:
    a6 *= 257;
LABEL_12:
    v13 = *(_DWORD *)(v9 + 16);
    v42 = v13 & 0x21;
    result = v42;
    v32 = v42 == 33;
    v15 = v32;
    v41 = v13 >> 3;
    v37 = (v13 >> 3) & 2;
    goto LABEL_13;
  }
LABEL_5:
  if ( v10 != 1 )
  {
    if ( v10 != 2 )
      goto LABEL_7;
    goto LABEL_12;
  }
LABEL_31:
  v13 = *(_DWORD *)(v9 + 16);
  v42 = v13 & 0x21;
  v32 = v42 == 33;
  v15 = v42 == 33;
  v41 = v13 >> 3;
  v37 = (v13 >> 3) & 2;
  if ( !v11 && !v36 )
    goto LABEL_33;
  a3 = (unsigned __int16)png_sRGB_table[a3];
  a4 = (unsigned __int16)png_sRGB_table[a4];
  a5 = (unsigned __int16)png_sRGB_table[a5];
  result = a6 << 8;
  a6 *= 257;
LABEL_13:
  if ( v35 )
  {
    result = 2366 * a5;
    a3 = 2366 * a5 + 6968 * a3 + 23434 * a4;
    if ( v12 == 2 )
    {
      a3 = (a3 + 0x4000) >> 15;
      a5 = a3;
      a4 = a3;
LABEL_15:
      v16 = a1[3];
      v17 = (v13 & 3) + 1;
      v18 = v16 + 2 * v17 * a2;
      if ( v17 != 3 )
      {
        if ( v17 != 4 )
        {
          if ( v17 == 2 )
          {
            result = v42 != 33;
            *(_WORD *)(v18 + 2 * result) = a6;
          }
          if ( a6 <= 0xFFFE )
          {
            result = a6;
            LOWORD(v19) = 0;
            if ( a6 )
            {
              result = -2147450879 * (a6 * a4 + 0x7FFF);
              v19 = (a6 * a4 + 0x7FFF) / 0xFFFF;
            }
          }
          else
          {
            LOWORD(v19) = a4;
          }
          *(_WORD *)(v18 + 2 * v15) = v19;
          return result;
        }
        v26 = (_WORD *)(v18 + 6);
        if ( v32 )
          v26 = (_WORD *)(v16 + 8 * a2);
        *v26 = a6;
      }
      if ( a6 <= 0xFFFE )
      {
        if ( a6 )
        {
          v27 = (a6 * a5 + 0x7FFF) / 0xFFFF;
          v28 = (a6 * a4 + 0x7FFF) / 0xFFFF;
          a3 = (a6 * a3 + 0x7FFF) / 0xFFFF;
        }
        else
        {
          LOWORD(a3) = 0;
          LOWORD(v28) = 0;
          LOWORD(v27) = 0;
        }
      }
      else
      {
        LOWORD(v27) = a5;
        LOWORD(v28) = a4;
      }
      result = v15 + 1;
      *(_WORD *)(v18 + 2 * (v15 + (~(_BYTE)v41 & 2))) = v27;
      *(_WORD *)(v18 + 2 * (v15 + 1)) = v28;
      *(_WORD *)(v18 + 2 * (v37 + v15)) = a3;
      return result;
    }
    LOBYTE(a3) = (unsigned __int16)(png_sRGB_base[(255 * ((a3 + 128) >> 8) + 64) >> 22]
                                  + (((unsigned __int8)png_sRGB_delta[(255 * ((a3 + 128) >> 8) + 64) >> 22]
                                    * (((255 * ((a3 + 128) >> 8) + 64) >> 7) & 0x7FFF)) >> 12)) >> 8;
    a6 = (255 * a6 + 32895) >> 16;
    LOBYTE(a5) = a3;
    LOBYTE(a4) = a3;
  }
  else
  {
    if ( v12 != 1 )
      goto LABEL_15;
    LOBYTE(a3) = (unsigned __int16)(png_sRGB_base[(255 * a3) >> 15]
                                  + (((unsigned __int8)png_sRGB_delta[(255 * a3) >> 15] * ((255 * (_WORD)a3) & 0x7FFFu)) >> 12)) >> 8;
    LOBYTE(a4) = (unsigned __int16)(png_sRGB_base[(255 * a4) >> 15]
                                  + (((unsigned __int8)png_sRGB_delta[(255 * a4) >> 15] * ((255 * a4) & 0x7FFF)) >> 12)) >> 8;
    LOBYTE(a5) = (unsigned __int16)(png_sRGB_base[(255 * a5) >> 15]
                                  + (((unsigned __int8)png_sRGB_delta[(255 * a5) >> 15] * ((255 * a5) & 0x7FFF)) >> 12)) >> 8;
    a6 = (255 * a6 + 32895) >> 16;
  }
LABEL_33:
  v22 = (v13 & 3) + 1;
  v23 = a1[3] + v22 * a2;
  switch ( v22 )
  {
    case 3:
LABEL_43:
      v25 = v23 + v15;
      *(_BYTE *)(v25 + (~(_BYTE)v41 & 2)) = a5;
      *(_BYTE *)(v23 + v15 + 1) = a4;
      result = v37;
      *(_BYTE *)(v25 + v37) = a3;
      return result;
    case 4:
      v24 = (_BYTE *)(v23 + 3);
      if ( v32 )
        v24 = (_BYTE *)v23;
      *v24 = a6;
      goto LABEL_43;
    case 2:
      *(_BYTE *)(v23 + (v42 != 33)) = a6;
      break;
  }
  result = (unsigned __int8)a4;
  *(_BYTE *)(v23 + v15) = a4;
  return result;
}
// 514EE0: using guessed type __int16 png_sRGB_base[512];
// 5154E0: using guessed type __int16 png_sRGB_table[256];

//----- (004341E0) --------------------------------------------------------
int __usercall png_create_colormap_entry_constprop_5@<eax>(
        int *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ecx>,
        unsigned int a4,
        unsigned int a5,
        int a6)
{
  int v8; // ebp
  int v9; // eax
  bool v10; // cl
  int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // eax
  __int16 v14; // cx
  unsigned int v15; // edx
  BOOL v16; // ebp
  int v17; // ecx
  int v18; // edx
  int v19; // esi
  int result; // eax
  int v21; // ebx
  int v22; // edx
  int v23; // esi
  int v24; // ebx
  char *v25; // eax
  int v26; // edx
  _WORD *v27; // eax
  BOOL v28; // eax
  int v29; // eax
  unsigned int v30; // [esp+10h] [ebp-3Ch]
  bool v31; // [esp+17h] [ebp-35h]
  bool v32; // [esp+17h] [ebp-35h]
  bool v33; // [esp+17h] [ebp-35h]
  bool v34; // [esp+17h] [ebp-35h]
  bool v35; // [esp+18h] [ebp-34h]
  char v36; // [esp+18h] [ebp-34h]
  BOOL v37; // [esp+1Ch] [ebp-30h]
  int v38; // [esp+20h] [ebp-2Ch]
  int v39; // [esp+24h] [ebp-28h]
  unsigned int v40; // [esp+28h] [ebp-24h]
  int v41; // [esp+2Ch] [ebp-20h]

  v8 = *a1;
  v30 = a3;
  v9 = a6;
  v35 = (*(_DWORD *)(v8 + 16) & 4) != 0;
  v38 = 2 - ((*(_DWORD *)(v8 + 16) & 4) == 0);
  if ( (*(_DWORD *)(v8 + 16) & 2) != 0 )
  {
    v10 = 0;
    v37 = 0;
  }
  else
  {
    v10 = a4 != a5 || a3 != a4;
    v37 = v10;
  }
  if ( a2 > 0xFF )
LABEL_7:
    png_err(**(_DWORD **)v8);
  if ( a6 == 3 )
  {
    v9 = a1[8];
    if ( !v9 )
    {
      v33 = v10;
      v21 = *(_DWORD *)(**(_DWORD **)v8 + 460);
      if ( !png_gamma_significant(v21) )
      {
        a1[8] = 4;
        goto LABEL_15;
      }
      v10 = v33;
      if ( v21 <= 99999 )
      {
        if ( !v21 || (v28 = png_gamma_significant((11 * v21 + 2) / 5), v10 = v33, !v28) )
        {
          a1[8] = 1;
          goto LABEL_30;
        }
      }
      a1[8] = 3;
      v34 = v10;
      v29 = png_reciprocal(v21);
      v10 = v34;
      a1[9] = v29;
      v9 = a1[8];
    }
    if ( v9 == 3 )
    {
      v11 = a1[9];
      v31 = v10;
      v30 = (unsigned __int16)png_gamma_16bit_correct(257 * v30, v11);
      a4 = (unsigned __int16)png_gamma_16bit_correct(257 * a4, v11);
      a5 = (unsigned __int16)png_gamma_16bit_correct(257 * a5, v11);
      if ( !v35 && !v31 )
      {
        v36 = -1;
        LOBYTE(v30) = (unsigned __int16)(png_sRGB_base[(255 * v30) >> 15]
                                       + (((unsigned __int8)png_sRGB_delta[(255 * v30) >> 15]
                                         * ((255 * (_WORD)v30) & 0x7FFFu)) >> 12)) >> 8;
        LOBYTE(a4) = (unsigned __int16)((((unsigned __int8)png_sRGB_delta[(255 * a4) >> 15] * ((255 * a4) & 0x7FFF)) >> 12)
                                      + png_sRGB_base[(255 * a4) >> 15]) >> 8;
        v12 = (255 * a5) >> 15;
        v13 = (unsigned __int8)png_sRGB_delta[v12] * ((255 * a5) & 0x7FFF);
        v14 = png_sRGB_base[v12];
        v15 = *(_DWORD *)(v8 + 16);
        LOBYTE(a5) = (unsigned __int16)(v14 + (v13 >> 12)) >> 8;
        v41 = v15 & 0x21;
        v32 = v41 == 33;
        v16 = v41 == 33;
        v40 = v15 >> 3;
        v39 = (v15 >> 3) & 2;
        goto LABEL_32;
      }
      goto LABEL_16;
    }
    if ( v9 != 4 )
      goto LABEL_5;
LABEL_15:
    v30 *= 257;
    a4 *= 257;
    a5 *= 257;
LABEL_16:
    v15 = *(_DWORD *)(v8 + 16);
    v36 = -1;
    v17 = 0xFFFF;
    v41 = v15 & 0x21;
    v32 = v41 == 33;
    v16 = v41 == 33;
    v40 = v15 >> 3;
    v39 = (v15 >> 3) & 2;
    goto LABEL_17;
  }
LABEL_5:
  if ( v9 != 1 )
  {
    if ( v9 != 2 )
      goto LABEL_7;
    v15 = *(_DWORD *)(v8 + 16);
    v36 = 1;
    v17 = 255;
    v41 = v15 & 0x21;
    v32 = v41 == 33;
    v16 = v41 == 33;
    v40 = v15 >> 3;
    v39 = (v15 >> 3) & 2;
    goto LABEL_17;
  }
LABEL_30:
  v15 = *(_DWORD *)(v8 + 16);
  v40 = v15 >> 3;
  v32 = (v15 & 0x21) == 33;
  v16 = v32;
  v41 = v15 & 0x21;
  v39 = (v15 >> 3) & 2;
  if ( !v35 )
  {
    v36 = -1;
    if ( !v10 )
      goto LABEL_32;
  }
  v36 = -1;
  v17 = 0xFFFF;
  v30 = (unsigned __int16)png_sRGB_table[v30];
  a4 = (unsigned __int16)png_sRGB_table[a4];
  a5 = (unsigned __int16)png_sRGB_table[a5];
LABEL_17:
  if ( v37 )
  {
    v24 = 2366 * a5 + 23434 * a4 + 6968 * v30;
    if ( v38 == 2 )
    {
      a5 = (unsigned int)(v24 + 0x4000) >> 15;
      a4 = a5;
      v30 = a5;
      goto LABEL_19;
    }
    LOBYTE(v30) = (unsigned __int16)(png_sRGB_base[(255 * ((unsigned int)(v24 + 128) >> 8) + 64) >> 22]
                                   + (((unsigned __int8)png_sRGB_delta[(255 * ((unsigned int)(v24 + 128) >> 8) + 64) >> 22]
                                     * (((255 * ((unsigned int)(v24 + 128) >> 8) + 64) >> 7) & 0x7FFF)) >> 12)) >> 8;
    LOBYTE(a5) = v30;
    LOBYTE(a4) = v30;
LABEL_32:
    v22 = (v15 & 3) + 1;
    v23 = a1[3] + v22 * a2;
    if ( v22 != 3 )
    {
      if ( v22 != 4 )
      {
        if ( v22 == 2 )
          *(_BYTE *)(v23 + (v41 != 33)) = v36;
        result = (unsigned __int8)a4;
        *(_BYTE *)(v23 + v16) = a4;
        return result;
      }
      v25 = (char *)(v23 + 3);
      if ( v32 )
        v25 = (char *)v23;
      *v25 = v36;
    }
    v26 = v23 + v16;
    *(_BYTE *)(v26 + (~(_BYTE)v40 & 2)) = a5;
    *(_BYTE *)(v23 + v16 + 1) = a4;
    result = v39;
    *(_BYTE *)(v26 + v39) = v30;
    return result;
  }
  if ( v38 == 1 )
  {
    LOBYTE(v30) = (unsigned __int16)(png_sRGB_base[(255 * v30) >> 15]
                                   + (((unsigned __int8)png_sRGB_delta[(255 * v30) >> 15]
                                     * ((255 * (_WORD)v30) & 0x7FFFu)) >> 12)) >> 8;
    LOBYTE(a4) = (unsigned __int16)(png_sRGB_base[(255 * a4) >> 15]
                                  + (((unsigned __int8)png_sRGB_delta[(255 * a4) >> 15] * ((255 * a4) & 0x7FFF)) >> 12)) >> 8;
    LOBYTE(a5) = (unsigned __int16)(png_sRGB_base[(255 * a5) >> 15]
                                  + (((unsigned __int8)png_sRGB_delta[(255 * a5) >> 15] * ((255 * a5) & 0x7FFF)) >> 12)) >> 8;
    goto LABEL_32;
  }
LABEL_19:
  v18 = (v15 & 3) + 1;
  v19 = a1[3] + 2 * v18 * a2;
  if ( v18 != 3 )
  {
    if ( v18 != 4 )
    {
      if ( v18 == 2 )
        *(_WORD *)(v19 + 2 * (v41 != 33)) = v17;
      if ( v17 != 0xFFFF )
        a4 = (a4 * v17 + 0x7FFF) / 0xFFFF;
      result = (unsigned __int16)a4;
      *(_WORD *)(v19 + 2 * v16) = a4;
      return result;
    }
    v27 = (_WORD *)(v19 + 6);
    if ( v32 )
      v27 = (_WORD *)v19;
    *v27 = v17;
  }
  if ( v17 != 0xFFFF )
  {
    a5 = (v17 * a5 + 0x7FFF) / 0xFFFF;
    a4 = (v17 * a4 + 0x7FFF) / 0xFFFF;
    v30 = (v17 * v30 + 0x7FFF) / 0xFFFF;
  }
  *(_WORD *)(v19 + 2 * (v16 + (~(_BYTE)v40 & 2))) = a5;
  *(_WORD *)(v19 + 2 * (v16 + 1)) = a4;
  result = (unsigned __int16)v30;
  *(_WORD *)(v19 + 2 * (v39 + v16)) = v30;
  return result;
}
// 514EE0: using guessed type __int16 png_sRGB_base[512];
// 5154E0: using guessed type __int16 png_sRGB_table[256];

//----- (00434890) --------------------------------------------------------
_DWORD *__cdecl png_create_info_struct(size_t Size)
{
  _DWORD *result; // eax

  if ( !Size )
    return 0;
  result = png_malloc_base(Size, 0x98u);
  if ( result )
  {
    *result = 0;
    result[37] = 0;
    memset(
      (void *)((unsigned int)(result + 1) & 0xFFFFFFFC),
      0,
      4 * (((unsigned int)result - ((unsigned int)(result + 1) & 0xFFFFFFFC) + 152) >> 2));
  }
  return result;
}

//----- (004348F0) --------------------------------------------------------
size_t *__cdecl png_create_png_struct(char *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  char v5; // bl
  size_t v6; // edx
  char v7; // bl
  char v8; // bl
  char v9; // bl
  char v10; // bl
  char v11; // bl
  char v12; // bl
  size_t *result; // eax
  char v14; // [esp+1Fh] [ebp-279h]
  char v15[64]; // [esp+28h] [ebp-270h] BYREF
  size_t Size[140]; // [esp+68h] [ebp-230h] BYREF

  memset(Size, 0, 0x218u);
  Size[102] = 1000000;
  Size[103] = 1000000;
  Size[104] = 1000;
  Size[105] = 8000000;
  png_set_error_fn((int)Size, a2, a3);
  v3 = _setjmp3(v15, 0);
  if ( v3 )
    return 0;
  Size[18] = 0;
  Size[17] = (size_t)v15;
  Size[16] = (size_t)longjmp;
  if ( !a1 )
    return 0;
  v4 = Size[25];
  v5 = *a1;
  v6 = Size[25];
  if ( *a1 == 49 )
  {
    v14 = 0;
  }
  else
  {
    v6 = Size[25] | 0x20000;
    if ( v5 != 46 )
    {
      if ( !v5 )
        goto LABEL_38;
      v14 = 1;
      v7 = a1[1];
      if ( v7 != 46 )
        goto LABEL_7;
      goto LABEL_34;
    }
    v14 = 1;
    v3 = 1;
  }
  v7 = a1[1];
  if ( v7 != 46 )
  {
LABEL_7:
    v6 |= 0x20000u;
    if ( !v7 )
      goto LABEL_38;
    v14 = 1;
    goto LABEL_9;
  }
LABEL_34:
  if ( v3 == 1 )
    goto LABEL_39;
  v3 = 1;
LABEL_9:
  v8 = a1[2];
  if ( v8 != 54 )
  {
    v6 |= 0x20000u;
    if ( v8 == 46 )
    {
      if ( v3 == 1 )
        goto LABEL_40;
      v14 = 1;
      v3 = 1;
    }
    else
    {
      if ( !v8 )
        goto LABEL_38;
      v14 = 1;
    }
  }
  v9 = a1[3];
  if ( v9 != 46 )
  {
    v6 |= 0x20000u;
    if ( !v9 )
      goto LABEL_38;
    v14 = 1;
    goto LABEL_16;
  }
  if ( v3 == 1 )
  {
LABEL_39:
    if ( !v14 )
      goto LABEL_27;
    goto LABEL_40;
  }
  v3 = 1;
LABEL_16:
  v10 = a1[4];
  if ( v10 != 51 )
  {
    v6 |= 0x20000u;
    if ( v10 == 46 )
    {
      if ( v3 == 1 )
        goto LABEL_40;
      v14 = 1;
      v3 = 1;
    }
    else
    {
      if ( !v10 )
        goto LABEL_38;
      v14 = 1;
    }
  }
  v11 = a1[5];
  if ( v11 == 52 )
  {
LABEL_24:
    v12 = a1[6];
    if ( v12 )
    {
      v4 = v6 | 0x20000;
      if ( v12 == 46 )
      {
        v6 |= 0x20000u;
        if ( v3 == 1 )
          goto LABEL_40;
      }
LABEL_26:
      Size[25] = v4;
      goto LABEL_27;
    }
    if ( !v14 )
      goto LABEL_27;
LABEL_38:
    v4 = v6;
    goto LABEL_26;
  }
  v6 |= 0x20000u;
  if ( v11 != 46 )
  {
    if ( !v11 )
      goto LABEL_38;
    v14 = 1;
    goto LABEL_24;
  }
  if ( v3 != 1 )
  {
    v14 = 1;
    v3 = 1;
    goto LABEL_24;
  }
LABEL_40:
  Size[25] = v6;
  v4 = v6;
LABEL_27:
  if ( (v4 & 0x20000) != 0 )
    return 0;
  result = (size_t *)png_malloc_warn((size_t)Size, 0x218u);
  if ( result )
  {
    Size[38] = (size_t)result;
    Size[36] = (size_t)png_zalloc;
    Size[37] = (size_t)png_zfree;
    memset(&Size[16], 0, 12);
    qmemcpy(result, Size, 0x218u);
  }
  return result;
}
// 424E70: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);
// 4447B0: using guessed type int __cdecl png_zfree(_DWORD, _DWORD);

//----- (00434C10) --------------------------------------------------------
size_t *__cdecl png_create_read_struct(char *a1, int a2, int a3)
{
  size_t *png_struct; // eax
  size_t *v4; // ebx

  png_struct = png_create_png_struct(a1, a2, a3);
  v4 = png_struct;
  if ( png_struct )
  {
    png_struct[24] = 0x8000;
    png_struct[109] = 0x2000;
    png_set_read_fn(png_struct, 0, 0);
  }
  return v4;
}

//----- (00434C90) --------------------------------------------------------
size_t *__cdecl png_create_write_struct(char *a1, int a2, int a3)
{
  size_t *png_struct; // eax
  size_t *v4; // ebx

  png_struct = png_create_png_struct(a1, a2, a3);
  v4 = png_struct;
  if ( png_struct )
  {
    png_struct[25] |= 0x200000u;
    png_struct[43] = 0x2000;
    png_struct[48] = 1;
    png_struct[44] = -1;
    png_struct[47] = 8;
    png_struct[46] = 15;
    png_struct[45] = 8;
    png_set_write_fn(png_struct, 0, 0);
  }
  return v4;
}

//----- (00434D40) --------------------------------------------------------
int __cdecl png_data_freer(int a1, int a2, int a3, int a4)
{
  int result; // eax

  result = a2;
  if ( a1 && a2 )
  {
    if ( a3 == 1 )
    {
      *(_DWORD *)(a2 + 148) |= a4;
    }
    else
    {
      if ( a3 != 2 )
        png_err(a1);
      *(_DWORD *)(a2 + 148) &= ~a4;
    }
  }
  return result;
}

//----- (00434D90) --------------------------------------------------------
void __cdecl png_default_read_data(int a1, void *Buffer, size_t ElementCount)
{
  if ( a1 )
  {
    if ( ElementCount != fread(Buffer, 1u, ElementCount, *(FILE **)(a1 + 92)) )
      png_err(a1);
  }
}

//----- (00434DE0) --------------------------------------------------------
void __cdecl png_default_write_data(int a1, void *Buffer, size_t ElementCount)
{
  if ( a1 )
  {
    if ( ElementCount != fwrite(Buffer, 1u, ElementCount, *(FILE **)(a1 + 92)) )
      png_err(a1);
  }
}

//----- (00434E30) --------------------------------------------------------
void __cdecl png_destroy_gamma_table(void **Block)
{
  _DWORD *v1; // eax
  int v2; // edi
  int i; // esi
  void *v4; // eax
  void *v5; // eax
  _DWORD *v6; // eax
  int v7; // edi
  int j; // esi
  void *v9; // eax
  _DWORD *v10; // eax
  int v11; // edi
  int k; // esi
  void *v13; // eax

  png_free(Block, Block[82]);
  v1 = Block[83];
  Block[82] = 0;
  if ( v1 )
  {
    v2 = 1 << (8 - *((_BYTE *)Block + 320));
    if ( v2 > 0 )
    {
      for ( i = 0; i != v2; ++i )
      {
        v4 = (void *)v1[i];
        png_free(Block, v4);
        v1 = Block[83];
      }
    }
    png_free(Block, v1);
    Block[83] = 0;
  }
  png_free(Block, Block[84]);
  v5 = Block[85];
  Block[84] = 0;
  png_free(Block, v5);
  v6 = Block[86];
  Block[85] = 0;
  if ( v6 )
  {
    v7 = 1 << (8 - *((_BYTE *)Block + 320));
    if ( v7 > 0 )
    {
      for ( j = 0; j != v7; ++j )
      {
        v9 = (void *)v6[j];
        png_free(Block, v9);
        v6 = Block[86];
      }
    }
    png_free(Block, v6);
    Block[86] = 0;
  }
  v10 = Block[87];
  if ( v10 )
  {
    v11 = 1 << (8 - *((_BYTE *)Block + 320));
    if ( v11 > 0 )
    {
      for ( k = 0; k != v11; ++k )
      {
        v13 = (void *)v10[k];
        png_free(Block, v13);
        v10 = Block[87];
      }
    }
    png_free(Block, v10);
    Block[87] = 0;
  }
}

//----- (00434FA0) --------------------------------------------------------
void __cdecl png_destroy_info_struct(void *Block, void ***a2)
{
  void **v2; // ebx
  void *v3; // eax
  void *v4; // eax

  if ( a2 )
  {
    if ( Block )
    {
      v2 = *a2;
      if ( *a2 )
      {
        *a2 = 0;
        v3 = v2[37];
        if ( (BYTE1(v3) & 0x20) != 0 )
        {
          v4 = v2[31];
          v2[2] = (void *)((unsigned int)v2[2] & 0xFFFFFFEF);
          png_free(Block, v4);
          v2[31] = 0;
          *((_WORD *)v2 + 11) = 0;
          if ( (((unsigned __int16)v2[37] >> 8) & 0x10) == 0 )
            goto LABEL_6;
        }
        else if ( (BYTE1(v3) & 0x10) == 0 )
        {
LABEL_6:
          *v2 = 0;
          v2[37] = 0;
          memset(
            (void *)((unsigned int)(v2 + 1) & 0xFFFFFFFC),
            0,
            4 * (((unsigned int)v2 - ((unsigned int)(v2 + 1) & 0xFFFFFFFC) + 152) >> 2));
          png_free(Block, v2);
          return;
        }
        png_free(Block, v2[4]);
        goto LABEL_6;
      }
    }
  }
}

//----- (00435060) --------------------------------------------------------
_DWORD *__cdecl png_destroy_png_struct(_DWORD *Block)
{
  _DWORD *result; // eax
  _DWORD v2[137]; // [esp+18h] [ebp-224h] BYREF

  result = Block;
  if ( Block )
  {
    qmemcpy(v2, Block, 0x218u);
    free(Block);
    return png_free_jmpbuf(v2);
  }
  return result;
}
// 435060: using guessed type _DWORD var_224[137];

//----- (004350A0) --------------------------------------------------------
void ***__cdecl png_destroy_read_struct(int *a1, void ***a2, void ***a3)
{
  void ***result; // eax
  int Block; // ebx
  void *v5; // eax
  void *v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edx

  result = a3;
  if ( a1 )
  {
    Block = *a1;
    if ( *a1 )
    {
      png_destroy_info_struct((void *)Block, a3);
      png_destroy_info_struct((void *)Block, a2);
      *a1 = 0;
      png_destroy_gamma_table((void **)Block);
      png_free((void *)Block, *(void **)(Block + 400));
      v5 = *(void **)(Block + 440);
      *(_DWORD *)(Block + 400) = 0;
      png_free((void *)Block, v5);
      v6 = *(void **)(Block + 428);
      *(_DWORD *)(Block + 440) = 0;
      png_free((void *)Block, v6);
      v7 = *(_DWORD *)(Block + 388);
      *(_DWORD *)(Block + 428) = 0;
      if ( (v7 & 0x1000) != 0 )
      {
        png_zfree(Block, *(_DWORD *)(Block + 268));
        v9 = *(_DWORD *)(Block + 388);
        *(_DWORD *)(Block + 268) = 0;
        v8 = v9;
        BYTE1(v8) = BYTE1(v9) & 0xEF;
        *(_DWORD *)(Block + 388) = v8;
        if ( (v9 & 0x2000) == 0 )
          goto LABEL_5;
      }
      else
      {
        v8 = v7;
        BYTE1(v8) = BYTE1(v7) & 0xEF;
        *(_DWORD *)(Block + 388) = v8;
        if ( (v7 & 0x2000) == 0 )
        {
LABEL_5:
          BYTE1(v8) &= ~0x20u;
          *(_DWORD *)(Block + 388) = v8;
          inflateEnd((_DWORD *)(Block + 112));
          return (void ***)png_destroy_png_struct((_DWORD *)Block);
        }
      }
      png_free((void *)Block, *(void **)(Block + 360));
      v8 = *(_DWORD *)(Block + 388);
      *(_DWORD *)(Block + 360) = 0;
      goto LABEL_5;
    }
  }
  return result;
}
// 4447B0: using guessed type int __cdecl png_zfree(_DWORD, _DWORD);

//----- (004351F0) --------------------------------------------------------
void ***__cdecl png_destroy_write_struct(int *a1, void ***a2)
{
  void ***result; // eax
  int Block; // ebx

  result = a2;
  if ( a1 )
  {
    Block = *a1;
    if ( *a1 )
    {
      png_destroy_info_struct((void *)Block, a2);
      *a1 = 0;
      if ( (*(_BYTE *)(Block + 100) & 2) != 0 )
        deflateEnd((_DWORD *)(Block + 112));
      png_free_buffer_list((void *)Block, (_DWORD **)(Block + 168));
      png_free((void *)Block, *(void **)(Block + 252));
      *(_DWORD *)(Block + 252) = 0;
      return (void ***)png_destroy_png_struct((_DWORD *)Block);
    }
  }
  return result;
}

//----- (00435280) --------------------------------------------------------
char *__cdecl png_do_bgr(int *a1, char *a2)
{
  char *result; // eax
  char v3; // cl
  int v4; // esi
  char v5; // dl
  int i; // edx
  char v7; // bl
  int v8; // edx
  char v9; // cl
  char v10; // bl
  char v11; // bl
  char v12; // cl
  char v13; // dl
  char v14; // cl
  int v15; // edx
  char v16; // cl
  char v17; // bl
  char v18; // bl
  char v19; // cl

  result = a2;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    v5 = *((_BYTE *)a1 + 9);
    if ( v5 == 8 )
    {
      if ( v3 == 2 )
      {
        if ( v4 )
        {
          do
          {
            v13 = *result;
            v14 = result[2];
            result += 3;
            *(result - 3) = v14;
            *(result - 1) = v13;
          }
          while ( result != &a2[3 * v4] );
        }
      }
      else if ( v3 == 6 && v4 )
      {
        for ( i = 0; i != v4; ++i )
        {
          v7 = a2[4 * i + 2];
          a2[4 * i + 2] = a2[4 * i];
          a2[4 * i] = v7;
        }
      }
    }
    else if ( v5 == 16 )
    {
      if ( v3 == 2 )
      {
        if ( v4 )
        {
          v15 = 0;
          do
          {
            v16 = *result;
            v17 = result[4];
            ++v15;
            result += 6;
            *(result - 6) = v17;
            v18 = *(result - 1);
            *(result - 2) = v16;
            v19 = *(result - 5);
            *(result - 5) = v18;
            *(result - 1) = v19;
          }
          while ( v4 != v15 );
        }
      }
      else if ( v3 == 6 && v4 )
      {
        v8 = 0;
        do
        {
          v9 = *result;
          v10 = result[4];
          ++v8;
          result += 8;
          *(result - 8) = v10;
          v11 = *(result - 3);
          *(result - 4) = v9;
          v12 = *(result - 7);
          *(result - 7) = v11;
          *(result - 3) = v12;
        }
        while ( v4 != v8 );
      }
    }
  }
  return result;
}

//----- (00435390) --------------------------------------------------------
int __usercall png_do_gray_to_rgb@<eax>(int *a1@<eax>, int a2@<edx>)
{
  unsigned __int8 v3; // di
  int result; // eax
  int v5; // esi
  char *v6; // edx
  char *v7; // ecx
  int v8; // edi
  char v9; // al
  char v10; // cl
  unsigned int v11; // esi
  char *v12; // ecx
  char *v13; // edx
  int v14; // edi
  char v15; // al
  char *v16; // ebp
  char *v17; // ecx
  char *v18; // edx
  char v19; // al
  char *v20; // ecx
  char *v21; // edx
  int v22; // edi
  char v23; // al
  char v24; // al

  v3 = *((_BYTE *)a1 + 9);
  result = v3;
  if ( v3 <= 7u )
    return result;
  result = *((unsigned __int8 *)a1 + 8);
  if ( (result & 2) != 0 )
    return result;
  v5 = *a1;
  if ( (_BYTE)result )
  {
    if ( (_BYTE)result != 4 )
      goto LABEL_10;
    if ( v3 == 8 )
    {
      v20 = (char *)(a2 + 2 * v5 - 1);
      v21 = &v20[2 * v5];
      if ( !v5 )
        goto LABEL_10;
      v22 = 0;
      do
      {
        v23 = *v20;
        v20 -= 2;
        v21 -= 4;
        ++v22;
        v21[4] = v23;
        v24 = v20[1];
        v21[3] = v24;
        v21[2] = v24;
        v21[1] = v20[1];
      }
      while ( v5 != v22 );
    }
    else
    {
      v12 = (char *)(a2 + 4 * v5 - 1);
      v13 = &v12[4 * v5];
      if ( !v5 )
        goto LABEL_10;
      v14 = 0;
      do
      {
        v15 = *v12;
        v12 -= 4;
        v13 -= 8;
        ++v14;
        v13[8] = v15;
        v13[7] = v12[3];
        v13[6] = v12[2];
        v13[5] = v12[1];
        v13[4] = v12[2];
        v13[3] = v12[1];
        v13[2] = v12[2];
        v13[1] = v12[1];
      }
      while ( v5 != v14 );
    }
    goto LABEL_8;
  }
  if ( v3 == 8 )
  {
    v16 = (char *)(a2 + v5 - 1);
    v17 = &v16[2 * v5];
    if ( !v5 )
      goto LABEL_10;
    v18 = (char *)(a2 - 1);
    do
    {
      v19 = *v16--;
      v17 -= 3;
      v17[3] = v19;
      v17[2] = v19;
      v17[1] = v16[1];
    }
    while ( v16 != v18 );
    goto LABEL_8;
  }
  v6 = (char *)(a2 + 2 * v5 - 1);
  v7 = &v6[4 * v5];
  if ( v5 )
  {
    v8 = 0;
    do
    {
      v9 = *v6;
      v6 -= 2;
      v7 -= 6;
      ++v8;
      v7[6] = v9;
      v7[5] = v6[1];
      v7[4] = v6[2];
      v7[3] = v6[1];
      v7[2] = v6[2];
      v7[1] = v6[1];
    }
    while ( v5 != v8 );
LABEL_8:
    LOBYTE(result) = *((_BYTE *)a1 + 8);
    v3 = *((_BYTE *)a1 + 9);
  }
LABEL_10:
  v10 = *((_BYTE *)a1 + 10);
  *((_BYTE *)a1 + 8) = result | 2;
  LOBYTE(result) = (v10 + 2) * v3;
  *((_BYTE *)a1 + 10) = v10 + 2;
  *((_BYTE *)a1 + 11) = result;
  if ( (unsigned __int8)result <= 7u )
  {
    result = (unsigned __int8)result;
    v11 = ((unsigned int)(unsigned __int8)result * v5 + 7) >> 3;
  }
  else
  {
    result = (unsigned __int8)result >> 3;
    v11 = result * v5;
  }
  a1[1] = v11;
  return result;
}

//----- (00435550) --------------------------------------------------------
void __cdecl png_do_read_interlace(int *a1, int a2, int a3)
{
  unsigned int v3; // ebx
  unsigned __int8 v4; // cl
  unsigned int v5; // edx
  unsigned __int8 v6; // di
  unsigned int v7; // eax
  unsigned __int8 v8; // cl
  unsigned int v9; // edi
  _DWORD *v10; // ecx
  int v11; // esi
  unsigned __int8 v12; // al
  unsigned int v13; // edi
  _BYTE *v14; // eax
  int v15; // edx
  int v16; // esi
  int v17; // edi
  _BYTE *v18; // esi
  int v19; // eax
  int v20; // ebx
  int v21; // edi
  _BYTE *v22; // eax
  int v23; // edx
  int v24; // esi
  int v25; // edi
  unsigned int v26; // ebx
  unsigned int v27; // eax
  unsigned int v28; // eax
  int v29; // [esp+0h] [ebp-50h]
  int v30; // [esp+4h] [ebp-4Ch]
  int v31; // [esp+4h] [ebp-4Ch]
  int v32; // [esp+4h] [ebp-4Ch]
  int v33; // [esp+4h] [ebp-4Ch]
  int v34; // [esp+8h] [ebp-48h]
  unsigned int v35; // [esp+8h] [ebp-48h]
  unsigned int v36; // [esp+8h] [ebp-48h]
  unsigned int v37; // [esp+8h] [ebp-48h]
  unsigned __int8 *v38; // [esp+Ch] [ebp-44h]
  unsigned __int8 *v39; // [esp+Ch] [ebp-44h]
  unsigned __int8 *v40; // [esp+Ch] [ebp-44h]
  unsigned int v41; // [esp+10h] [ebp-40h]
  _BYTE *v42; // [esp+18h] [ebp-38h]
  _DWORD *v43; // [esp+1Ch] [ebp-34h]
  int v44; // [esp+20h] [ebp-30h]
  unsigned int v45; // [esp+28h] [ebp-28h]
  _BYTE v46[4]; // [esp+34h] [ebp-1Ch]
  _DWORD v47[6]; // [esp+38h] [ebp-18h] BYREF

  if ( a2 && a1 )
  {
    v3 = *a1;
    v4 = *((_BYTE *)a1 + 11);
    v5 = *a1 - 1;
    v6 = v4;
    v29 = png_pass_inc_63829[a3];
    v44 = *a1 * v29;
    v7 = v44 - 1;
    switch ( v4 )
    {
      case 2u:
        v22 = (_BYTE *)(a2 + (v7 >> 2));
        v40 = (unsigned __int8 *)(a2 + (v5 >> 2));
        v33 = ((unsigned __int8)(2 * v3 + 6) ^ 0xFE) & 6;
        v23 = ((unsigned __int8)(2 * v44 + 6) ^ 0xFE) & 6;
        if ( v3 )
        {
          if ( v29 <= 0 )
            goto LABEL_59;
          v37 = 0;
          do
          {
            v24 = 0;
            v25 = ((int)*v40 >> v33) & 3;
            do
            {
              while ( 1 )
              {
                *v22 = ((_BYTE)v25 << v23) | (16191 >> (6 - v23)) & *v22;
                if ( v23 == 6 )
                  break;
                v23 += 2;
                if ( v29 == ++v24 )
                  goto LABEL_55;
              }
              --v22;
              v23 = 0;
              ++v24;
            }
            while ( v29 != v24 );
LABEL_55:
            if ( v33 == 6 )
            {
              --v40;
              v33 = 0;
            }
            else
            {
              v33 += 2;
            }
            ++v37;
          }
          while ( v37 < *a1 );
LABEL_58:
          v4 = *((_BYTE *)a1 + 11);
LABEL_59:
          v11 = v44;
          v6 = v4;
          *a1 = v44;
          v12 = v4;
          if ( v4 > 7u )
          {
LABEL_23:
            v13 = v11 * (v12 >> 3);
LABEL_24:
            a1[1] = v13;
            return;
          }
LABEL_60:
          v13 = (v44 * (unsigned int)v6 + 7) >> 3;
          goto LABEL_24;
        }
        break;
      case 4u:
        v18 = (_BYTE *)((v7 >> 1) + a2);
        v39 = (unsigned __int8 *)(a2 + (v5 >> 1));
        v32 = 4 * (*a1 & 1);
        v19 = 4 * (v44 & 1);
        if ( v3 )
        {
          if ( v29 <= 0 )
            goto LABEL_59;
          v36 = 0;
          do
          {
            v20 = 0;
            v21 = ((int)*v39 >> v32) & 0xF;
            do
            {
              while ( 1 )
              {
                *v18 = ((_BYTE)v21 << v19) | (3855 >> (4 - v19)) & *v18;
                if ( v19 == 4 )
                  break;
                v19 += 4;
                if ( v29 == ++v20 )
                  goto LABEL_44;
              }
              --v18;
              v19 = 0;
              ++v20;
            }
            while ( v29 != v20 );
LABEL_44:
            if ( v32 == 4 )
            {
              --v39;
              v32 = 0;
            }
            else
            {
              v32 += 4;
            }
            ++v36;
          }
          while ( v36 < *a1 );
          goto LABEL_58;
        }
        break;
      case 1u:
        v14 = (_BYTE *)(a2 + (v7 >> 3));
        v38 = (unsigned __int8 *)(a2 + (v5 >> 3));
        v31 = ~((_BYTE)v3 + 7) & 7;
        v15 = ~((_BYTE)v44 + 7) & 7;
        if ( v3 )
        {
          if ( v29 <= 0 )
            goto LABEL_59;
          v35 = 0;
          do
          {
            v16 = 0;
            v17 = ((int)*v38 >> v31) & 1;
            do
            {
              while ( 1 )
              {
                *v14 = ((_BYTE)v17 << v15) | (32639 >> (7 - v15)) & *v14;
                if ( v15 == 7 )
                  break;
                ++v15;
                if ( v29 == ++v16 )
                  goto LABEL_33;
              }
              --v14;
              v15 = 0;
              ++v16;
            }
            while ( v29 != v16 );
LABEL_33:
            if ( v31 == 7 )
            {
              --v38;
              v31 = 0;
            }
            else
            {
              ++v31;
            }
            ++v35;
          }
          while ( v35 < *a1 );
          goto LABEL_58;
        }
        break;
      default:
        v8 = v4 >> 3;
        v42 = (_BYTE *)(a2 + v8 * v5);
        v43 = (_DWORD *)(a2 + v8 * v7);
        if ( v3 )
        {
          v41 = 0;
          v9 = v8;
          v34 = -v8;
          v45 = v8 - 1;
          do
          {
            if ( v9 >= 4 )
            {
              *(_DWORD *)&v46[v9] = *(_DWORD *)&v42[v9 - 4];
              if ( v45 >= 4 )
              {
                v28 = 0;
                do
                {
                  v47[v28 / 4] = *(_DWORD *)&v42[v28];
                  v28 += 4;
                }
                while ( v28 < (v45 & 0xFFFFFFFC) );
              }
            }
            else if ( v9 )
            {
              LOBYTE(v47[0]) = *v42;
              if ( (v9 & 2) != 0 )
                *(_WORD *)&v46[v9 + 2] = *(_WORD *)&v42[v9 - 2];
            }
            if ( v29 > 0 )
            {
              v30 = 0;
              v10 = v43;
              do
              {
                if ( v9 >= 4 )
                {
                  v26 = (unsigned int)(v10 + 1) & 0xFFFFFFFC;
                  *v10 = v47[0];
                  *(_DWORD *)((char *)v10 + v9 - 4) = *(_DWORD *)&v46[v9];
                  if ( (((unsigned int)v10 + v9 - v26) & 0xFFFFFFFC) >= 4 )
                  {
                    v27 = 0;
                    do
                    {
                      *(_DWORD *)(v26 + v27) = *(_DWORD *)((char *)v47 - ((char *)v10 - v26) + v27);
                      v27 += 4;
                    }
                    while ( v27 < (((unsigned int)v10 + v9 - v26) & 0xFFFFFFFC) );
                  }
                }
                else if ( v9 )
                {
                  *(_BYTE *)v10 = v47[0];
                  if ( (v9 & 2) != 0 )
                    *(_WORD *)((char *)v10 + v9 - 2) = *(_WORD *)&v46[v9 + 2];
                }
                ++v30;
                v10 = (_DWORD *)((char *)v10 + v34);
              }
              while ( v30 != v29 );
              v43 = (_DWORD *)((char *)v43 + v34 * v29);
              v3 = *a1;
            }
            ++v41;
            v42 += v34;
          }
          while ( v41 < v3 );
          v6 = *((_BYTE *)a1 + 11);
        }
        v11 = v44;
        *a1 = v44;
        v12 = v6;
        if ( v6 > 7u )
          goto LABEL_23;
        goto LABEL_60;
    }
    *a1 = v44;
    goto LABEL_60;
  }
}
// 514EA0: using guessed type int png_pass_inc_63829[7];
// 435550: using guessed type _DWORD var_18[6];

//----- (00435A50) --------------------------------------------------------
int __cdecl png_do_read_transformations(int a1, int a2)
{
  int v2; // ebp
  unsigned __int8 *v3; // eax
  int v4; // ebx
  unsigned __int16 v5; // dx
  char v6; // cl
  unsigned __int8 v7; // dl
  int result; // eax
  unsigned __int8 v9; // dl
  _BYTE *v10; // esi
  int v11; // edi
  _BYTE *v12; // ecx
  __int16 v13; // dx
  int v14; // esi
  char v15; // di
  char v16; // cl
  _BYTE *v17; // eax
  _BYTE *v18; // esi
  int v19; // ecx
  _BYTE *v20; // ecx
  int v21; // ebx
  char v22; // cl
  char v23; // si
  int v24; // esi
  unsigned __int8 *v25; // edx
  int v26; // ecx
  unsigned __int16 v27; // bx
  int v28; // esi
  int v29; // ecx
  unsigned __int8 *v30; // edi
  int v31; // edx
  unsigned __int8 v32; // al
  int v33; // esi
  char v34; // cl
  __int16 v35; // dx
  __int16 v36; // dx
  __int16 v37; // ax
  unsigned __int16 v38; // bx
  int v39; // ebx
  __int16 v40; // ax
  unsigned __int8 v41; // dh
  int v42; // eax
  __int16 v43; // dx
  int v44; // eax
  int v45; // edx
  int v46; // eax
  __int16 v47; // ax
  unsigned int v48; // ecx
  char *v49; // eax
  unsigned int v50; // esi
  char v51; // dl
  int v52; // eax
  char v53; // dl
  int v54; // ecx
  _BYTE *v55; // edx
  _BYTE *v56; // eax
  char v57; // cl
  int v58; // eax
  unsigned __int8 *v59; // ecx
  unsigned __int8 *v60; // esi
  _BYTE *v61; // edi
  int v62; // edx
  int v63; // eax
  char v64; // dl
  char v65; // al
  int v66; // ecx
  int v67; // edi
  char v68; // si
  unsigned __int16 v69; // bx
  unsigned __int16 v70; // si
  unsigned __int16 v71; // di
  int v72; // ebx
  int v73; // ebx
  __int16 v74; // cx
  int v75; // esi
  char v76; // al
  char v77; // cl
  int v78; // edx
  int v79; // ecx
  int v80; // esi
  char v81; // dl
  char v82; // di
  char v83; // bl
  int v84; // edi
  int v85; // esi
  unsigned __int8 *v86; // eax
  unsigned __int8 v87; // dl
  unsigned __int8 v88; // cl
  char v89; // cl
  int v90; // edi
  int v91; // ebx
  int v92; // ebp
  unsigned __int8 v93; // dl
  int v94; // ebx
  int v95; // ebp
  unsigned __int8 v96; // dl
  int v97; // ebx
  int v98; // ebp
  char v99; // cl
  _BYTE *v100; // eax
  _BYTE *v101; // ebx
  int v102; // ecx
  _BYTE *v103; // ecx
  int v104; // esi
  int ii; // ebx
  __int16 v106; // ax
  unsigned __int16 v107; // ax
  __int16 v108; // ax
  int v109; // ecx
  int v110; // esi
  char v111; // dl
  char v112; // di
  char v113; // bl
  char v114; // dl
  __int16 v115; // si
  unsigned __int8 *v116; // edi
  int v117; // esi
  unsigned __int8 *v118; // eax
  unsigned __int8 *v119; // ecx
  int v120; // edi
  unsigned __int8 v121; // cl
  unsigned __int8 *v122; // esi
  int v123; // ebx
  char *v124; // eax
  unsigned __int8 *v125; // ebp
  int v126; // ecx
  char v127; // dl
  int v128; // edx
  __int16 v129; // ax
  int v130; // ebp
  __int16 v131; // cx
  __int16 v132; // ax
  __int16 v133; // ax
  int v134; // ebx
  int v135; // edx
  int v136; // eax
  __int16 v137; // dx
  __int16 v138; // dx
  __int16 v139; // ax
  _BYTE *v140; // edi
  int v141; // eax
  _BYTE *v142; // esi
  _BYTE *v143; // ecx
  unsigned int v144; // edi
  int v145; // eax
  __int16 v146; // bx
  unsigned __int8 v147; // cl
  unsigned int v148; // eax
  _BYTE *v149; // edx
  int v150; // ebx
  int v151; // esi
  char v152; // cl
  int n; // ecx
  __int16 v154; // ax
  int v155; // edx
  int v156; // ebx
  int v157; // edx
  int v158; // ecx
  int v159; // eax
  int v160; // esi
  unsigned int v161; // eax
  _BYTE *v162; // eax
  _BYTE *v163; // esi
  _BYTE *v164; // ecx
  int v165; // edi
  char v166; // dl
  unsigned __int16 *v167; // edx
  int v168; // edi
  unsigned int v169; // ebx
  unsigned __int16 v170; // bx
  unsigned __int16 v171; // si
  unsigned __int16 v172; // ax
  int k; // eax
  __int16 v174; // dx
  int v175; // edx
  int v176; // eax
  int v177; // esi
  int v178; // ebp
  int v179; // eax
  int v180; // edx
  int v181; // esi
  int v182; // ebx
  int v183; // ebx
  int v184; // esi
  int v185; // ebx
  int v186; // eax
  int v187; // eax
  int v188; // ecx
  unsigned __int8 *v189; // edi
  int v190; // edx
  unsigned int v191; // eax
  unsigned __int8 *v192; // edx
  _BYTE *v193; // eax
  int v194; // ecx
  unsigned __int8 *v195; // ebx
  unsigned __int8 *v196; // edx
  _BYTE *v197; // eax
  int v198; // ecx
  unsigned __int8 *v199; // ebx
  unsigned __int8 *v200; // edx
  _BYTE *v201; // eax
  int v202; // ecx
  unsigned __int8 *v203; // ebx
  unsigned int v204; // edx
  unsigned __int16 v205; // cx
  unsigned __int16 v206; // ax
  unsigned int v207; // edx
  unsigned __int16 v208; // ax
  unsigned __int16 v209; // bx
  int v210; // eax
  unsigned int v211; // edx
  __int16 v212; // ax
  unsigned __int8 v213; // dh
  int v214; // eax
  unsigned int v215; // edx
  int v216; // eax
  int v217; // ebx
  int v218; // esi
  char v219; // dl
  char v220; // cl
  char v221; // dl
  int v222; // edx
  int v223; // esi
  unsigned __int8 *v224; // edi
  int v225; // ecx
  int v226; // eax
  int v227; // ecx
  int v228; // ebx
  int v229; // esi
  int v230; // eax
  int v231; // ebx
  int v232; // ecx
  char v233; // al
  int v234; // ecx
  char v235; // dl
  int v236; // edx
  char v237; // cl
  unsigned __int8 v238; // al
  unsigned int v239; // eax
  int v240; // ecx
  __int16 v241; // dx
  __int16 v242; // dx
  __int16 v243; // ax
  unsigned __int16 v244; // bx
  int v245; // edi
  unsigned int v246; // kr00_4
  unsigned int v247; // edx
  unsigned int v248; // edx
  int v249; // ecx
  __int16 v250; // ax
  unsigned __int16 v251; // ax
  unsigned int v252; // edx
  int v253; // esi
  int v254; // ecx
  _BYTE *v255; // edx
  unsigned int v256; // edx
  unsigned __int8 *v257; // ebx
  int v258; // ecx
  unsigned __int8 v259; // dl
  unsigned int v260; // eax
  int v261; // esi
  int v262; // edi
  unsigned __int8 *v263; // ecx
  int v264; // ebx
  int v265; // edx
  int v266; // eax
  unsigned __int8 *v267; // esi
  unsigned __int8 *v268; // edx
  int v269; // ecx
  unsigned __int8 *v270; // edi
  unsigned __int8 *v271; // esi
  int v272; // ecx
  unsigned __int8 *v273; // edi
  unsigned __int8 *v274; // esi
  int v275; // ecx
  int j; // eax
  unsigned int v277; // ebx
  unsigned __int16 v278; // bx
  unsigned __int16 v279; // si
  unsigned __int16 v280; // dx
  int v281; // edi
  int v282; // esi
  unsigned __int8 *v283; // ecx
  unsigned __int8 *v284; // eax
  int v285; // ebx
  int v286; // edx
  int v287; // ecx
  int v288; // eax
  int v289; // ecx
  __int16 v290; // ax
  int v291; // edi
  int v292; // ebx
  __int16 v293; // cx
  int v294; // edx
  char v295; // cl
  int v296; // edi
  int v297; // ebx
  int v298; // ebp
  unsigned __int8 v299; // dl
  int v300; // ebx
  int v301; // ebp
  unsigned __int8 v302; // dl
  int v303; // ebx
  int v304; // ebp
  int v305; // eax
  int v306; // edi
  __int16 v307; // bx
  _BYTE *v308; // edi
  char v309; // cl
  int i; // eax
  unsigned __int8 v311; // si
  unsigned __int8 v312; // di
  int v313; // edi
  int v314; // eax
  int v315; // ebx
  int v316; // edx
  unsigned __int8 v317; // si
  int v318; // edi
  int v319; // edx
  int v320; // ebx
  __int16 v321; // cx
  unsigned __int8 *v322; // edx
  unsigned __int8 *v323; // esi
  int v324; // ecx
  unsigned __int8 *v325; // ebx
  unsigned __int8 *v326; // ebx
  unsigned __int8 *v327; // esi
  int v328; // ecx
  unsigned __int8 *v329; // esi
  unsigned __int8 *v330; // ebx
  int v331; // ecx
  unsigned __int8 *v332; // eax
  unsigned __int8 *v333; // edx
  int v334; // ecx
  int v335; // ecx
  unsigned __int8 *v336; // ebx
  unsigned __int8 *v337; // edi
  int v338; // ecx
  unsigned __int8 *v339; // edi
  unsigned int jj; // esi
  char v341; // cl
  char v342; // di
  unsigned __int8 *v343; // edx
  unsigned __int8 *v344; // eax
  unsigned __int8 *v345; // esi
  unsigned __int8 v346; // cl
  int v347; // ecx
  int m; // ebx
  int v349; // edx
  int v350; // ecx
  int v351; // edx
  int v352; // edx
  int kk; // edx
  int v354; // esi
  int v355; // eax
  int v356; // ebp
  __int16 v357; // bx
  int v358; // ecx
  int v359; // edx
  __int16 v360; // cx
  int v361; // edx
  int v362; // esi
  int v363; // eax
  int v364; // ebp
  char v365; // si
  __int16 v366; // di
  unsigned __int8 *v367; // edx
  unsigned __int8 *v368; // eax
  int v369; // ecx
  int v370; // [esp+1Ch] [ebp-50h]
  unsigned int v371; // [esp+1Ch] [ebp-50h]
  int v372; // [esp+1Ch] [ebp-50h]
  int v373; // [esp+1Ch] [ebp-50h]
  int v374; // [esp+1Ch] [ebp-50h]
  int v375; // [esp+1Ch] [ebp-50h]
  unsigned int v376; // [esp+1Ch] [ebp-50h]
  int v377; // [esp+1Ch] [ebp-50h]
  int v378; // [esp+1Ch] [ebp-50h]
  unsigned __int16 v379; // [esp+1Ch] [ebp-50h]
  int v380; // [esp+1Ch] [ebp-50h]
  int v381; // [esp+1Ch] [ebp-50h]
  int v382; // [esp+1Ch] [ebp-50h]
  __int16 v383; // [esp+1Ch] [ebp-50h]
  __int16 v384; // [esp+1Ch] [ebp-50h]
  __int16 v385; // [esp+1Ch] [ebp-50h]
  int v386; // [esp+1Ch] [ebp-50h]
  unsigned __int8 v387; // [esp+1Ch] [ebp-50h]
  unsigned __int8 v388; // [esp+1Ch] [ebp-50h]
  __int16 v389; // [esp+1Ch] [ebp-50h]
  unsigned __int8 *v390; // [esp+20h] [ebp-4Ch]
  int v391; // [esp+20h] [ebp-4Ch]
  int v392; // [esp+20h] [ebp-4Ch]
  int v393; // [esp+20h] [ebp-4Ch]
  unsigned __int16 v394; // [esp+20h] [ebp-4Ch]
  int v395; // [esp+20h] [ebp-4Ch]
  int v396; // [esp+20h] [ebp-4Ch]
  int v397; // [esp+20h] [ebp-4Ch]
  _BYTE *v398; // [esp+20h] [ebp-4Ch]
  char v399; // [esp+20h] [ebp-4Ch]
  unsigned __int8 *v400; // [esp+20h] [ebp-4Ch]
  __int16 v401; // [esp+20h] [ebp-4Ch]
  __int16 v402; // [esp+20h] [ebp-4Ch]
  int v403; // [esp+20h] [ebp-4Ch]
  unsigned __int8 *v404; // [esp+20h] [ebp-4Ch]
  int v405; // [esp+20h] [ebp-4Ch]
  int v406; // [esp+20h] [ebp-4Ch]
  unsigned __int16 v407; // [esp+20h] [ebp-4Ch]
  __int16 v408; // [esp+20h] [ebp-4Ch]
  unsigned __int8 *v409; // [esp+20h] [ebp-4Ch]
  unsigned __int8 *v410; // [esp+20h] [ebp-4Ch]
  char v411; // [esp+20h] [ebp-4Ch]
  int v412; // [esp+20h] [ebp-4Ch]
  char v413; // [esp+24h] [ebp-48h]
  int v414; // [esp+24h] [ebp-48h]
  int v415; // [esp+24h] [ebp-48h]
  int v416; // [esp+24h] [ebp-48h]
  int v417; // [esp+24h] [ebp-48h]
  int v418; // [esp+24h] [ebp-48h]
  int v419; // [esp+24h] [ebp-48h]
  int v420; // [esp+24h] [ebp-48h]
  int v421; // [esp+24h] [ebp-48h]
  int v422; // [esp+24h] [ebp-48h]
  unsigned __int16 v423; // [esp+24h] [ebp-48h]
  unsigned __int8 v424; // [esp+24h] [ebp-48h]
  char v425; // [esp+24h] [ebp-48h]
  int v426; // [esp+28h] [ebp-44h]
  int v427; // [esp+28h] [ebp-44h]
  int v428; // [esp+28h] [ebp-44h]
  int v429; // [esp+28h] [ebp-44h]
  unsigned int v430; // [esp+28h] [ebp-44h]
  unsigned __int8 *v431; // [esp+28h] [ebp-44h]
  int v432; // [esp+28h] [ebp-44h]
  char v433; // [esp+28h] [ebp-44h]
  int v434; // [esp+2Ch] [ebp-40h]
  _BYTE *v435; // [esp+2Ch] [ebp-40h]
  unsigned __int8 *v436; // [esp+2Ch] [ebp-40h]
  char *v437; // [esp+2Ch] [ebp-40h]
  int v438; // [esp+2Ch] [ebp-40h]
  char v439; // [esp+2Ch] [ebp-40h]
  int v440; // [esp+30h] [ebp-3Ch]
  int v441; // [esp+30h] [ebp-3Ch]
  unsigned __int8 v442; // [esp+30h] [ebp-3Ch]
  unsigned __int8 v443; // [esp+30h] [ebp-3Ch]
  _BYTE *v444; // [esp+34h] [ebp-38h]
  int v445; // [esp+34h] [ebp-38h]
  int v446; // [esp+34h] [ebp-38h]
  _BYTE *v447; // [esp+34h] [ebp-38h]
  __int16 v448; // [esp+34h] [ebp-38h]
  int v449; // [esp+34h] [ebp-38h]
  int v450; // [esp+38h] [ebp-34h]
  int v451; // [esp+38h] [ebp-34h]
  int v452; // [esp+38h] [ebp-34h]
  int v453; // [esp+3Ch] [ebp-30h]
  char v454; // [esp+43h] [ebp-29h]
  int v455; // [esp+48h] [ebp-24h]
  int v456; // [esp+4Ch] [ebp-20h]

  v2 = a1;
  v3 = *(unsigned __int8 **)(a1 + 252);
  if ( !v3 || (*(_DWORD *)(a1 + 100) & 0x4040) == 0x4000 )
    goto LABEL_371;
  v4 = *(_DWORD *)(a1 + 104);
  if ( (v4 & 0x1000) == 0 )
    goto LABEL_13;
  v5 = *(_WORD *)(a1 + 274);
  v390 = v3 + 1;
  v6 = *(_BYTE *)(a2 + 8);
  v370 = *(_DWORD *)a2;
  if ( v6 == 3 )
  {
    v120 = *(_DWORD *)(a1 + 268);
    v418 = *(_DWORD *)(a1 + 360);
    v121 = *(_BYTE *)(a2 + 9);
    if ( v121 > 7u )
    {
      if ( v121 != 8 )
        goto LABEL_14;
      v122 = &v3[v370];
      goto LABEL_183;
    }
    v122 = &v3[v370];
    if ( v121 == 2 )
    {
      v404 = &v390[(unsigned int)(v370 - 1) >> 2];
      v188 = ((unsigned __int8)(2 * v370 + 6) ^ 0xFE) & 6;
      if ( v370 )
      {
        v429 = *(_DWORD *)(a1 + 268);
        v189 = v404;
        v436 = &v3[v370];
        do
        {
          *v122 = ((int)*v189 >> v188) & 3;
          if ( v188 == 6 )
          {
            --v189;
            v188 = 0;
          }
          else
          {
            v188 += 2;
          }
          --v122;
        }
        while ( v3 != v122 );
        goto LABEL_515;
      }
    }
    else
    {
      if ( v121 != 4 )
      {
        if ( v121 == 1 )
        {
          v335 = ~((_BYTE)v370 + 7) & 7;
          v409 = &v390[(unsigned int)(v370 - 1) >> 3];
          v336 = &v3[v370];
          if ( v370 )
          {
            v432 = *(_DWORD *)(a1 + 268);
            v337 = v409;
            do
            {
              *v336 = (int)*v337 >> v335;
              *v336 &= 1u;
              if ( v335 == 7 )
              {
                --v337;
                v335 = 0;
              }
              else
              {
                ++v335;
              }
              --v336;
            }
            while ( v3 != v336 );
            v120 = v432;
            v122 = &v3[v370];
          }
        }
        goto LABEL_182;
      }
      v410 = &v390[(unsigned int)(v370 - 1) >> 1];
      v338 = (4 * (_BYTE)v370) & 4;
      if ( v370 )
      {
        v429 = *(_DWORD *)(a1 + 268);
        v339 = v410;
        v436 = &v3[v370];
        do
        {
          *v122 = ((int)*v339 >> v338) & 0xF;
          if ( v338 == 4 )
          {
            --v339;
            v338 = 0;
          }
          else
          {
            v338 += 4;
          }
          --v122;
        }
        while ( v3 != v122 );
LABEL_515:
        v120 = v429;
        v122 = v436;
      }
    }
LABEL_182:
    *(_BYTE *)(a2 + 9) = 8;
    *(_BYTE *)(a2 + 11) = 8;
    *(_DWORD *)(a2 + 4) = v370;
LABEL_183:
    v123 = v5;
    if ( v5 )
    {
      v124 = (char *)&v3[4 * v370];
      if ( v370 )
      {
        v125 = &v122[-v370];
        do
        {
          v126 = *v122;
          v127 = -1;
          if ( v123 > v126 )
            v127 = *(_BYTE *)(v418 + v126);
          *v124 = v127;
          v128 = *v122;
          v124 -= 4;
          --v122;
          v124[3] = *(_BYTE *)(v120 + 3 * v128 + 2);
          v124[2] = *(_BYTE *)(v120 + 3 * v122[1] + 1);
          v124[1] = *(_BYTE *)(v120 + 3 * v122[1]);
        }
        while ( v122 != v125 );
        v2 = a1;
      }
      *(_DWORD *)(a2 + 8) = 537135110;
      v4 = *(_DWORD *)(v2 + 104);
      *(_DWORD *)(a2 + 4) = 4 * v370;
    }
    else
    {
      v332 = &v3[3 * v370];
      v333 = &v122[-v370];
      if ( v370 )
      {
        do
        {
          v334 = *v122;
          v332 -= 3;
          --v122;
          v332[3] = *(_BYTE *)(v120 + 3 * v334 + 2);
          v332[2] = *(_BYTE *)(v120 + 3 * v122[1] + 1);
          v332[1] = *(_BYTE *)(v120 + 3 * v122[1]);
        }
        while ( v122 != v333 );
      }
      *(_DWORD *)(a2 + 4) = 3 * v370;
      *(_DWORD *)(a2 + 8) = 402851842;
      v4 = *(_DWORD *)(a1 + 104);
    }
    goto LABEL_13;
  }
  if ( v5 && (v4 & 0x2000000) != 0 )
  {
    if ( !v6 )
    {
      v114 = *(_BYTE *)(a2 + 9);
      v115 = *(_WORD *)(a1 + 372);
      if ( (unsigned __int8)v114 > 7u )
      {
        if ( v114 != 8 )
        {
          if ( v114 != 16 )
            goto LABEL_406;
          v281 = HIBYTE(*(unsigned __int16 *)(a1 + 372));
          v408 = (unsigned __int8)v115;
          v282 = *(_DWORD *)(a2 + 4);
          v283 = &v3[v282];
          v284 = &v3[2 * v282];
          if ( v370 )
          {
            v285 = 0;
            do
            {
              LOBYTE(v286) = -1;
              if ( v281 == *(v283 - 1) )
                v286 = -(*v283 != v408);
              *(v284 - 1) = v286;
              v283 -= 2;
              v284 -= 4;
              ++v285;
              v284[4] = v286;
              v284[2] = v283[2];
              v284[1] = v283[1];
            }
            while ( v285 != v370 );
            v2 = a1;
            goto LABEL_457;
          }
LABEL_449:
          v259 = 2 * v114;
          *(_BYTE *)(a2 + 8) = 4;
          *(_BYTE *)(a2 + 10) = 2;
          *(_BYTE *)(a2 + 11) = v259;
          goto LABEL_450;
        }
        v417 = (unsigned __int8)v115;
        v116 = &v3[v370];
        v117 = *(_DWORD *)a2;
      }
      else
      {
        v116 = &v3[v370];
        switch ( v114 )
        {
          case 2:
            v417 = 85 * (v115 & 3);
            if ( v370 )
            {
              v329 = &v3[((unsigned int)(v370 - 1) >> 2) + 1];
              v330 = &v3[v370];
              v331 = ((unsigned __int8)(2 * v370 + 6) ^ 0xFE) & 6;
              do
              {
                *v330 = ((int)*v329 >> v331) & 3 | (4 * (((int)*v329 >> v331) & 3)) | (16 * (((int)*v329 >> v331) & 3)) | ((((int)*v329 >> v331) & 3) << 6);
                if ( v331 == 6 )
                {
                  --v329;
                  v331 = 0;
                }
                else
                {
                  v331 += 2;
                }
                --v330;
              }
              while ( v3 != v330 );
              v116 = &v3[v370];
              v2 = a1;
            }
            break;
          case 4:
            v326 = &v3[v370];
            v417 = 17 * (v115 & 0xF);
            v327 = &v3[((unsigned int)(v370 - 1) >> 1) + 1];
            v328 = 4 * (*(_DWORD *)a2 & 1);
            if ( v370 )
            {
              do
              {
                *v326 = (16 * (((int)*v327 >> v328) & 0xF)) | ((int)*v327 >> v328) & 0xF;
                if ( v328 == 4 )
                {
                  --v327;
                  v328 = 0;
                }
                else
                {
                  v328 = 4;
                }
                --v326;
              }
              while ( v3 != v326 );
              v116 = &v3[v370];
            }
            break;
          case 1:
            v417 = 255 * (v115 & 1);
            v323 = &v390[(unsigned int)(v370 - 1) >> 3];
            v324 = ~((_BYTE)v370 + 7) & 7;
            if ( v370 )
            {
              v325 = &v3[v370];
              do
              {
                *v325 = -(((int)*v323 >> v324) & 1);
                if ( v324 == 7 )
                {
                  --v323;
                  v324 = 0;
                }
                else
                {
                  ++v324;
                }
                --v325;
              }
              while ( v3 != v325 );
            }
            break;
          default:
            v417 = (unsigned __int8)v115;
            break;
        }
        *(_BYTE *)(a2 + 9) = 8;
        *(_BYTE *)(a2 + 11) = 8;
        *(_DWORD *)(a2 + 4) = v370;
        v117 = v370;
      }
      v118 = &v3[2 * v117];
      if ( v117 )
      {
        v119 = &v116[-v117];
        do
        {
          if ( *v116 == v417 )
            *v118 = 0;
          else
            *v118 = -1;
          --v116;
          v118 -= 2;
          v118[1] = v116[1];
        }
        while ( v119 != v116 );
LABEL_457:
        v4 = *(_DWORD *)(v2 + 104);
        v114 = *(_BYTE *)(a2 + 9);
LABEL_406:
        v259 = 2 * v114;
        *(_BYTE *)(a2 + 8) = 4;
        *(_BYTE *)(a2 + 10) = 2;
        *(_BYTE *)(a2 + 11) = v259;
        if ( v259 <= 7u )
        {
          v260 = ((unsigned int)v259 * v370 + 7) >> 3;
LABEL_408:
          *(_DWORD *)(a2 + 4) = v260;
          goto LABEL_13;
        }
LABEL_450:
        v260 = v370 * (v259 >> 3);
        goto LABEL_408;
      }
      v4 = *(_DWORD *)(v2 + 104);
      v114 = 8;
      goto LABEL_449;
    }
    if ( v6 != 2 )
      goto LABEL_13;
    v399 = *(_BYTE *)(a2 + 9);
    if ( v399 == 8 )
    {
      v342 = *(_BYTE *)(a1 + 368);
      v424 = *(_BYTE *)(a1 + 370);
      v343 = &v3[*(_DWORD *)(a2 + 4)];
      v344 = &v3[4 * v370];
      if ( v370 )
      {
        v411 = *(_BYTE *)(a1 + 366);
        v345 = &v343[-3 * v370];
        do
        {
          LOBYTE(v347) = -1;
          if ( v411 == *(v343 - 2) && v342 == *(v343 - 1) )
            v347 = -(*v343 != v424);
          *v344 = v347;
          v346 = *v343;
          v343 -= 3;
          v344 -= 4;
          v344[3] = v346;
          v344[2] = v343[2];
          v344[1] = v343[1];
        }
        while ( v343 != v345 );
        goto LABEL_576;
      }
    }
    else
    {
      if ( v399 != 16 )
        goto LABEL_220;
      v365 = HIBYTE(*(_WORD *)(a1 + 366));
      v425 = HIBYTE(*(_WORD *)(a1 + 368));
      v433 = HIBYTE(*(_WORD *)(a1 + 370));
      v366 = *(_WORD *)(a1 + 366);
      v439 = *(_BYTE *)(a1 + 368);
      v443 = *(_BYTE *)(a1 + 370);
      v367 = &v3[*(_DWORD *)(a2 + 4)];
      v368 = &v3[8 * v370];
      if ( v370 )
      {
        v412 = 0;
        do
        {
          LOBYTE(v369) = -1;
          if ( v365 == *(v367 - 5)
            && (_BYTE)v366 == *(v367 - 4)
            && v425 == *(v367 - 3)
            && v439 == *(v367 - 2)
            && v433 == *(v367 - 1) )
          {
            v369 = -(*v367 != v443);
          }
          *(v368 - 1) = v369;
          v367 -= 6;
          v368 -= 8;
          v368[8] = v369;
          ++v412;
          v368[6] = v367[6];
          v368[5] = v367[5];
          v368[4] = v367[4];
          v368[3] = v367[3];
          v368[2] = v367[2];
          v368[1] = v367[1];
        }
        while ( v412 != v370 );
        v2 = a1;
LABEL_576:
        v4 = *(_DWORD *)(v2 + 104);
        v399 = *(_BYTE *)(a2 + 9);
LABEL_220:
        v147 = 4 * v399;
        *(_BYTE *)(a2 + 8) = 6;
        *(_BYTE *)(a2 + 10) = 4;
        *(_BYTE *)(a2 + 11) = 4 * v399;
        if ( (unsigned __int8)(4 * v399) <= 7u )
        {
          v148 = (v370 * (unsigned int)v147 + 7) >> 3;
LABEL_222:
          *(_DWORD *)(a2 + 4) = v148;
          goto LABEL_13;
        }
LABEL_545:
        v148 = v370 * (v147 >> 3);
        goto LABEL_222;
      }
    }
    v147 = 4 * v399;
    *(_BYTE *)(a2 + 8) = 6;
    *(_BYTE *)(a2 + 10) = 4;
    *(_BYTE *)(a2 + 11) = 4 * v399;
    goto LABEL_545;
  }
  if ( !v6 )
  {
    v7 = *(_BYTE *)(a2 + 9);
    if ( v7 > 7u )
      goto LABEL_14;
    switch ( v7 )
    {
      case 2u:
        v270 = &v3[v370];
        v271 = &v390[(unsigned int)(v370 - 1) >> 2];
        v272 = ((unsigned __int8)(2 * v370 + 6) ^ 0xFE) & 6;
        if ( v370 )
        {
          do
          {
            *v270 = ((int)*v271 >> v272) & 3 | (4 * (((int)*v271 >> v272) & 3)) | (16 * (((int)*v271 >> v272) & 3)) | ((((int)*v271 >> v272) & 3) << 6);
            if ( v272 == 6 )
            {
              --v271;
              v272 = 0;
            }
            else
            {
              v272 += 2;
            }
            --v270;
          }
          while ( v3 != v270 );
          v2 = a1;
          v4 = *(_DWORD *)(a1 + 104);
        }
        goto LABEL_12;
      case 4u:
        v267 = &v3[v370];
        v268 = &v390[(unsigned int)(v370 - 1) >> 1];
        v269 = 4 * (*(_DWORD *)a2 & 1);
        if ( !v370 )
          goto LABEL_12;
        do
        {
          *v267 = (16 * (((int)*v268 >> v269) & 0xF)) | ((int)*v268 >> v269) & 0xF;
          if ( v269 == 4 )
          {
            --v268;
            v269 = 0;
          }
          else
          {
            v269 = 4;
          }
          --v267;
        }
        while ( v3 != v267 );
        break;
      case 1u:
        v273 = &v3[v370];
        v274 = &v390[(unsigned int)(v370 - 1) >> 3];
        v275 = ~((_BYTE)v370 + 7) & 7;
        if ( !v370 )
          goto LABEL_12;
        do
        {
          *v273 = -(((int)*v274 >> v275) & 1);
          if ( v275 == 7 )
          {
            --v274;
            v275 = 0;
          }
          else
          {
            ++v275;
          }
          --v273;
        }
        while ( v3 != v273 );
        break;
      default:
        goto LABEL_12;
    }
    v4 = *(_DWORD *)(a1 + 104);
LABEL_12:
    *(_BYTE *)(a2 + 9) = 8;
    *(_BYTE *)(a2 + 11) = 8;
    *(_DWORD *)(a2 + 4) = v370;
  }
LABEL_13:
  if ( (v4 & 0x40080) == 0x40000 && (*(_BYTE *)(a2 + 8) & 0xFD) == 4 )
  {
    png_do_strip_channel(a2, (_BYTE *)(*(_DWORD *)(v2 + 252) + 1), 0);
    v4 = *(_DWORD *)(v2 + 104);
  }
LABEL_14:
  if ( (v4 & 0x600000) == 0 )
    goto LABEL_15;
  v65 = *(_BYTE *)(a2 + 8);
  if ( (v65 & 3) != 2 )
    goto LABEL_15;
  v66 = *(_DWORD *)(v2 + 252);
  v441 = *(unsigned __int16 *)(v2 + 394);
  v375 = v66 + 1;
  v454 = v65 & 4;
  v446 = *(unsigned __int16 *)(v2 + 396);
  v453 = 0x8000 - (v446 + v441);
  v67 = *(_DWORD *)a2;
  v68 = *(_BYTE *)(a2 + 9);
  v415 = *(_DWORD *)a2;
  if ( v68 == 8 )
  {
    if ( *(_DWORD *)(v2 + 336) && *(_DWORD *)(v2 + 340) )
    {
      if ( v67 )
      {
        if ( v454 )
        {
          v313 = 0;
          v314 = 0;
          do
          {
            v316 = *(unsigned __int8 *)(v66 + 4 * v314 + 1);
            v317 = *(_BYTE *)(v66 + 4 * v314 + 3);
            v388 = *(_BYTE *)(v66 + 4 * v314 + 2);
            if ( (_BYTE)v316 == v388 && (_BYTE)v316 == v317 )
            {
              v315 = *(_DWORD *)(v2 + 328);
              if ( v315 )
                LOBYTE(v316) = *(_BYTE *)(v315 + v316);
              *(_BYTE *)(v66 + 2 * v314 + 1) = v316;
            }
            else
            {
              v318 = *(_DWORD *)(v2 + 340);
              v319 = v441 * *(unsigned __int8 *)(v318 + v316) + v446 * *(unsigned __int8 *)(v318 + v388) + 0x4000;
              v320 = *(unsigned __int8 *)(v318 + v317);
              v313 = 1;
              *(_BYTE *)(v66 + 2 * v314 + 1) = *(_BYTE *)(*(_DWORD *)(v2 + 336)
                                                        + ((unsigned int)(v453 * v320 + v319) >> 15));
            }
            *(_BYTE *)(v66 + 2 * v314 + 2) = *(_BYTE *)(v66 + 4 * v314 + 4);
            ++v314;
          }
          while ( v415 != v314 );
          v451 = v313;
        }
        else
        {
          v222 = v66 + 1;
          v223 = 0;
          v406 = v66 + v67 + 1;
          v224 = (unsigned __int8 *)(v66 + 1);
          do
          {
            v226 = *v224;
            v227 = v224[2];
            ++v222;
            v228 = v224[1];
            if ( (_BYTE)v227 == (_BYTE)v226 && (_BYTE)v228 == (_BYTE)v226 )
            {
              v225 = *(_DWORD *)(v2 + 328);
              if ( v225 )
                LOBYTE(v226) = *(_BYTE *)(v225 + v226);
              *(_BYTE *)(v222 - 1) = v226;
            }
            else
            {
              v229 = *(_DWORD *)(v2 + 340);
              v230 = *(unsigned __int8 *)(v229 + v226);
              v231 = v446 * *(unsigned __int8 *)(v229 + v228);
              v232 = *(unsigned __int8 *)(v229 + v227);
              v223 = 1;
              *(_BYTE *)(v222 - 1) = *(_BYTE *)(*(_DWORD *)(v2 + 336)
                                              + ((unsigned int)(v453 * v232 + v231 + v441 * v230 + 0x4000) >> 15));
            }
            v224 += 3;
          }
          while ( v406 != v222 );
          v451 = v223;
        }
        goto LABEL_366;
      }
    }
    else if ( v415 )
    {
      if ( v454 )
      {
        v451 = 0;
        for ( i = 0; i != v415; ++i )
        {
          while ( 1 )
          {
            v311 = *(_BYTE *)(v66 + 4 * i + 1);
            v312 = *(_BYTE *)(v66 + 4 * i + 2);
            v387 = *(_BYTE *)(v66 + 4 * i + 3);
            if ( v387 != v311 || v312 != v311 )
              break;
            *(_BYTE *)(v66 + 2 * i + 1) = v311;
            *(_BYTE *)(v66 + 2 * i + 2) = *(_BYTE *)(v66 + 4 * i + 4);
            if ( v415 == ++i )
              goto LABEL_366;
          }
          v451 = 1;
          *(_BYTE *)(v66 + 2 * i + 1) = (v441 * v311 + v312 * v446 + v453 * (unsigned int)v387) >> 15;
          *(_BYTE *)(v66 + 2 * i + 2) = *(_BYTE *)(v66 + 4 * i + 4);
        }
      }
      else
      {
        v261 = v66 + 1;
        v451 = 0;
        v262 = v66 + v415 + 1;
        v263 = (unsigned __int8 *)(v66 + 1);
        do
        {
          while ( 1 )
          {
            v264 = *v263;
            v265 = v263[2];
            ++v261;
            v266 = v263[1];
            if ( (_BYTE)v265 != (_BYTE)v264 || (_BYTE)v266 != (_BYTE)v264 )
              break;
            *(_BYTE *)(v261 - 1) = v264;
            v263 += 3;
            if ( v262 == v261 )
              goto LABEL_366;
          }
          v263 += 3;
          v451 = 1;
          *(_BYTE *)(v261 - 1) = (unsigned int)(v441 * v264 + v446 * v266 + v453 * v265) >> 15;
        }
        while ( v262 != v261 );
      }
      goto LABEL_366;
    }
  }
  else
  {
    v455 = *(_DWORD *)(v2 + 348);
    if ( v455 && (v456 = *(_DWORD *)(v2 + 344)) != 0 )
    {
      if ( v415 )
      {
        v451 = 0;
        v427 = 0;
        v435 = (_BYTE *)(v66 + 1);
        do
        {
          v394 = _byteswap_ushort(*(_WORD *)v375);
          v69 = _byteswap_ushort(*(_WORD *)(v375 + 2));
          v70 = _byteswap_ushort(*(_WORD *)(v375 + 4));
          v71 = HIBYTE(v394);
          if ( v394 == v69 && v394 == v70 )
          {
            v72 = *(_DWORD *)(v2 + 332);
            if ( v72 )
            {
              v394 = *(_WORD *)(*(_DWORD *)(v72 + 4 * ((int)(unsigned __int8)v394 >> *(_DWORD *)(v2 + 320))) + 2 * v71);
              v71 = HIBYTE(v394);
            }
          }
          else
          {
            v190 = *(_DWORD *)(v2 + 320);
            v451 = 1;
            v191 = (v453
                  * *(unsigned __int16 *)(*(_DWORD *)(v455 + 4 * ((int)(unsigned __int8)v70 >> v190)) + 2 * HIBYTE(v70))
                  + v446
                  * *(unsigned __int16 *)(*(_DWORD *)(v455 + 4 * ((int)(unsigned __int8)v69 >> v190)) + 2 * HIBYTE(v69))
                  + v441
                  * (unsigned int)*(unsigned __int16 *)(*(_DWORD *)(v455 + 4 * ((int)(unsigned __int8)v394 >> v190))
                                                      + 2 * v71)
                  + 0x4000) >> 15;
            LOWORD(v191) = *(_WORD *)(*(_DWORD *)(v456 + 4 * ((int)(unsigned __int8)v191 >> v190)) + 2 * BYTE1(v191));
            LOBYTE(v394) = v191;
            v71 = BYTE1(v191);
          }
          *v435 = v71;
          v435[1] = v394;
          if ( v454 )
          {
            v435[2] = *(_BYTE *)(v375 + 6);
            v435[3] = *(_BYTE *)(v375 + 7);
            v435 += 4;
            v375 += 8;
          }
          else
          {
            v375 += 6;
            v435 += 2;
          }
          ++v427;
        }
        while ( v415 != v427 );
LABEL_366:
        v4 = *(_DWORD *)(v2 + 104);
        v65 = *(_BYTE *)(a2 + 8);
        v68 = *(_BYTE *)(a2 + 9);
        goto LABEL_367;
      }
    }
    else if ( v415 )
    {
      v451 = 0;
      if ( v454 )
      {
        v380 = v2;
        for ( j = 0; j != v415; ++j )
        {
          v278 = _byteswap_ushort(*(_WORD *)(v66 + 8 * j + 1));
          v279 = _byteswap_ushort(*(_WORD *)(v66 + 8 * j + 3));
          v280 = _byteswap_ushort(*(_WORD *)(v66 + 8 * j + 5));
          if ( v280 != v278 || v279 != v278 )
            v451 = 1;
          v277 = (v453 * v280 + v446 * v279 + v441 * (unsigned int)v278 + 0x4000) >> 15;
          *(_BYTE *)(v66 + 4 * j + 1) = BYTE1(v277);
          *(_BYTE *)(v66 + 4 * j + 2) = v277;
          *(_BYTE *)(v66 + 4 * j + 3) = *(_BYTE *)(v66 + 8 * j + 7);
          *(_BYTE *)(v66 + 4 * j + 4) = *(_BYTE *)(v66 + 8 * j + 8);
        }
      }
      else
      {
        v167 = (unsigned __int16 *)(v66 + 1);
        v168 = 0;
        v380 = v2;
        do
        {
          v170 = _byteswap_ushort(*v167);
          v171 = _byteswap_ushort(v167[1]);
          v172 = _byteswap_ushort(v167[2]);
          if ( v172 != v170 || v171 != v170 )
            v451 = 1;
          v167 += 3;
          v169 = (v453 * v172 + v446 * v171 + v441 * (unsigned int)v170 + 0x4000) >> 15;
          *(_BYTE *)(v66 + 2 * v168 + 1) = BYTE1(v169);
          *(_BYTE *)(v66 + 2 * v168++ + 2) = v169;
        }
        while ( v415 != v168 );
      }
      v2 = v380;
      goto LABEL_366;
    }
  }
  v451 = 0;
LABEL_367:
  v237 = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(a2 + 8) = v65 & 0xFD;
  v238 = (v237 - 2) * v68;
  *(_BYTE *)(a2 + 10) = v237 - 2;
  *(_BYTE *)(a2 + 11) = v238;
  if ( v238 <= 7u )
    v239 = (v415 * (unsigned int)v238 + 7) >> 3;
  else
    v239 = v415 * (v238 >> 3);
  *(_DWORD *)(a2 + 4) = v239;
  if ( v451 )
  {
    *(_BYTE *)(v2 + 392) = 1;
    if ( (v4 & 0x600000) == 0x200000 )
LABEL_371:
      png_err(v2);
  }
LABEL_15:
  if ( (v4 & 0x4000) == 0 || (*(_BYTE *)(v2 + 97) & 8) != 0 )
  {
    if ( (v4 & 0x80u) != 0 )
      goto LABEL_57;
LABEL_17:
    if ( (v4 & 0x602000) != 0x2000 )
      goto LABEL_18;
    goto LABEL_128;
  }
  png_do_gray_to_rgb((int *)a2, *(_DWORD *)(v2 + 252) + 1);
  v4 = *(_DWORD *)(v2 + 104);
  if ( (v4 & 0x80u) == 0 )
    goto LABEL_17;
LABEL_57:
  v28 = *(_DWORD *)(v2 + 252);
  v29 = *(_DWORD *)(v2 + 336);
  v393 = *(_DWORD *)(v2 + 328);
  v30 = (unsigned __int8 *)(v28 + 1);
  v450 = *(_DWORD *)(v2 + 340);
  v426 = *(_DWORD *)(v2 + 332);
  v445 = *(_DWORD *)(v2 + 344);
  v434 = *(_DWORD *)(v2 + 348);
  v414 = *(_DWORD *)(v2 + 320);
  v440 = *(_DWORD *)(v2 + 100) & 0x2000;
  v31 = *(_DWORD *)a2;
  v32 = *(_BYTE *)(a2 + 8);
  v374 = *(_DWORD *)a2;
  if ( v32 != 2 )
  {
    if ( v32 <= 2u )
    {
      if ( v32 )
        goto LABEL_113;
      switch ( *(_BYTE *)(a2 + 9) )
      {
        case 1:
          if ( !v374 )
            goto LABEL_392;
          v176 = *(unsigned __int16 *)(v2 + 372);
          v403 = v2;
          v177 = 0;
          v178 = *(_DWORD *)a2;
          v381 = v176;
          v179 = 7;
          do
          {
            if ( (((int)*v30 >> v179) & 1) == v381 )
              *v30 = (*(unsigned __int16 *)(v403 + 308) << v179) | *v30 & (32639 >> (7 - v179));
            if ( v179 )
            {
              --v179;
            }
            else
            {
              ++v30;
              v179 = 7;
            }
            ++v177;
          }
          while ( v178 != v177 );
          goto LABEL_447;
        case 2:
          if ( v393 )
          {
            if ( !v374 )
              goto LABEL_392;
            v184 = 0;
            v185 = 6;
            v428 = v2;
            v421 = *(unsigned __int16 *)(v2 + 372);
            do
            {
              v186 = ((int)*v30 >> v185) & 3;
              if ( v186 == v421 )
                v187 = *(unsigned __int16 *)(v2 + 308) << v185;
              else
                v187 = *(_BYTE *)(v393 + (v186 | (16 * v186) | (4 * v186) | (v186 << 6))) >> 6 << v185;
              *v30 = v187 | (16191 >> (6 - v185)) & *v30;
              if ( v185 )
              {
                v185 -= 2;
              }
              else
              {
                ++v30;
                v185 = 6;
              }
              ++v184;
            }
            while ( v374 != v184 );
            goto LABEL_472;
          }
          if ( !v374 )
            goto LABEL_392;
          v403 = v2;
          v354 = 0;
          v355 = 6;
          v356 = *(unsigned __int16 *)(v2 + 372);
          do
          {
            if ( (((int)*v30 >> v355) & 3) == v356 )
              *v30 = (*(unsigned __int16 *)(v403 + 308) << v355) | *v30 & (16191 >> (6 - v355));
            if ( v355 )
            {
              v355 -= 2;
            }
            else
            {
              ++v30;
              v355 = 6;
            }
            ++v354;
          }
          while ( v374 != v354 );
          goto LABEL_447;
        case 4:
          if ( v393 )
          {
            if ( !v31 )
              goto LABEL_392;
            v180 = 4;
            v428 = v2;
            v420 = *(_DWORD *)a2;
            v382 = *(unsigned __int16 *)(v2 + 372);
            v181 = 0;
            do
            {
              v182 = ((int)*v30 >> v180) & 0xF;
              if ( v182 == v382 )
                v183 = *(unsigned __int16 *)(v2 + 308) << v180;
              else
                v183 = *(_BYTE *)(v393 + ((16 * v182) | v182)) >> 4 << v180;
              *v30 = v183 | (3855 >> (4 - v180)) & *v30;
              if ( v180 )
              {
                v180 -= 4;
              }
              else
              {
                ++v30;
                v180 = 4;
              }
              ++v181;
            }
            while ( v420 != v181 );
LABEL_472:
            v2 = v428;
            v4 = *(_DWORD *)(v428 + 104);
          }
          else
          {
            if ( !v374 )
              goto LABEL_392;
            v403 = v2;
            v362 = 0;
            v363 = 4;
            v364 = *(unsigned __int16 *)(v2 + 372);
            do
            {
              if ( (((int)*v30 >> v363) & 0xF) == v364 )
                *v30 = (*(unsigned __int16 *)(v403 + 308) << v363) | *v30 & (3855 >> (4 - v363));
              if ( v363 )
              {
                v363 -= 4;
              }
              else
              {
                ++v30;
                v363 = 4;
              }
              ++v362;
            }
            while ( v374 != v362 );
LABEL_447:
            v2 = v403;
            v4 = *(_DWORD *)(v403 + 104);
          }
          goto LABEL_113;
        case 8:
          if ( v393 )
          {
            if ( !v31 )
              goto LABEL_392;
            v73 = v28 + v31 + 1;
            v74 = *(_WORD *)(v2 + 372);
            do
            {
              while ( 1 )
              {
                v75 = *v30;
                if ( (_WORD)v75 == v74 )
                  break;
                *v30++ = *(_BYTE *)(v393 + v75);
                if ( (unsigned __int8 *)v73 == v30 )
                  goto LABEL_112;
              }
              *v30++ = *(_WORD *)(v2 + 308);
            }
            while ( (unsigned __int8 *)v73 != v30 );
          }
          else
          {
            if ( !v374 )
              goto LABEL_392;
            v360 = *(_WORD *)(v2 + 372);
            v361 = v28 + v31 + 1;
            do
            {
              if ( *v30 == v360 )
                *v30 = *(_WORD *)(v2 + 308);
              ++v30;
            }
            while ( v30 != (unsigned __int8 *)v361 );
          }
          goto LABEL_112;
        case 0x10:
          if ( v426 )
          {
            if ( !v374 )
              goto LABEL_392;
            v402 = *(_WORD *)(v2 + 372);
            for ( k = 0; k != v374; ++k )
            {
              v175 = *(unsigned __int8 *)(v28 + 2 * k + 2);
              if ( (_WORD)v175 + (*(unsigned __int8 *)(v28 + 2 * k + 1) << 8) == v402 )
                v174 = *(_WORD *)(v2 + 308);
              else
                v174 = *(_WORD *)(*(_DWORD *)(v426 + 4 * (v175 >> v414)) + 2 * *(unsigned __int8 *)(v28 + 2 * k + 1));
              *(_BYTE *)(v28 + 2 * k + 2) = v174;
              *(_BYTE *)(v28 + 2 * k + 1) = HIBYTE(v174);
            }
          }
          else
          {
            if ( !v374 )
              goto LABEL_392;
            v357 = *(_WORD *)(v2 + 372);
            v358 = *(_DWORD *)a2;
            v359 = 0;
            do
            {
              if ( *(unsigned __int8 *)(v28 + 2 * v359 + 2) + (*(unsigned __int8 *)(v28 + 2 * v359 + 1) << 8) == v357 )
              {
                v389 = *(_WORD *)(v2 + 308);
                *(_BYTE *)(v28 + 2 * v359 + 1) = HIBYTE(v389);
                *(_BYTE *)(v28 + 2 * v359 + 2) = v389;
              }
              ++v359;
            }
            while ( v358 != v359 );
          }
          break;
        default:
          goto LABEL_113;
      }
    }
    else if ( v32 == 4 )
    {
      if ( *(_BYTE *)(a2 + 9) == 8 )
      {
        if ( v29 != 0 && v450 != 0 && v393 )
        {
          if ( !v374 )
            goto LABEL_392;
          if ( v440 )
          {
            for ( m = 0; m != v374; ++m )
            {
              v349 = *(unsigned __int8 *)(v28 + 2 * m + 2);
              if ( (_WORD)v349 == 255 )
              {
                *(_BYTE *)(v28 + 2 * m + 1) = *(_BYTE *)(v393 + *(unsigned __int8 *)(v28 + 2 * m + 1));
              }
              else if ( *(_BYTE *)(v28 + 2 * m + 2) )
              {
                *(_BYTE *)(v28 + 2 * m + 1) = (*(unsigned __int8 *)(v450 + *(unsigned __int8 *)(v28 + 2 * m + 1)) * v349
                                             + *(unsigned __int16 *)(v2 + 318)
                                             * (unsigned int)(unsigned __int16)(255 - v349)
                                             + 127)
                                            / 0xFF;
              }
              else
              {
                *(_BYTE *)(v28 + 2 * m + 1) = *(_WORD *)(v2 + 308);
              }
            }
          }
          else
          {
            v419 = *(_DWORD *)(v2 + 336);
            for ( n = 0; n != v374; ++n )
            {
              v155 = *(unsigned __int8 *)(v28 + 2 * n + 2);
              if ( (_WORD)v155 == 255 )
              {
                *(_BYTE *)(v28 + 2 * n + 1) = *(_BYTE *)(v393 + *(unsigned __int8 *)(v28 + 2 * n + 1));
              }
              else
              {
                if ( *(_BYTE *)(v28 + 2 * n + 2) )
                  LOBYTE(v154) = *(_BYTE *)(v419
                                          + (unsigned __int8)((*(unsigned __int8 *)(v450
                                                                                  + *(unsigned __int8 *)(v28 + 2 * n + 1))
                                                             * v155
                                                             + (unsigned __int16)(255 - v155)
                                                             * (unsigned int)*(unsigned __int16 *)(v2 + 318)
                                                             + 127)
                                                            / 0xFF));
                else
                  v154 = *(_WORD *)(v2 + 308);
                *(_BYTE *)(v28 + 2 * n + 1) = v154;
              }
            }
          }
        }
        else
        {
          v287 = 0;
          if ( !v374 )
            goto LABEL_392;
          do
          {
            v288 = *(unsigned __int8 *)(v28 + 2 * v287 + 2);
            if ( (_BYTE)v288 )
            {
              if ( (_BYTE)v288 != 0xFF )
                *(_BYTE *)(v28 + 2 * v287 + 1) = ((unsigned __int16)(255 - (unsigned __int8)v288)
                                                * *(unsigned __int16 *)(v2 + 308)
                                                + (unsigned int)*(unsigned __int8 *)(v28 + 2 * v287 + 1) * v288
                                                + 127)
                                               / 0xFF;
            }
            else
            {
              *(_BYTE *)(v28 + 2 * v287 + 1) = *(_WORD *)(v2 + 308);
            }
            ++v287;
          }
          while ( v374 != v287 );
        }
      }
      else if ( v445 != 0 && v426 != 0 && v434 )
      {
        if ( !v374 )
          goto LABEL_392;
        for ( ii = 0; ii != v374; ++ii )
        {
          v107 = v30[3] + (v30[2] << 8);
          if ( v107 == 0xFFFF )
          {
            v108 = *(_WORD *)(*(_DWORD *)(v426 + 4 * ((int)v30[1] >> v414)) + 2 * *v30);
            v30[1] = v108;
            *v30 = HIBYTE(v108);
          }
          else if ( v107 )
          {
            v204 = (v107 * *(unsigned __int16 *)(*(_DWORD *)(v434 + 4 * ((int)v30[1] >> v414)) + 2 * *v30)
                  + (0xFFFF - v107) * (unsigned int)*(unsigned __int16 *)(v2 + 318)
                  + 0x7FFF)
                 / 0xFFFF;
            LOBYTE(v205) = v204;
            v206 = BYTE1(v204);
            if ( !v440 )
            {
              v205 = *(_WORD *)(*(_DWORD *)(v445 + 4 * ((int)(unsigned __int8)v204 >> v414)) + 2 * v206);
              v206 = HIBYTE(v205);
            }
            *v30 = v206;
            v30[1] = v205;
          }
          else
          {
            v106 = *(_WORD *)(v2 + 308);
            v30[1] = v106;
            *v30 = HIBYTE(v106);
          }
          v30 += 4;
        }
      }
      else
      {
        v249 = 0;
        if ( !v374 )
          goto LABEL_392;
        do
        {
          v251 = *(unsigned __int8 *)(v28 + 4 * v249 + 4) + (*(unsigned __int8 *)(v28 + 4 * v249 + 3) << 8);
          if ( v251 )
          {
            if ( v251 != 0xFFFF )
            {
              v252 = (v251
                    * (unsigned __int16)(*(unsigned __int8 *)(v28 + 4 * v249 + 2)
                                       + (*(unsigned __int8 *)(v28 + 4 * v249 + 1) << 8))
                    + (0xFFFF - v251) * (unsigned int)*(unsigned __int16 *)(v2 + 308)
                    + 0x7FFF)
                   / 0xFFFF;
              *(_BYTE *)(v28 + 4 * v249 + 1) = BYTE1(v252);
              *(_BYTE *)(v28 + 4 * v249 + 2) = v252;
            }
          }
          else
          {
            v250 = *(_WORD *)(v2 + 308);
            *(_BYTE *)(v28 + 4 * v249 + 2) = v250;
            *(_BYTE *)(v28 + 4 * v249 + 1) = HIBYTE(v250);
          }
          ++v249;
        }
        while ( v374 != v249 );
      }
    }
    else
    {
      if ( v32 != 6 )
        goto LABEL_113;
      if ( *(_BYTE *)(a2 + 9) == 8 )
      {
        if ( v29 != 0 && v450 != 0 && v393 )
        {
          if ( !v374 )
            goto LABEL_392;
          v160 = 0;
          v449 = *(_DWORD *)(v2 + 336);
          do
          {
            LOWORD(v161) = v30[3];
            if ( (_BYTE)v161 == 0xFF )
            {
              *v30 = *(_BYTE *)(v393 + *v30);
              v30[1] = *(_BYTE *)(v393 + v30[1]);
              v30[2] = *(_BYTE *)(v393 + v30[2]);
            }
            else if ( (_BYTE)v161 )
            {
              v431 = (unsigned __int8 *)(v30[2] + v450);
              v256 = ((unsigned __int8)v161 * *(unsigned __int8 *)(v450 + *v30)
                    + (unsigned __int16)(255 - v161) * (unsigned int)*(unsigned __int16 *)(v2 + 312)
                    + 127)
                   / 0xFF;
              v438 = (unsigned __int16)(255 - v161) * *(unsigned __int16 *)(v2 + 316);
              v257 = (unsigned __int8 *)(v30[1] + v450);
              v258 = *(unsigned __int16 *)(v2 + 314) * (unsigned __int16)(255 - v161);
              if ( v440 )
              {
                *v30 = v256;
                v30[1] = (v258 + (unsigned __int8)v161 * (unsigned int)*v257 + 127) / 0xFF;
                v161 = (v438 + (unsigned __int8)v161 * (unsigned int)*v431 + 127) / 0xFF;
              }
              else
              {
                *v30 = *(_BYTE *)(v449 + (unsigned __int8)v256);
                v30[1] = *(_BYTE *)(v449
                                  + (unsigned __int8)((v258 + (unsigned __int8)v161 * (unsigned int)*v257 + 127) / 0xFF));
                LOBYTE(v161) = *(_BYTE *)(v449
                                        + (unsigned __int8)((v438 + (unsigned __int8)v161 * (unsigned int)*v431 + 127)
                                                          / 0xFF));
              }
              v30[2] = v161;
            }
            else
            {
              *v30 = *(_WORD *)(v2 + 302);
              v30[1] = *(_WORD *)(v2 + 304);
              v30[2] = *(_WORD *)(v2 + 306);
            }
            ++v160;
            v30 += 4;
          }
          while ( v374 != v160 );
        }
        else
        {
          v289 = 0;
          if ( !v374 )
            goto LABEL_392;
          do
          {
            v290 = *(unsigned __int8 *)(v28 + 4 * v289 + 4);
            if ( (_BYTE)v290 )
            {
              if ( (_BYTE)v290 != 0xFF )
              {
                *(_BYTE *)(v28 + 4 * v289 + 1) = ((unsigned __int8)v290 * *(unsigned __int8 *)(v28 + 4 * v289 + 1)
                                                + (unsigned __int16)(255 - v290)
                                                * (unsigned int)*(unsigned __int16 *)(v2 + 302)
                                                + 127)
                                               / 0xFF;
                v291 = *(unsigned __int8 *)(v28 + 4 * v289 + 3) * (unsigned __int8)v290;
                *(_BYTE *)(v28 + 4 * v289 + 2) = ((unsigned __int8)v290 * *(unsigned __int8 *)(v28 + 4 * v289 + 2)
                                                + (unsigned __int16)(255 - v290)
                                                * (unsigned int)*(unsigned __int16 *)(v2 + 304)
                                                + 127)
                                               / 0xFF;
                *(_BYTE *)(v28 + 4 * v289 + 3) = (v291
                                                + *(unsigned __int16 *)(v2 + 306)
                                                * (unsigned int)(unsigned __int16)(255 - v290)
                                                + 127)
                                               / 0xFF;
              }
            }
            else
            {
              *(_BYTE *)(v28 + 4 * v289 + 1) = *(_WORD *)(v2 + 302);
              *(_BYTE *)(v28 + 4 * v289 + 2) = *(_WORD *)(v2 + 304);
              *(_BYTE *)(v28 + 4 * v289 + 3) = *(_WORD *)(v2 + 306);
            }
            ++v289;
          }
          while ( v374 != v289 );
        }
      }
      else
      {
        if ( v445 != 0 && v426 != 0 && v434 )
        {
          if ( v374 )
          {
            v33 = 0;
            v34 = *(_DWORD *)(v2 + 320);
            while ( 1 )
            {
              v38 = v30[7] + (v30[6] << 8);
              if ( v38 == 0xFFFF )
                break;
              if ( v38 )
              {
                v405 = v38;
                v422 = 0xFFFF - v38;
                v207 = (v38 * *(unsigned __int16 *)(*(_DWORD *)(v434 + 4 * ((int)v30[1] >> v34)) + 2 * *v30)
                      + v422 * (unsigned int)*(unsigned __int16 *)(v2 + 312)
                      + 0x7FFF)
                     / 0xFFFF;
                LOBYTE(v208) = v207;
                v209 = BYTE1(v207);
                if ( !v440 )
                {
                  v208 = *(_WORD *)(*(_DWORD *)(v445 + 4 * ((int)(unsigned __int8)v207 >> v34)) + 2 * v209);
                  v209 = HIBYTE(v208);
                }
                v30[1] = v208;
                v210 = v30[3];
                *v30 = v209;
                v211 = (v405 * *(unsigned __int16 *)(*(_DWORD *)(v434 + 4 * (v210 >> v34)) + 2 * v30[2])
                      + v422 * (unsigned int)*(unsigned __int16 *)(v2 + 314)
                      + 0x7FFF)
                     / 0xFFFF;
                v212 = v211;
                if ( !v440 )
                  v212 = *(_WORD *)(*(_DWORD *)(v445 + 4 * ((int)(unsigned __int8)v211 >> v34)) + 2 * BYTE1(v211));
                v30[3] = v212;
                v213 = HIBYTE(v212);
                v214 = (int)v30[5] >> v34;
                v30[2] = v213;
                v215 = (*(unsigned __int16 *)(*(_DWORD *)(v434 + 4 * v214) + 2 * v30[4]) * v405
                      + v422 * (unsigned int)*(unsigned __int16 *)(v2 + 316)
                      + 0x7FFF)
                     / 0xFFFF;
                v47 = v215;
                if ( !v440 )
                {
                  v216 = (unsigned __int8)v215;
                  v39 = v445;
                  v45 = BYTE1(v215);
                  v46 = v216 >> v34;
LABEL_71:
                  v47 = *(_WORD *)(*(_DWORD *)(v39 + 4 * v46) + 2 * v45);
                }
                v30[5] = v47;
                v30[4] = HIBYTE(v47);
                goto LABEL_68;
              }
              v35 = *(_WORD *)(v2 + 302);
              v30[1] = v35;
              *v30 = HIBYTE(v35);
              v36 = *(_WORD *)(v2 + 304);
              v30[3] = v36;
              v30[2] = HIBYTE(v36);
              v37 = *(_WORD *)(v2 + 306);
              v30[5] = v37;
              v30[4] = HIBYTE(v37);
LABEL_68:
              ++v33;
              v30 += 8;
              if ( v374 == v33 )
                goto LABEL_112;
            }
            v39 = v426;
            v40 = *(_WORD *)(*(_DWORD *)(v426 + 4 * ((int)v30[1] >> v34)) + 2 * *v30);
            v30[1] = v40;
            v41 = HIBYTE(v40);
            v42 = (int)v30[3] >> v34;
            *v30 = v41;
            v43 = *(_WORD *)(*(_DWORD *)(v426 + 4 * v42) + 2 * v30[2]);
            v30[3] = v43;
            v44 = v30[5];
            v30[2] = HIBYTE(v43);
            v45 = v30[4];
            v46 = v44 >> v34;
            goto LABEL_71;
          }
LABEL_392:
          if ( (v4 & 0x602000) != 0x2000 )
            goto LABEL_18;
          goto LABEL_115;
        }
        v240 = 0;
        if ( !v374 )
          goto LABEL_392;
        do
        {
          v244 = *(unsigned __int8 *)(v28 + 8 * v240 + 8) + (*(unsigned __int8 *)(v28 + 8 * v240 + 7) << 8);
          if ( v244 )
          {
            if ( v244 != 0xFFFF )
            {
              v407 = *(unsigned __int8 *)(v28 + 8 * v240 + 4) + (*(unsigned __int8 *)(v28 + 8 * v240 + 3) << 8);
              v423 = (*(unsigned __int8 *)(v28 + 8 * v240 + 5) << 8) + *(unsigned __int8 *)(v28 + 8 * v240 + 6);
              v245 = 0xFFFF - v244;
              v246 = v244
                   * (unsigned __int16)(*(unsigned __int8 *)(v28 + 8 * v240 + 2)
                                      + (*(unsigned __int8 *)(v28 + 8 * v240 + 1) << 8))
                   + v245 * *(unsigned __int16 *)(v2 + 302)
                   + 0x7FFF;
              *(_BYTE *)(v28 + 8 * v240 + 1) = v246 / 0xFFFF00;
              *(_BYTE *)(v28 + 8 * v240 + 2) = v246 / 0xFFFF;
              v247 = (v245 * *(unsigned __int16 *)(v2 + 304) + v244 * (unsigned int)v407 + 0x7FFF) / 0xFFFF;
              *(_BYTE *)(v28 + 8 * v240 + 3) = BYTE1(v247);
              *(_BYTE *)(v28 + 8 * v240 + 4) = v247;
              v248 = (*(unsigned __int16 *)(v2 + 306) * v245 + v423 * (unsigned int)v244 + 0x7FFF) / 0xFFFF;
              *(_BYTE *)(v28 + 8 * v240 + 5) = BYTE1(v248);
              *(_BYTE *)(v28 + 8 * v240 + 6) = v248;
            }
          }
          else
          {
            v241 = *(_WORD *)(v2 + 302);
            *(_BYTE *)(v28 + 8 * v240 + 2) = v241;
            *(_BYTE *)(v28 + 8 * v240 + 1) = HIBYTE(v241);
            v242 = *(_WORD *)(v2 + 304);
            *(_BYTE *)(v28 + 8 * v240 + 4) = v242;
            *(_BYTE *)(v28 + 8 * v240 + 3) = HIBYTE(v242);
            v243 = *(_WORD *)(v2 + 306);
            *(_BYTE *)(v28 + 8 * v240 + 6) = v243;
            *(_BYTE *)(v28 + 8 * v240 + 5) = HIBYTE(v243);
          }
          ++v240;
        }
        while ( v374 != v240 );
      }
    }
    goto LABEL_112;
  }
  if ( *(_BYTE *)(a2 + 9) == 8 )
  {
    if ( v393 )
    {
      if ( !v31 )
        goto LABEL_392;
      v156 = *(_DWORD *)(v2 + 328);
      v379 = *(_WORD *)(v2 + 366);
      v400 = (unsigned __int8 *)(3 * v31 + 1 + v28);
      do
      {
        v157 = v30[1];
        v158 = v30[2];
        v159 = *v30;
        if ( __PAIR32__((unsigned __int8)v157, v159) == __PAIR32__(*(_WORD *)(v2 + 368), v379)
          && (unsigned __int8)v158 == *(_WORD *)(v2 + 370) )
        {
          *v30 = *(_WORD *)(v2 + 302);
          v30[1] = *(_WORD *)(v2 + 304);
          v30[2] = *(_WORD *)(v2 + 306);
        }
        else
        {
          *v30 = *(_BYTE *)(v156 + v159);
          v30[1] = *(_BYTE *)(v156 + v157);
          v30[2] = *(_BYTE *)(v156 + v158);
        }
        v30 += 3;
      }
      while ( v400 != v30 );
    }
    else
    {
      if ( !v374 )
        goto LABEL_392;
      v321 = *(_WORD *)(v2 + 366);
      v322 = (unsigned __int8 *)(v28 + 3 * v31 + 1);
      do
      {
        if ( *v30 == v321 && v30[1] == *(_WORD *)(v2 + 368) && v30[2] == *(_WORD *)(v2 + 370) )
        {
          *v30 = *(_WORD *)(v2 + 302);
          v30[1] = *(_WORD *)(v2 + 304);
          v30[2] = *(_WORD *)(v2 + 306);
        }
        v30 += 3;
      }
      while ( v30 != v322 );
    }
    goto LABEL_112;
  }
  if ( !v426 )
  {
    if ( !v374 )
      goto LABEL_392;
    v292 = *(_DWORD *)a2;
    v293 = *(_WORD *)(v2 + 366);
    v294 = 0;
    do
    {
      if ( v30[1] + (*v30 << 8) == v293
        && v30[3] + (v30[2] << 8) == *(_WORD *)(v2 + 368)
        && v30[5] + (v30[4] << 8) == *(_WORD *)(v2 + 370) )
      {
        v383 = *(_WORD *)(v2 + 302);
        *v30 = HIBYTE(v383);
        v30[1] = v383;
        v384 = *(_WORD *)(v2 + 304);
        v30[2] = HIBYTE(v384);
        v30[3] = v384;
        v385 = *(_WORD *)(v2 + 306);
        v30[4] = HIBYTE(v385);
        v30[5] = v385;
      }
      ++v294;
      v30 += 6;
    }
    while ( v292 != v294 );
LABEL_112:
    v4 = *(_DWORD *)(v2 + 104);
    goto LABEL_113;
  }
  if ( !v374 )
    goto LABEL_392;
  v129 = *(_WORD *)(v2 + 366);
  v452 = v2;
  v397 = 0;
  v130 = *(_DWORD *)(v2 + 332);
  v448 = v129;
  do
  {
    v134 = *v30;
    v135 = v30[3];
    LOBYTE(v426) = v30[2];
    v136 = v30[1];
    LOBYTE(v434) = v30[4];
    v442 = v30[5];
    if ( (_WORD)v136 + ((_WORD)v134 << 8) == v448
      && ((_WORD)v426 << 8) + (unsigned __int8)v135 == *(_WORD *)(v452 + 368)
      && ((_WORD)v434 << 8) + v442 == *(_WORD *)(v452 + 370) )
    {
      v137 = *(_WORD *)(v452 + 302);
      v30[1] = v137;
      *v30 = HIBYTE(v137);
      v138 = *(_WORD *)(v452 + 304);
      v30[3] = v138;
      v30[2] = HIBYTE(v138);
      v139 = *(_WORD *)(v452 + 306);
      v30[5] = v139;
      v30[4] = HIBYTE(v139);
    }
    else
    {
      v131 = *(_WORD *)(*(_DWORD *)(v130 + 4 * (v136 >> v414)) + 2 * v134);
      v30[1] = v131;
      *v30 = HIBYTE(v131);
      v132 = *(_WORD *)(*(_DWORD *)(v130 + 4 * (v135 >> v414)) + 2 * (unsigned __int8)v426);
      v30[3] = v132;
      v30[2] = HIBYTE(v132);
      v133 = *(_WORD *)(*(_DWORD *)(v130 + 4 * ((int)v442 >> v414)) + 2 * (unsigned __int8)v434);
      v30[5] = v133;
      v30[4] = HIBYTE(v133);
    }
    ++v397;
    v30 += 6;
  }
  while ( v374 != v397 );
  v2 = v452;
  v4 = *(_DWORD *)(v452 + 104);
LABEL_113:
  if ( (v4 & 0x602000) != 0x2000 )
    goto LABEL_18;
  if ( (v4 & 0x80u) == 0 )
  {
LABEL_128:
    v76 = *(_BYTE *)(v2 + 281);
    goto LABEL_129;
  }
LABEL_115:
  if ( *(_WORD *)(v2 + 274) )
    goto LABEL_18;
  v76 = *(_BYTE *)(v2 + 281);
  if ( (v76 & 4) != 0 )
    goto LABEL_18;
LABEL_129:
  if ( v76 == 3 )
    goto LABEL_18;
  v84 = *(_DWORD *)(v2 + 328);
  v85 = *(_DWORD *)(v2 + 332);
  v395 = *(_DWORD *)(v2 + 320);
  v416 = *(_DWORD *)(v2 + 252);
  v86 = (unsigned __int8 *)(v416 + 1);
  v376 = *(_DWORD *)a2;
  v87 = *(_BYTE *)(a2 + 9);
  if ( v87 <= 8u )
  {
    if ( !v84 )
      goto LABEL_18;
    v88 = *(_BYTE *)(a2 + 8);
    if ( v88 != 2 )
    {
      if ( v88 > 2u )
        goto LABEL_134;
      if ( v88 )
        goto LABEL_18;
      if ( v87 == 2 )
      {
        if ( !v376 )
          goto LABEL_18;
        v430 = 0;
        v437 = (char *)(v416 + 1);
        do
        {
          v233 = *v437;
          v234 = *v437 & 0xC;
          v430 += 4;
          *v437 = (*(_BYTE *)(v84 + (*v437 & 0x30 | ((*v437 & 0x30) >> 2) | (4 * (*v437 & 0x30)) | ((*v437 & 0x30) >> 4))) >> 2) & 0x30 | (*(_BYTE *)(v84 + (*v437 & 3 | (16 * (*v437 & 3)) | ((*v437 & 3) << 6) | (4 * (*v437 & 3)))) >> 6) | *(_BYTE *)(v84 + (v233 & 0xC0 | ((v233 & 0xC0) >> 4) | ((v233 & 0xC0) >> 2) | ((v233 & 0xC0) >> 6))) & 0xC0 | (*(_BYTE *)(v84 + (v234 | (4 * v234) | (16 * v234) | (v234 >> 2))) >> 4) & 0xC;
          ++v437;
        }
        while ( v376 > v430 );
        v86 = (unsigned __int8 *)(v416 + 1);
        v235 = *(_BYTE *)(a2 + 9);
        if ( v235 != 4 )
        {
          if ( v235 == 8 )
          {
            do
            {
LABEL_363:
              v236 = *v86++;
              *(v86 - 1) = *(_BYTE *)(v84 + v236);
            }
            while ( (unsigned __int8 *)(v416 + v376 + 1) != v86 );
            goto LABEL_216;
          }
          if ( v235 != 16 )
            goto LABEL_216;
          goto LABEL_212;
        }
      }
      else
      {
        if ( v87 != 4 )
        {
          if ( v87 != 8 || !v376 )
            goto LABEL_216;
          goto LABEL_363;
        }
        if ( !v376 )
          goto LABEL_216;
      }
      v396 = v2;
      for ( jj = 0; jj < v376; jj += 2 )
      {
        v341 = *v86++;
        *(v86 - 1) = (*(_BYTE *)(v84 + ((16 * (v341 & 0xF)) | v341 & 0xF)) >> 4) | *(_BYTE *)(v84
                                                                                            + (v341 & 0xF0 | ((v341 & 0xF0) >> 4))) & 0xF0;
      }
      goto LABEL_140;
    }
LABEL_482:
    if ( v87 != 8 )
    {
      if ( !v376 )
        goto LABEL_18;
      v295 = *(_DWORD *)(v2 + 320);
      v296 = *(_DWORD *)a2;
      v396 = v2;
      v386 = 0;
      do
      {
        v297 = v86[1];
        v298 = *v86;
        v86 += 6;
        ++v386;
        LOWORD(v297) = *(_WORD *)(*(_DWORD *)(v85 + 4 * (v297 >> v295)) + 2 * v298);
        *(v86 - 5) = v297;
        v299 = BYTE1(v297);
        v300 = (int)*(v86 - 3) >> v295;
        v301 = *(v86 - 4);
        *(v86 - 6) = v299;
        LOWORD(v300) = *(_WORD *)(*(_DWORD *)(v85 + 4 * v300) + 2 * v301);
        *(v86 - 3) = v300;
        v302 = BYTE1(v300);
        v303 = (int)*(v86 - 1) >> v295;
        v304 = *(v86 - 2);
        *(v86 - 4) = v302;
        LOWORD(v304) = *(_WORD *)(*(_DWORD *)(v85 + 4 * v303) + 2 * v304);
        *(v86 - 1) = v304;
        *(v86 - 2) = BYTE1(v304);
      }
      while ( v296 != v386 );
      goto LABEL_140;
    }
    if ( !v376 )
      goto LABEL_18;
    do
    {
      v352 = *v86;
      v86 += 3;
      *(v86 - 3) = *(_BYTE *)(v84 + v352);
      *(v86 - 2) = *(_BYTE *)(v84 + *(v86 - 2));
      *(v86 - 1) = *(_BYTE *)(v84 + *(v86 - 1));
    }
    while ( (unsigned __int8 *)(v416 + 3 * v376 + 1) != v86 );
    goto LABEL_216;
  }
  if ( !v85 || v87 != 16 )
    goto LABEL_18;
  v88 = *(_BYTE *)(a2 + 8);
  if ( v88 == 2 )
    goto LABEL_482;
  if ( v88 <= 2u )
  {
    if ( v88 )
      goto LABEL_18;
LABEL_212:
    v144 = v376;
    if ( v376 )
    {
      v378 = v2;
      v145 = 0;
      do
      {
        v146 = *(_WORD *)(*(_DWORD *)(v85 + 4 * ((int)*(unsigned __int8 *)(v416 + 2 * v145 + 2) >> v395))
                        + 2 * *(unsigned __int8 *)(v416 + 2 * v145 + 1));
        *(_BYTE *)(v416 + 2 * v145 + 2) = v146;
        *(_BYTE *)(v416 + 2 * v145++ + 1) = HIBYTE(v146);
      }
      while ( v144 != v145 );
LABEL_215:
      v2 = v378;
    }
LABEL_216:
    v4 = *(_DWORD *)(v2 + 104);
    goto LABEL_18;
  }
LABEL_134:
  if ( v88 == 4 )
  {
    if ( v87 == 8 )
    {
      if ( !v376 )
        goto LABEL_18;
      for ( kk = 0; kk != v376; ++kk )
        *(_BYTE *)(v416 + 2 * kk + 1) = *(_BYTE *)(v84 + *(unsigned __int8 *)(v416 + 2 * kk + 1));
      goto LABEL_216;
    }
    v305 = 0;
    if ( !v376 )
      goto LABEL_18;
    v306 = *(_DWORD *)a2;
    v378 = v2;
    do
    {
      v307 = *(_WORD *)(*(_DWORD *)(v85 + 4 * ((int)*(unsigned __int8 *)(v416 + 4 * v305 + 2) >> v395))
                      + 2 * *(unsigned __int8 *)(v416 + 4 * v305 + 1));
      *(_BYTE *)(v416 + 4 * v305 + 2) = v307;
      *(_BYTE *)(v416 + 4 * v305++ + 1) = HIBYTE(v307);
    }
    while ( v306 != v305 );
    goto LABEL_215;
  }
  if ( v88 != 6 )
    goto LABEL_18;
  if ( v87 == 8 )
  {
    if ( !v376 )
      goto LABEL_18;
    v350 = 0;
    do
    {
      v351 = *v86;
      ++v350;
      v86 += 4;
      *(v86 - 4) = *(_BYTE *)(v84 + v351);
      *(v86 - 3) = *(_BYTE *)(v84 + *(v86 - 3));
      *(v86 - 2) = *(_BYTE *)(v84 + *(v86 - 2));
    }
    while ( v376 != v350 );
    goto LABEL_216;
  }
  if ( v376 )
  {
    v89 = *(_DWORD *)(v2 + 320);
    v90 = *(_DWORD *)a2;
    v396 = v2;
    v377 = 0;
    do
    {
      v91 = v86[1];
      v92 = *v86;
      v86 += 8;
      ++v377;
      LOWORD(v91) = *(_WORD *)(*(_DWORD *)(v85 + 4 * (v91 >> v89)) + 2 * v92);
      *(v86 - 7) = v91;
      v93 = BYTE1(v91);
      v94 = (int)*(v86 - 5) >> v89;
      v95 = *(v86 - 6);
      *(v86 - 8) = v93;
      LOWORD(v94) = *(_WORD *)(*(_DWORD *)(v85 + 4 * v94) + 2 * v95);
      *(v86 - 5) = v94;
      v96 = BYTE1(v94);
      v97 = (int)*(v86 - 3) >> v89;
      v98 = *(v86 - 4);
      *(v86 - 6) = v96;
      LOWORD(v98) = *(_WORD *)(*(_DWORD *)(v85 + 4 * v97) + 2 * v98);
      *(v86 - 3) = v98;
      *(v86 - 4) = BYTE1(v98);
    }
    while ( v90 != v377 );
LABEL_140:
    v2 = v396;
    v4 = *(_DWORD *)(v396 + 104);
  }
LABEL_18:
  result = v4 & 0x40080;
  if ( (v4 & 0x40080) == 262272 )
  {
    result = *(_BYTE *)(a2 + 8) & 0xFD;
    if ( (_BYTE)result == 4 )
    {
      result = png_do_strip_channel(a2, (_BYTE *)(*(_DWORD *)(v2 + 252) + 1), 0);
      v4 = *(_DWORD *)(v2 + 104);
    }
  }
  if ( (v4 & 0x800000) != 0 )
  {
    result = a2;
    v22 = *(_BYTE *)(a2 + 8);
    if ( (v22 & 4) != 0 )
    {
      v23 = *(_BYTE *)(a2 + 9);
      v372 = *(_DWORD *)(v2 + 252);
      result = *(_DWORD *)a2;
      if ( v23 == 8 )
      {
        v253 = *(_DWORD *)(v2 + 336);
        if ( v253 )
        {
          v254 = (v22 & 2) == 0 ? 2 : 4;
          v255 = (_BYTE *)(v254 + v372);
          if ( result )
          {
            do
            {
              *v255 = *(_BYTE *)(v253 + (unsigned __int8)*v255);
              v255 += v254;
              --result;
            }
            while ( result );
            goto LABEL_54;
          }
        }
      }
      else if ( v23 == 16 )
      {
        v24 = *(_DWORD *)(v2 + 344);
        if ( v24 )
        {
          v25 = (unsigned __int8 *)(v372 + ((v22 & 2) == 0 ? 0xFFFFFFFC : 0) + 7);
          if ( result )
          {
            v392 = (v22 & 2) == 0 ? 4 : 8;
            v26 = *(_DWORD *)(v2 + 320);
            v373 = *(_DWORD *)a2;
            do
            {
              v27 = *(_WORD *)(*(_DWORD *)(v24 + 4 * ((int)v25[1] >> v26)) + 2 * *v25);
              v25[1] = v27;
              result = HIBYTE(v27);
              *v25 = HIBYTE(v27);
              v25 += v392;
              --v373;
            }
            while ( v373 );
LABEL_54:
            v4 = *(_DWORD *)(v2 + 104);
          }
        }
      }
    }
  }
  if ( (v4 & 0x4000000) != 0 )
  {
    result = a2;
    if ( *(_BYTE *)(a2 + 9) == 16 )
    {
      v59 = (unsigned __int8 *)(*(_DWORD *)(v2 + 252) + 1);
      v60 = &v59[*(_DWORD *)(a2 + 4)];
      if ( v59 < v60 )
      {
        v61 = (_BYTE *)(*(_DWORD *)(v2 + 252) + 1);
        do
        {
          v62 = *v59;
          v59 += 2;
          *v61++ = ((0xFFFF * ((unsigned int)*(v59 - 1) - v62 + 128)) >> 24) + v62;
        }
        while ( v59 < v60 );
        v4 = *(_DWORD *)(v2 + 104);
      }
      v63 = *(unsigned __int8 *)(a2 + 10);
      *(_BYTE *)(a2 + 9) = 8;
      v64 = 8 * v63;
      result = *(_DWORD *)a2 * v63;
      *(_BYTE *)(a2 + 11) = v64;
      *(_DWORD *)(a2 + 4) = result;
    }
  }
  if ( (v4 & 0x400) == 0 || (result = a2, *(_BYTE *)(a2 + 9) != 16) )
  {
    if ( (v4 & 0x200) == 0 )
      goto LABEL_23;
    goto LABEL_77;
  }
  v48 = *(_DWORD *)(v2 + 252) + 1;
  v49 = (char *)v48;
  v50 = v48 + *(_DWORD *)(a2 + 4);
  if ( v48 < v50 )
  {
    do
    {
      v51 = *v49;
      ++v48;
      v49 += 2;
      *(_BYTE *)(v48 - 1) = v51;
    }
    while ( v50 > (unsigned int)v49 );
  }
  v52 = *(unsigned __int8 *)(a2 + 10);
  *(_BYTE *)(a2 + 9) = 8;
  v53 = 8 * v52;
  result = *(_DWORD *)a2 * v52;
  *(_BYTE *)(a2 + 11) = v53;
  *(_DWORD *)(a2 + 4) = result;
  if ( (v4 & 0x200) != 0 )
  {
LABEL_77:
    result = a2;
    if ( *(_BYTE *)(a2 + 9) == 8 && *(_BYTE *)(a2 + 8) != 3 )
    {
      v54 = *(_DWORD *)(a2 + 4);
      v55 = (_BYTE *)(*(_DWORD *)(v2 + 252) + v54 + 1);
      v56 = &v55[v54];
      if ( v55 < &v55[v54] )
      {
        do
        {
          v57 = *--v55;
          v56 -= 2;
          v56[1] = *v55;
          *v56 = v57;
        }
        while ( v55 < v56 );
        v4 = *(_DWORD *)(v2 + 104);
        v54 = *(_DWORD *)(a2 + 4);
      }
      v58 = *(unsigned __int8 *)(a2 + 10);
      *(_DWORD *)(a2 + 4) = 2 * v54;
      *(_BYTE *)(a2 + 9) = 16;
      result = 16 * v58;
      *(_BYTE *)(a2 + 11) = result;
    }
  }
LABEL_23:
  if ( (v4 & 0x4000) != 0 && (*(_BYTE *)(v2 + 97) & 8) != 0 )
  {
    result = png_do_gray_to_rgb((int *)a2, *(_DWORD *)(v2 + 252) + 1);
    v4 = *(_DWORD *)(v2 + 104);
    if ( (v4 & 4) == 0 )
      goto LABEL_25;
  }
  else if ( (v4 & 4) == 0 )
  {
    goto LABEL_25;
  }
  result = a2;
  v9 = *(_BYTE *)(a2 + 9);
  if ( v9 > 7u )
  {
LABEL_25:
    if ( (v4 & 1) != 0 )
      goto LABEL_37;
    goto LABEL_26;
  }
  v10 = *(_BYTE **)(v2 + 252);
  v11 = *(_DWORD *)a2;
  v12 = v10 + 1;
  switch ( v9 )
  {
    case 2u:
      v200 = &v12[(unsigned int)(v11 - 1) >> 2];
      v201 = &v10[v11];
      v202 = ((unsigned __int8)(2 * v11 + 6) ^ 0xFE) & 6;
      if ( v11 )
      {
        v203 = v200;
        do
        {
          *v201 = ((int)*v203 >> v202) & 3;
          if ( v202 == 6 )
          {
            --v203;
            v202 = 0;
          }
          else
          {
            v202 += 2;
          }
          --v201;
        }
        while ( v10 != v201 );
        goto LABEL_318;
      }
      break;
    case 4u:
      v196 = &v12[(unsigned int)(v11 - 1) >> 1];
      v197 = &v10[v11];
      v198 = 4 * (*(_DWORD *)a2 & 1);
      if ( v11 )
      {
        v199 = v196;
        do
        {
          *v197 = ((int)*v199 >> v198) & 0xF;
          if ( v198 == 4 )
          {
            --v199;
            v198 = 0;
          }
          else
          {
            v198 = 4;
          }
          --v197;
        }
        while ( v10 != v197 );
        goto LABEL_318;
      }
      break;
    case 1u:
      v192 = &v12[(unsigned int)(v11 - 1) >> 3];
      v193 = &v10[v11];
      v194 = ~((_BYTE)v11 + 7) & 7;
      if ( v11 )
      {
        v195 = v192;
        do
        {
          *v193 = ((int)*v195 >> v194) & 1;
          if ( v194 == 7 )
          {
            --v195;
            v194 = 0;
          }
          else
          {
            ++v194;
          }
          --v193;
        }
        while ( v10 != v193 );
LABEL_318:
        v4 = *(_DWORD *)(v2 + 104);
      }
      break;
  }
  result = *(unsigned __int8 *)(a2 + 10);
  *(_BYTE *)(a2 + 9) = 8;
  *(_BYTE *)(a2 + 11) = 8 * result;
  *(_DWORD *)(a2 + 4) = result * v11;
  if ( (v4 & 1) != 0 )
  {
LABEL_37:
    result = (int)png_do_bgr((int *)a2, (char *)(*(_DWORD *)(v2 + 252) + 1));
    v4 = *(_DWORD *)(v2 + 104);
    if ( (v4 & 0x8000) == 0 )
      goto LABEL_27;
    goto LABEL_38;
  }
LABEL_26:
  if ( (v4 & 0x8000) == 0 )
    goto LABEL_27;
LABEL_38:
  v13 = *(_WORD *)(v2 + 292);
  v14 = *(_DWORD *)(v2 + 252);
  v15 = *(_BYTE *)(a2 + 8);
  v413 = v13;
  v391 = *(_DWORD *)(v2 + 100);
  result = v14 + 1;
  v371 = *(_DWORD *)a2;
  if ( v15 )
  {
    if ( v15 == 2 )
    {
      v99 = *(_BYTE *)(a2 + 9);
      if ( v99 == 8 )
      {
        v162 = (_BYTE *)(3 * v371 + result);
        v163 = &v162[v371];
        if ( (v391 & 0x80u) == 0 )
        {
          if ( v371 )
          {
            v308 = &v163[-4 * v371];
            do
            {
              v309 = *(v162 - 1);
              v162 -= 3;
              v163 -= 4;
              v163[3] = v309;
              v163[2] = v162[1];
              v163[1] = *v162;
              *v163 = v13;
            }
            while ( v162 != v308 );
            v4 = *(_DWORD *)(v2 + 104);
          }
          result = 4 * v371;
          *(_WORD *)(a2 + 10) = 8196;
          *(_DWORD *)(a2 + 4) = 4 * v371;
        }
        else
        {
          if ( v371 > 1 )
          {
            v401 = *(_WORD *)(v2 + 292);
            v164 = &v162[v371];
            v165 = (int)&v162[-3 * v371 + 3];
            do
            {
              *(v164 - 1) = v413;
              v166 = *(v162 - 1);
              v162 -= 3;
              v164 -= 4;
              v164[2] = v166;
              v164[1] = v162[1];
              *v164 = *v162;
            }
            while ( v162 != (_BYTE *)v165 );
            LOBYTE(v13) = v401;
            v163 = &v163[-4 * v371 + 4];
          }
          *(v163 - 1) = v13;
          *(_WORD *)(a2 + 10) = 8196;
          v4 = *(_DWORD *)(v2 + 104);
          result = 4 * v371;
          *(_DWORD *)(a2 + 4) = 4 * v371;
        }
      }
      else
      {
        if ( v99 != 16 )
          goto LABEL_28;
        v100 = (_BYTE *)(result + 6 * v371);
        v101 = &v100[2 * v371];
        v102 = *(_DWORD *)(v2 + 100) & 0x80;
        if ( (v391 & 0x80) != 0 )
        {
          if ( v371 > 1 )
          {
            v103 = &v100[2 * v371];
            v104 = 1;
            v447 = v103;
            do
            {
              *(v103 - 2) = HIBYTE(v13);
              v100 -= 6;
              v103 -= 8;
              v103[7] = v13;
              ++v104;
              v103[5] = v100[5];
              v103[4] = v100[4];
              v103[3] = v100[3];
              v103[2] = v100[2];
              v103[1] = v100[1];
              *v103 = *v100;
            }
            while ( v371 != v104 );
            v101 = &v447[-8 * v371 + 8];
          }
          *(v101 - 1) = v13;
          *(v101 - 2) = HIBYTE(v13);
          *(_WORD *)(a2 + 10) = 16388;
          v4 = *(_DWORD *)(v2 + 104);
          result = 8 * v371;
          *(_DWORD *)(a2 + 4) = 8 * v371;
        }
        else
        {
          if ( v371 )
          {
            do
            {
              LOBYTE(v13) = *(v100 - 1);
              v100 -= 6;
              v101 -= 8;
              ++v102;
              v101[7] = v13;
              v101[6] = v100[4];
              v101[5] = v100[3];
              v101[4] = v100[2];
              v101[3] = v100[1];
              v101[2] = *v100;
              v101[1] = v413;
              *v101 = HIBYTE(v13);
            }
            while ( v371 != v102 );
          }
          *(_WORD *)(a2 + 10) = 16388;
          v4 = *(_DWORD *)(v2 + 104);
          result = 8 * v371;
          *(_DWORD *)(a2 + 4) = 8 * v371;
        }
      }
    }
  }
  else
  {
    v16 = *(_BYTE *)(a2 + 9);
    if ( v16 == 8 )
    {
      v140 = (_BYTE *)(result + v371);
      if ( (v391 & 0x80u) == 0 )
      {
        v149 = &v140[v371];
        if ( v371 )
        {
          do
          {
            --v140;
            v149 -= 2;
            v149[1] = *v140;
            *v149 = v413;
          }
          while ( (_BYTE *)result != v140 );
          v4 = *(_DWORD *)(v2 + 104);
        }
        *(_WORD *)(a2 + 10) = 4098;
        result = 2 * v371;
        *(_DWORD *)(a2 + 4) = 2 * v371;
      }
      else
      {
        v141 = (int)&v140[v371];
        if ( v371 > 1 )
        {
          v398 = &v140[v371];
          v142 = (_BYTE *)(v14 + 2);
          v143 = &v140[v371];
          do
          {
            --v140;
            *(v143 - 1) = v13;
            v143 -= 2;
            *v143 = *v140;
          }
          while ( v142 != v140 );
          v141 = (int)&v398[-2 * v371 + 2];
        }
        *(_BYTE *)(v141 - 1) = v13;
        *(_WORD *)(a2 + 10) = 4098;
        v4 = *(_DWORD *)(v2 + 104);
        result = 2 * v371;
        *(_DWORD *)(a2 + 4) = 2 * v371;
      }
    }
    else
    {
      if ( v16 != 16 )
        goto LABEL_28;
      v17 = (_BYTE *)(2 * v371 + result);
      v18 = &v17[2 * v371];
      v19 = *(_DWORD *)(v2 + 100) & 0x80;
      if ( (v391 & 0x80) != 0 )
      {
        if ( v371 > 1 )
        {
          v20 = &v17[2 * v371];
          v21 = 1;
          v444 = v20;
          do
          {
            v17 -= 2;
            v20 -= 4;
            ++v21;
            v20[3] = v13;
            v20[2] = HIBYTE(v13);
            v20[1] = v17[1];
            *v20 = *v17;
          }
          while ( v371 != v21 );
          v18 = &v444[-4 * v371 + 4];
        }
        *(v18 - 1) = v13;
        *(v18 - 2) = HIBYTE(v13);
        *(_WORD *)(a2 + 10) = 8194;
        v4 = *(_DWORD *)(v2 + 104);
        result = 4 * v371;
        *(_DWORD *)(a2 + 4) = 4 * v371;
      }
      else
      {
        if ( v371 )
        {
          do
          {
            LOBYTE(v13) = *(v17 - 1);
            v17 -= 2;
            v18 -= 4;
            ++v19;
            v18[3] = v13;
            v18[2] = *v17;
            v18[1] = v413;
            *v18 = HIBYTE(v13);
          }
          while ( v371 != v19 );
          v4 = *(_DWORD *)(v2 + 104);
        }
        *(_WORD *)(a2 + 10) = 8194;
        result = 4 * v371;
        *(_DWORD *)(a2 + 4) = 4 * v371;
      }
    }
  }
LABEL_27:
  if ( (v4 & 0x20000) == 0 )
    goto LABEL_28;
  v77 = *(_BYTE *)(a2 + 8);
  result = *(_DWORD *)(v2 + 252) + 1;
  v78 = *(_DWORD *)a2;
  if ( v77 == 6 )
  {
    result += *(_DWORD *)(a2 + 4);
    if ( *(_BYTE *)(a2 + 9) == 8 )
    {
      if ( v78 )
      {
        v217 = 0;
        v218 = *(_DWORD *)a2;
        do
        {
          v219 = *(_BYTE *)(result - 2);
          v220 = *(_BYTE *)(result - 1);
          result -= 4;
          ++v217;
          *(_BYTE *)(result + 3) = v219;
          *(_BYTE *)(result + 2) = *(_BYTE *)(result + 1);
          v221 = *(_BYTE *)result;
          *(_BYTE *)result = v220;
          *(_BYTE *)(result + 1) = v221;
        }
        while ( v218 != v217 );
        goto LABEL_127;
      }
    }
    else if ( v78 )
    {
      v109 = 0;
      v110 = *(_DWORD *)a2;
      do
      {
        v111 = *(_BYTE *)(result - 3);
        v112 = *(_BYTE *)(result - 1);
        result -= 8;
        ++v109;
        v113 = *(_BYTE *)(result + 6);
        *(_BYTE *)(result + 7) = v111;
        *(_BYTE *)(result + 6) = *(_BYTE *)(result + 4);
        *(_BYTE *)(result + 5) = *(_BYTE *)(result + 3);
        *(_BYTE *)(result + 4) = *(_BYTE *)(result + 2);
        *(_BYTE *)(result + 3) = *(_BYTE *)(result + 1);
        *(_BYTE *)(result + 2) = *(_BYTE *)result;
        *(_BYTE *)(result + 1) = v112;
        *(_BYTE *)result = v113;
      }
      while ( v110 != v109 );
      goto LABEL_127;
    }
  }
  else
  {
    if ( v77 != 4 )
      goto LABEL_28;
    result += *(_DWORD *)(a2 + 4);
    if ( *(_BYTE *)(a2 + 9) != 8 )
    {
      if ( !v78 )
        goto LABEL_28;
      v79 = 0;
      v80 = *(_DWORD *)a2;
      do
      {
        v81 = *(_BYTE *)(result - 3);
        v82 = *(_BYTE *)(result - 1);
        result -= 4;
        ++v79;
        v83 = *(_BYTE *)(result + 2);
        *(_BYTE *)(result + 3) = v81;
        *(_BYTE *)(result + 2) = *(_BYTE *)result;
        *(_BYTE *)(result + 1) = v82;
        *(_BYTE *)result = v83;
      }
      while ( v80 != v79 );
      goto LABEL_127;
    }
    if ( v78 )
    {
      v150 = 0;
      v151 = *(_DWORD *)a2;
      do
      {
        v152 = *(_BYTE *)(result - 1);
        result -= 2;
        ++v150;
        *(_BYTE *)(result + 1) = *(_BYTE *)result;
        *(_BYTE *)result = v152;
      }
      while ( v151 != v150 );
LABEL_127:
      v4 = *(_DWORD *)(v2 + 104);
    }
  }
LABEL_28:
  if ( (v4 & 0x10) != 0 )
    return png_do_swap(a2, *(_DWORD *)(v2 + 252) + 1);
  return result;
}

//----- (00438CC0) --------------------------------------------------------
unsigned int __cdecl png_do_strip_channel(int a1, _BYTE *a2, int a3)
{
  int v3; // edx
  char v4; // cl
  unsigned int result; // eax
  char v6; // cl
  char *v7; // esi
  _BYTE *v8; // edi
  int v9; // ecx
  _BYTE *v10; // ebp
  char *v11; // ecx
  char v12; // dl
  bool v13; // zf
  char v14; // cl
  char *v15; // esi
  _BYTE *v16; // edi
  _BYTE *v17; // ebp
  char *v18; // ecx
  char v19; // dl
  char *v20; // edi
  _BYTE *v21; // ebp
  _BYTE *v22; // esi
  char *v23; // ecx
  char v24; // dl
  char *v25; // ebp
  _BYTE *v26; // edi
  _BYTE *v27; // ecx
  char *v28; // esi
  char v29; // dl

  v3 = a1;
  v4 = *(_BYTE *)(a1 + 10);
  result = (unsigned int)&a2[*(_DWORD *)(a1 + 4)];
  if ( v4 == 2 )
  {
    v14 = *(_BYTE *)(a1 + 9);
    if ( v14 == 8 )
    {
      v20 = a2 + 1;
      if ( a3 )
      {
        v21 = a2;
        v9 = 0;
      }
      else
      {
        v21 = a2 + 1;
        v9 = 1;
        v20 = a2 + 2;
      }
      if ( result > (unsigned int)v20 )
      {
        v22 = v21;
        v23 = v20;
        do
        {
          v24 = *v23;
          ++v22;
          v23 += 2;
          *(v22 - 1) = v24;
        }
        while ( result > (unsigned int)v23 );
        v3 = a1;
        result = (result - 1 - (unsigned int)v20) >> 1;
        v9 = &v21[result + 1] - a2;
      }
      *(_BYTE *)(v3 + 11) = 8;
    }
    else
    {
      if ( v14 != 16 )
        return result;
      v15 = a2 + 2;
      if ( a3 )
      {
        v16 = a2;
        v9 = 0;
      }
      else
      {
        v16 = a2 + 2;
        v9 = 2;
        v15 = a2 + 4;
      }
      if ( result > (unsigned int)v15 )
      {
        v17 = v16;
        v18 = v15;
        do
        {
          v19 = *v18;
          v17 += 2;
          v18 += 4;
          *(v17 - 2) = v19;
          *(v17 - 1) = *(v18 - 3);
        }
        while ( (unsigned int)v18 < result );
        v3 = a1;
        result = (result - 1 - (unsigned int)v15) >> 2;
        v9 = &v16[2 * result + 2] - a2;
      }
      *(_BYTE *)(v3 + 11) = 16;
    }
    v13 = *(_BYTE *)(v3 + 8) == 4;
    *(_BYTE *)(v3 + 10) = 1;
    if ( v13 )
      *(_BYTE *)(v3 + 8) = 0;
  }
  else
  {
    if ( v4 != 4 )
      return result;
    v6 = *(_BYTE *)(a1 + 9);
    if ( v6 == 8 )
    {
      if ( a3 )
      {
        v25 = a2 + 1;
        v26 = a2;
        v9 = 0;
      }
      else
      {
        v25 = a2 + 4;
        v26 = a2 + 3;
        v9 = 3;
      }
      if ( (unsigned int)v25 < result )
      {
        v27 = v26;
        v28 = v25;
        do
        {
          v29 = *v28;
          v27 += 3;
          v28 += 4;
          *(v27 - 3) = v29;
          *(v27 - 2) = *(v28 - 3);
          *(v27 - 1) = *(v28 - 2);
        }
        while ( (unsigned int)v28 < result );
        v3 = a1;
        result = (result - 1 - (unsigned int)v25) >> 2;
        v9 = &v26[3 * result + 3] - a2;
      }
      *(_BYTE *)(v3 + 11) = 24;
    }
    else
    {
      if ( v6 != 16 )
        return result;
      if ( a3 )
      {
        v7 = a2 + 2;
        v8 = a2;
        v9 = 0;
      }
      else
      {
        v7 = a2 + 8;
        v8 = a2 + 6;
        v9 = 6;
      }
      if ( result > (unsigned int)v7 )
      {
        v10 = v8;
        v11 = v7;
        do
        {
          v12 = *v11;
          v10 += 6;
          v11 += 8;
          *(v10 - 6) = v12;
          *(v10 - 5) = *(v11 - 7);
          *(v10 - 4) = *(v11 - 6);
          *(v10 - 3) = *(v11 - 5);
          *(v10 - 2) = *(v11 - 4);
          *(v10 - 1) = *(v11 - 3);
        }
        while ( result > (unsigned int)v11 );
        v3 = a1;
        result = 3 * ((result - 1 - (unsigned int)v7) >> 3) + 3;
        v9 = &v8[2 * result] - a2;
      }
      *(_BYTE *)(v3 + 11) = 48;
    }
    v13 = *(_BYTE *)(v3 + 8) == 6;
    *(_BYTE *)(v3 + 10) = 3;
    if ( v13 )
      *(_BYTE *)(v3 + 8) = 2;
  }
  *(_DWORD *)(v3 + 4) = v9;
  return result;
}

//----- (00438EF0) --------------------------------------------------------
int __cdecl png_do_swap(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  char v4; // bl

  result = a1;
  if ( *(_BYTE *)(a1 + 9) == 16 )
  {
    v3 = *(unsigned __int8 *)(a1 + 10) * *(_DWORD *)a1;
    if ( v3 )
    {
      for ( result = 0; result != v3; ++result )
      {
        v4 = *(_BYTE *)(a2 + 2 * result + 1);
        *(_BYTE *)(a2 + 2 * result + 1) = *(_BYTE *)(a2 + 2 * result);
        *(_BYTE *)(a2 + 2 * result) = v4;
      }
    }
  }
  return result;
}

//----- (00438F30) --------------------------------------------------------
void __cdecl __noreturn png_err(int a1)
{
  void (__cdecl *v1)(int, void *); // eax

  if ( a1 )
  {
    v1 = *(void (__cdecl **)(int, void *))(a1 + 76);
    if ( v1 )
      v1(a1, &unk_5109FC);
  }
  png_longjmp(a1, 1);
}

//----- (00438F60) --------------------------------------------------------
unsigned int __usercall png_exp@<eax>(int a1@<eax>)
{
  unsigned int v2; // ebx
  unsigned int v3; // edx

  if ( (unsigned int)(a1 - 1) > 0xFFFFE )
    return -(a1 <= 0);
  v2 = png_32bit_exp[(a1 >> 12) & 0xF];
  v3 = HIWORD(v2);
  if ( (a1 & 0x800) != 0 )
  {
    v2 -= (44938 * v3 + 16) >> 5;
    v3 = HIWORD(v2);
  }
  if ( (a1 & 0x400) != 0 )
  {
    v2 -= (45181 * v3 + 32) >> 6;
    v3 = HIWORD(v2);
  }
  if ( (a1 & 0x200) != 0 )
  {
    v2 -= (45303 * v3 + 64) >> 7;
    v3 = HIWORD(v2);
  }
  if ( (a1 & 0x100) != 0 )
  {
    v2 -= (45365 * v3 + 128) >> 8;
    v3 = HIWORD(v2);
  }
  if ( (a1 & 0x80u) != 0 )
  {
    v2 -= (45395 * v3 + 256) >> 9;
    v3 = HIWORD(v2);
  }
  if ( (a1 & 0x40) != 0 )
  {
    v2 -= (45410 * v3 + 512) >> 10;
    v3 = HIWORD(v2);
  }
  return (v2 - ((355 * (a1 & 0x3F) * v3 + 256) >> 9)) >> SBYTE2(a1);
}
// 514C60: using guessed type int png_32bit_exp[16];

//----- (00439050) --------------------------------------------------------
void __cdecl png_free(void *Block, void *a2)
{
  if ( Block )
  {
    if ( a2 )
      free(a2);
  }
}

//----- (00439080) --------------------------------------------------------
_DWORD *__cdecl png_free_buffer_list(void *Block, _DWORD **a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ebx

  result = *a2;
  if ( *a2 )
  {
    *a2 = 0;
    do
    {
      v3 = (_DWORD *)*result;
      png_free(Block, result);
      result = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (004390C0) --------------------------------------------------------
void __cdecl png_free_data(void *Block, int a2, int a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  void *v6; // eax

  v4 = a3;
  if ( !Block || !a2 )
    return;
  v5 = *(_DWORD *)(a2 + 148);
  if ( ((unsigned __int16)v5 & (unsigned __int16)a3 & 0x2000) != 0 )
  {
    v6 = *(void **)(a2 + 124);
    *(_DWORD *)(a2 + 8) &= ~0x10u;
    png_free(Block, v6);
    v5 = *(_DWORD *)(a2 + 148);
    *(_DWORD *)(a2 + 124) = 0;
    *(_WORD *)(a2 + 22) = 0;
    if ( ((unsigned __int16)v5 & (unsigned __int16)a3 & 0x1000) == 0 )
      goto LABEL_5;
    goto LABEL_9;
  }
  if ( (BYTE1(v5) & BYTE1(a3) & 0x10) != 0 )
  {
LABEL_9:
    png_free(Block, *(void **)(a2 + 16));
    *(_DWORD *)(a2 + 16) = 0;
    *(_WORD *)(a2 + 20) = 0;
    v5 = *(_DWORD *)(a2 + 148);
    *(_DWORD *)(a2 + 8) &= ~8u;
  }
LABEL_5:
  if ( a4 != -1 )
    v4 = a3 & 0xFFFFBDDF;
  *(_DWORD *)(a2 + 148) = v5 & ~v4;
}

//----- (00439180) --------------------------------------------------------
_DWORD *__cdecl png_free_jmpbuf(_DWORD *Block)
{
  _DWORD *result; // eax
  _DWORD *v2; // eax
  void *v3; // [esp+1Ch] [ebp-4Ch]
  char v4[72]; // [esp+20h] [ebp-48h] BYREF

  result = Block;
  if ( Block )
  {
    v2 = (_DWORD *)Block[17];
    v3 = v2;
    if ( v2 && Block[18] && Block != v2 && !_setjmp3(v4, 0) )
    {
      Block[17] = v4;
      Block[18] = 0;
      Block[16] = longjmp;
      png_free(Block, v3);
    }
    result = Block;
    Block[18] = 0;
    Block[17] = 0;
    Block[16] = 0;
  }
  return result;
}
// 424E70: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);

//----- (00439210) --------------------------------------------------------
unsigned int __cdecl png_gamma_16bit_correct(unsigned int a1, int a2)
{
  unsigned int result; // eax
  int v3; // edx
  int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  unsigned int v11; // eax
  int v12; // [esp+10h] [ebp-8h] BYREF

  result = a1;
  if ( a1 - 1 <= 0xFFFD )
  {
    if ( BYTE1(a1) )
    {
      v3 = 4;
      v4 = 0;
    }
    else
    {
      result = a1 << 8;
      v3 = 12;
      v4 = 8;
    }
    if ( (result & 0xF000) == 0 )
    {
      result *= 16;
      v4 = v3;
    }
    if ( (result & 0xC000) == 0 )
    {
      v4 += 2;
      result *= 4;
    }
    if ( (result & 0x8000) == 0 )
    {
      ++v4;
      result *= 2;
    }
    v5 = ((unsigned int)(dword_514AA0[result >> 8] + 8) >> 4) + (v4 << 28);
    v6 = ((result << 16) + (result >> 9)) / (result >> 8) - 0x1000000;
    if ( v6 > 0x10000 )
      v7 = v5 - ((23499 * v6 - 1540029952) >> 10);
    else
      v7 = ((-23591 * v6 + 1546060288) >> 10) + v5;
    v8 = (v7 + 2048) >> 12;
    if ( v8 && a2 )
    {
      v9 = png_muldiv_part_3(&v12, a2, v8, 100000);
      result = 0;
      if ( !v9 )
        return result;
      v10 = v12;
    }
    else
    {
      v10 = 0;
    }
    v11 = png_exp(v10);
    return (v11 + 0x7FFF - HIWORD(v11)) >> 16;
  }
  return result;
}
// 514AA0: using guessed type int dword_514AA0[80];

//----- (00439320) --------------------------------------------------------
unsigned int __cdecl png_gamma_8bit_correct(unsigned int a1, int a2)
{
  unsigned int result; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  unsigned int v8; // eax
  int v9; // [esp+10h] [ebp-4h] BYREF

  result = a1;
  if ( a1 - 1 <= 0xFD )
  {
    if ( (a1 & 0xF0) != 0 )
    {
      v3 = 2;
      v4 = 0;
    }
    else
    {
      result = 16 * a1;
      v3 = 6;
      v4 = 4;
    }
    if ( (result & 0xC0) == 0 )
    {
      result *= 4;
      v4 = v3;
    }
    if ( (result & 0x80u) == 0 )
    {
      ++v4;
      result *= 2;
    }
    v5 = (v4 << 16) + ((unsigned int)(dword_514AA0[result] + 0x8000) >> 16);
    if ( v5 && a2 )
    {
      v6 = png_muldiv_part_3(&v9, a2, v5, 100000);
      result = 0;
      if ( !v6 )
        return result;
      v7 = v9;
    }
    else
    {
      v7 = 0;
    }
    v8 = png_exp(v7);
    return (v8 + 0x7FFFFF - (v8 >> 8)) >> 24;
  }
  return result;
}
// 514AA0: using guessed type int dword_514AA0[80];

//----- (004393D0) --------------------------------------------------------
unsigned int __cdecl png_gamma_correct(int a1, unsigned int a2, int a3)
{
  unsigned int result; // eax
  unsigned int v4; // edx
  int v5; // edx
  int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  unsigned int v19; // eax
  int v20[2]; // [esp+10h] [ebp-8h] BYREF

  result = a2;
  v4 = a2 - 1;
  if ( *(_BYTE *)(a1 + 282) == 8 )
  {
    if ( v4 > 0xFD )
      return (unsigned __int8)a2;
    if ( (a2 & 0xF0) != 0 )
    {
      v14 = 2;
      v15 = 0;
    }
    else
    {
      result = 16 * a2;
      v14 = 6;
      v15 = 4;
    }
    if ( (result & 0xC0) == 0 )
    {
      result *= 4;
      v15 = v14;
    }
    if ( (result & 0x80u) == 0 )
    {
      ++v15;
      result *= 2;
    }
    v16 = ((unsigned int)(dword_514AA0[result] + 0x8000) >> 16) + (v15 << 16);
    if ( a3 && v16 )
    {
      v17 = png_muldiv_part_3(v20, a3, v16, 100000);
      result = 0;
      if ( !v17 )
        return result;
      v18 = v20[0];
    }
    else
    {
      v18 = 0;
    }
    v19 = png_exp(v18);
    return (v19 + 0x7FFFFF - (v19 >> 8)) >> 24;
  }
  if ( v4 > 0xFFFD )
    return result;
  if ( BYTE1(a2) )
  {
    v5 = 4;
    v6 = 0;
  }
  else
  {
    result = a2 << 8;
    v5 = 12;
    v6 = 8;
  }
  if ( (result & 0xF000) == 0 )
  {
    result *= 16;
    v6 = v5;
  }
  if ( (result & 0xC000) == 0 )
  {
    v6 += 2;
    result *= 4;
  }
  if ( (result & 0x8000) == 0 )
  {
    ++v6;
    result *= 2;
  }
  v7 = ((unsigned int)(dword_514AA0[result >> 8] + 8) >> 4) + (v6 << 28);
  v8 = ((result << 16) + (result >> 9)) / (result >> 8) - 0x1000000;
  if ( v8 > 0x10000 )
    v9 = v7 - ((23499 * v8 - 1540029952) >> 10);
  else
    v9 = ((-23591 * v8 + 1546060288) >> 10) + v7;
  v10 = (v9 + 2048) >> 12;
  if ( a3 && v10 )
  {
    v11 = png_muldiv_part_3(v20, a3, v10, 100000);
    result = 0;
    if ( !v11 )
      return result;
    v12 = v20[0];
  }
  else
  {
    v12 = 0;
  }
  v13 = png_exp(v12);
  return (v13 + 0x7FFF - HIWORD(v13)) >> 16;
}
// 514AA0: using guessed type int dword_514AA0[80];

//----- (004395C0) --------------------------------------------------------
BOOL __cdecl png_gamma_significant(int a1)
{
  return (unsigned int)(a1 - 95000) > 0x2710;
}

//----- (004395E0) --------------------------------------------------------
int __cdecl png_get_IHDR(
        int a1,
        int a2,
        _DWORD *a3,
        int *a4,
        int *a5,
        unsigned int *a6,
        int *a7,
        unsigned int *a8,
        unsigned int *a9)
{
  int v9; // ecx
  int v10; // ebx
  unsigned int v11; // esi
  unsigned int v12; // edi
  unsigned int v13; // ebp
  int v14; // eax
  unsigned int v16; // [esp+2Ch] [ebp-20h]

  if ( !a1 || !a2 )
    return 0;
  v16 = *(_DWORD *)a2;
  if ( a3 )
    *a3 = *(_DWORD *)a2;
  v9 = *(_DWORD *)(a2 + 4);
  if ( a4 )
    *a4 = v9;
  v10 = *(unsigned __int8 *)(a2 + 24);
  if ( a5 )
    *a5 = v10;
  v11 = *(unsigned __int8 *)(a2 + 25);
  if ( a6 )
    *a6 = v11;
  v12 = *(unsigned __int8 *)(a2 + 26);
  if ( a8 )
    *a8 = v12;
  v13 = *(unsigned __int8 *)(a2 + 27);
  if ( a9 )
    *a9 = v13;
  v14 = *(unsigned __int8 *)(a2 + 28);
  if ( a7 )
    *a7 = v14;
  png_check_IHDR(a1, v16, v9, v10, v11, v14, __SPAIR64__(v13, v12));
  return 1;
}

//----- (004396B0) --------------------------------------------------------
int __cdecl png_get_PLTE(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 8) == 0 || !a3 )
    return 0;
  *a3 = *(_DWORD *)(a2 + 16);
  *a4 = *(unsigned __int16 *)(a2 + 20);
  return 8;
}

//----- (004396F0) --------------------------------------------------------
int __cdecl png_get_bKGD(int a1, int a2, _DWORD *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 0x20) == 0 || !a3 )
    return 0;
  *a3 = a2 + 138;
  return 32;
}

//----- (00439730) --------------------------------------------------------
int __cdecl png_get_cHRM_XYZ_fixed(
        int a1,
        int a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        _DWORD *a9,
        _DWORD *a10,
        _DWORD *a11)
{
  int result; // eax

  result = 0;
  if ( a1 && a2 && (*(_BYTE *)(a2 + 114) & 2) != 0 )
  {
    if ( a3 )
      *a3 = *(_DWORD *)(a2 + 76);
    if ( a4 )
      *a4 = *(_DWORD *)(a2 + 80);
    if ( a5 )
      *a5 = *(_DWORD *)(a2 + 84);
    if ( a6 )
      *a6 = *(_DWORD *)(a2 + 88);
    if ( a7 )
      *a7 = *(_DWORD *)(a2 + 92);
    if ( a8 )
      *a8 = *(_DWORD *)(a2 + 96);
    if ( a9 )
      *a9 = *(_DWORD *)(a2 + 100);
    if ( a10 )
      *a10 = *(_DWORD *)(a2 + 104);
    result = 4;
    if ( a11 )
      *a11 = *(_DWORD *)(a2 + 108);
  }
  return result;
}

//----- (00439800) --------------------------------------------------------
int __cdecl png_get_cHRM_fixed(
        int a1,
        int a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        _DWORD *a9,
        _DWORD *a10)
{
  int result; // eax

  result = 0;
  if ( a1 && a2 && (*(_BYTE *)(a2 + 114) & 2) != 0 )
  {
    if ( a3 )
      *a3 = *(_DWORD *)(a2 + 68);
    if ( a4 )
      *a4 = *(_DWORD *)(a2 + 72);
    if ( a5 )
      *a5 = *(_DWORD *)(a2 + 44);
    if ( a6 )
      *a6 = *(_DWORD *)(a2 + 48);
    if ( a7 )
      *a7 = *(_DWORD *)(a2 + 52);
    if ( a8 )
      *a8 = *(_DWORD *)(a2 + 56);
    if ( a9 )
      *a9 = *(_DWORD *)(a2 + 60);
    result = 4;
    if ( a10 )
      *a10 = *(_DWORD *)(a2 + 64);
  }
  return result;
}

//----- (004398C0) --------------------------------------------------------
int __cdecl png_get_channels(int a1, int a2)
{
  if ( a1 && a2 )
    return *(unsigned __int8 *)(a2 + 29);
  else
    return 0;
}

//----- (004398E0) --------------------------------------------------------
int __cdecl png_get_compression_buffer_size(int a1)
{
  if ( !a1 )
    return 0;
  if ( *(char *)(a1 + 97) >= 0 )
    return *(_DWORD *)(a1 + 172);
  return *(_DWORD *)(a1 + 436);
}

//----- (00439910) --------------------------------------------------------
const char *png_get_copyright()
{
  return "\n"
         "libpng version 1.6.34 - September 29, 2017\n"
         "Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson\n"
         "Copyright (c) 1996-1997 Andreas Dilger\n"
         "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n";
}

//----- (00439920) --------------------------------------------------------
int __cdecl png_get_error_ptr(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 80);
  else
    return 0;
}

//----- (00439940) --------------------------------------------------------
int __cdecl png_get_gAMA_fixed(int a1, int a2, _DWORD *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 114) & 1) == 0 || !a3 )
    return 0;
  *a3 = *(_DWORD *)(a2 + 40);
  return 1;
}

//----- (00439970) --------------------------------------------------------
const char *png_get_header_ver()
{
  return "1.6.34";
}

//----- (00439980) --------------------------------------------------------
const char *png_get_header_version()
{
  return " libpng version 1.6.34 - September 29, 2017\n\n";
}

//----- (00439990) --------------------------------------------------------
int __cdecl png_get_io_ptr(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 92);
  else
    return 0;
}

//----- (004399B0) --------------------------------------------------------
const char *png_get_libpng_ver()
{
  return "1.6.34";
}

//----- (004399C0) --------------------------------------------------------
int __cdecl png_get_rgb_to_gray_status(int a1)
{
  int result; // eax

  result = 0;
  if ( a1 )
    return *(unsigned __int8 *)(a1 + 392);
  return result;
}

//----- (004399E0) --------------------------------------------------------
int __cdecl png_get_rowbytes(int a1, int a2)
{
  if ( a1 && a2 )
    return *(_DWORD *)(a2 + 12);
  else
    return 0;
}

//----- (00439A00) --------------------------------------------------------
int __cdecl png_get_sBIT(int a1, int a2, _DWORD *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 2) == 0 || !a3 )
    return 0;
  *a3 = a2 + 116;
  return 2;
}

//----- (00439A30) --------------------------------------------------------
int __cdecl png_get_sRGB(int a1, int a2, _DWORD *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 9) & 8) == 0 || !a3 )
    return 0;
  *a3 = *(unsigned __int16 *)(a2 + 112);
  return 2048;
}

//----- (00439A70) --------------------------------------------------------
int __cdecl png_get_signature(int a1, int a2)
{
  if ( a1 && a2 )
    return a2 + 32;
  else
    return 0;
}

//----- (00439A90) --------------------------------------------------------
int __cdecl png_get_tRNS(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int result; // eax

  if ( !a1 || !a2 )
    return 0;
  result = *(_DWORD *)(a2 + 8) & 0x10;
  if ( result )
  {
    result = 0;
    if ( *(_BYTE *)(a2 + 25) == 3 )
    {
      if ( a3 )
      {
        *a3 = *(_DWORD *)(a2 + 124);
        result = 16;
      }
      if ( a5 )
        *a5 = a2 + 128;
    }
    else
    {
      if ( a5 )
      {
        *a5 = a2 + 128;
        result = 16;
      }
      if ( a3 )
        *a3 = 0;
    }
    if ( a4 )
    {
      *a4 = *(unsigned __int16 *)(a2 + 22);
      return 16;
    }
  }
  return result;
}

//----- (00439B30) --------------------------------------------------------
int __cdecl png_get_uint_31(int a1, unsigned __int8 *a2)
{
  int result; // eax

  result = (a2[2] << 8) + a2[3] + (*a2 << 24) + (a2[1] << 16);
  if ( result < 0 )
    png_err(a1);
  return result;
}

//----- (00439B70) --------------------------------------------------------
int __cdecl png_get_valid(int a1, int a2, int a3)
{
  if ( a1 && a2 )
    return *(_DWORD *)(a2 + 8) & a3;
  else
    return 0;
}

//----- (00439BA0) --------------------------------------------------------
int __cdecl png_handle_IEND(int a1, int a2, unsigned int a3)
{
  int result; // eax

  if ( (*(_DWORD *)(a1 + 96) & 5) != 5 )
    png_err(a1);
  *(_DWORD *)(a1 + 96) |= 0x18u;
  result = png_crc_finish(a1, a3);
  if ( a3 )
    return png_chunk_benign_error(a1);
  return result;
}

//----- (00439C00) --------------------------------------------------------
void __cdecl png_handle_IHDR(int a1, int a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  int v5; // edx
  unsigned __int8 v6; // di
  unsigned __int8 v7; // al
  char v8; // di
  unsigned __int8 v9; // bp
  unsigned int v10; // eax
  unsigned __int8 v11; // [esp+30h] [ebp-3Ch]
  unsigned __int8 v12; // [esp+34h] [ebp-38h]
  unsigned __int8 v13; // [esp+38h] [ebp-34h]
  unsigned __int8 v14; // [esp+3Ch] [ebp-30h]
  char v15[8]; // [esp+43h] [ebp-29h] BYREF
  __int16 v16; // [esp+4Bh] [ebp-21h]
  unsigned __int8 v17; // [esp+4Dh] [ebp-1Fh]
  unsigned __int8 v18; // [esp+4Eh] [ebp-1Eh]
  unsigned __int8 v19; // [esp+4Fh] [ebp-1Dh]

  v3 = *(_DWORD *)(a1 + 96);
  if ( (v3 & 1) != 0
    || a3 != 13
    || (*(_DWORD *)(a1 + 96) = v3 | 1,
        png_read_data(a1),
        png_calculate_crc(a1, v15, 0xDu),
        png_crc_finish_constprop_7(a1),
        v4 = ((unsigned __int8)v15[0] << 24)
           + ((unsigned __int8)v15[1] << 16)
           + (unsigned __int8)v15[3]
           + ((unsigned __int8)v15[2] << 8),
        v4 < 0)
    || (v5 = (unsigned __int8)v15[7]
           + ((unsigned __int8)v15[4] << 24)
           + ((unsigned __int8)v15[5] << 16)
           + ((unsigned __int8)v15[6] << 8),
        v5 < 0) )
  {
    png_err(a1);
  }
  v6 = v16;
  *(_DWORD *)(a1 + 216) = v4;
  *(_DWORD *)(a1 + 220) = v5;
  v7 = v6;
  v11 = v6;
  *(_WORD *)(a1 + 281) = __ROL2__(v16, 8);
  v8 = HIBYTE(v16);
  v9 = HIBYTE(v16);
  v12 = v17;
  v13 = v18;
  v14 = v19;
  *(_BYTE *)(a1 + 278) = v19;
  *(_BYTE *)(a1 + 404) = v17;
  switch ( v8 )
  {
    case 4:
      v7 *= 2;
      *(_BYTE *)(a1 + 285) = 2;
      *(_BYTE *)(a1 + 284) = v7;
      if ( v7 <= 7u )
        goto LABEL_9;
      goto LABEL_11;
    case 6:
      v7 *= 4;
      *(_BYTE *)(a1 + 285) = 4;
      *(_BYTE *)(a1 + 284) = v7;
      if ( v7 <= 7u )
        goto LABEL_9;
      goto LABEL_11;
    case 2:
      v7 *= 3;
      *(_BYTE *)(a1 + 285) = 3;
      *(_BYTE *)(a1 + 284) = v7;
      if ( v7 <= 7u )
        goto LABEL_9;
LABEL_11:
      v10 = v4 * (v7 >> 3);
      goto LABEL_10;
  }
  *(_BYTE *)(a1 + 285) = 1;
  *(_BYTE *)(a1 + 284) = v7;
  if ( v7 > 7u )
    goto LABEL_11;
LABEL_9:
  v10 = (v4 * (unsigned int)v7 + 7) >> 3;
LABEL_10:
  *(_DWORD *)(a1 + 232) = v10;
  png_set_IHDR(a1, a2, v4, v5, v11, v9, v14, v12, v13);
}

//----- (00439E10) --------------------------------------------------------
void __cdecl png_handle_PLTE(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // eax
  char v4; // al
  signed int v5; // edx
  char v6; // cl
  char *v7; // ebp
  char *v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // [esp+18h] [ebp-334h]
  unsigned __int8 v12; // [esp+2Ch] [ebp-320h] BYREF
  unsigned __int8 v13; // [esp+2Dh] [ebp-31Fh]
  unsigned __int8 v14; // [esp+2Eh] [ebp-31Eh]
  unsigned __int8 v15; // [esp+2Fh] [ebp-31Dh]
  char v16[796]; // [esp+30h] [ebp-31Ch] BYREF

  v3 = a1[24];
  if ( (v3 & 1) == 0 || (v3 & 2) != 0 )
    goto LABEL_33;
  if ( (v3 & 4) != 0 || (a1[24] = v3 | 2, v4 = *((_BYTE *)a1 + 281), (v4 & 2) == 0) )
  {
    png_crc_finish((int)a1, a3);
    png_chunk_benign_error((int)a1);
    return;
  }
  if ( v4 != 3 )
  {
    png_crc_finish((int)a1, a3);
    return;
  }
  if ( a3 > 0x300 || (v5 = a3 / 3, a3 != 3 * (a3 / 3)) )
  {
    png_crc_finish((int)a1, a3);
    if ( *((_BYTE *)a1 + 281) != 3 )
    {
      png_chunk_benign_error((int)a1);
      return;
    }
    goto LABEL_33;
  }
  v6 = *((_BYTE *)a1 + 282);
  if ( 1 << v6 <= v5 )
    v5 = 1 << v6;
  v11 = v5;
  if ( v5 <= 0 )
    goto LABEL_36;
  v7 = v16;
  v8 = &v16[3 * v5];
  do
  {
    v7 += 3;
    png_read_data((int)a1);
    png_calculate_crc((int)a1, &v12, 3u);
    *(v7 - 3) = v12;
    *(v7 - 2) = v13;
    *(v7 - 1) = v14;
  }
  while ( v8 != v7 );
  if ( *((_BYTE *)a1 + 281) == 3 )
  {
LABEL_36:
    png_crc_finish((int)a1, a3 - 3 * v11);
  }
  else
  {
    if ( (*((_BYTE *)a1 + 247) & 0x20) != 0 )
    {
      if ( (a1[25] & 0x300) == 768 )
      {
LABEL_16:
        png_read_data((int)a1);
        goto LABEL_17;
      }
    }
    else if ( (a1[25] & 0x800) != 0 )
    {
      goto LABEL_16;
    }
    png_read_data((int)a1);
    if ( (v12 << 24) + (v13 << 16) + v15 + (v14 << 8) != a1[66] )
    {
      v10 = a1[25];
      if ( (v10 & 0x100) == 0 )
      {
        if ( (v10 & 0x200) != 0 )
          return;
LABEL_33:
        png_err((int)a1);
      }
    }
  }
LABEL_17:
  png_set_PLTE(a1, a2, v16, v11);
  if ( *((_WORD *)a1 + 137) )
  {
    *((_WORD *)a1 + 137) = 0;
    if ( !a2 )
      goto LABEL_22;
  }
  else
  {
    if ( !a2 )
      return;
    v9 = *(_DWORD *)(a2 + 8);
    if ( (v9 & 0x10) == 0 )
      goto LABEL_21;
  }
  *(_WORD *)(a2 + 22) = 0;
  png_chunk_benign_error((int)a1);
  v9 = *(_DWORD *)(a2 + 8);
LABEL_21:
  if ( (v9 & 0x20) != 0 )
LABEL_22:
    png_chunk_benign_error((int)a1);
}

//----- (0043A160) --------------------------------------------------------
int __cdecl png_handle_bKGD(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // esi
  char v5; // dl
  int result; // eax
  char v7; // dl
  unsigned __int16 v8; // dx
  unsigned __int8 *v9; // eax
  unsigned __int8 v10; // [esp+10h] [ebp-2Ch] BYREF
  unsigned __int8 v11; // [esp+11h] [ebp-2Bh]
  unsigned __int8 v12; // [esp+12h] [ebp-2Ah]
  unsigned __int8 v13; // [esp+13h] [ebp-29h]
  unsigned __int8 v14; // [esp+14h] [ebp-28h]
  unsigned __int8 v15; // [esp+15h] [ebp-27h]
  unsigned __int8 v16; // [esp+16h] [ebp-26h] BYREF
  int v17; // [esp+18h] [ebp-24h]
  __int16 v18; // [esp+1Ch] [ebp-20h]
  __int16 v19; // [esp+1Eh] [ebp-1Eh]

  v3 = *(_DWORD *)(a1 + 96);
  v4 = v3 & 1;
  if ( (v3 & 1) == 0 )
    png_err(a1);
  if ( (v3 & 4) != 0 )
    goto LABEL_16;
  v5 = *(_BYTE *)(a1 + 281);
  if ( v5 != 3 )
  {
    if ( !a2 || (*(_BYTE *)(a2 + 8) & 0x20) == 0 )
    {
      v4 = (v5 & 2) == 0 ? 2 : 6;
      goto LABEL_7;
    }
LABEL_16:
    png_crc_finish(a1, a3);
    return png_chunk_benign_error(a1);
  }
  if ( (v3 & 2) == 0 || a2 && (*(_BYTE *)(a2 + 8) & 0x20) != 0 )
    goto LABEL_16;
LABEL_7:
  if ( v4 != a3 )
  {
    png_crc_finish(a1, a3);
    return png_chunk_benign_error(a1);
  }
  png_read_data(a1);
  png_calculate_crc(a1, &v10, v4);
  result = png_crc_finish_constprop_7(a1);
  if ( !result )
  {
    v7 = *(_BYTE *)(a1 + 281);
    if ( v7 == 3 )
    {
      v16 = v10;
      if ( a2 && (v8 = *(_WORD *)(a2 + 20)) != 0 )
      {
        if ( v8 <= v10 )
          return png_chunk_benign_error(a1);
        v9 = (unsigned __int8 *)(*(_DWORD *)(a1 + 268) + 3 * v10);
        LOWORD(v17) = *v9;
        HIWORD(v17) = v9[1];
        v18 = v9[2];
      }
      else
      {
        v17 = 0;
        v18 = 0;
      }
    }
    else
    {
      v16 = 0;
      if ( (v7 & 2) == 0 )
      {
        v19 = v11 + (v10 << 8);
        v18 = v19;
        HIWORD(v17) = v19;
        LOWORD(v17) = v19;
        return png_set_bKGD(a1, a2, (int *)&v16);
      }
      LOWORD(v17) = v11 + (v10 << 8);
      HIWORD(v17) = v13 + (v12 << 8);
      v18 = v15 + (v14 << 8);
    }
    v19 = 0;
    return png_set_bKGD(a1, a2, (int *)&v16);
  }
  return result;
}

//----- (0043A380) --------------------------------------------------------
void __cdecl png_handle_cHRM(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // esi
  int v5; // eax
  int v6; // edx
  bool v7; // sf
  int v8; // eax
  int v9; // edi
  int v10; // edi
  int v11; // edx
  int v12; // ebp
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // edi
  int v17; // edx
  int v18; // edi
  int v19; // eax
  int v20; // eax
  int v21; // edi
  int v22; // edi
  __int16 v23; // ax
  int v24; // [esp+10h] [ebp-6Ch]
  int v25; // [esp+14h] [ebp-68h]
  int v26; // [esp+18h] [ebp-64h]
  int v27; // [esp+1Ch] [ebp-60h]
  int v28[8]; // [esp+20h] [ebp-5Ch] BYREF
  char v29[16]; // [esp+40h] [ebp-3Ch] BYREF
  unsigned __int8 v30; // [esp+50h] [ebp-2Ch]
  unsigned __int8 v31; // [esp+51h] [ebp-2Bh]
  unsigned __int8 v32; // [esp+52h] [ebp-2Ah]
  unsigned __int8 v33; // [esp+53h] [ebp-29h]
  unsigned __int8 v34; // [esp+54h] [ebp-28h]
  unsigned __int8 v35; // [esp+55h] [ebp-27h]
  unsigned __int8 v36; // [esp+56h] [ebp-26h]
  unsigned __int8 v37; // [esp+57h] [ebp-25h]
  unsigned __int8 v38; // [esp+58h] [ebp-24h]
  unsigned __int8 v39; // [esp+59h] [ebp-23h]
  unsigned __int8 v40; // [esp+5Ah] [ebp-22h]
  unsigned __int8 v41; // [esp+5Bh] [ebp-21h]
  unsigned __int8 v42; // [esp+5Ch] [ebp-20h]
  unsigned __int8 v43; // [esp+5Dh] [ebp-1Fh]
  unsigned __int8 v44; // [esp+5Eh] [ebp-1Eh]
  unsigned __int8 v45; // [esp+5Fh] [ebp-1Dh]

  v3 = *(_DWORD *)(a1 + 96);
  if ( (v3 & 1) == 0 )
    png_err(a1);
  if ( (v3 & 6) != 0 )
  {
    png_crc_finish(a1, a3);
    png_chunk_benign_error(a1);
  }
  else if ( a3 == 32 )
  {
    png_read_data(a1);
    png_calculate_crc(a1, v29, 0x20u);
    if ( !png_crc_finish_constprop_7(a1) )
    {
      v4 = -1;
      v5 = (unsigned __int8)v29[3] + ((unsigned __int8)v29[0] << 24) + ((unsigned __int8)v29[1] << 16);
      v6 = (unsigned __int8)v29[2] << 8;
      v7 = v6 + v5 < 0;
      v8 = v6 + v5;
      v27 = v8;
      if ( v7 )
        v8 = -1;
      v28[6] = v8;
      v9 = ((unsigned __int8)v29[6] << 8)
         + (unsigned __int8)v29[7]
         + ((unsigned __int8)v29[4] << 24)
         + ((unsigned __int8)v29[5] << 16);
      v26 = v9;
      if ( v9 < 0 )
        v9 = -1;
      v28[7] = v9;
      v10 = -1;
      v11 = ((unsigned __int8)v29[10] << 8)
          + (unsigned __int8)v29[11]
          + ((unsigned __int8)v29[8] << 24)
          + ((unsigned __int8)v29[9] << 16);
      v25 = v11;
      if ( v11 < 0 )
        v11 = -1;
      v28[0] = v11;
      v12 = (unsigned __int8)v29[14] << 8;
      v13 = (unsigned __int8)v29[15] + ((unsigned __int8)v29[12] << 24) + ((unsigned __int8)v29[13] << 16);
      v7 = v12 + v13 < 0;
      v14 = v12 + v13;
      v24 = v14;
      if ( v7 )
        v14 = -1;
      v28[1] = v14;
      v15 = (v30 << 24) + (v31 << 16) + v33 + (v32 << 8);
      if ( v15 >= 0 )
        v10 = (v30 << 24) + (v31 << 16) + v33 + (v32 << 8);
      v28[2] = v10;
      v16 = -1;
      v17 = (v34 << 24) + (v35 << 16) + v37 + (v36 << 8);
      if ( v17 >= 0 )
        v16 = (v34 << 24) + (v35 << 16) + v37 + (v36 << 8);
      v28[3] = v16;
      v18 = (v38 << 24) + (v39 << 16) + v41;
      v19 = v40 << 8;
      v7 = v18 + v19 < 0;
      v20 = v18 + v19;
      v21 = -1;
      if ( !v7 )
        v21 = v20;
      v28[4] = v21;
      v22 = (v44 << 8) + v45 + (v43 << 16) + (v42 << 24);
      if ( v22 >= 0 )
        v4 = (v44 << 8) + v45 + (v43 << 16) + (v42 << 24);
      v28[5] = v4;
      if ( v20 < 0 || v24 < 0 || v26 < 0 || v27 < 0 || v25 < 0 || v15 < 0 || v17 < 0 || v22 < 0 )
      {
        png_chunk_benign_error(a1);
      }
      else
      {
        v23 = *(_WORD *)(a1 + 534);
        if ( v23 >= 0 )
        {
          if ( (v23 & 0x10) != 0 )
          {
            *(_WORD *)(a1 + 534) = v23 | 0x8000;
            png_colorspace_sync(a1, a2);
            png_chunk_benign_error(a1);
          }
          else
          {
            *(_WORD *)(a1 + 534) = v23 | 0x10;
            png_colorspace_set_chromaticities(a1, a1 + 460, v28, 1);
            png_colorspace_sync(a1, a2);
          }
        }
      }
    }
  }
  else
  {
    png_crc_finish(a1, a3);
    png_chunk_benign_error(a1);
  }
}

//----- (0043A6A0) --------------------------------------------------------
void __cdecl png_handle_gAMA(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  char v5[16]; // [esp+1Ch] [ebp-10h] BYREF

  v3 = *(_DWORD *)(a1 + 96);
  if ( (v3 & 1) == 0 )
    png_err(a1);
  if ( (v3 & 6) != 0 || a3 != 4 )
  {
    png_crc_finish(a1, a3);
    png_chunk_benign_error(a1);
  }
  else
  {
    png_read_data(a1);
    png_calculate_crc(a1, v5, 4u);
    if ( !png_crc_finish_constprop_7(a1) )
    {
      v4 = ((unsigned __int8)v5[0] << 24)
         + ((unsigned __int8)v5[1] << 16)
         + (unsigned __int8)v5[3]
         + ((unsigned __int8)v5[2] << 8);
      if ( v4 < 0 )
        v4 = -1;
      png_colorspace_set_gamma(a1, a1 + 460, v4);
      png_colorspace_sync(a1, a2);
    }
  }
}

//----- (0043A7B0) --------------------------------------------------------
int __cdecl png_handle_sBIT(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int v4; // ebp
  unsigned __int8 v5; // dl
  unsigned __int16 v6; // ax
  int result; // eax
  unsigned __int8 v8; // dl
  unsigned __int16 v9; // dx
  unsigned __int8 v10; // [esp+1Fh] [ebp-2Dh]
  char v11; // [esp+1Fh] [ebp-2Dh]
  int v12; // [esp+2Ch] [ebp-20h] BYREF

  v3 = *(_DWORD *)(a1 + 96);
  if ( (v3 & 1) == 0 )
    png_err(a1);
  if ( (v3 & 6) != 0 || a2 && (*(_BYTE *)(a2 + 8) & 2) != 0 )
  {
    png_crc_finish(a1, a3);
    return png_chunk_benign_error(a1);
  }
  if ( *(_BYTE *)(a1 + 281) == 3 )
  {
    v4 = 3;
    v5 = 8;
    if ( a3 != 3 )
      goto LABEL_26;
  }
  else
  {
    v4 = *(unsigned __int8 *)(a1 + 285);
    v5 = *(_BYTE *)(a1 + 282);
    if ( v4 != a3 )
    {
LABEL_26:
      png_chunk_benign_error(a1);
      return png_crc_finish(a1, a3);
    }
  }
  if ( a3 > 4 )
    goto LABEL_26;
  LOBYTE(v6) = v5;
  HIBYTE(v6) = v5;
  v10 = v5;
  v12 = (v5 << 24) | (v5 << 16) | v6;
  png_read_data(a1);
  png_calculate_crc(a1, &v12, v4);
  result = png_crc_finish_constprop_7(a1);
  if ( result )
    return result;
  v8 = v10;
  if ( !v4 )
    goto LABEL_31;
  if ( !(_BYTE)v12 || v10 < (unsigned __int8)v12 )
    return png_chunk_benign_error(a1);
  if ( v4 == 1 )
  {
LABEL_31:
    v11 = BYTE1(v12);
    goto LABEL_21;
  }
  v11 = BYTE1(v12);
  if ( !BYTE1(v12)
    || v8 < BYTE1(v12)
    || v4 != 2 && (BYTE2(v12) > v8 || !BYTE2(v12) || v4 != 3 && (v8 < HIBYTE(v12) || !HIBYTE(v12))) )
  {
    return png_chunk_benign_error(a1);
  }
LABEL_21:
  if ( (*(_BYTE *)(a1 + 281) & 2) != 0 )
  {
    *(_BYTE *)(a1 + 352) = v12;
    *(_BYTE *)(a1 + 353) = v11;
    *(_BYTE *)(a1 + 354) = BYTE2(v12);
    *(_BYTE *)(a1 + 356) = HIBYTE(v12);
  }
  else
  {
    LOBYTE(v9) = v12;
    HIBYTE(v9) = v12;
    *(_DWORD *)(a1 + 352) = ((unsigned __int8)v12 << 16) | v9 | ((unsigned __int8)v12 << 24);
    *(_BYTE *)(a1 + 356) = v11;
  }
  return png_set_sBIT(a1, a2, (int *)(a1 + 352));
}

//----- (0043AA30) --------------------------------------------------------
void __cdecl png_handle_sRGB(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  __int16 v4; // ax
  char v5[13]; // [esp+1Fh] [ebp-Dh] BYREF

  v3 = *(_DWORD *)(a1 + 96);
  if ( (v3 & 1) == 0 )
    png_err(a1);
  if ( (v3 & 6) != 0 )
  {
    png_crc_finish(a1, a3);
    png_chunk_benign_error(a1);
  }
  else if ( a3 == 1 )
  {
    png_read_data(a1);
    png_calculate_crc(a1, v5, 1u);
    if ( !png_crc_finish_constprop_7(a1) )
    {
      v4 = *(_WORD *)(a1 + 534);
      if ( v4 >= 0 )
      {
        if ( (v4 & 4) != 0 )
        {
          *(_WORD *)(a1 + 534) = v4 | 0x8000;
          png_colorspace_sync(a1, a2);
          png_chunk_benign_error(a1);
        }
        else
        {
          png_colorspace_set_sRGB(a1, a1 + 460, (unsigned __int8)v5[0]);
          png_colorspace_sync(a1, a2);
        }
      }
    }
  }
  else
  {
    png_crc_finish(a1, a3);
    png_chunk_benign_error(a1);
  }
}
// 43AA30: using guessed type char var_D[13];

//----- (0043AB60) --------------------------------------------------------
void __cdecl png_handle_tRNS(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // eax
  char v4; // dl
  __int16 v5; // ax
  __int16 v6; // dx
  __int16 v7; // ax
  __int16 v8; // dx
  __int16 v9; // ax
  __int16 v10; // dx
  unsigned __int8 v11; // [esp+20h] [ebp-11Ch] BYREF
  unsigned __int8 v12; // [esp+21h] [ebp-11Bh]
  unsigned __int8 v13; // [esp+22h] [ebp-11Ah]
  unsigned __int8 v14; // [esp+23h] [ebp-119h]
  unsigned __int8 v15; // [esp+24h] [ebp-118h]
  unsigned __int8 v16; // [esp+25h] [ebp-117h]

  v3 = a1[24];
  if ( (v3 & 1) == 0 )
    png_err((int)a1);
  if ( (v3 & 4) != 0 || a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
    goto LABEL_11;
  v4 = *((_BYTE *)a1 + 281);
  if ( !v4 )
  {
    if ( a3 == 2 )
    {
      png_read_data((int)a1);
      png_calculate_crc((int)a1, &v11, 2u);
      v5 = v11;
      v6 = v12;
      *((_WORD *)a1 + 137) = 1;
      *((_WORD *)a1 + 186) = v6 + (v5 << 8);
      goto LABEL_14;
    }
    goto LABEL_11;
  }
  if ( v4 == 2 )
  {
    if ( a3 == 6 )
    {
      png_read_data((int)a1);
      png_calculate_crc((int)a1, &v11, 6u);
      v7 = v11;
      *((_WORD *)a1 + 137) = 1;
      v8 = v14;
      *((_WORD *)a1 + 183) = v12 + (v7 << 8);
      v9 = v8 + (v13 << 8);
      v10 = v16;
      *((_WORD *)a1 + 184) = v9;
      *((_WORD *)a1 + 185) = v10 + (v15 << 8);
      goto LABEL_14;
    }
LABEL_11:
    png_crc_finish((int)a1, a3);
    png_chunk_benign_error((int)a1);
    return;
  }
  if ( v4 != 3 || (v3 & 2) == 0 || *((unsigned __int16 *)a1 + 136) < a3 || a3 - 1 > 0xFF )
    goto LABEL_11;
  png_read_data((int)a1);
  png_calculate_crc((int)a1, &v11, a3);
  *((_WORD *)a1 + 137) = a3;
LABEL_14:
  if ( png_crc_finish_constprop_7((int)a1) )
    *((_WORD *)a1 + 137) = 0;
  else
    png_set_tRNS(a1, a2, &v11, *((unsigned __int16 *)a1 + 137), (int)(a1 + 91));
}

//----- (0043AE10) --------------------------------------------------------
int __cdecl png_handle_unknown(int a1, int a2, unsigned int a3)
{
  int result; // eax

  result = png_crc_finish(a1, a3);
  if ( (*(_BYTE *)(a1 + 247) & 0x20) == 0 )
    png_err(a1);
  return result;
}

//----- (0043AE40) --------------------------------------------------------
int __usercall png_icc_profile_error_constprop_9@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, char *a4)
{
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // eax
  char *v11; // edx
  unsigned int v12; // eax
  char v14[224]; // [esp+3Ch] [ebp-E0h] BYREF

  if ( a2 )
    *(_WORD *)(a2 + 74) |= 0x8000u;
  v6 = png_safecat((int)v14, 0xC4u, 0, "profile '");
  v7 = png_safecat((int)v14, v6 + 79, v6, "sRGB");
  v8 = png_safecat((int)v14, 0xC4u, v7, "': ");
  v9 = HIBYTE(a3);
  if ( (HIBYTE(a3) - 48 <= 9u || v9 == 32 || (v9 & 0xFFFFFFDF) - 65 <= 0x19)
    && ((unsigned int)BYTE2(a3) - 48 <= 9 || BYTE2(a3) == 32 || (BYTE2(a3) & 0xDFu) - 65 <= 0x19)
    && ((unsigned int)BYTE1(a3) - 48 <= 9 || BYTE1(a3) == 32 || (BYTE1(a3) & 0xDFu) - 65 <= 0x19)
    && ((unsigned int)(unsigned __int8)a3 - 48 <= 9 || (unsigned __int8)a3 == 32 || (a3 & 0xDF) - 65 <= 0x19) )
  {
    v11 = &v14[v8];
    v14[v8] = 39;
    if ( v9 - 32 >= 0x5F )
      LOBYTE(v9) = 63;
    v11[5] = 39;
    v11[1] = v9;
    LOBYTE(v9) = 63;
    if ( (unsigned int)BYTE2(a3) - 32 < 0x5F )
      v9 = HIWORD(a3);
    v11[2] = v9;
    LOBYTE(v9) = 63;
    if ( (unsigned int)BYTE1(a3) - 32 < 0x5F )
      v9 = a3 >> 8;
    v11[3] = v9;
    if ( (unsigned int)(unsigned __int8)a3 - 32 >= 0x5F )
      LOBYTE(a3) = 63;
    v11[4] = a3;
    v12 = v8 + 7;
    v14[v8 + 6] = 58;
    v8 += 8;
    v14[v12] = 32;
  }
  png_safecat((int)v14, 0xC4u, v8, a4);
  png_chunk_report(a1, (int)v14, (a2 != 0) + 1);
  return 0;
}

//----- (0043B030) --------------------------------------------------------
int __cdecl png_image_begin_read_from_file(int *a1, char *FileName)
{
  FILE *v3; // edi
  int init_part_4; // esi
  int v6; // eax
  int *v7; // eax
  char *v8; // [esp+24h] [ebp+8h]

  if ( !a1 )
    return 0;
  if ( a1[1] != 1 )
  {
    v8 = "png_image_begin_read_from_file: incorrect PNG_IMAGE_VERSION";
    return png_image_error(a1, v8);
  }
  if ( !FileName )
  {
    v8 = "png_image_begin_read_from_file: invalid argument";
    return png_image_error(a1, v8);
  }
  v3 = fopen(FileName, "rb");
  if ( !v3 )
  {
    v7 = __errno();
    v8 = strerror(*v7);
    return png_image_error(a1, v8);
  }
  if ( *a1 )
    init_part_4 = png_image_error(a1, "png_image_read: opaque pointer not NULL");
  else
    init_part_4 = png_image_read_init_part_4(a1);
  if ( !init_part_4 )
  {
    fclose(v3);
    return 0;
  }
  v6 = *a1;
  *(_DWORD *)(*(_DWORD *)*a1 + 92) = v3;
  *(_BYTE *)(v6 + 20) |= 2u;
  return png_safe_execute((int)a1, png_image_read_header, (int)a1);
}

//----- (0043B120) --------------------------------------------------------
int __cdecl png_image_begin_read_from_memory(int *a1, int a2, int a3)
{
  int *v5; // eax
  int v6; // eax
  char *v7; // [esp+24h] [ebp+8h]

  if ( !a1 )
    return 0;
  if ( a1[1] != 1 )
  {
    v7 = "png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION";
    return png_image_error(a1, v7);
  }
  if ( !a2 || !a3 )
  {
    v7 = "png_image_begin_read_from_memory: invalid argument";
    return png_image_error(a1, v7);
  }
  if ( !(*a1 ? png_image_error(a1, "png_image_read: opaque pointer not NULL") : png_image_read_init_part_4(a1)) )
    return 0;
  v5 = (int *)*a1;
  v5[3] = a2;
  v5[4] = a3;
  v6 = *v5;
  *(_DWORD *)(v6 + 92) = a1;
  *(_DWORD *)(v6 + 88) = png_image_memory_read;
  return png_safe_execute((int)a1, png_image_read_header, (int)a1);
}

//----- (0043B1D0) --------------------------------------------------------
int __cdecl png_image_begin_read_from_stdio(int *a1, int a2)
{
  int init_part_4; // eax

  if ( !a1 )
    return 0;
  if ( a1[1] != 1 )
    return png_image_error(a1, "png_image_begin_read_from_stdio: incorrect PNG_IMAGE_VERSION");
  if ( !a2 )
    return png_image_error(a1, "png_image_begin_read_from_stdio: invalid argument");
  if ( *a1 )
    init_part_4 = png_image_error(a1, "png_image_read: opaque pointer not NULL");
  else
    init_part_4 = png_image_read_init_part_4(a1);
  if ( !init_part_4 )
    return 0;
  *(_DWORD *)(*(_DWORD *)*a1 + 92) = a2;
  return png_safe_execute((int)a1, png_image_read_header, (int)a1);
}

//----- (0043B270) --------------------------------------------------------
int __cdecl png_image_error(int *a1, char *a2)
{
  int v2; // eax

  png_safecat((int)(a1 + 8), 0x40u, 0, a2);
  v2 = *a1;
  a1[7] |= 2u;
  if ( v2 && !*(_DWORD *)(v2 + 8) )
  {
    png_safe_execute((int)a1, (int (__cdecl *)(int))png_image_free_function, (int)a1);
    *a1 = 0;
  }
  return 0;
}

//----- (0043B2D0) --------------------------------------------------------
int __cdecl png_image_finish_read(int *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  unsigned int v6; // ecx
  unsigned int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // edx
  unsigned int v10; // ecx
  int v11; // eax
  unsigned int v12; // edi
  unsigned int v13; // ecx
  unsigned int i; // eax
  int v15; // eax
  unsigned int j; // eax
  int v17; // [esp+1Ch] [ebp-50h]
  int *v18; // [esp+24h] [ebp-48h] BYREF
  int v19; // [esp+28h] [ebp-44h]
  int v20; // [esp+2Ch] [ebp-40h]
  int v21; // [esp+30h] [ebp-3Ch]
  int v22; // [esp+34h] [ebp-38h]
  int v23[13]; // [esp+38h] [ebp-34h]
  int v24; // [esp+7Ch] [ebp+10h]

  result = 0;
  if ( a1 )
  {
    v6 = a1[1];
    if ( v6 != 1 )
      return png_image_error(a1, "png_image_finish_read: damaged PNG_IMAGE_VERSION");
    v7 = a1[4];
    v8 = 0x7FFFFFFF;
    if ( (v7 & 8) == 0 )
    {
      v6 = (v7 & 3) + 1;
      v8 = 0x7FFFFFFF / v6;
    }
    v9 = a1[2];
    if ( v9 > v8 )
      return png_image_error(a1, "png_image_finish_read: row_stride too large");
    v10 = v9 * v6;
    v11 = v10;
    if ( a4 )
      v11 = a4;
    v24 = v11;
    v12 = abs32(v11);
    if ( !*a1 || !a3 || v12 < v10 )
      return png_image_error(a1, "png_image_finish_read: invalid argument");
    v13 = a1[3];
    if ( (a1[4] & 8) != 0 )
    {
      if ( !is_mul_ok(v12, v13) )
        return png_image_error(a1, "png_image_finish_read: image too large");
      if ( !a1[6] || !a5 )
        return png_image_error(a1, "png_image_finish_read[color-map]: no color-map");
      for ( i = 0; i < 6; ++i )
        v23[i] = 0;
      v19 = a3;
      v20 = v24;
      v18 = a1;
      v21 = a5;
      v22 = a2;
      v15 = png_safe_execute((int)a1, (int (__cdecl *)(int))png_image_read_colormap, (int)&v18);
      if ( v15 )
        v15 = png_safe_execute((int)a1, png_image_read_colormapped, (int)&v18) != 0;
    }
    else
    {
      if ( v13 > 0xFFFFFFFF / (((v7 >> 2) & 1) + 1) / v12 )
        return png_image_error(a1, "png_image_finish_read: image too large");
      for ( j = 0; j < 6; ++j )
        v23[j] = 0;
      v19 = a3;
      v18 = a1;
      v20 = v24;
      v21 = a5;
      v22 = a2;
      v15 = png_safe_execute((int)a1, png_image_read_direct, (int)&v18);
    }
    v17 = v15;
    png_image_free((int)a1);
    return v17;
  }
  return result;
}

//----- (0043B4E0) --------------------------------------------------------
void __cdecl png_image_free(int a1)
{
  if ( a1 && *(_DWORD *)a1 && !*(_DWORD *)(*(_DWORD *)a1 + 8) )
  {
    png_safe_execute(a1, (int (__cdecl *)(int))png_image_free_function, a1);
    *(_DWORD *)a1 = 0;
  }
}

//----- (0043B520) --------------------------------------------------------
int __cdecl png_image_free_function(int **a1)
{
  int *v1; // ebx
  int v2; // edx
  char v3; // al
  void *v4; // eax
  int v5; // edx
  FILE *Stream; // ecx
  void *v8; // [esp+18h] [ebp-24h] BYREF
  void **v9[4]; // [esp+1Ch] [ebp-20h] BYREF
  int v10; // [esp+2Ch] [ebp-10h]

  v1 = *a1;
  v2 = **a1;
  if ( !v2 )
    return 0;
  v3 = *((_BYTE *)v1 + 20);
  if ( (v3 & 2) != 0 )
  {
    Stream = *(FILE **)(v2 + 92);
    *((_BYTE *)v1 + 20) = v3 & 0xFD;
    if ( Stream )
    {
      *(_DWORD *)(v2 + 92) = 0;
      fclose(Stream);
    }
  }
  v8 = (void *)*v1;
  v4 = v8;
  v9[0] = (void **)v1[1];
  v9[1] = (void **)v1[2];
  v9[2] = (void **)v1[3];
  v9[3] = (void **)v1[4];
  v5 = v1[5];
  *a1 = (int *)&v8;
  v10 = v5;
  png_free(v4, v1);
  if ( (v10 & 1) != 0 )
    png_err((int)v8);
  png_destroy_read_struct((int *)&v8, v9, 0);
  return 1;
}

//----- (0043B5E0) --------------------------------------------------------
void *__cdecl png_image_memory_read(_DWORD *a1, void *a2, size_t Size)
{
  void *result; // eax
  int *v4; // edx
  int v5; // ebx
  int v6; // esi
  size_t v7; // ebp

  result = a1;
  if ( a1 )
  {
    v4 = (int *)a1[23];
    if ( !v4 || (v5 = *v4) == 0 || (v6 = *(_DWORD *)(v5 + 12), v7 = *(_DWORD *)(v5 + 16), !v6) || v7 < Size )
      png_err((int)a1);
    result = memcpy(a2, *(const void **)(v5 + 12), Size);
    *(_DWORD *)(v5 + 12) = Size + v6;
    *(_DWORD *)(v5 + 16) = v7 - Size;
  }
  return result;
}

//----- (0043B640) --------------------------------------------------------
int __cdecl png_image_read_and_map(int a1)
{
  size_t **v1; // edx
  char v2; // al
  int v3; // ebx
  int v4; // ecx
  int v5; // eax
  int v6; // edi
  int v7; // edi
  unsigned int v8; // esi
  char *v9; // ebx
  char *v10; // eax
  unsigned int v11; // edx
  char v12; // dl
  __int16 v13; // dx
  unsigned int v14; // ebp
  int v15; // edx
  unsigned int v16; // ecx
  char v17; // cl
  char v18; // dl
  char v19; // dl
  unsigned int v21; // [esp+10h] [ebp-4Ch]
  int v22; // [esp+14h] [ebp-48h]
  int v23; // [esp+18h] [ebp-44h]
  size_t *v24; // [esp+1Ch] [ebp-40h]
  size_t v25; // [esp+20h] [ebp-3Ch]
  size_t *v26; // [esp+24h] [ebp-38h]
  int v27; // [esp+28h] [ebp-34h]
  int v28; // [esp+30h] [ebp-2Ch]
  int v29; // [esp+34h] [ebp-28h]
  int v30; // [esp+38h] [ebp-24h]
  int v31; // [esp+3Ch] [ebp-20h]

  v1 = *(size_t ***)a1;
  v25 = ***(_DWORD ***)a1;
  v2 = *(_BYTE *)(v25 + 278);
  if ( v2 )
  {
    if ( v2 != 1 )
      png_err(v25);
    v29 = 7;
  }
  else
  {
    v29 = 1;
  }
  v3 = 0;
  v26 = v1[3];
  v24 = v1[2];
  v22 = *(_DWORD *)(a1 + 40);
  v30 = *(_DWORD *)(a1 + 24);
  v31 = *(_DWORD *)(a1 + 28);
  while ( 1 )
  {
    v6 = v3 + 1;
    v28 = v3 + 1;
    if ( v2 == 1 )
    {
      if ( (unsigned int)v3 <= 1 )
      {
        LOBYTE(v4) = 3;
        v5 = ~(unsigned __int8)((v3 & 1) << (3 - (v6 >> 1))) & 7;
      }
      else
      {
        v4 = (8 - v6) >> 1;
        v5 = (1 << v4) - 1 - (((v3 & 1) << (3 - (v6 >> 1))) & 7);
      }
      if ( !(((unsigned int)v24 + v5) >> v4) )
        goto LABEL_8;
      v27 = ((v3 & 1) << (3 - (v6 >> 1))) & 7;
      v7 = 1 << ((8 - v28) >> 1);
      v21 = (((v3 & 1) == 0) << (3 - (v3 >> 1))) & 7;
      v23 = 8;
      if ( (unsigned int)v3 > 2 )
        v23 = 8 >> ((v3 - 1) >> 1);
    }
    else
    {
      v21 = 0;
      v7 = 1;
      v23 = 1;
      v27 = 0;
    }
    if ( (unsigned int)v26 > v21 )
    {
      v8 = (unsigned int)v24 + v31 * v21 + v30;
      while ( 1 )
      {
        v9 = *(char **)(a1 + 20);
        png_read_row_constprop_6(v25, v9);
        v10 = (char *)(v8 + v27 - (_DWORD)v24);
        if ( v22 == 2 )
        {
          while ( (unsigned int)v10 < v8 )
          {
            v9 += 2;
            if ( *(v9 - 1) )
            {
              v12 = *(v9 - 2);
              if ( v12 == -2 )
                v12 = -1;
              *v10 = v12;
              v10 += v7;
            }
            else
            {
              *v10 = -2;
              v10 += v7;
            }
          }
          goto LABEL_25;
        }
        if ( v22 <= 2 )
        {
          if ( v22 == 1 && v8 > (unsigned int)v10 )
          {
            do
            {
              v15 = (unsigned __int8)*v9;
              v9 += 2;
              v16 = (unsigned __int8)*(v9 - 1);
              if ( v16 > 0xE5 )
              {
                LOBYTE(v14) = (unsigned __int16)(231 * v15 + 128) >> 8;
              }
              else
              {
                LOBYTE(v14) = -25;
                if ( v16 > 0x19 )
                  v14 = ((unsigned int)(5 * v15 + 130) >> 8) + 6 * ((5 * v16 + 130) >> 8) - 30;
              }
              *v10 = v14;
              v10 += v7;
            }
            while ( v8 > (unsigned int)v10 );
          }
          goto LABEL_25;
        }
        if ( v22 == 3 )
        {
          while ( (unsigned int)v10 < v8 )
          {
            v13 = (unsigned __int8)*v9;
            v9 += 3;
            *v10 = ((unsigned __int16)(5 * (unsigned __int8)*(v9 - 1) + 130) >> 8)
                 + 6
                 * (((unsigned __int16)(5 * (unsigned __int8)*(v9 - 2) + 130) >> 8)
                  + 6 * ((unsigned __int16)(5 * v13 + 130) >> 8));
            v10 += v7;
          }
          goto LABEL_25;
        }
        if ( v22 == 4 && (unsigned int)v10 < v8 )
          break;
LABEL_25:
        v8 += v31 * v23;
        v21 += v23;
        if ( (unsigned int)v26 <= v21 )
          goto LABEL_8;
      }
      while ( 1 )
      {
        v11 = (unsigned __int8)v9[3];
        if ( v11 > 0xC3 )
          break;
        if ( v11 > 0x3F )
        {
          v17 = *v9 & 0x40;
          if ( *v9 < 0 )
          {
            v18 = -26;
            if ( v17 )
            {
              v19 = -14;
LABEL_47:
              v18 = v19 + 1;
            }
          }
          else
          {
            v18 = -39;
            if ( v17 )
            {
              v19 = -27;
              goto LABEL_47;
            }
          }
          *v10 = v18;
LABEL_21:
          v10 += v7;
          v9 += 4;
          if ( v8 <= (unsigned int)v10 )
            goto LABEL_25;
          continue;
        }
        *v10 = -40;
        v10 += v7;
        v9 += 4;
        if ( v8 <= (unsigned int)v10 )
          goto LABEL_25;
      }
      *v10 = ((unsigned __int16)(5 * (unsigned __int8)v9[2] + 130) >> 8)
           + 6
           * (((unsigned __int16)(5 * (unsigned __int8)v9[1] + 130) >> 8)
            + 6 * ((unsigned __int16)(5 * (unsigned __int8)*v9 + 130) >> 8));
      goto LABEL_21;
    }
LABEL_8:
    if ( v29 == v28 )
      return 1;
    v3 = v28;
    v2 = *(_BYTE *)(v25 + 278);
  }
}

//----- (0043B9F0) --------------------------------------------------------
int __cdecl png_image_read_background(int a1)
{
  int **v1; // esi
  int *v2; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  int *v6; // edx
  int v7; // eax
  char v8; // al
  char v9; // cl
  int v10; // esi
  int v11; // ebp
  int v12; // edi
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  unsigned int v19; // edi
  unsigned int v20; // ecx
  _WORD *v21; // esi
  unsigned int v22; // edx
  unsigned __int16 v23; // ax
  _WORD *v25; // ebx
  unsigned int v26; // edx
  unsigned __int16 v27; // si
  int v28; // edi
  int v29; // esi
  int v30; // ebx
  int v31; // ebp
  int v32; // eax
  int v33; // eax
  unsigned int v34; // esi
  int v35; // edi
  char *v36; // ebx
  _BYTE *j; // edx
  char v38; // al
  unsigned int v39; // ecx
  int v40; // ecx
  int v41; // eax
  char v42; // bp
  int v43; // ecx
  int v44; // eax
  unsigned int v45; // esi
  int v46; // edi
  char *v47; // ebx
  _BYTE *i; // edx
  unsigned __int8 v49; // cl
  char v50; // al
  unsigned int v51; // ecx
  int v52; // [esp+1Ch] [ebp-60h]
  unsigned int v53; // [esp+1Ch] [ebp-60h]
  int v54; // [esp+20h] [ebp-5Ch]
  char v55; // [esp+20h] [ebp-5Ch]
  unsigned int v56; // [esp+24h] [ebp-58h]
  _BYTE *v57; // [esp+24h] [ebp-58h]
  char *v58; // [esp+28h] [ebp-54h]
  _BYTE *v59; // [esp+28h] [ebp-54h]
  int v60; // [esp+28h] [ebp-54h]
  size_t v61; // [esp+2Ch] [ebp-50h]
  unsigned int v62; // [esp+30h] [ebp-4Ch]
  unsigned int v63; // [esp+34h] [ebp-48h]
  int v64; // [esp+34h] [ebp-48h]
  int v65; // [esp+38h] [ebp-44h]
  unsigned __int16 v66; // [esp+38h] [ebp-44h]
  int v67; // [esp+3Ch] [ebp-40h]
  int v68; // [esp+3Ch] [ebp-40h]
  int v69; // [esp+40h] [ebp-3Ch]
  int v70; // [esp+40h] [ebp-3Ch]
  int v71; // [esp+44h] [ebp-38h]
  int v72; // [esp+44h] [ebp-38h]
  int v73; // [esp+48h] [ebp-34h]
  int v74; // [esp+4Ch] [ebp-30h]
  int v75; // [esp+50h] [ebp-2Ch]
  int v76; // [esp+50h] [ebp-2Ch]
  int v77; // [esp+58h] [ebp-24h]
  int v78; // [esp+5Ch] [ebp-20h]

  v1 = *(int ***)a1;
  v2 = **(int ***)a1;
  v3 = *v2;
  v4 = v2[1];
  v61 = *v2;
  v62 = *(_DWORD *)(*(_DWORD *)a1 + 12);
  v74 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  v5 = *(_DWORD *)(*v2 + 104);
  if ( (v5 & 0x600000) == 0 )
    png_err(v3);
  if ( (v5 & 0x80u) != 0 || (unsigned __int8)png_get_channels(v3, v4) != 2 )
    goto LABEL_71;
  v6 = v1[4];
  v7 = v61;
  if ( ((unsigned __int8)v6 & 5) == 1 )
    goto LABEL_72;
  v8 = *(_BYTE *)(v61 + 278);
  if ( v8 )
  {
    if ( v8 == 1 )
    {
      v73 = 7;
      goto LABEL_8;
    }
LABEL_71:
    v7 = v61;
LABEL_72:
    png_err(v7);
  }
  v73 = 1;
LABEL_8:
  v9 = *(_BYTE *)(v4 + 24);
  if ( v9 == 8 )
  {
    v72 = *(_DWORD *)(a1 + 24);
    v76 = *(_DWORD *)(a1 + 28);
    v28 = 0;
    v29 = 1;
    v70 = 1;
    if ( v8 == 1 )
      goto LABEL_54;
LABEL_40:
    v53 = 0;
    v30 = 1;
    v31 = 0;
    v64 = 1;
    while ( 1 )
    {
      v32 = *(_DWORD *)(a1 + 16);
      if ( v32 )
        break;
      while ( 1 )
      {
        if ( v53 < v62 )
        {
          v60 = v76 * v64;
          v45 = v72 + v76 * v53 + v74;
          v46 = v30;
          v57 = (_BYTE *)(v72 + v31 + v76 * v53);
          do
          {
            v47 = *(char **)(a1 + 20);
            png_read_row_constprop_6(v61, v47);
            for ( i = v57; (unsigned int)i < v45; i += v46 )
            {
              v49 = v47[1];
              if ( v49 )
              {
                v50 = *v47;
                if ( v49 != 0xFF )
                {
                  v51 = v49 * (unsigned __int16)png_sRGB_table[(unsigned __int8)*v47]
                      + (255 - v49) * (unsigned __int16)png_sRGB_table[(unsigned __int8)*i];
                  v50 = (unsigned __int16)(png_sRGB_base[v51 >> 15]
                                         + (((unsigned __int8)png_sRGB_delta[v51 >> 15] * (v51 & 0x7FFF)) >> 12)) >> 8;
                }
                *i = v50;
              }
              v47 += 2;
            }
            v53 += v64;
            v57 += v60;
            v45 += v60;
          }
          while ( v62 > v53 );
        }
        do
        {
LABEL_52:
          v28 = v70;
          if ( v73 == v70 )
            return 1;
          v29 = ++v70;
          if ( *(_BYTE *)(v61 + 278) != 1 )
            goto LABEL_40;
LABEL_54:
          v41 = (v28 & 1) << (3 - (v29 >> 1));
          v42 = v41;
          if ( (unsigned int)v28 <= 1 )
          {
            LOBYTE(v43) = 3;
            v44 = ~(_BYTE)v41 & 7;
          }
          else
          {
            v43 = (8 - v29) >> 1;
            v44 = (1 << v43) - 1 - (v41 & 7);
          }
        }
        while ( !((unsigned int)(v74 + v44) >> v43) );
        v31 = v42 & 7;
        v30 = 1 << ((8 - v70) >> 1);
        v53 = (((v28 & 1) == 0) << (3 - (v28 >> 1))) & 7;
        v64 = 8;
        if ( (unsigned int)v28 <= 2 )
          break;
        v64 = 8 >> ((v28 - 1) >> 1);
        v32 = *(_DWORD *)(a1 + 16);
        if ( v32 )
          goto LABEL_42;
      }
    }
LABEL_42:
    v33 = *(unsigned __int8 *)(v32 + 1);
    v55 = v33;
    v66 = png_sRGB_table[v33];
    if ( v53 >= v62 )
      goto LABEL_52;
    v68 = v76 * v64;
    v34 = v72 + v74 + v76 * v53;
    v59 = (_BYTE *)(v31 + v76 * v53 + v72);
    v35 = v30;
    while ( 1 )
    {
      v36 = *(char **)(a1 + 20);
      png_read_row_constprop_6(v61, v36);
      for ( j = v59; (unsigned int)j < v34; v36 += 2 )
      {
        while ( 1 )
        {
          v40 = (unsigned __int8)v36[1];
          if ( (_BYTE)v40 )
            break;
          v36 += 2;
          *j = v55;
          j += v35;
          if ( (unsigned int)j >= v34 )
            goto LABEL_51;
        }
        v38 = *v36;
        if ( (_BYTE)v40 != 0xFF )
        {
          v39 = v40 * (unsigned __int16)png_sRGB_table[(unsigned __int8)*v36] + v66 * (255 - v40);
          v38 = (unsigned __int16)(png_sRGB_base[v39 >> 15]
                                 + (((unsigned __int8)png_sRGB_delta[v39 >> 15] * (v39 & 0x7FFF)) >> 12)) >> 8;
        }
        *j = v38;
        j += v35;
      }
LABEL_51:
      v53 += v64;
      v59 += v68;
      v34 += v68;
      if ( v62 <= v53 )
        goto LABEL_52;
    }
  }
  if ( v9 != 16 )
    goto LABEL_71;
  v77 = *(_DWORD *)(a1 + 24);
  v69 = (unsigned __int8)v6 & 1;
  v75 = v69 + 1;
  v78 = *(_DWORD *)(a1 + 28) / 2;
  v10 = 0;
  v11 = 2 * (((unsigned __int8)v6 & 0x21) == 33);
  v54 = 2 * (((unsigned __int8)v6 & 0x21) != 33);
  v12 = 1;
  v71 = 1;
  if ( v8 == 1 )
    goto LABEL_11;
LABEL_16:
  v56 = 0;
  v16 = v69 + 1;
  v17 = 0;
  v65 = 1;
LABEL_17:
  if ( v62 <= v56 )
  {
    while ( 1 )
    {
      v15 = v71;
      if ( v73 == v71 )
        break;
LABEL_15:
      v10 = v15;
      v12 = v15 + 1;
      v71 = v12;
      if ( *(_BYTE *)(v61 + 278) != 1 )
        goto LABEL_16;
LABEL_11:
      if ( (unsigned int)v10 <= 1 )
      {
        LOBYTE(v13) = 3;
        v14 = ~(unsigned __int8)((v10 & 1) << (3 - (v12 >> 1))) & 7;
      }
      else
      {
        v13 = (8 - v12) >> 1;
        v14 = (1 << v13) - 1 - (((v10 & 1) << (3 - (v12 >> 1))) & 7);
      }
      if ( (unsigned int)(v74 + v14) >> v13 )
      {
        v17 = v75 * (((v10 & 1) << (3 - (v12 >> 1))) & 7);
        v16 = v75 << ((8 - v71) >> 1);
        v65 = 8;
        v56 = (((v10 & 1) == 0) << (3 - (v10 >> 1))) & 7;
        if ( (unsigned int)v10 > 2 )
          v65 = 8 >> ((v10 - 1) >> 1);
        goto LABEL_17;
      }
    }
  }
  else
  {
    v52 = 2 * v16;
    v58 = *(char **)(a1 + 20);
    v18 = v56 * 2 * v78;
    v67 = 2 * v78 * v65;
    v19 = v77 + v18 + 2 * (v69 + 1) * v74;
    v63 = v77 + v18 + 2 * v17;
    do
    {
      png_read_row_constprop_6(v61, v58);
      v58 = *(char **)(a1 + 20);
      v20 = v63;
      if ( v63 < v19 )
      {
        if ( v69 )
        {
          v25 = *(_WORD **)(a1 + 20);
          do
          {
            v27 = v25[1];
            LOWORD(v26) = *v25;
            if ( v27 )
            {
              if ( v27 != 0xFFFF )
                v26 = ((unsigned __int16)v26 * (unsigned int)v27 + 0x7FFF) / 0xFFFF;
            }
            else
            {
              LOWORD(v26) = 0;
            }
            *(_WORD *)(v20 + v11) = v26;
            v25 += 2;
            *(_WORD *)(v20 + v54) = v27;
            v20 += v52;
          }
          while ( v19 > v20 );
        }
        else
        {
          v21 = *(_WORD **)(a1 + 20);
          do
          {
            while ( 1 )
            {
              v23 = v21[1];
              LOWORD(v22) = *v21;
              if ( v23 )
                break;
              v21 += 2;
              *(_WORD *)(v20 + v11) = 0;
              v20 += v52;
              if ( v19 <= v20 )
                goto LABEL_27;
            }
            if ( v23 != 0xFFFF )
              v22 = (v23 * (unsigned int)(unsigned __int16)v22 + 0x7FFF) / 0xFFFF;
            *(_WORD *)(v20 + v11) = v22;
            v20 += v52;
            v21 += 2;
          }
          while ( v19 > v20 );
        }
      }
LABEL_27:
      v63 += v67;
      v56 += v65;
      v19 += v67;
    }
    while ( v62 > v56 );
    v15 = v71;
    if ( v73 != v71 )
      goto LABEL_15;
  }
  return 1;
}
// 514EE0: using guessed type __int16 png_sRGB_base[512];
// 5154E0: using guessed type __int16 png_sRGB_table[256];

//----- (0043C0F0) --------------------------------------------------------
int __cdecl png_image_read_colormap(int *a1)
{
  int *v1; // ebp
  unsigned int v2; // esi
  char v3; // dl
  char v4; // al
  __int16 v5; // ax
  int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // ebx
  unsigned int v9; // esi
  unsigned int i; // edi
  unsigned int v11; // edx
  unsigned int v12; // eax
  unsigned __int8 *v13; // esi
  unsigned int v14; // ebx
  int v15; // edx
  int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // edx
  unsigned __int8 v20; // al
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int j; // esi
  unsigned int v24; // edx
  char *k; // ebx
  unsigned int v26; // ebp
  unsigned __int8 v28; // cl
  unsigned int v29; // eax
  int v30; // ecx
  unsigned int v31; // esi
  unsigned int v32; // ebx
  unsigned int v33; // edx
  unsigned __int8 *v34; // eax
  unsigned int nn; // ebx
  unsigned int v36; // kr00_4
  unsigned int v37; // edx
  __int16 *v38; // ebx
  unsigned int v39; // ebp
  int v40; // ecx
  unsigned int v41; // ecx
  unsigned int v42; // edx
  char v43; // al
  unsigned int v44; // edx
  int v45; // eax
  char *mm; // ebx
  unsigned int v47; // ecx
  unsigned int v48; // edx
  int v49; // ebx
  int v50; // eax
  int v51; // edi
  unsigned __int8 *v52; // esi
  int v53; // eax
  int v54; // edx
  int v55; // eax
  unsigned int v56; // ecx
  unsigned int v57; // edx
  unsigned int v58; // edi
  unsigned int m; // esi
  unsigned int v60; // edx
  char *n; // ebx
  unsigned int v62; // ebp
  int v63; // esi
  unsigned int v64; // edx
  int v65; // ebx
  unsigned int v66; // ebp
  unsigned int v67; // ecx
  unsigned int v68; // edx
  unsigned int v69; // edi
  unsigned int ii; // esi
  char *v71; // ebx
  unsigned int v72; // edx
  unsigned int v73; // ebp
  __int16 v74; // bx
  __int16 v75; // si
  __int16 v76; // ax
  int v77; // edi
  int v78; // esi
  int *v79; // edi
  int v80; // eax
  unsigned int v81; // ebx
  int *v82; // eax
  int v83; // edi
  int v84; // eax
  unsigned int v85; // eax
  char *kk; // esi
  unsigned int v87; // ecx
  unsigned int v88; // edx
  __int16 v89; // si
  unsigned int v90; // eax
  unsigned int v91; // ebx
  __int16 v92; // si
  void *Buf1; // [esp+0h] [ebp-8Ch]
  char *Buf1a; // [esp+0h] [ebp-8Ch]
  void *Buf1b; // [esp+0h] [ebp-8Ch]
  char *Buf1c; // [esp+0h] [ebp-8Ch]
  char *Buf2; // [esp+4h] [ebp-88h]
  void *Buf2a; // [esp+4h] [ebp-88h]
  char *Buf2b; // [esp+4h] [ebp-88h]
  char *Buf2c; // [esp+4h] [ebp-88h]
  void *Buf2d; // [esp+4h] [ebp-88h]
  void *Buf2e; // [esp+4h] [ebp-88h]
  char *Buf2f; // [esp+4h] [ebp-88h]
  char *Buf2g; // [esp+4h] [ebp-88h]
  int v105; // [esp+24h] [ebp-68h]
  int v106; // [esp+28h] [ebp-64h]
  unsigned int v107; // [esp+28h] [ebp-64h]
  unsigned int v108; // [esp+28h] [ebp-64h]
  int v109; // [esp+28h] [ebp-64h]
  unsigned int v110; // [esp+2Ch] [ebp-60h]
  unsigned int v111; // [esp+2Ch] [ebp-60h]
  unsigned int v112; // [esp+2Ch] [ebp-60h]
  unsigned int v113; // [esp+2Ch] [ebp-60h]
  int v114; // [esp+2Ch] [ebp-60h]
  unsigned int v115; // [esp+2Ch] [ebp-60h]
  int jj; // [esp+2Ch] [ebp-60h]
  int v117; // [esp+30h] [ebp-5Ch]
  unsigned int v118; // [esp+30h] [ebp-5Ch]
  unsigned int v119; // [esp+30h] [ebp-5Ch]
  int v120; // [esp+30h] [ebp-5Ch]
  int v121; // [esp+34h] [ebp-58h]
  int v122; // [esp+34h] [ebp-58h]
  int v123; // [esp+38h] [ebp-54h]
  int v124; // [esp+38h] [ebp-54h]
  bool v125; // [esp+3Ch] [ebp-50h]
  unsigned int v126; // [esp+3Ch] [ebp-50h]
  size_t v127; // [esp+3Ch] [ebp-50h]
  int Size; // [esp+3Ch] [ebp-50h]
  int v129; // [esp+3Ch] [ebp-50h]
  int v130; // [esp+40h] [ebp-4Ch]
  unsigned int v131; // [esp+44h] [ebp-48h]
  int v132; // [esp+44h] [ebp-48h]
  unsigned int v133; // [esp+44h] [ebp-48h]
  int v134; // [esp+48h] [ebp-44h]
  int v135; // [esp+48h] [ebp-44h]
  unsigned int v136; // [esp+48h] [ebp-44h]
  int v137; // [esp+48h] [ebp-44h]
  int v138; // [esp+4Ch] [ebp-40h]
  int v139; // [esp+4Ch] [ebp-40h]
  int v140; // [esp+4Ch] [ebp-40h]
  int v141; // [esp+4Ch] [ebp-40h]
  int v142; // [esp+50h] [ebp-3Ch]
  int v143; // [esp+50h] [ebp-3Ch]
  int v144; // [esp+50h] [ebp-3Ch]
  unsigned int v145; // [esp+54h] [ebp-38h]
  int v146; // [esp+54h] [ebp-38h]
  int v147; // [esp+58h] [ebp-34h]
  char v148[2]; // [esp+66h] [ebp-26h] BYREF
  __int16 v149; // [esp+68h] [ebp-24h]
  __int16 v150; // [esp+6Ah] [ebp-22h]
  __int16 v151; // [esp+6Ch] [ebp-20h]
  __int16 v152; // [esp+6Eh] [ebp-1Eh]

  v1 = a1;
  v2 = *(_DWORD *)(*a1 + 16);
  v130 = *a1;
  v3 = *(_BYTE *)(**(_DWORD **)*a1 + 281);
  v105 = **(_DWORD **)*a1;
  v4 = v3 & 4;
  if ( (v2 & 4) != 0 )
  {
    if ( v4 )
    {
      v134 = 2;
      v123 = (unsigned __int16)-(v2 & 1);
      v106 = v123;
      v121 = v123;
    }
    else
    {
      v134 = 2;
      if ( *(_WORD *)(v105 + 274) )
      {
        v123 = (unsigned __int16)-(v2 & 1);
        v106 = v123;
        v121 = v123;
      }
      else
      {
        v123 = 0xFFFF;
        v106 = 0xFFFF;
        v121 = 0xFFFF;
      }
    }
  }
  else if ( (v4 || *(_WORD *)(v105 + 274)) && (v2 & 1) == 0 )
  {
    v34 = (unsigned __int8 *)a1[4];
    if ( !v34 )
      goto LABEL_121;
    v106 = v34[1];
    if ( (v2 & 2) != 0 )
    {
      v134 = 1;
      v121 = *v34;
      v123 = v34[2];
    }
    else
    {
      v123 = v34[1];
      v121 = v123;
      v134 = 1;
    }
  }
  else
  {
    v134 = 1;
    v123 = 255;
    v106 = 255;
    v121 = 255;
  }
  v5 = *(_WORD *)(v105 + 534);
  if ( (v5 & 1) == 0 )
  {
    v6 = 45455;
    if ( *(_BYTE *)(v105 + 282) == 16 )
      v6 = (*(_DWORD *)(v130 + 20) & 4) == 0 ? 100000 : 45455;
    *(_DWORD *)(v105 + 460) = v6;
    *(_WORD *)(v105 + 534) = v5 | 1;
  }
  switch ( v3 )
  {
    case 0:
      v28 = *(_BYTE *)(v105 + 282);
      v29 = *(_DWORD *)(v130 + 24);
      if ( v28 > 8u )
      {
        if ( v29 <= 0xFF )
          goto LABEL_121;
        for ( i = 0; i != 256; ++i )
        {
          Buf2a = (void *)i;
          v41 = i;
          v42 = i;
          Buf1 = (void *)i;
          png_create_colormap_entry_constprop_5(a1, v42, v41, (unsigned int)Buf1, (unsigned int)Buf2a, 1);
        }
        if ( !*(_WORD *)(v105 + 274) )
        {
LABEL_169:
          v9 = 256;
          v8 = 0;
          i = 256;
          goto LABEL_48;
        }
        v8 = v2 & 1;
        if ( (v2 & 1) != 0 )
        {
          v85 = 0;
        }
        else
        {
          if ( v121 == v106 && v106 == v123 )
          {
            if ( v134 != 2 )
              goto LABEL_168;
LABEL_167:
            v89 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v106) >> 15]
                                                     + (((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v106) >> 15]
                                                       * ((255 * v106) & 0x7FFFu)) >> 12)) >> 8);
            png_create_colormap_entry(
              a1,
              (unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v106) >> 15]
                               + (((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v106) >> 15]
                                 * ((255 * v106) & 0x7FFFu)) >> 12)) >> 8,
              v106,
              v106,
              v106,
              0xFFFFu,
              2);
            LOWORD(v106) = v89;
LABEL_168:
            v9 = 256;
            v151 = v106;
            v150 = v106;
            v149 = v106;
            v152 = v106;
            v148[0] = 0;
            png_set_background_fixed(v105, (int)v148, 1, 0, 0);
LABEL_48:
            png_set_alpha_mode_fixed(v105, 0, 220000);
            if ( *(_BYTE *)(v105 + 282) <= 8u )
            {
LABEL_49:
              if ( i > 0x100 )
                goto LABEL_121;
              goto LABEL_50;
            }
LABEL_36:
            png_set_scale_16(v105);
            goto LABEL_49;
          }
          v85 = 0xFFFF;
          if ( v134 != 2 )
            v85 = 255;
        }
        v8 = 2;
        v9 = 254;
        png_create_colormap_entry(a1, 0xFEu, v121, v106, v123, v85, v134);
        goto LABEL_160;
      }
      i = 1 << v28;
      if ( 1 << v28 > v29 )
        goto LABEL_121;
      v30 = 255;
      v118 = 0xFF / (i - 1);
      if ( *(_WORD *)(v105 + 274) )
      {
        v126 = 0;
        v112 = *(unsigned __int16 *)(v105 + 372);
        if ( (v2 & 1) == 0 )
        {
          if ( v134 == 2 )
            v30 = 0xFFFF;
          v126 = v30;
        }
      }
      else
      {
        v126 = 0;
        v112 = 256;
      }
      v31 = 0;
      v32 = 0;
      while ( v112 == v32 )
      {
LABEL_65:
        v32 = v112 + 1;
        png_create_colormap_entry(a1, v112, v121, v106, v123, v126, v134);
        v31 += v118;
        if ( i == v112 + 1 )
          goto LABEL_34;
      }
      while ( 1 )
      {
        v33 = v32++;
        png_create_colormap_entry_constprop_5(a1, v33, v31, v31, v31, 3);
        v31 += v118;
        if ( i == v32 )
          break;
        if ( v112 == v32 )
          goto LABEL_65;
      }
LABEL_34:
      v20 = *(_BYTE *)(v105 + 282);
      if ( v20 <= 7u )
      {
LABEL_134:
        png_set_packing(v105);
        v20 = *(_BYTE *)(v105 + 282);
      }
LABEL_35:
      v9 = 256;
      v8 = 0;
      if ( v20 > 8u )
        goto LABEL_36;
LABEL_50:
      if ( *(_DWORD *)(v130 + 24) < i )
        goto LABEL_121;
      *(_DWORD *)(v130 + 24) = i;
      if ( v8 == 2 )
      {
        if ( v9 >= i || v9 != 254 )
          goto LABEL_121;
        v1[10] = 2;
        return 1;
      }
      else
      {
        if ( v8 <= 2 )
        {
          if ( v8 == 1 )
          {
            if ( v9 == 231 )
              goto LABEL_56;
            goto LABEL_121;
          }
          goto LABEL_142;
        }
        if ( v8 != 3 )
        {
          if ( v8 == 4 )
          {
            if ( v9 == 216 )
            {
LABEL_56:
              v1[10] = v8;
              return 1;
            }
LABEL_121:
            png_err(v105);
          }
LABEL_142:
          if ( v9 != 256 )
            goto LABEL_121;
          goto LABEL_118;
        }
        if ( v9 != 256 )
          goto LABEL_121;
        v1[10] = 3;
        return 1;
      }
    case 2:
    case 6:
      if ( (v2 & 2) != 0 )
      {
        v21 = *(_DWORD *)(v130 + 24);
        if ( v3 != 6 && !*(_WORD *)(v105 + 274) )
        {
          if ( v21 <= 0xD7 )
            goto LABEL_121;
          v107 = 0;
          v111 = 0;
          do
          {
            v22 = v111;
            for ( j = 0; j != 306; j += 51 )
            {
              v24 = v22;
              for ( k = 0; k != (char *)306; k += 51 )
              {
                Buf2 = k;
                v26 = v24 + 1;
                png_create_colormap_entry_constprop_5(a1, v24, v107, j, (unsigned int)Buf2, 1);
                v24 = v26;
              }
              v22 += 6;
            }
            v107 += 51;
            v111 += 36;
          }
          while ( v107 != 306 );
          v9 = 256;
          v8 = 3;
          i = 216;
          v1 = a1;
          goto LABEL_48;
        }
        if ( (v2 & 1) != 0 )
        {
          if ( v21 <= 0xF3 )
            goto LABEL_121;
          v108 = 0;
          v113 = 0;
          do
          {
            v58 = v113;
            for ( m = 0; m != 306; m += 51 )
            {
              v60 = v58;
              for ( n = 0; n != (char *)306; n += 51 )
              {
                Buf2c = n;
                v62 = v60 + 1;
                png_create_colormap_entry_constprop_5(a1, v60, v108, m, (unsigned int)Buf2c, 1);
                v60 = v62;
              }
              v58 += 6;
            }
            v108 += 51;
            v113 += 36;
          }
          while ( v108 != 306 );
          png_create_colormap_entry(a1, 0xD8u, 0xFFu, 0xFFu, 0xFFu, 0, 1);
          v114 = 229;
          v109 = 0;
          do
          {
            v63 = 0;
            for ( i = v114 - 9; ; i += 3 )
            {
              v64 = i - 3;
              v65 = 0;
              do
              {
                Buf2d = (void *)v65;
                v66 = v64 + 1;
                v65 = (2 * v65) | 0x7F;
                png_create_colormap_entry(a1, v64, v109, v63, (unsigned int)Buf2d, 0x80u, 1);
                v64 = v66;
              }
              while ( v66 != i );
              v63 = (2 * v63) | 0x7F;
              if ( v114 == i + 3 )
                break;
            }
            v109 = (2 * v109) | 0x7F;
            v114 = i + 12;
          }
          while ( i != 244 );
          v1 = a1;
          v9 = 216;
          v8 = 4;
        }
        else
        {
          Size = ((v2 & 3) + 1) * (((v2 >> 2) & 1) + 1);
          if ( v21 <= 0xF3 )
            goto LABEL_121;
          v115 = 0;
          v119 = 0;
          do
          {
            v69 = v119;
            for ( ii = 0; ii != 306; ii += 51 )
            {
              v71 = 0;
              v72 = v69;
              do
              {
                Buf2f = v71;
                v73 = v72 + 1;
                v71 += 51;
                png_create_colormap_entry_constprop_5(a1, v72, v115, ii, (unsigned int)Buf2f, 1);
                v72 = v73;
              }
              while ( v71 != (char *)306 );
              v69 += 6;
            }
            v115 += 51;
            v119 += 36;
          }
          while ( v115 != 306 );
          v1 = a1;
          png_create_colormap_entry(a1, 0xD8u, v121, v106, v123, 0, v134);
          if ( v134 == 2 )
          {
            v75 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v121) >> 15]
                                                     + (((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v121) >> 15]
                                                       * ((255 * v121) & 0x7FFFu)) >> 12)) >> 8);
            v74 = (unsigned __int8)((unsigned __int16)((((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v106) >> 15]
                                                       * ((255 * v106) & 0x7FFFu)) >> 12)
                                                     + png_sRGB_base[(unsigned int)(255 * v106) >> 15]) >> 8);
            v76 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v123) >> 15]
                                                     + (((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v123) >> 15]
                                                       * ((255 * v123) & 0x7FFFu)) >> 12)) >> 8);
          }
          else
          {
            v74 = v106;
            v75 = v121;
            v76 = v106;
          }
          v144 = 229;
          v77 = v134;
          v141 = 0;
          if ( !memcmp(
                  (const void *)(216 * Size + a1[3]),
                  (const void *)(a1[3]
                               + Size
                               * (unsigned __int8)(((unsigned __int16)(5 * v76 + 130) >> 8)
                                                 + 6
                                                 * (((unsigned __int16)(5 * v74 + 130) >> 8)
                                                  + 6 * ((unsigned __int16)(5 * v75 + 130) >> 8)))),
                  Size) )
          {
            v9 = 256;
            v8 = 3;
            i = 216;
            v149 = v121;
            v150 = v106;
            v152 = v106;
            v148[0] = 0;
            v151 = v123;
            png_set_background_fixed(v105, (int)v148, 1, 0, 0);
            goto LABEL_48;
          }
          do
          {
            v137 = 0;
            v78 = v77;
            v79 = v1;
            v80 = v144 - 9;
            for ( jj = v144 - 9; ; jj += 3 )
            {
              v81 = v80 - 3;
              v82 = v79;
              v83 = 0;
              v1 = v82;
              do
              {
                v120 = png_colormap_compose((int ***)v1, v83, 1, 128, v123, v78);
                v129 = png_colormap_compose((int ***)v1, v137, 1, 128, v106, v78);
                v84 = png_colormap_compose((int ***)v1, v141, 1, 128, v121, v78);
                png_create_colormap_entry(v1, v81++, v84, v129, v120, 0, v78);
                v83 = (2 * v83) | 0x7F;
              }
              while ( v81 != jj );
              v79 = v1;
              v137 = (2 * v137) | 0x7F;
              v80 = jj + 3;
              if ( v144 == jj + 3 )
                break;
            }
            v77 = v78;
            v141 = (2 * v141) | 0x7F;
            v144 = jj + 12;
          }
          while ( jj != 244 );
          i = 244;
          v9 = 216;
          v8 = 4;
        }
LABEL_160:
        if ( *(_WORD *)(v105 + 274) && (*(_BYTE *)(v105 + 281) & 4) == 0 )
          png_set_tRNS_to_alpha(v105);
        goto LABEL_48;
      }
      png_set_rgb_to_gray_fixed(v105, 1, -1, -1);
      v43 = *(_BYTE *)(v105 + 281);
      if ( v43 == 6 )
      {
        v44 = *(_DWORD *)(v130 + 24);
      }
      else
      {
        v44 = *(_DWORD *)(v130 + 24);
        if ( !*(_WORD *)(v105 + 274) )
        {
          if ( v44 <= 0xFF )
            goto LABEL_121;
          goto LABEL_107;
        }
      }
      v8 = v2 & 1;
      if ( (v2 & 1) != 0 )
      {
        if ( v44 <= 0xFF )
          goto LABEL_121;
        v9 = 231;
        i = make_ga_colormap(a1);
        goto LABEL_160;
      }
      if ( v44 <= 0xFF )
        goto LABEL_121;
      if ( v43 == 6 || *(_WORD *)(v105 + 274) )
      {
        v45 = *(_DWORD *)(v105 + 460);
        if ( v45 > 99999 || v45 && png_gamma_significant((11 * v45 + 2) / 5) )
        {
          for ( kk = 0; kk != (char *)256; ++kk )
          {
            Buf2g = kk;
            v87 = (unsigned int)kk;
            v88 = (unsigned int)kk;
            Buf1c = kk;
            png_create_colormap_entry_constprop_5(a1, v88, v87, (unsigned int)Buf1c, (unsigned int)Buf2g, 3);
          }
          v50 = v105;
          if ( *(_BYTE *)(v105 + 281) != 6 && !*(_WORD *)(v105 + 274) )
          {
            if ( *(_BYTE *)(v105 + 282) <= 8u )
            {
              if ( *(_DWORD *)(v130 + 24) > 0xFFu )
              {
                *(_DWORD *)(v130 + 24) = 256;
                goto LABEL_56;
              }
              goto LABEL_121;
            }
LABEL_208:
            png_set_scale_16(v50);
LABEL_116:
            if ( *(_DWORD *)(v130 + 24) <= 0xFFu )
              goto LABEL_121;
            *(_DWORD *)(v130 + 24) = 256;
LABEL_118:
            v1[10] = 0;
            return 1;
          }
          v90 = v106;
          if ( v134 == 1 )
            v90 = (unsigned __int16)png_sRGB_table[v106];
          v91 = (255 * (unsigned int)(unsigned __int16)png_gamma_16bit_correct(v90, *(_DWORD *)(v105 + 460)) + 32895) >> 16;
          png_create_colormap_entry(a1, v91, v106, v106, v106, 0, v134);
          LOWORD(v106) = v91;
          v49 = 3;
LABEL_113:
          v151 = v106;
          v150 = v106;
          v149 = v106;
          v152 = v106;
          v148[0] = 0;
          png_set_background_fixed(v105, (int)v148, 1, 0, 0);
          if ( *(_WORD *)(v105 + 274) && (*(_BYTE *)(v105 + 281) & 4) == 0 )
            png_set_tRNS_to_alpha(v105);
          if ( v49 == 1 )
          {
            v8 = 0;
            v9 = 256;
            i = 256;
            goto LABEL_48;
          }
          v50 = v105;
          if ( *(_BYTE *)(v105 + 282) <= 8u )
            goto LABEL_116;
          goto LABEL_208;
        }
      }
LABEL_107:
      for ( mm = 0; mm != (char *)256; ++mm )
      {
        Buf2b = mm;
        v47 = (unsigned int)mm;
        v48 = (unsigned int)mm;
        Buf1a = mm;
        png_create_colormap_entry_constprop_5(a1, v48, v47, (unsigned int)Buf1a, (unsigned int)Buf2b, 1);
      }
      if ( *(_BYTE *)(v105 + 281) != 6 && !*(_WORD *)(v105 + 274) )
        goto LABEL_169;
      v49 = 1;
      if ( v134 == 2 )
      {
        v92 = (unsigned __int8)((unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v106) >> 15]
                                                 + (((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v106) >> 15]
                                                   * ((255 * v106) & 0x7FFFu)) >> 12)) >> 8);
        png_create_colormap_entry(
          a1,
          (unsigned __int16)(png_sRGB_base[(unsigned int)(255 * v106) >> 15]
                           + (((unsigned __int8)png_sRGB_delta[(unsigned int)(255 * v106) >> 15]
                             * ((255 * v106) & 0x7FFFu)) >> 12)) >> 8,
          v106,
          v106,
          v106,
          0,
          2);
        LOWORD(v106) = v92;
      }
      goto LABEL_113;
    case 3:
      v110 = *(unsigned __int16 *)(v105 + 274);
      v147 = *(_DWORD *)(v105 + 268);
      if ( *(_WORD *)(v105 + 274) )
      {
        v117 = *(_DWORD *)(v105 + 360);
        if ( v117 )
        {
          v125 = (v2 & 1) == 0;
        }
        else
        {
          v125 = 0;
          v110 = 0;
        }
      }
      else
      {
        v125 = 0;
        v117 = 0;
      }
      i = 256;
      v11 = *(unsigned __int16 *)(v105 + 272);
      if ( v11 <= 0x100 )
        i = *(unsigned __int16 *)(v105 + 272);
      if ( *(_DWORD *)(v130 + 24) < i )
        goto LABEL_121;
      if ( !(_WORD)v11 )
        goto LABEL_34;
      v12 = v110;
      if ( !v110 )
      {
        v14 = 0;
        goto LABEL_123;
      }
      v13 = *(unsigned __int8 **)(v105 + 268);
      if ( v110 > i )
        v12 = i;
      v14 = 0;
      v131 = v12;
      do
      {
        while ( 1 )
        {
          v17 = *(unsigned __int8 *)(v117 + v14);
          if ( v110 > v14 && v125 && (_BYTE)v17 != 0xFF )
            break;
          v18 = *v13;
          v19 = v14;
          v13 += 3;
          ++v14;
          png_create_colormap_entry(a1, v19, v18, *(v13 - 2), *(v13 - 1), v17, 3);
          if ( v14 >= v131 )
            goto LABEL_33;
        }
        if ( (_BYTE)v17 )
        {
          v15 = 257 * v17;
          if ( v134 != 2 )
            v15 = *(unsigned __int8 *)(v117 + v14);
          v145 = v15;
          v138 = png_colormap_compose((int ***)a1, v13[2], 3, v17, v123, v134);
          v142 = png_colormap_compose((int ***)a1, v13[1], 3, *(unsigned __int8 *)(v117 + v14), v106, v134);
          v16 = png_colormap_compose((int ***)a1, *v13, 3, *(unsigned __int8 *)(v117 + v14), v121, v134);
          png_create_colormap_entry(a1, v14, v16, v142, v138, v145, v134);
        }
        else
        {
          png_create_colormap_entry(a1, v14, v121, v106, v123, 0, v134);
        }
        ++v14;
        v13 += 3;
      }
      while ( v14 < v131 );
LABEL_33:
      if ( v14 >= i )
        goto LABEL_34;
LABEL_123:
      v133 = i;
      v51 = v134;
      v52 = (unsigned __int8 *)(3 * v14 + v147);
      do
      {
        while ( 1 )
        {
          if ( v110 > v14 && v125 )
          {
            v53 = *(unsigned __int8 *)(v117 + v14);
            if ( (_BYTE)v53 != 0xFF )
              break;
          }
          v56 = *v52;
          v57 = v14;
          v52 += 3;
          ++v14;
          png_create_colormap_entry(a1, v57, v56, *(v52 - 2), *(v52 - 1), 0xFFu, 3);
          if ( v14 >= v133 )
            goto LABEL_133;
        }
        if ( (_BYTE)v53 )
        {
          v54 = 257 * v53;
          if ( v51 != 2 )
            v54 = *(unsigned __int8 *)(v117 + v14);
          v136 = v54;
          v143 = png_colormap_compose((int ***)a1, v52[2], 3, v53, v123, v51);
          v140 = png_colormap_compose((int ***)a1, v52[1], 3, *(unsigned __int8 *)(v117 + v14), v106, v51);
          v55 = png_colormap_compose((int ***)a1, *v52, 3, *(unsigned __int8 *)(v117 + v14), v121, v51);
          png_create_colormap_entry(a1, v14, v55, v140, v143, v136, v51);
        }
        else
        {
          png_create_colormap_entry(a1, v14, v121, v106, v123, 0, v51);
        }
        ++v14;
        v52 += 3;
      }
      while ( v14 < v133 );
LABEL_133:
      i = v133;
      v20 = *(_BYTE *)(v105 + 282);
      if ( v20 <= 7u )
        goto LABEL_134;
      goto LABEL_35;
    case 4:
      v7 = *(_DWORD *)(v130 + 24);
      v8 = v2 & 1;
      if ( (v2 & 1) != 0 )
      {
        if ( v7 <= 0xFF )
          goto LABEL_121;
        v9 = 231;
        i = make_ga_colormap(a1);
        goto LABEL_48;
      }
      if ( (v2 & 2) != 0 && (v121 != v106 || v106 != v123) )
      {
        if ( v7 <= 0xFF )
          goto LABEL_121;
        for ( nn = 0; nn != 231; ++nn )
        {
          v36 = (nn << 8) + 115;
          v37 = nn;
          png_create_colormap_entry_constprop_5(a1, v37, v36 / 0xE7, v36 / 0xE7, v36 / 0xE7, 1);
        }
        if ( v134 == 2 )
        {
          png_create_colormap_entry(a1, 0xE7u, v121, v106, v123, 0xFFFFu, 2);
        }
        else
        {
          png_create_colormap_entry(a1, 0xE7u, v121, v106, v123, 0xFFu, 1);
          v121 = (unsigned __int16)png_sRGB_table[v121];
          v106 = (unsigned __int16)png_sRGB_table[v106];
          v123 = (unsigned __int16)png_sRGB_table[v123];
        }
        v132 = 51;
        v146 = -51 * v123;
        v127 = 204 * v123;
        v124 = 204 * v106;
        v139 = -51 * v121;
        v122 = 204 * v121;
        v135 = 232;
        do
        {
          v38 = png_sRGB_table;
          v39 = v135;
          do
          {
            v40 = v132 * (unsigned __int16)*v38;
            v38 += 51;
            png_create_colormap_entry_constprop_5(
              a1,
              v39++,
              (unsigned __int16)(png_sRGB_base[(unsigned int)(v122 + v40) >> 15]
                               + (((unsigned __int8)png_sRGB_delta[(unsigned int)(v122 + v40) >> 15]
                                 * ((v122 + v40) & 0x7FFFu)) >> 12)) >> 8,
              (unsigned __int16)(png_sRGB_base[(unsigned int)(v40 + v124) >> 15]
                               + (((unsigned __int8)png_sRGB_delta[(unsigned int)(v40 + v124) >> 15]
                                 * (((_WORD)v40 + (_WORD)v124) & 0x7FFFu)) >> 12)) >> 8,
              (unsigned __int16)(png_sRGB_base[(v40 + v127) >> 15]
                               + (((unsigned __int8)png_sRGB_delta[(v40 + v127) >> 15] * ((v40 + v127) & 0x7FFF)) >> 12)) >> 8,
              1);
          }
          while ( &unk_515744 != (_UNKNOWN *)v38 );
          v135 += 6;
          v132 += 51;
          v127 += v146;
          v124 += -51 * v106;
          v122 += v139;
        }
        while ( v135 != 256 );
        v9 = 231;
        i = 256;
        v8 = 1;
        v1 = a1;
        goto LABEL_48;
      }
      if ( v7 <= 0xFF )
        goto LABEL_121;
      for ( i = 0; i != 256; ++i )
      {
        Buf2e = (void *)i;
        v67 = i;
        v68 = i;
        Buf1b = (void *)i;
        png_create_colormap_entry_constprop_5(a1, v68, v67, (unsigned int)Buf1b, (unsigned int)Buf2e, 1);
      }
      if ( v134 == 2 )
        goto LABEL_167;
      goto LABEL_168;
    default:
      goto LABEL_121;
  }
}
// 43CBA7: conditional instruction was optimized away because ebx.4==3
// 514EE0: using guessed type __int16 png_sRGB_base[512];
// 5154E0: using guessed type __int16 png_sRGB_table[256];

//----- (0043D740) --------------------------------------------------------
int __cdecl png_image_read_colormapped(int a1)
{
  int v1; // ebp
  size_t Block; // esi
  int v3; // ebx
  int v4; // edi
  int v5; // edx
  size_t *v6; // ebx
  char *i; // ebp
  char v9; // al
  int rowbytes; // eax
  void *v11; // ebx
  char *v12; // [esp+4h] [ebp-38h]
  int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+18h] [ebp-24h]
  size_t **v15; // [esp+1Ch] [ebp-20h]

  v1 = 0;
  v15 = *(size_t ***)a1;
  Block = ***(_DWORD ***)a1;
  v3 = *(_DWORD *)(**(_DWORD **)a1 + 4);
  if ( !*(_DWORD *)(a1 + 40) )
    v1 = png_set_interlace_handling(**v15);
  if ( Block )
  {
    if ( (*(_BYTE *)(Block + 100) & 0x40) != 0 )
    {
      png_app_error(Block);
    }
    else
    {
      png_read_start_row((unsigned __int8 *)Block);
      png_read_transform_info(Block, (int *)v3);
    }
  }
  switch ( *(_DWORD *)(a1 + 40) )
  {
    case 0:
      v9 = *(_BYTE *)(v3 + 25);
      if ( v9 != 3 && v9 || *(_BYTE *)(v3 + 24) != 8 )
        goto LABEL_22;
      goto LABEL_11;
    case 1:
    case 2:
      if ( *(_WORD *)(v3 + 24) != 1032 || *(_DWORD *)(Block + 324) != 220000 || v15[6] != (size_t *)256 )
        goto LABEL_22;
      goto LABEL_11;
    case 3:
      if ( *(_WORD *)(v3 + 24) == 520 && *(_DWORD *)(Block + 324) == 220000 && v15[6] == (size_t *)216 )
        goto LABEL_11;
      goto LABEL_22;
    case 4:
      if ( *(_WORD *)(v3 + 24) != 1544 || *(_DWORD *)(Block + 324) != 220000 || v15[6] != (size_t *)244 )
        goto LABEL_22;
LABEL_11:
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_DWORD *)(a1 + 4);
      if ( v4 < 0 )
        v5 -= v4 * ((_DWORD)v15[3] - 1);
      *(_DWORD *)(a1 + 24) = v5;
      *(_DWORD *)(a1 + 28) = v4;
      if ( v1 )
      {
        v13 = v1 - 1;
        if ( v1 - 1 >= 0 )
        {
          do
          {
            v6 = v15[3];
            for ( i = *(char **)(a1 + 24); v6; v6 = (size_t *)((char *)v6 - 1) )
            {
              v12 = i;
              i += v4;
              png_read_row_constprop_6(Block, v12);
            }
            --v13;
          }
          while ( v13 != -1 );
        }
        return 1;
      }
      else
      {
        rowbytes = png_get_rowbytes(Block, v3);
        v11 = png_malloc(Block, rowbytes);
        *(_DWORD *)(a1 + 20) = v11;
        v14 = png_safe_execute((int)v15, png_image_read_and_map, a1);
        *(_DWORD *)(a1 + 20) = 0;
        png_free((void *)Block, v11);
        return v14;
      }
    default:
LABEL_22:
      png_err(Block);
  }
}

//----- (0043D950) --------------------------------------------------------
int __cdecl png_image_read_composite(int a1)
{
  size_t **v1; // edx
  char v2; // al
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // edx
  char *v9; // ebx
  int v10; // eax
  unsigned int v11; // edi
  char *v12; // eax
  int v13; // ecx
  int v14; // edi
  unsigned int v15; // ebp
  unsigned int v16; // ebp
  int v17; // ebp
  unsigned int v18; // ebp
  unsigned int v20; // [esp+14h] [ebp-58h]
  int v21; // [esp+18h] [ebp-54h]
  int v22; // [esp+1Ch] [ebp-50h]
  unsigned int v23; // [esp+20h] [ebp-4Ch]
  int v24; // [esp+24h] [ebp-48h]
  int v25; // [esp+28h] [ebp-44h]
  size_t v26; // [esp+2Ch] [ebp-40h]
  size_t *v27; // [esp+30h] [ebp-3Ch]
  int v28; // [esp+34h] [ebp-38h]
  int v29; // [esp+3Ch] [ebp-30h]
  int v30; // [esp+40h] [ebp-2Ch]
  int v31; // [esp+44h] [ebp-28h]
  size_t *v32; // [esp+48h] [ebp-24h]
  int v33; // [esp+4Ch] [ebp-20h]

  v1 = *(size_t ***)a1;
  v26 = ***(_DWORD ***)a1;
  v2 = *(_BYTE *)(v26 + 278);
  if ( v2 )
  {
    if ( v2 != 1 )
      png_err(v26);
    v31 = 7;
  }
  else
  {
    v31 = 1;
  }
  v27 = v1[3];
  v33 = *(_DWORD *)(a1 + 28);
  v32 = v1[2];
  if ( ((_BYTE)v1[4] & 2) != 0 )
  {
    v22 = 4;
    v29 = 3 * (_DWORD)v1[2];
    v3 = 3;
  }
  else
  {
    v29 = (int)v1[2];
    v3 = 1;
    v22 = 2;
  }
  v4 = 0;
  while ( 1 )
  {
    v8 = v4 + 1;
    v30 = v4 + 1;
    if ( v2 != 1 )
    {
      v21 = v3;
      v23 = 0;
      v25 = 1;
      v28 = 0;
      goto LABEL_14;
    }
    if ( (unsigned int)v4 <= 1 )
    {
      LOBYTE(v5) = 3;
      v6 = ~(unsigned __int8)((v4 & 1) << (3 - (v8 >> 1))) & 7;
    }
    else
    {
      v5 = (8 - v8) >> 1;
      v6 = (1 << v5) - 1 - (((v4 & 1) << (3 - (v8 >> 1))) & 7);
    }
    if ( ((unsigned int)v32 + v6) >> v5 )
      break;
LABEL_10:
    v7 = v4 + 1;
    if ( v31 == v30 )
      return 1;
LABEL_11:
    v4 = v7;
    v2 = *(_BYTE *)(v26 + 278);
  }
  v21 = v3 << ((8 - v30) >> 1);
  v28 = v3 * (((v4 & 1) << (3 - (v8 >> 1))) & 7);
  v23 = (((v4 & 1) == 0) << (3 - (v4 >> 1))) & 7;
  v25 = 8;
  if ( (unsigned int)v4 > 2 )
    v25 = 8 >> ((v4 - 1) >> 1);
LABEL_14:
  if ( (unsigned int)v27 <= v23 )
    goto LABEL_10;
  v24 = v33 * v23;
  do
  {
    v9 = *(char **)(a1 + 20);
    png_read_row_constprop_6(v26, v9);
    v10 = *(_DWORD *)(a1 + 24) + v24;
    v11 = v10 + v29;
    v12 = (char *)(v28 + v10);
    v20 = v11;
    if ( v11 > (unsigned int)v12 )
    {
      while ( 1 )
      {
        v13 = (unsigned __int8)v9[v3];
        if ( !(_BYTE)v13 )
          goto LABEL_18;
        if ( (_BYTE)v13 == 0xFF )
        {
          *v12 = *v9;
          if ( v3 != 1 )
          {
            v12[1] = v9[1];
            v12[2] = v9[2];
          }
          goto LABEL_18;
        }
        v14 = 255 - v13;
        v15 = 0xFFFF * (unsigned __int8)*v9 + (255 - v13) * (unsigned __int16)png_sRGB_table[(unsigned __int8)*v12];
        *v12 = (unsigned __int16)(png_sRGB_base[v15 >> 15]
                                + (((unsigned __int8)png_sRGB_delta[v15 >> 15] * (v15 & 0x7FFF)) >> 12)) >> 8;
        if ( v3 == 1 )
        {
LABEL_18:
          v9 += v22;
          v12 += v21;
          if ( v20 <= (unsigned int)v12 )
            break;
        }
        else
        {
          v16 = 0xFFFF * (unsigned __int8)v9[1] + v14 * (unsigned __int16)png_sRGB_table[(unsigned __int8)v12[1]];
          v12[1] = (unsigned __int16)(png_sRGB_base[v16 >> 15]
                                    + (((unsigned __int8)png_sRGB_delta[v16 >> 15] * (v16 & 0x7FFF)) >> 12)) >> 8;
          v17 = (unsigned __int8)v9[2];
          v9 += v22;
          v18 = 0xFFFF * v17 + (unsigned __int16)png_sRGB_table[(unsigned __int8)v12[2]] * v14;
          v12[2] = (unsigned __int16)((((unsigned __int8)png_sRGB_delta[v18 >> 15] * (v18 & 0x7FFF)) >> 12)
                                    + png_sRGB_base[v18 >> 15]) >> 8;
          v12 += v21;
          if ( v20 <= (unsigned int)v12 )
            break;
        }
      }
    }
    v23 += v25;
    v24 += v33 * v25;
  }
  while ( (unsigned int)v27 > v23 );
  v7 = v30;
  if ( v31 != v30 )
    goto LABEL_11;
  return 1;
}
// 43DB6A: conditional instruction was optimized away because esi.4==3
// 43DC2A: conditional instruction was optimized away because esi.4==3
// 514EE0: using guessed type __int16 png_sRGB_base[512];
// 5154E0: using guessed type __int16 png_sRGB_table[256];

//----- (0043DCD0) --------------------------------------------------------
int __cdecl png_image_read_direct(int a1)
{
  int *v1; // eax
  size_t Block; // ebx
  int v3; // ebp
  unsigned __int8 v4; // al
  int v5; // esi
  char v6; // di
  int v7; // esi
  int v8; // eax
  int v9; // ecx
  unsigned __int8 *v10; // edx
  __int16 v11; // dx
  int v12; // edx
  char v13; // al
  int v14; // edi
  int v15; // ecx
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // edx
  int v20; // edi
  int v21; // eax
  int *v22; // esi
  char *i; // ebp
  int v25; // eax
  int rowbytes; // eax
  void *v27; // esi
  int v28; // eax
  int v29; // eax
  BOOL v30; // eax
  char *v31; // [esp+4h] [ebp-D8h]
  int v32; // [esp+28h] [ebp-B4h]
  int v33; // [esp+28h] [ebp-B4h]
  int v34; // [esp+28h] [ebp-B4h]
  int **v35; // [esp+2Ch] [ebp-B0h]
  int v36; // [esp+30h] [ebp-ACh]
  int v37; // [esp+34h] [ebp-A8h]
  int v38; // [esp+38h] [ebp-A4h]
  int v39; // [esp+38h] [ebp-A4h]
  int v40; // [esp+38h] [ebp-A4h]
  int v41; // [esp+3Ch] [ebp-A0h]
  int v42; // [esp+3Ch] [ebp-A0h]
  int v43; // [esp+3Ch] [ebp-A0h]
  int v44; // [esp+40h] [ebp-9Ch]
  int v45; // [esp+40h] [ebp-9Ch]
  int v46; // [esp+40h] [ebp-9Ch]
  int v47; // [esp+44h] [ebp-98h]
  int v48; // [esp+48h] [ebp-94h]
  int v49; // [esp+4Ch] [ebp-90h]
  int v50; // [esp+50h] [ebp-8Ch]
  int v51; // [esp+54h] [ebp-88h]
  int v52; // [esp+58h] [ebp-84h]
  int v53; // [esp+5Ch] [ebp-80h]
  int v54; // [esp+60h] [ebp-7Ch]
  int v55; // [esp+64h] [ebp-78h]
  int v56; // [esp+68h] [ebp-74h]
  int v57; // [esp+6Ch] [ebp-70h]
  int v58; // [esp+70h] [ebp-6Ch]
  int v59; // [esp+B4h] [ebp-28h] BYREF
  __int16 v60; // [esp+B8h] [ebp-24h]
  __int16 v61; // [esp+BAh] [ebp-22h]
  __int16 v62; // [esp+BCh] [ebp-20h]

  v1 = **(int ***)a1;
  v35 = *(int ***)a1;
  Block = *v1;
  v3 = v1[1];
  v32 = *(_DWORD *)(*(_DWORD *)a1 + 16);
  v37 = v32 & 4;
  png_set_expand(*v1);
  v4 = *(_BYTE *)(Block + 281) & 2;
  v5 = v4 == 0 ? 1 : 3;
  if ( (*(_BYTE *)(Block + 281) & 4) == 0 && !*(_WORD *)(Block + 274) )
    v5 = v4;
  if ( *(_BYTE *)(Block + 282) == 16 )
    v5 |= 4u;
  v36 = 0;
  v6 = v5 | 8;
  if ( (*(_BYTE *)(Block + 281) & 1) == 0 )
    v6 = v5;
  v7 = v32 ^ v5;
  if ( (v7 & 2) != 0 )
  {
    if ( (v32 & 2) != 0 )
    {
      png_set_gray_to_rgb(Block);
    }
    else
    {
      v36 = v6 & 1;
      png_set_rgb_to_gray_fixed(Block, 1, -1, -1);
    }
    v7 &= ~2u;
  }
  v8 = -1;
  if ( (v6 & 4) != 0 )
    v8 = ((unsigned int)v35[5] & 4) == 0 ? 100000 : -1;
  png_set_alpha_mode_fixed(Block, 0, v8);
  if ( (v32 & 4) != 0 )
  {
    v38 = 100000;
    v9 = v6 & 1;
  }
  else
  {
    v9 = 0;
    v38 = -1;
  }
  if ( (v7 & 0x40) != 0 )
  {
    v7 &= ~0x40u;
    v9 = 2;
  }
  if ( v36 )
  {
    v43 = v9;
    v25 = png_muldiv(&v59, v38, *(_DWORD *)(Block + 460), 100000);
    v9 = v43;
    if ( !v25 || (v30 = png_gamma_significant(v59), v9 = v43, v30) )
    {
      if ( v9 == 1 )
      {
        v9 = 0;
        v36 = 2;
      }
    }
    else
    {
      v36 = 0;
    }
  }
  if ( (v7 & 4) != 0 )
  {
    v41 = v9;
    if ( (v32 & 4) != 0 )
      png_set_expand_16(Block);
    else
      png_set_scale_16(Block);
    v9 = v41;
    v7 &= ~4u;
  }
  v42 = 0;
  if ( (v7 & 1) != 0 )
  {
    if ( (v6 & 1) != 0 )
    {
      if ( v36 )
      {
        v36 = 2;
      }
      else
      {
        v44 = v9;
        if ( (v32 & 4) != 0 )
        {
          png_set_strip_alpha(Block);
          v9 = v44;
          v42 = 0;
        }
        else
        {
          v10 = *(unsigned __int8 **)(a1 + 16);
          if ( v10 )
          {
            LOBYTE(v59) = 0;
            HIWORD(v59) = *v10;
            v60 = v10[1];
            v11 = v10[2];
            v62 = v60;
            v61 = v11;
            png_set_background_fixed(Block, (int)&v59, 1, 0, 0);
            v9 = v44;
            v42 = 0;
          }
          else
          {
            v9 = 2;
            v42 = 1;
          }
        }
      }
    }
    else
    {
      v12 = 1;
      if ( (v32 & 0x20) != 0 )
      {
        v7 &= ~0x20u;
        v12 = 0;
      }
      v45 = v9;
      png_set_add_alpha(Block, v37 == 0 ? 255 : -1, v12);
      v42 = 0;
      v9 = v45;
    }
    v7 &= ~1u;
  }
  png_set_alpha_mode_fixed(Block, v9, v38);
  if ( (v7 & 0x10) != 0 )
  {
    if ( (v32 & 2) != 0 )
      png_set_bgr(Block);
    else
      v32 &= ~0x10u;
    v7 &= ~0x10u;
  }
  if ( (v7 & 0x20) != 0 )
  {
    if ( (v32 & 1) != 0 )
    {
      if ( v36 != 2 )
        png_set_swap_alpha(Block);
    }
    else
    {
      v32 &= ~0x20u;
    }
    v7 &= ~0x20u;
  }
  if ( v37 )
    png_set_swap(Block);
  if ( v7 )
    goto LABEL_92;
  if ( v42 || v36 == 2 )
    v58 = 0;
  else
    v58 = png_set_interlace_handling(Block);
  if ( (*(_BYTE *)(Block + 100) & 0x40) != 0 )
  {
    png_app_error(Block);
  }
  else
  {
    png_read_start_row((unsigned __int8 *)Block);
    png_read_transform_info(Block, (int *)v3);
  }
  v13 = *(_BYTE *)(v3 + 25) & 2;
  v57 = v13 == 0 ? 32 : 34;
  v56 = v13 == 0 ? 48 : 50;
  v55 = v13 == 0 ? 16 : 18;
  v54 = v13 == 0 ? 36 : 38;
  v53 = v13 == 0 ? 52 : 54;
  v52 = v13 == 0 ? 20 : 22;
  v51 = v13 == 0 ? 4 : 6;
  v50 = v13 == 0 ? 96 : 98;
  v14 = v13 == 0 ? 112 : 114;
  v15 = v13 == 0 ? 80 : 82;
  v49 = v13 == 0 ? 100 : 102;
  v48 = v13 == 0 ? 116 : 118;
  v47 = v13 == 0 ? 84 : 86;
  v46 = v13 == 0 ? 68 : 70;
  v39 = v13 == 0 ? 64 : 66;
  if ( v13 )
    v7 = 2;
  if ( (*(_BYTE *)(v3 + 25) & 4) != 0 )
  {
    if ( !v42 && (v36 != 2 || (v32 & 1) != 0) )
    {
      v14 = v13 == 0 ? 113 : 115;
      v7 = v13 == 0 ? 1 : 3;
      v15 = v13 == 0 ? 81 : 83;
      v57 = v13 == 0 ? 33 : 35;
      v56 = v13 == 0 ? 49 : 51;
      v55 = v13 == 0 ? 17 : 19;
      v54 = v13 == 0 ? 37 : 39;
      v53 = v13 == 0 ? 53 : 55;
      v52 = v13 == 0 ? 21 : 23;
      v51 = v13 == 0 ? 5 : 7;
      v50 = v13 == 0 ? 97 : 99;
      v49 = v13 == 0 ? 101 : 103;
      v48 = v13 == 0 ? 117 : 119;
      v47 = v13 == 0 ? 85 : 87;
      v46 = v13 == 0 ? 69 : 71;
      v39 = v13 == 0 ? 65 : 67;
    }
  }
  else if ( v42 )
  {
    goto LABEL_92;
  }
  if ( (v32 & 0x40) == 0 )
  {
    v14 = v56;
    v39 = v7;
    v15 = v55;
    v50 = v57;
    v49 = v54;
    v48 = v53;
    v47 = v52;
    v46 = v51;
  }
  v16 = v46;
  if ( *(_BYTE *)(v3 + 24) == 16 )
    v14 = v48;
  else
    v16 = v39;
  v17 = v49;
  if ( *(_BYTE *)(v3 + 24) != 16 )
    v17 = v50;
  v40 = v16;
  v18 = *(_DWORD *)(Block + 104);
  if ( *(_BYTE *)(v3 + 24) == 16 )
    v15 = v47;
  if ( (v18 & 1) == 0 )
  {
    v15 = v40;
    v14 = v17;
  }
  v19 = v18 & 0x20000;
  if ( v36 == 2 )
  {
    if ( (v32 & 0x20) != 0 )
      v15 = v14;
    if ( !v19 )
      goto LABEL_89;
LABEL_92:
    png_err(Block);
  }
  if ( v19 )
    goto LABEL_68;
LABEL_89:
  if ( (v18 & 0x1000000) != 0 && *(char *)(Block + 100) >= 0 )
  {
    if ( v36 == 2 )
      goto LABEL_92;
  }
  else
  {
    v14 = v15;
  }
LABEL_68:
  if ( v32 != v14 )
    goto LABEL_92;
  v20 = *(_DWORD *)(a1 + 8);
  v21 = *(_DWORD *)(a1 + 4);
  if ( v37 )
    v20 *= 2;
  if ( v20 < 0 )
    v21 -= v20 * ((_DWORD)v35[3] - 1);
  *(_DWORD *)(a1 + 24) = v21;
  *(_DWORD *)(a1 + 28) = v20;
  if ( v42 )
  {
    rowbytes = png_get_rowbytes(Block, v3);
    v27 = png_malloc(Block, rowbytes);
    *(_DWORD *)(a1 + 20) = v27;
    v28 = png_safe_execute((int)v35, png_image_read_composite, a1);
LABEL_100:
    v34 = v28;
    *(_DWORD *)(a1 + 20) = 0;
    png_free((void *)Block, v27);
    return v34;
  }
  if ( v36 == 2 )
  {
    v29 = png_get_rowbytes(Block, v3);
    v27 = png_malloc(Block, v29);
    *(_DWORD *)(a1 + 20) = v27;
    v28 = png_safe_execute((int)v35, png_image_read_background, a1);
    goto LABEL_100;
  }
  v33 = v58 - 1;
  if ( v58 - 1 >= 0 )
  {
    do
    {
      v22 = v35[3];
      for ( i = *(char **)(a1 + 24); v22; v22 = (int *)((char *)v22 - 1) )
      {
        v31 = i;
        i += v20;
        png_read_row_constprop_6(Block, v31);
      }
      --v33;
    }
    while ( v33 != -1 );
  }
  return 1;
}

//----- (0043E5E0) --------------------------------------------------------
int __cdecl png_image_read_header(int a1)
{
  int v1; // ebx
  int v2; // edi
  int v3; // eax
  char v4; // dl
  int v5; // eax
  char v6; // cl
  unsigned int v7; // eax

  v1 = **(_DWORD **)a1;
  v2 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  png_set_benign_errors(v1, 1);
  if ( v1 && v2 )
    png_read_info_part_2((_DWORD *)v1, v2);
  v3 = *(_DWORD *)(v1 + 220);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 216);
  *(_DWORD *)(a1 + 12) = v3;
  v4 = *(_BYTE *)(v1 + 281);
  v5 = (v4 & 2) == 0 ? 1 : 3;
  if ( (v4 & 4) == 0 && !*(_WORD *)(v1 + 274) )
    v5 = *(_BYTE *)(v1 + 281) & 2;
  v6 = *(_BYTE *)(v1 + 282);
  if ( v6 == 16 )
    v5 |= 4u;
  if ( (v4 & 1) != 0 )
    v5 |= 8u;
  *(_DWORD *)(a1 + 16) = v5;
  if ( (v5 & 2) != 0 && (*(_WORD *)(v1 + 534) & 0x8042) == 2 )
    *(_DWORD *)(a1 + 20) |= 1u;
  if ( v4 )
  {
    v7 = 256;
    if ( v4 != 3 )
      goto LABEL_19;
    v7 = *(unsigned __int16 *)(v1 + 272);
  }
  else
  {
    v7 = 1 << v6;
  }
  if ( v7 > 0x100 )
    v7 = 256;
LABEL_19:
  *(_DWORD *)(a1 + 24) = v7;
  return 1;
}

//----- (0043E6E0) --------------------------------------------------------
int __usercall png_image_read_init_part_4@<eax>(int *a1@<eax>)
{
  size_t *png_struct; // eax
  size_t Size; // esi
  _DWORD *v4; // eax
  size_t v5; // edx
  void **v6; // edx
  size_t v8; // [esp+28h] [ebp-14h] BYREF
  void **info_struct; // [esp+2Ch] [ebp-10h] BYREF

  png_struct = png_create_png_struct("1.6.34", (int)a1, (int)png_safe_error);
  Size = (size_t)png_struct;
  if ( png_struct )
  {
    png_struct[24] = 0x8000;
    png_struct[109] = 0x2000;
    png_set_read_fn(png_struct, 0, 0);
    v8 = Size;
    *a1 = 0;
    a1[23] = 0;
    memset(
      (void *)((unsigned int)(a1 + 1) & 0xFFFFFFFC),
      0,
      4 * (((unsigned int)a1 - ((unsigned int)(a1 + 1) & 0xFFFFFFFC) + 96) >> 2));
    a1[1] = 1;
    info_struct = (void **)png_create_info_struct(Size);
    if ( info_struct )
    {
      v4 = png_malloc_warn(v8, 0x18u);
      if ( v4 )
      {
        v5 = v8;
        v4[5] = 0;
        v4[2] = 0;
        *v4 = v5;
        v6 = info_struct;
        v4[3] = 0;
        v4[4] = 0;
        v4[1] = v6;
        *((_BYTE *)v4 + 20) = 0;
        *a1 = (int)v4;
        return 1;
      }
      png_destroy_info_struct((void *)v8, &info_struct);
    }
    png_destroy_read_struct((int *)&v8, 0, 0);
  }
  else
  {
    v8 = 0;
    *a1 = 0;
    a1[23] = 0;
    memset(
      (void *)((unsigned int)(a1 + 1) & 0xFFFFFFFC),
      0,
      4 * (((unsigned int)a1 - ((unsigned int)(a1 + 1) & 0xFFFFFFFC) + 96) >> 2));
    a1[1] = 1;
  }
  return png_image_error(a1, "png_image_read: out of memory");
}

//----- (0043E860) --------------------------------------------------------
_DWORD *__cdecl png_info_init_3(_DWORD **a1, unsigned int a2)
{
  _DWORD *result; // eax
  _BYTE *v3; // edi
  unsigned int v4; // ecx

  result = *a1;
  if ( *a1 )
  {
    if ( a2 <= 0x97 )
    {
      *a1 = 0;
      free(result);
      result = png_malloc_base(0, 0x98u);
      if ( !result )
        return result;
      *a1 = result;
    }
    *result = 0;
    result[37] = 0;
    v3 = (_BYTE *)((unsigned int)(result + 1) & 0xFFFFFFFC);
    v4 = (char *)result - v3 + 152;
    result = 0;
    memset(v3, 0, 4 * (v4 >> 2));
  }
  return result;
}

//----- (0043E8D0) --------------------------------------------------------
int __cdecl png_init_io(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
    *(_DWORD *)(a1 + 92) = a2;
  return result;
}

//----- (0043E8E0) --------------------------------------------------------
char __cdecl png_init_read_transformations(_DWORD *a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // edx
  bool v5; // zf
  unsigned int v6; // eax
  char v7; // dl
  int v8; // ecx
  int v9; // esi
  char v10; // al
  __int16 v11; // cx
  int v12; // ecx
  int v13; // edx
  unsigned int v14; // edi
  int v15; // ecx
  _BYTE *v16; // edx
  int v17; // edi
  _BYTE *v18; // esi
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // edx
  int v23; // ecx
  __int16 v24; // si
  __int16 v25; // bp
  char v26; // cl
  __int16 v27; // dx
  unsigned __int8 *v28; // edx
  __int16 v29; // cx
  int v30; // edi
  int v31; // esi
  BOOL v32; // ebp
  BOOL v33; // eax
  BOOL v34; // edx
  BOOL v35; // eax
  __int16 v36; // cx
  __int16 v37; // dx
  __int16 v38; // cx
  __int16 v39; // dx
  __int16 v40; // cx
  int v41; // eax
  int v42; // edi
  int v43; // esi
  unsigned __int8 v44; // dl
  int v45; // eax
  unsigned __int8 *v46; // esi
  int v47; // edi
  int v48; // ebp
  int v49; // edx
  __int16 v50; // ax
  __int16 v51; // ax
  int v52; // eax
  unsigned __int8 *v53; // ecx
  unsigned __int8 *v54; // esi
  unsigned __int8 *v55; // edi
  __int16 v56; // ax
  int v57; // ebp
  int v58; // edx
  int v59; // ebp
  int v60; // edx
  unsigned int v61; // kr04_4
  int v62; // edx
  unsigned __int8 *v63; // ecx
  int v64; // edx
  int v65; // eax
  int v66; // edx
  int v67; // esi
  int v68; // edi
  int v69; // eax
  unsigned __int8 v70; // al
  int v72; // [esp+10h] [ebp-4Ch]
  BOOL v73; // [esp+10h] [ebp-4Ch]
  BOOL v74; // [esp+10h] [ebp-4Ch]
  BOOL v75; // [esp+10h] [ebp-4Ch]
  unsigned __int8 v76; // [esp+10h] [ebp-4Ch]
  unsigned __int8 v77; // [esp+10h] [ebp-4Ch]
  unsigned __int8 v78; // [esp+14h] [ebp-48h]
  int v79; // [esp+14h] [ebp-48h]
  int v80; // [esp+18h] [ebp-44h]
  unsigned __int8 v81; // [esp+18h] [ebp-44h]
  unsigned int v82; // [esp+1Ch] [ebp-40h]
  int v83; // [esp+1Ch] [ebp-40h]
  unsigned __int8 *v84; // [esp+20h] [ebp-3Ch]
  unsigned __int8 v85; // [esp+27h] [ebp-35h]
  unsigned __int8 v86; // [esp+28h] [ebp-34h]
  unsigned __int8 v87; // [esp+29h] [ebp-33h]
  unsigned __int8 v88; // [esp+2Ah] [ebp-32h]
  unsigned __int8 v89; // [esp+2Bh] [ebp-31h]
  int v90; // [esp+2Ch] [ebp-30h]
  int v91[8]; // [esp+3Ch] [ebp-20h] BYREF

  v1 = a1[115];
  v2 = a1[81];
  if ( !v1 )
  {
    if ( v2 )
    {
      v41 = png_reciprocal(a1[81]);
      *((_WORD *)a1 + 267) |= 1u;
      a1[115] = v41;
      v3 = a1[81];
    }
    else
    {
      a1[115] = 100000;
      v3 = 100000;
      a1[81] = 100000;
      *((_WORD *)a1 + 267) |= 1u;
    }
    goto LABEL_4;
  }
  if ( !v2 )
  {
    v3 = png_reciprocal(v1);
    *((_WORD *)a1 + 267) |= 1u;
    a1[81] = v3;
LABEL_4:
    v4 = a1[26];
    BYTE1(v4) &= ~0x20u;
    a1[26] = v4;
    goto LABEL_5;
  }
  if ( png_muldiv(v91, a1[115], v2, 100000) )
  {
    v35 = png_gamma_significant(v91[0]);
    *((_WORD *)a1 + 267) |= 1u;
    if ( !v35 )
    {
      v3 = a1[81];
      goto LABEL_4;
    }
  }
  else
  {
    *((_WORD *)a1 + 267) |= 1u;
  }
  v4 = a1[26];
  v3 = a1[81];
  BYTE1(v4) |= 0x20u;
  a1[26] = v4;
LABEL_5:
  if ( (v4 & 0x40080) == 0x40000 )
  {
    a1[25] &= ~0x2000u;
    a1[26] = v4 & 0xFD7FFEFF;
    *((_WORD *)a1 + 137) = 0;
  }
  v5 = !png_gamma_significant(v3);
  v6 = a1[26];
  if ( v5 )
  {
    v6 &= ~0x800000u;
    a1[25] &= ~0x2000u;
    a1[26] = v6;
  }
  if ( (v6 & 0x600000) != 0 )
  {
    png_colorspace_set_rgb_coefficients((int)a1);
    v6 = a1[26];
  }
  v7 = *((_BYTE *)a1 + 281);
  if ( (v6 & 0x100) != 0 )
  {
    if ( (v7 & 2) == 0 )
      a1[24] |= 0x800u;
  }
  else if ( (v6 & 0x4080) == 16512 )
  {
    v11 = *((_WORD *)a1 + 151);
    if ( v11 == *((_WORD *)a1 + 152) && v11 == *((_WORD *)a1 + 153) )
    {
      a1[24] |= 0x800u;
      *((_WORD *)a1 + 154) = v11;
    }
  }
  v8 = *((unsigned __int16 *)a1 + 137);
  if ( v7 != 3 )
  {
    if ( (v7 & 4) == 0 )
    {
      a1[25] &= ~0x2000u;
      a1[26] = v6 & 0xFF7FFFFF;
      if ( (_WORD)v8 )
      {
        v6 &= ~0x800000u;
      }
      else
      {
        v6 &= 0xFF7FFE7F;
        a1[26] = v6;
      }
    }
    if ( (v6 & 0x1100) == 4352 && (v7 & 2) == 0 )
    {
      v24 = *((_WORD *)a1 + 154);
      v25 = *((_WORD *)a1 + 186);
      v26 = *((_BYTE *)a1 + 282);
      v27 = v24;
      switch ( v26 )
      {
        case 2:
          v25 *= 85;
          v27 = 85 * v24;
          break;
        case 4:
          v25 *= 17;
          v27 = 17 * v24;
          break;
        case 1:
          v25 *= 255;
          v27 = 255 * v24;
          break;
      }
      *((_WORD *)a1 + 153) = v27;
      *((_WORD *)a1 + 152) = v27;
      *((_WORD *)a1 + 151) = v27;
      if ( (v6 & 0x2000000) == 0 )
      {
        *((_WORD *)a1 + 185) = v25;
        *((_WORD *)a1 + 184) = v25;
        *((_WORD *)a1 + 183) = v25;
      }
    }
    goto LABEL_19;
  }
  if ( (_WORD)v8 )
  {
    v16 = (_BYTE *)a1[90];
    v17 = 0;
    v18 = &v16[v8];
    do
    {
      if ( *v16 != 0xFF )
      {
        if ( *v16 )
          goto LABEL_73;
        v17 = 1;
      }
      ++v16;
    }
    while ( v18 != v16 );
    a1[25] &= ~0x2000u;
    a1[26] = v6 & 0xFF7FFFFF;
    if ( v17 )
    {
      v6 &= ~0x800000u;
      goto LABEL_73;
    }
  }
  else
  {
    a1[25] &= ~0x2000u;
  }
  v6 &= 0xFF7FFE7F;
  a1[26] = v6;
LABEL_73:
  if ( (v6 & 0x1100) == 4352 )
  {
    v28 = (unsigned __int8 *)(a1[67] + 3 * *((unsigned __int8 *)a1 + 300));
    *((_WORD *)a1 + 151) = *v28;
    v29 = v28[1];
    LOWORD(v28) = v28[2];
    *((_WORD *)a1 + 152) = v29;
    *((_WORD *)a1 + 153) = (_WORD)v28;
  }
LABEL_19:
  if ( (v6 & 0x380) == 640 && *((_BYTE *)a1 + 282) != 16 )
  {
    v19 = *((unsigned __int16 *)a1 + 152);
    *((_WORD *)a1 + 151) = (255 * (unsigned int)*((unsigned __int16 *)a1 + 151) + 32895) >> 16;
    v20 = 255 * v19;
    v21 = *((unsigned __int16 *)a1 + 153);
    *((_WORD *)a1 + 152) = (unsigned int)(v20 + 32895) >> 16;
    v22 = 255 * v21;
    v23 = *((unsigned __int16 *)a1 + 154);
    *((_WORD *)a1 + 153) = (unsigned int)(v22 + 32895) >> 16;
    *((_WORD *)a1 + 154) = (unsigned int)(255 * v23 + 32895) >> 16;
  }
  if ( (v6 & 0x4000400) != 0 && (v6 & 0x180) == 128 && *((_BYTE *)a1 + 282) == 16 )
  {
    v36 = *((_WORD *)a1 + 152);
    *((_WORD *)a1 + 151) *= 257;
    v37 = 257 * v36;
    v38 = *((_WORD *)a1 + 153);
    *((_WORD *)a1 + 152) = v37;
    v39 = 257 * v38;
    v40 = *((_WORD *)a1 + 154);
    *((_WORD *)a1 + 153) = v39;
    *((_WORD *)a1 + 154) = 257 * v40;
  }
  *(_DWORD *)((char *)a1 + 310) = a1[75];
  *(_DWORD *)((char *)a1 + 314) = a1[76];
  *((_WORD *)a1 + 159) = *((_WORD *)a1 + 154);
  if ( (v6 & 0x2000) == 0 )
  {
    if ( (v6 & 0x600000) != 0 )
    {
      if ( png_gamma_significant(a1[115]) || png_gamma_significant(a1[81]) )
        goto LABEL_35;
      v6 = a1[26];
    }
    if ( (v6 & 0x80u) != 0 )
    {
      if ( png_gamma_significant(a1[115])
        || png_gamma_significant(a1[81])
        || *((_BYTE *)a1 + 294) == 3 && png_gamma_significant(a1[74]) )
      {
        goto LABEL_35;
      }
      v6 = a1[26];
      v82 = v6;
      if ( (v6 & 0x800000) == 0 )
        goto LABEL_28;
    }
    else if ( (v6 & 0x800000) == 0 )
    {
      return v6;
    }
    if ( !png_gamma_significant(a1[81]) )
    {
      v6 = a1[26];
      v82 = v6;
LABEL_28:
      if ( (v82 & 0x80u) != 0 && *((_BYTE *)a1 + 281) == 3 )
      {
        v52 = *((unsigned __int16 *)a1 + 137);
        v53 = (unsigned __int8 *)a1[67];
        v81 = *((_BYTE *)a1 + 302);
        v76 = *((_BYTE *)a1 + 304);
        v78 = *((_BYTE *)a1 + 306);
        if ( (_WORD)v52 )
        {
          v54 = (unsigned __int8 *)a1[90];
          v55 = &v54[v52];
          do
          {
            v56 = *v54;
            if ( (_BYTE)v56 )
            {
              if ( (_BYTE)v56 != 0xFF )
              {
                v57 = v53[1];
                *v53 = (*v53 * (unsigned __int8)v56 + v81 * (unsigned int)(unsigned __int16)(255 - v56) + 127) / 0xFF;
                v58 = v57 * *v54;
                v59 = v53[2];
                v53[1] = (v58 + v76 * (unsigned int)(unsigned __int16)(255 - *v54) + 127) / 0xFF;
                v53[2] = (v59 * *v54 + v78 * (unsigned int)(unsigned __int16)(255 - *v54) + 127) / 0xFF;
              }
            }
            else
            {
              *v53 = v81;
              v53[1] = v76;
              v53[2] = v78;
            }
            ++v54;
            v53 += 3;
          }
          while ( v55 != v54 );
        }
        v6 = v82;
        LOBYTE(v6) = v82 & 0x7F;
        a1[26] = v6;
      }
      return v6;
    }
  }
LABEL_35:
  LOBYTE(v6) = png_build_gamma_table((void **)a1, *((unsigned __int8 *)a1 + 282));
  v9 = a1[26];
  if ( (v9 & 0x80) != 0 )
  {
    v10 = *((_BYTE *)a1 + 294);
    if ( *((_BYTE *)a1 + 281) != 3 )
    {
      switch ( v10 )
      {
        case 2:
          v30 = png_reciprocal(a1[115]);
          v31 = png_reciprocal2(a1[115], a1[81]);
          break;
        case 3:
          v30 = png_reciprocal(a1[74]);
          v31 = png_reciprocal2(a1[74], a1[81]);
          break;
        case 1:
          v30 = a1[81];
          v31 = 100000;
          break;
        default:
          png_err((int)a1);
      }
      v32 = png_gamma_significant(v30);
      v33 = png_gamma_significant(v31);
      v34 = v33;
      if ( v32 )
      {
        v74 = v33;
        v51 = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 154), v30);
        v34 = v74;
        *((_WORD *)a1 + 159) = v51;
      }
      if ( v34 )
      {
        v73 = v34;
        v50 = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 154), v31);
        v34 = v73;
        *((_WORD *)a1 + 154) = v50;
      }
      v6 = *((unsigned __int16 *)a1 + 151);
      if ( (_WORD)v6 == *((_WORD *)a1 + 152) && (_WORD)v6 == *((_WORD *)a1 + 153) && (_WORD)v6 == *((_WORD *)a1 + 154) )
      {
        LOWORD(v6) = *((_WORD *)a1 + 159);
        *((_WORD *)a1 + 158) = v6;
        *((_WORD *)a1 + 157) = v6;
        *((_WORD *)a1 + 156) = v6;
      }
      else
      {
        if ( v32 )
        {
          v75 = v34;
          *((_WORD *)a1 + 156) = png_gamma_correct((int)a1, v6, v30);
          *((_WORD *)a1 + 157) = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 152), v30);
          LOWORD(v6) = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 153), v30);
          v34 = v75;
          *((_WORD *)a1 + 158) = v6;
        }
        if ( v34 )
        {
          *((_WORD *)a1 + 151) = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 151), v31);
          *((_WORD *)a1 + 152) = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 152), v31);
          LOWORD(v6) = png_gamma_correct((int)a1, *((unsigned __int16 *)a1 + 153), v31);
          *((_WORD *)a1 + 153) = v6;
        }
      }
      *((_BYTE *)a1 + 294) = 1;
      return v6;
    }
    v84 = (unsigned __int8 *)a1[67];
    v80 = *((unsigned __int16 *)a1 + 136);
    if ( v10 == 2 )
    {
      v65 = a1[82];
      v66 = *((unsigned __int16 *)a1 + 151);
      v67 = *((unsigned __int16 *)a1 + 152);
      v68 = *((unsigned __int16 *)a1 + 153);
      v87 = *(_BYTE *)(v65 + v66);
      v88 = *(_BYTE *)(v65 + v67);
      v89 = *(_BYTE *)(v65 + v68);
      v69 = a1[85];
      v44 = *(_BYTE *)(v69 + v66);
      v85 = *(_BYTE *)(v69 + v67);
      v86 = *(_BYTE *)(v69 + v68);
    }
    else
    {
      if ( v10 == 1 )
      {
        v43 = a1[81];
        v42 = 100000;
      }
      else if ( v10 == 3 )
      {
        v43 = png_reciprocal(a1[74]);
        v42 = png_reciprocal2(a1[74], a1[81]);
      }
      else
      {
        v42 = 100000;
        v43 = 100000;
      }
      if ( png_gamma_significant(v42) )
      {
        v87 = png_gamma_8bit_correct(*((unsigned __int16 *)a1 + 151), v42);
        v88 = png_gamma_8bit_correct(*((unsigned __int16 *)a1 + 152), v42);
        v89 = png_gamma_8bit_correct(*((unsigned __int16 *)a1 + 153), v42);
      }
      else
      {
        v87 = *((_BYTE *)a1 + 302);
        v88 = *((_BYTE *)a1 + 304);
        v89 = *((_BYTE *)a1 + 306);
      }
      if ( png_gamma_significant(v43) )
      {
        v77 = png_gamma_8bit_correct(*((unsigned __int16 *)a1 + 151), v43);
        v85 = png_gamma_8bit_correct(*((unsigned __int16 *)a1 + 152), v43);
        v70 = png_gamma_8bit_correct(*((unsigned __int16 *)a1 + 153), v43);
        v44 = v77;
        v86 = v70;
      }
      else
      {
        v44 = *((_BYTE *)a1 + 302);
        v85 = *((_BYTE *)a1 + 304);
        v86 = *((_BYTE *)a1 + 306);
      }
    }
    LOBYTE(v6) = v80;
    if ( v80 )
    {
      v45 = *((unsigned __int16 *)a1 + 137);
      if ( *((_WORD *)a1 + 137) )
      {
        v46 = v84;
        if ( v45 > v80 )
          v45 = v80;
        v47 = a1[90];
        v48 = 0;
        v72 = v45;
        v90 = v44;
        do
        {
          while ( 1 )
          {
            LOWORD(v6) = *(unsigned __int8 *)(v47 + v48);
            if ( (_BYTE)v6 != 0xFF )
              break;
            v6 = a1[82];
            v49 = *v46;
            ++v48;
            v46 += 3;
            *(v46 - 3) = *(_BYTE *)(v6 + v49);
            *(v46 - 2) = *(_BYTE *)(v6 + *(v46 - 2));
            LOBYTE(v6) = *(_BYTE *)(v6 + *(v46 - 1));
            *(v46 - 1) = v6;
            if ( v48 >= v72 )
              goto LABEL_119;
          }
          if ( (_BYTE)v6 )
          {
            v79 = a1[84];
            v83 = a1[85];
            v60 = v46[1];
            *v46 = *(_BYTE *)(v79
                            + (unsigned __int8)((*(unsigned __int8 *)(v83 + *v46) * (unsigned __int8)v6
                                               + v90 * (unsigned int)(unsigned __int16)(255 - v6)
                                               + 127)
                                              / 0xFF));
            v61 = *(unsigned __int8 *)(v83 + v60) * *(unsigned __int8 *)(v47 + v48)
                + v85 * (unsigned __int16)(255 - *(unsigned __int8 *)(v47 + v48))
                + 127;
            v62 = v46[2];
            v46[1] = *(_BYTE *)(v79 + (unsigned __int8)(v61 / 0xFF));
            LOBYTE(v6) = *(_BYTE *)(v79
                                  + (unsigned __int8)((*(unsigned __int8 *)(v83 + v62) * *(unsigned __int8 *)(v47 + v48)
                                                     + v86
                                                     * (unsigned int)(unsigned __int16)(255
                                                                                      - *(unsigned __int8 *)(v47 + v48))
                                                     + 127)
                                                    / 0xFF));
            v46[2] = v6;
          }
          else
          {
            *v46 = v87;
            v46[1] = v88;
            LOBYTE(v6) = v89;
            v46[2] = v89;
          }
          ++v48;
          v46 += 3;
        }
        while ( v48 < v72 );
LABEL_119:
        if ( v80 <= v48 )
          goto LABEL_120;
      }
      else
      {
        v48 = 0;
      }
      v6 = a1[82];
      v63 = &v84[3 * v48];
      do
      {
        v64 = *v63;
        ++v48;
        v63 += 3;
        *(v63 - 3) = *(_BYTE *)(v6 + v64);
        *(v63 - 2) = *(_BYTE *)(v6 + *(v63 - 2));
        *(v63 - 1) = *(_BYTE *)(v6 + *(v63 - 1));
      }
      while ( v80 > v48 );
      a1[26] &= 0xFFFFDF7F;
      return v6;
    }
LABEL_120:
    a1[26] &= 0xFFFFDF7F;
    return v6;
  }
  if ( *((_BYTE *)a1 + 281) == 3 && ((v9 & 0x1000) == 0 || (v9 & 0x600000) == 0) )
  {
    v12 = *((unsigned __int16 *)a1 + 136);
    v6 = a1[67];
    if ( (_WORD)v12 )
    {
      v13 = a1[82];
      v14 = v6 + 3 * v12;
      do
      {
        v15 = *(unsigned __int8 *)v6;
        v6 += 3;
        *(_BYTE *)(v6 - 3) = *(_BYTE *)(v13 + v15);
        *(_BYTE *)(v6 - 2) = *(_BYTE *)(v13 + *(unsigned __int8 *)(v6 - 2));
        *(_BYTE *)(v6 - 1) = *(_BYTE *)(v13 + *(unsigned __int8 *)(v6 - 1));
      }
      while ( v14 != v6 );
    }
    a1[26] = v9 & 0xFFFFDFFF;
  }
  return v6;
}
// 43E8E0: using guessed type int var_20[8];

//----- (0043F6B0) --------------------------------------------------------
void __cdecl __noreturn png_longjmp(int a1, int a2)
{
  void (__cdecl *v2)(int, int); // edx
  int v3; // eax

  if ( a1 )
  {
    v2 = *(void (__cdecl **)(int, int))(a1 + 64);
    if ( v2 )
    {
      v3 = *(_DWORD *)(a1 + 68);
      if ( v3 )
        v2(v3, a2);
    }
  }
  ExitProcess(0);
}

//----- (0043F6F0) --------------------------------------------------------
void *__cdecl png_malloc(int a1, size_t Size)
{
  void *result; // eax

  if ( !a1 )
    return 0;
  if ( !Size || (result = malloc(Size)) == 0 )
    png_err(a1);
  return result;
}

//----- (0043F730) --------------------------------------------------------
void *__cdecl png_malloc_base(size_t Size, size_t a2)
{
  if ( a2 )
    return malloc(a2);
  else
    return 0;
}

//----- (0043F750) --------------------------------------------------------
void *__cdecl png_malloc_warn(size_t Size, size_t a2)
{
  if ( a2 && Size )
    return malloc(a2);
  else
    return 0;
}

//----- (0043F780) --------------------------------------------------------
int __cdecl png_muldiv(int *a1, int a2, int a3, int a4)
{
  if ( !a4 )
    return 0;
  if ( a2 && a3 )
    return png_muldiv_part_3(a1, a2, a3, a4);
  *a1 = 0;
  return 1;
}

//----- (0043F7D0) --------------------------------------------------------
int __usercall png_muldiv_part_3@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // eax
  int v5; // ebx
  unsigned int v6; // edi
  int v7; // esi
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // ebp
  int v11; // ebx
  int v12; // edx
  int v13; // eax
  int v14; // kr00_4
  unsigned int v15; // esi
  unsigned int v16; // edx
  int v18; // ebp
  int v19; // eax
  int v20; // edx
  unsigned int v21; // edx
  unsigned int v22; // ebx
  unsigned int v23; // ecx
  char v24; // cl
  int v25; // ebp
  unsigned int v26; // [esp+0h] [ebp-1Ch]
  int v27; // [esp+4h] [ebp-18h]

  if ( a2 < 0 )
  {
    a2 = -a2;
    v4 = 0;
    v27 = 1;
  }
  else
  {
    v27 = 0;
    v4 = 1;
  }
  if ( a3 < 0 )
  {
    v5 = v27;
    a3 = -a3;
    v27 = v4;
    v4 = v5;
  }
  v6 = a4;
  if ( a4 < 0 )
  {
    v27 = v4;
    v6 = -a4;
  }
  v7 = (unsigned __int16)a2;
  v8 = (unsigned __int16)a3;
  v9 = HIWORD(a3);
  v10 = HIWORD(a2);
  v11 = v9 * (unsigned __int16)a2;
  v12 = v8 * HIWORD(a2);
  v13 = v7 * v8;
  v14 = (v12 + v11) << 16;
  v15 = v13 + v14;
  v16 = v10 * v9 + ((unsigned __int64)(unsigned int)(v12 + v11) >> 16) - (!__CFADD__(v13, v14) - 1);
  if ( v6 <= v16 )
    return 0;
  v18 = 0;
  v19 = 31;
  v26 = v16;
LABEL_14:
  v22 = v6 >> (32 - v19);
  v23 = v6 << v19;
  v21 = v26;
  while ( 1 )
  {
    if ( v22 < v21 )
    {
      v20 = (__PAIR64__(v21, v15) - v23) >> 32;
      v15 -= v23;
      v21 = v20 - v22;
      v18 += 1 << v19;
      goto LABEL_11;
    }
    if ( v22 == v21 && v23 <= v15 )
      break;
LABEL_11:
    if ( --v19 == -1 )
      goto LABEL_19;
LABEL_12:
    v22 = 0;
    if ( v19 )
    {
      v26 = v21;
      goto LABEL_14;
    }
    v23 = v6;
  }
  v15 -= v23;
  v24 = v19--;
  v18 += 1 << v24;
  v21 = 0;
  if ( v19 != -1 )
    goto LABEL_12;
LABEL_19:
  v25 = v18 - ((v15 < v6 >> 1) - 1);
  if ( v27 )
  {
    if ( v25 >= 0 )
    {
      v25 = -v25;
      goto LABEL_22;
    }
    return 0;
  }
  else if ( v25 >= 0 )
  {
LABEL_22:
    *a1 = v25;
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (0043F940) --------------------------------------------------------
int __cdecl png_muldiv_warn(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+10h] [ebp-4h] BYREF

  if ( a4 && a2 && a3 && png_muldiv_part_3(&v5, a2, a3, a4) )
    return v5;
  else
    return 0;
}

//----- (0043F990) --------------------------------------------------------
int __cdecl png_read_IDAT_data(size_t Block, int a2, int a3)
{
  int v3; // esi
  int result; // eax
  int v5; // edx
  int v6; // ecx
  unsigned int chunk_header; // eax
  bool v8; // zf
  void *v9; // ecx
  size_t Size; // ebp
  void *v11; // eax
  int v12; // edx
  _BYTE *v13; // [esp+1Ch] [ebp-420h]
  void *v14; // [esp+1Ch] [ebp-420h]
  char v15; // [esp+20h] [ebp-41Ch] BYREF

  v3 = 0;
  *(_DWORD *)(Block + 124) = a2;
  if ( a2 )
    v3 = a3;
  *(_DWORD *)(Block + 128) = 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(Block + 116) )
      goto LABEL_16;
    chunk_header = *(_DWORD *)(Block + 260);
    while ( !chunk_header )
    {
      png_crc_finish_constprop_7(Block);
      chunk_header = png_read_chunk_header(Block);
      v8 = *(_DWORD *)(Block + 244) == 1229209940;
      *(_DWORD *)(Block + 260) = chunk_header;
      if ( !v8 )
        goto LABEL_36;
    }
    v9 = *(void **)(Block + 428);
    if ( *(_DWORD *)(Block + 436) <= chunk_header )
      chunk_header = *(_DWORD *)(Block + 436);
    Size = chunk_header;
    if ( !v9 )
      goto LABEL_27;
    if ( chunk_header > *(_DWORD *)(Block + 432) )
    {
      *(_DWORD *)(Block + 428) = 0;
      *(_DWORD *)(Block + 432) = 0;
      png_free((void *)Block, v9);
LABEL_27:
      v11 = png_malloc_base(Block, Size);
      if ( !v11 )
        goto LABEL_36;
      v14 = v11;
      memset(v11, 0, Size);
      v9 = v14;
      *(_DWORD *)(Block + 432) = Size;
      *(_DWORD *)(Block + 428) = v14;
    }
    v13 = v9;
    png_read_data(Block);
    png_calculate_crc(Block, v13, Size);
    *(_DWORD *)(Block + 260) -= Size;
    *(_DWORD *)(Block + 116) = Size;
    *(_DWORD *)(Block + 112) = v13;
LABEL_16:
    if ( a2 )
    {
      *(_DWORD *)(Block + 128) = v3;
      v3 = 0;
    }
    else
    {
      *(_DWORD *)(Block + 128) = 1024;
      *(_DWORD *)(Block + 124) = &v15;
    }
    if ( !*(_BYTE *)(Block + 290) || !*(_DWORD *)(Block + 116) )
      goto LABEL_9;
    if ( **(char **)(Block + 112) >= 0 )
    {
      *(_BYTE *)(Block + 290) = 0;
LABEL_9:
      result = inflate(Block + 112, 0);
      goto LABEL_10;
    }
    *(_DWORD *)(Block + 136) = "invalid window size (libpng)";
    result = -3;
LABEL_10:
    v5 = *(_DWORD *)(Block + 128);
    *(_DWORD *)(Block + 128) = 0;
    v6 = v3 + v5;
    v3 = v3 - v5 + 1024;
    if ( a2 )
      v3 = v6;
    if ( result == 1 )
      break;
    if ( result )
    {
      png_zstream_error(Block, result);
      if ( !a2 )
        return png_chunk_benign_error(Block);
      goto LABEL_36;
    }
    if ( !v3 )
      return result;
  }
  v12 = *(_DWORD *)(Block + 116);
  *(_DWORD *)(Block + 124) = 0;
  *(_DWORD *)(Block + 96) |= 8u;
  *(_DWORD *)(Block + 100) |= 8u;
  if ( v12 || (result = *(_DWORD *)(Block + 260)) != 0 )
    result = png_chunk_benign_error(Block);
  if ( v3 )
  {
    if ( !a2 )
      return png_chunk_benign_error(Block);
LABEL_36:
    png_err(Block);
  }
  return result;
}

//----- (0043FC10) --------------------------------------------------------
int __cdecl png_read_chunk_header(int a1)
{
  int v1; // ebx
  unsigned int v2; // edx
  int v3; // eax
  int v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v8; // ecx
  unsigned __int8 v9; // [esp+18h] [ebp-14h]
  unsigned __int8 v10; // [esp+19h] [ebp-13h]
  unsigned __int8 v11; // [esp+1Ah] [ebp-12h]
  unsigned __int8 v12; // [esp+1Bh] [ebp-11h]
  unsigned int v13[4]; // [esp+1Ch] [ebp-10h] BYREF

  png_read_data(a1);
  v1 = v12 + (v9 << 24) + (v10 << 16) + (v11 << 8);
  if ( v1 < 0 )
    goto LABEL_24;
  *(_DWORD *)(a1 + 244) = _byteswap_ulong(v13[0]);
  png_reset_crc(a1);
  png_calculate_crc(a1, v13, 4u);
  v2 = *(_DWORD *)(a1 + 244);
  if ( (unsigned int)(unsigned __int8)v2 - 65 > 0x39
    || (unsigned int)(unsigned __int8)v2 - 91 <= 5
    || (unsigned int)BYTE1(v2) - 91 <= 5
    || (unsigned int)BYTE1(v2) - 65 > 0x39
    || (unsigned int)BYTE2(v2) - 91 <= 5
    || (unsigned int)BYTE2(v2) - 65 > 0x39
    || HIBYTE(v2) - 65 > 0x39u
    || HIBYTE(v2) - 91 <= 5u )
  {
    goto LABEL_24;
  }
  v3 = 8000000;
  if ( v2 == 1229209940 )
  {
    v5 = *(_DWORD *)(a1 + 216) * *(unsigned __int8 *)(a1 + 285);
    if ( *(_BYTE *)(a1 + 282) > 8u )
      v5 *= 2;
    v6 = v5 + (*(_BYTE *)(a1 + 278) != 0 ? 6 : 0) + 1;
    v7 = *(_DWORD *)(a1 + 220) * v6;
    if ( is_mul_ok(*(_DWORD *)(a1 + 220), v6) )
    {
      v8 = v7 + 6;
    }
    else
    {
      v8 = -2147483643;
      v7 = 0x7FFFFFFF;
    }
    if ( v6 > 0x7F36 )
      v6 = 32566;
    v3 = v8 + 5 * (v7 / v6) + 5;
    if ( v3 < 0 )
      v3 = 0x7FFFFFFF;
    if ( (unsigned int)v3 < 0x7A1200 )
      v3 = 8000000;
  }
  if ( v3 < (unsigned int)v1 )
LABEL_24:
    png_err(a1);
  return v12 + (v9 << 24) + (v10 << 16) + (v11 << 8);
}
// 43FC4E: variable 'v12' is possibly undefined
// 43FC32: variable 'v9' is possibly undefined
// 43FC44: variable 'v10' is possibly undefined
// 43FC37: variable 'v11' is possibly undefined
// 43FC10: using guessed type unsigned int var_10[4];

//----- (0043FDA0) --------------------------------------------------------
int __cdecl png_read_data(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(a1 + 88);
  if ( !v1 )
    png_err(a1);
  return v1();
}

//----- (0043FDC0) --------------------------------------------------------
void __cdecl png_read_end(int a1, int a2)
{
  int chunk_header; // eax
  int v3; // edx
  int v4; // [esp+1Ch] [ebp-10h]

  if ( a1 )
  {
    png_read_finish_IDAT((_DWORD *)a1);
    while ( 1 )
    {
      chunk_header = png_read_chunk_header(a1);
      v3 = *(_DWORD *)(a1 + 244);
      if ( v3 == 1229209940 )
        break;
      *(_DWORD *)(a1 + 96) |= 0x2000u;
      if ( v3 == 1229278788 )
      {
        png_handle_IEND(a1, a2, chunk_header);
        goto LABEL_21;
      }
      if ( v3 == 1229472850 )
      {
        png_handle_IHDR(a1, a2, chunk_header);
        goto LABEL_21;
      }
      if ( a2 )
      {
        switch ( v3 )
        {
          case 1347179589:
            png_handle_PLTE((_DWORD *)a1, a2, chunk_header);
            goto LABEL_21;
          case 1649100612:
            png_handle_bKGD(a1, a2, chunk_header);
            goto LABEL_21;
          case 1665684045:
            png_handle_cHRM(a1, a2, chunk_header);
            goto LABEL_21;
          case 1732332865:
            png_handle_gAMA(a1, a2, chunk_header);
            goto LABEL_21;
          case 1933723988:
            png_handle_sBIT(a1, a2, chunk_header);
            goto LABEL_21;
          case 1934772034:
            png_handle_sRGB(a1, a2, chunk_header);
            goto LABEL_21;
          case 1951551059:
            png_handle_tRNS((_DWORD *)a1, a2, chunk_header);
            goto LABEL_21;
        }
        png_handle_unknown(a1, a2, chunk_header);
        if ( (*(_BYTE *)(a1 + 96) & 0x10) != 0 )
          return;
      }
      else
      {
LABEL_20:
        png_crc_finish(a1, chunk_header);
LABEL_21:
        if ( (*(_BYTE *)(a1 + 96) & 0x10) != 0 )
          return;
      }
    }
    if ( a2 && (chunk_header && (*(_BYTE *)(a1 + 100) & 8) == 0 || (*(_BYTE *)(a1 + 97) & 0x20) != 0) )
    {
      v4 = chunk_header;
      png_benign_error(a1);
      chunk_header = v4;
    }
    goto LABEL_20;
  }
}

//----- (0043FFC0) --------------------------------------------------------
int __cdecl png_read_filter_row(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int v6; // ecx
  bool v7; // zf
  void *v8; // ecx

  result = a1;
  if ( (unsigned int)(a5 - 1) <= 3 )
  {
    if ( !*(_DWORD *)(a1 + 444) )
    {
      v6 = *(unsigned __int8 *)(a1 + 284);
      *(_DWORD *)(a1 + 444) = png_read_filter_row_sub;
      *(_DWORD *)(a1 + 448) = png_read_filter_row_up;
      *(_DWORD *)(a1 + 452) = png_read_filter_row_avg;
      v7 = (v6 + 7) >> 3 == 1;
      v8 = png_read_filter_row_paeth_multibyte_pixel;
      if ( v7 )
        v8 = png_read_filter_row_paeth_1byte_pixel;
      *(_DWORD *)(a1 + 456) = v8;
    }
    return (*(int (__cdecl **)(int, int, int))(a1 + 4 * a5 + 440))(a2, a3, a4);
  }
  return result;
}

//----- (00440060) --------------------------------------------------------
_BYTE *__cdecl png_read_filter_row_avg(int a1, _BYTE *a2, unsigned __int8 *a3)
{
  _BYTE *v3; // edx
  unsigned __int8 *v4; // ebp
  int v5; // ebx
  int v6; // edi
  unsigned __int8 *v7; // esi
  _BYTE *result; // eax
  unsigned __int8 v9; // cl
  int v10; // ebx
  unsigned __int8 *v11; // ecx
  _BYTE *v12; // esi
  int v13; // edx

  v3 = a2;
  v4 = a3;
  v5 = (*(unsigned __int8 *)(a1 + 11) + 7) >> 3;
  v6 = *(_DWORD *)(a1 + 4) - v5;
  if ( v5 )
  {
    v7 = a3;
    result = &a2[v5];
    do
    {
      v9 = *v7++;
      *v3++ += v9 >> 1;
    }
    while ( v3 != result );
    v4 = &a3[v5];
  }
  else
  {
    result = a2;
  }
  v10 = -v5;
  v11 = v4;
  v12 = &result[v6];
  if ( v6 )
  {
    do
    {
      v13 = *v11++;
      *result += ((unsigned __int8)result[v10] + v13) >> 1;
      ++result;
    }
    while ( result != v12 );
  }
  return result;
}

//----- (004400E0) --------------------------------------------------------
int __cdecl png_read_filter_row_paeth_1byte_pixel(int a1, _BYTE *a2, unsigned __int8 *a3)
{
  int v3; // esi
  int v4; // edi
  char v5; // cl
  int result; // eax
  unsigned __int8 *v7; // esi
  int v8; // ecx
  unsigned __int8 *v9; // ebx
  int v10; // eax
  int v11; // edi
  signed int v12; // edx
  int v13; // ecx
  signed int v14; // eax
  bool v15; // cc
  int v16; // eax
  int v17; // [esp+0h] [ebp-20h]
  int v18; // [esp+4h] [ebp-1Ch]
  int v19; // [esp+8h] [ebp-18h]
  unsigned __int8 *v20; // [esp+Ch] [ebp-14h]

  v3 = *a3;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = *a2 + v3;
  result = (unsigned __int8)*a2 + v3;
  v17 = v3;
  v7 = a2 + 1;
  *a2 = v5;
  if ( a2 + 1 < &a2[v4] )
  {
    v8 = v17;
    v20 = &a3[v4];
    v9 = a3 + 1;
    while ( 1 )
    {
      ++v9;
      v19 = (unsigned __int8)result;
      v18 = *(v9 - 1);
      v10 = (unsigned __int8)result - v8;
      v11 = v18 - v8;
      v12 = abs32(v18 - v8);
      v13 = (v10 ^ ((v19 - v8) >> 31)) - ((v19 - v8) >> 31);
      v14 = abs32(v11 + v10);
      if ( v13 < v12 )
      {
        v12 = v13;
        v19 = *(v9 - 1);
      }
      v15 = v12 <= v14;
      v16 = *v7;
      if ( v15 )
      {
        result = v19 + v16;
        *v7++ = result;
        if ( v20 == v9 )
          return result;
      }
      else
      {
        result = v17 + v16;
        *v7++ = result;
        if ( v20 == v9 )
          return result;
      }
      v17 = v18;
      v8 = v18;
    }
  }
  return result;
}

//----- (004401C0) --------------------------------------------------------
char __cdecl png_read_filter_row_paeth_multibyte_pixel(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  int v4; // eax
  char *v5; // ebp
  int *v6; // ecx
  int *v7; // ebx
  int *v8; // esi
  int v9; // edi
  int v10; // eax
  unsigned int v11; // edx
  _BYTE *v12; // eax
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  int v15; // eax
  int v16; // ebx
  int v17; // eax
  signed int v18; // edx
  signed int v19; // ecx
  signed int v20; // eax
  char v21; // al
  char v22; // al
  unsigned int v23; // ecx
  char *v24; // eax
  char v25; // bl
  int v27; // [esp+0h] [ebp-24h]
  int v28; // [esp+0h] [ebp-24h]
  unsigned int v29; // [esp+4h] [ebp-20h]
  unsigned int v30; // [esp+Ch] [ebp-18h]
  int v31; // [esp+10h] [ebp-14h]

  v3 = a3;
  v4 = (*(unsigned __int8 *)(a1 + 11) + 7) >> 3;
  v27 = v4;
  v5 = (char *)(v4 + a2);
  if ( a2 >= v4 + a2 )
  {
    v5 = (char *)a2;
  }
  else
  {
    v6 = (int *)a2;
    if ( (((unsigned __int8)a2 | (unsigned __int8)a3) & 3) == 0
      && (a2 >= a3 + 4 || a3 >= a2 + 4)
      && (unsigned int)&v5[~a2] > 2 )
    {
      v29 = v4 + a2;
      v7 = (int *)a3;
      v8 = (int *)(a2 + (((*(unsigned __int8 *)(a1 + 11) + 7) >> 3) & 0x3C));
      do
      {
        v9 = *v6;
        v10 = *v7;
        ++v6;
        ++v7;
        *(v6 - 1) = (v9 ^ v10) & 0x80808080 ^ ((v9 & 0x7F7F7F7F) + (v10 & 0x7F7F7F7F));
      }
      while ( v8 != v6 );
      v11 = a3 + v27;
      v12 = (_BYTE *)((v27 & 0xFFFFFFFC) + a2);
      v13 = (_BYTE *)(a3 + (v27 & 0xFFFFFFFC));
      if ( v27 != (v27 & 0xFFFFFFFC) )
      {
        *v12 += *v13;
        if ( v29 > (unsigned int)(v12 + 1) )
        {
          v12[1] += v13[1];
          if ( v29 > (unsigned int)(v12 + 2) )
            v12[2] += v13[2];
        }
      }
    }
    else
    {
      v23 = a3;
      v11 = a3 + v4;
      v24 = (char *)a2;
      do
      {
        ++v23;
        v25 = *v24++;
        *(v24 - 1) = *(_BYTE *)(v23 - 1) + v25;
      }
      while ( v11 != v23 );
    }
    v3 = v11;
  }
  v14 = *(_DWORD *)(a1 + 4) + a2;
  v31 = -v27;
  v30 = v3 + v14 - (_DWORD)v5;
  if ( v14 > (unsigned int)v5 )
  {
    do
    {
      while ( 1 )
      {
        v15 = *(unsigned __int8 *)(++v3 + v31 - 1);
        v16 = *(unsigned __int8 *)(v3 - 1) - v15;
        v28 = (unsigned __int8)v5[v31];
        v17 = v28 - v15;
        v18 = abs32(v16);
        v19 = abs32(v17);
        v20 = abs32(v16 + v17);
        if ( v19 < v18 )
        {
          v18 = v19;
          LOBYTE(v28) = *(_BYTE *)(v3 - 1);
        }
        if ( v18 > v20 )
          break;
        v21 = *v5++;
        LOBYTE(v14) = v28 + v21;
        *(v5 - 1) = v14;
        if ( v30 == v3 )
          return v14;
      }
      v22 = *v5++;
      LOBYTE(v14) = *(_BYTE *)(v3 + v31 - 1) + v22;
      *(v5 - 1) = v14;
    }
    while ( v30 != v3 );
  }
  return v14;
}

//----- (004403A0) --------------------------------------------------------
unsigned int __cdecl png_read_filter_row_sub(int a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned int result; // eax
  _BYTE *v4; // edx
  int v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  _BYTE *v8; // edx
  unsigned int v9; // [esp+0h] [ebp-24h]
  int v10; // [esp+8h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 4);
  result = (*(unsigned __int8 *)(a1 + 11) + 7) >> 3;
  v4 = (_BYTE *)(a2 + result);
  if ( v2 > result )
  {
    v5 = (*(unsigned __int8 *)(a1 + 11) + 7) >> 3;
    v10 = -result;
    if ( v2 - 1 - result <= 2
      || a2 < a2 + result + 4 && (unsigned int)v4 < a2 + 4
      || (((unsigned __int8)a2 | (unsigned __int8)v4) & 3) != 0 )
    {
      do
      {
        result = (unsigned __int8)v4[v10];
        *v4++ += result;
      }
      while ( v4 != (_BYTE *)(v2 + a2) );
    }
    else
    {
      v6 = 0;
      v9 = ((v2 - result - 4) >> 2) + 1;
      do
      {
        *(_DWORD *)&v4[4 * v6] = (*(_DWORD *)&v4[4 * v6] ^ *(_DWORD *)(a2 + 4 * v6)) & 0x80808080 ^ ((*(_DWORD *)(a2 + 4 * v6) & 0x7F7F7F7F) + (*(_DWORD *)&v4[4 * v6] & 0x7F7F7F7F));
        ++v6;
      }
      while ( v9 > v6 );
      result = 4 * v9;
      v7 = v5 + 4 * v9;
      v8 = &v4[4 * v9];
      if ( v2 - v5 != 4 * v9 )
      {
        *v8 += v8[v10];
        result = v7 + 1;
        if ( v2 > v7 + 1 )
        {
          result = (unsigned __int8)v8[-v5 + 1];
          v8[1] += result;
          if ( v2 > v7 + 2 )
          {
            result = (unsigned __int8)v8[v10 + 2];
            v8[2] += result;
          }
        }
      }
    }
  }
  return result;
}

//----- (004404D0) --------------------------------------------------------
unsigned int __cdecl png_read_filter_row_up(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax
  _BYTE *v4; // ebx
  int v5; // edi
  int *v6; // esi
  int *v7; // ecx
  int *v8; // ebx
  int v9; // edi
  int v10; // eax
  _BYTE *v11; // ebx
  _BYTE *v12; // ecx
  unsigned int v13; // [esp+0h] [ebp-14h]

  result = a1;
  v4 = (_BYTE *)a2;
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 )
  {
    v6 = (int *)a3;
    if ( (unsigned int)(v5 - 1) <= 2
      || a2 < a3 + 4 && a3 < a2 + 4
      || (((unsigned __int8)a3 | (unsigned __int8)a2) & 3) != 0 )
    {
      result = a3;
      do
        *v4++ += *(_BYTE *)result++;
      while ( v4 != (_BYTE *)(a2 + v5) );
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 4);
      v7 = (int *)a2;
      v8 = (int *)(a2 + (v5 & 0xFFFFFFFC));
      do
      {
        v9 = *v7;
        v10 = *v6;
        ++v7;
        ++v6;
        *(v7 - 1) = (v9 ^ v10) & 0x80808080 ^ ((v9 & 0x7F7F7F7F) + (v10 & 0x7F7F7F7F));
      }
      while ( v7 != v8 );
      result = v13 & 0xFFFFFFFC;
      v11 = (_BYTE *)((v13 & 0xFFFFFFFC) + a2);
      v12 = (_BYTE *)((v13 & 0xFFFFFFFC) + a3);
      if ( v13 != (v13 & 0xFFFFFFFC) )
      {
        *v11 += *v12;
        if ( v13 > result + 1 )
        {
          result += 2;
          v11[1] += v12[1];
          if ( v13 > result )
          {
            result = (unsigned __int8)v12[2];
            v11[2] += result;
          }
        }
      }
    }
  }
  return result;
}

//----- (004405D0) --------------------------------------------------------
void __cdecl png_read_finish_IDAT(_DWORD *a1)
{
  int v1; // eax
  bool v2; // zf
  unsigned int v3; // eax

  if ( (a1[25] & 8) != 0 || (png_read_IDAT_data((size_t)a1, 0, 0), v1 = a1[25], a1[31] = 0, (v1 & 8) != 0) )
  {
    if ( a1[27] == 1229209940 )
    {
LABEL_6:
      v3 = a1[65];
      a1[28] = 0;
      a1[29] = 0;
      a1[27] = 0;
      png_crc_finish((int)a1, v3);
    }
  }
  else
  {
    a1[24] |= 8u;
    v2 = a1[27] == 1229209940;
    a1[25] = v1 | 8;
    if ( v2 )
      goto LABEL_6;
  }
}

//----- (00440660) --------------------------------------------------------
unsigned int __cdecl png_read_finish_row(size_t a1)
{
  unsigned int result; // eax
  int v2; // eax
  void *v3; // edx
  unsigned __int8 v4; // al
  unsigned int v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ebp
  unsigned int v8; // esi
  unsigned __int8 v9; // al
  unsigned int v10; // edi
  unsigned int v11; // ecx
  unsigned int v12; // edx
  unsigned int v13; // esi
  unsigned __int8 v14; // al
  unsigned int v15; // edi
  unsigned int v16; // ecx
  unsigned int v17; // edx
  unsigned int v18; // esi
  unsigned __int8 v19; // al
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // edx
  unsigned int v23; // esi
  unsigned __int8 v24; // al
  unsigned int v25; // edi
  unsigned int v26; // ecx
  unsigned int v27; // edx
  unsigned int v28; // esi
  unsigned __int8 v29; // al
  unsigned int v30; // edi
  unsigned int v31; // ecx
  unsigned int v32; // edx
  unsigned int v33; // esi
  unsigned int v34; // eax
  unsigned __int8 v35; // [esp+1Eh] [ebp-2Eh]
  char v36; // [esp+1Fh] [ebp-2Dh]
  int v37; // [esp+20h] [ebp-2Ch]
  unsigned int v38; // [esp+24h] [ebp-28h]
  int v39; // [esp+28h] [ebp-24h]
  unsigned int v40; // [esp+2Ch] [ebp-20h]

  result = *(_DWORD *)(a1 + 240) + 1;
  *(_DWORD *)(a1 + 240) = result;
  if ( result < *(_DWORD *)(a1 + 224) )
    return result;
  if ( *(_BYTE *)(a1 + 278) )
  {
    v2 = *(_DWORD *)(a1 + 232);
    v3 = *(void **)(a1 + 248);
    *(_DWORD *)(a1 + 240) = 0;
    memset(v3, 0, v2 + 1);
    v36 = *(_BYTE *)(a1 + 279);
    v4 = v36 + 1;
    v35 = v36 + 1;
    if ( (unsigned __int8)(v36 + 1) <= 6u )
    {
      v5 = (unsigned __int8)png_pass_inc_64022[v4];
      v39 = *(_DWORD *)(a1 + 216);
      v37 = v39 - 1;
      v6 = v39 - 1 + v5 - (unsigned __int8)png_pass_start_64021[v4];
      *(_DWORD *)(a1 + 236) = v6 / v5;
      if ( (*(_BYTE *)(a1 + 104) & 2) != 0 )
        goto LABEL_34;
      v7 = (unsigned __int8)png_pass_yinc_64015[v4];
      v40 = *(_DWORD *)(a1 + 220);
      v38 = v40 - 1;
      v8 = v40 - 1 + v7 - (unsigned __int8)png_pass_ystart_64014[v4];
      *(_DWORD *)(a1 + 224) = v8 / v7;
      if ( v6 >= v5 && v7 <= v8 )
        goto LABEL_34;
      v9 = v36 + 2;
      v35 = v36 + 2;
      if ( v36 != 5 )
      {
        v10 = (unsigned __int8)png_pass_inc_64022[v9];
        v11 = v37 + v10 - (unsigned __int8)png_pass_start_64021[v9];
        v12 = (unsigned __int8)png_pass_yinc_64015[v9];
        *(_DWORD *)(a1 + 236) = v11 / v10;
        v13 = v12 + v38 - (unsigned __int8)png_pass_ystart_64014[v9];
        *(_DWORD *)(a1 + 224) = v13 / v12;
        if ( v10 <= v11 && v12 <= v13 )
          goto LABEL_34;
        v14 = v36 + 3;
        v35 = v36 + 3;
        if ( v36 != 4 )
        {
          v15 = (unsigned __int8)png_pass_inc_64022[v14];
          v16 = v37 + v15 - (unsigned __int8)png_pass_start_64021[v14];
          v17 = (unsigned __int8)png_pass_yinc_64015[v14];
          *(_DWORD *)(a1 + 236) = v16 / v15;
          v18 = v17 + v38 - (unsigned __int8)png_pass_ystart_64014[v14];
          *(_DWORD *)(a1 + 224) = v18 / v17;
          if ( v15 <= v16 && v17 <= v18 )
            goto LABEL_34;
          v19 = v36 + 4;
          v35 = v36 + 4;
          if ( v36 != 3 )
          {
            v20 = (unsigned __int8)png_pass_inc_64022[v19];
            v21 = v37 + v20 - (unsigned __int8)png_pass_start_64021[v19];
            v22 = (unsigned __int8)png_pass_yinc_64015[v19];
            *(_DWORD *)(a1 + 236) = v21 / v20;
            v23 = v22 + v38 - (unsigned __int8)png_pass_ystart_64014[v19];
            *(_DWORD *)(a1 + 224) = v23 / v22;
            if ( v20 <= v21 && v22 <= v23 )
              goto LABEL_34;
            v24 = v36 + 5;
            v35 = v36 + 5;
            if ( v36 != 2 )
            {
              v25 = (unsigned __int8)png_pass_inc_64022[v24];
              v26 = v37 + v25 - (unsigned __int8)png_pass_start_64021[v24];
              v27 = (unsigned __int8)png_pass_yinc_64015[v24];
              *(_DWORD *)(a1 + 236) = v26 / v25;
              v28 = v27 + v38 - (unsigned __int8)png_pass_ystart_64014[v24];
              *(_DWORD *)(a1 + 224) = v28 / v27;
              if ( v25 <= v26 && v27 <= v28 )
                goto LABEL_34;
              v29 = v36 + 6;
              v35 = v36 + 6;
              if ( v36 != 1 )
              {
                v30 = (unsigned __int8)png_pass_inc_64022[v29];
                v31 = v30 + v37 - (unsigned __int8)png_pass_start_64021[v29];
                v32 = (unsigned __int8)png_pass_yinc_64015[v29];
                *(_DWORD *)(a1 + 236) = v31 / v30;
                v33 = v32 + v38 - (unsigned __int8)png_pass_ystart_64014[v29];
                *(_DWORD *)(a1 + 224) = v33 / v32;
                if ( v30 > v31 || v32 > v33 )
                {
                  if ( !v36 || (*(_DWORD *)(a1 + 236) = v39, *(_DWORD *)(a1 + 224) = v40 >> 1, !v39) || v40 <= 1 )
                  {
                    v35 = 7;
                    goto LABEL_26;
                  }
                  v35 = 6;
                }
LABEL_34:
                result = v35;
                *(_BYTE *)(a1 + 279) = v35;
                return result;
              }
            }
          }
        }
      }
    }
LABEL_26:
    result = v35;
    *(_BYTE *)(a1 + 279) = v35;
  }
  if ( (*(_BYTE *)(a1 + 100) & 8) == 0 )
  {
    png_read_IDAT_data(a1, 0, 0);
    result = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 124) = 0;
    if ( (result & 8) == 0 )
    {
      result |= 8u;
      *(_DWORD *)(a1 + 96) |= 8u;
      *(_DWORD *)(a1 + 100) = result;
    }
  }
  if ( *(_DWORD *)(a1 + 108) == 1229209940 )
  {
    v34 = *(_DWORD *)(a1 + 260);
    *(_DWORD *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 116) = 0;
    *(_DWORD *)(a1 + 108) = 0;
    return png_crc_finish(a1, v34);
  }
  return result;
}

//----- (00440A40) --------------------------------------------------------
void __cdecl png_read_image(size_t a1, int a2)
{
  int v2; // esi
  int i; // ebp
  char *v4; // edx
  int v5; // [esp+18h] [ebp-24h]
  int v6; // [esp+1Ch] [ebp-20h]

  if ( a1 )
  {
    if ( (*(_BYTE *)(a1 + 100) & 0x40) != 0 )
    {
      if ( *(_BYTE *)(a1 + 278) && (*(_BYTE *)(a1 + 104) & 2) == 0 )
        *(_DWORD *)(a1 + 224) = *(_DWORD *)(a1 + 220);
      v6 = png_set_interlace_handling(a1);
    }
    else
    {
      v6 = png_set_interlace_handling(a1);
      if ( (*(_BYTE *)(a1 + 100) & 0x40) != 0 )
        png_app_error(a1);
      else
        png_read_start_row((unsigned __int8 *)a1);
    }
    v2 = *(_DWORD *)(a1 + 220);
    if ( v6 > 0 )
    {
      v5 = 0;
      if ( v2 )
      {
        do
        {
          for ( i = 0; i != v2; ++i )
          {
            v4 = *(char **)(a2 + 4 * i);
            png_read_row_constprop_6(a1, v4);
          }
          ++v5;
        }
        while ( v6 != v5 );
      }
    }
  }
}

//----- (00440B10) --------------------------------------------------------
int __cdecl png_read_info(_DWORD *a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a1 )
  {
    if ( a2 )
      return png_read_info_part_2(a1, a2);
  }
  return result;
}

//----- (00440B30) --------------------------------------------------------
int __cdecl png_read_info_part_2(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // [esp+1Ch] [ebp-10h]

  png_read_sig((int)a1, a2);
  while ( 1 )
  {
    result = png_read_chunk_header((int)a1);
    v3 = a1[61];
    if ( v3 == 1229209940 )
      break;
    v4 = a1[24];
    if ( (v4 & 4) != 0 )
      a1[24] = v4 | 0x2008;
    switch ( v3 )
    {
      case 1229472850:
        png_handle_IHDR((int)a1, a2, result);
        break;
      case 1229278788:
        png_handle_IEND((int)a1, a2, result);
        break;
      case 1347179589:
        png_handle_PLTE(a1, a2, result);
        break;
      case 1649100612:
        png_handle_bKGD((int)a1, a2, result);
        break;
      case 1665684045:
        png_handle_cHRM((int)a1, a2, result);
        break;
      case 1732332865:
        png_handle_gAMA((int)a1, a2, result);
        break;
      case 1933723988:
        png_handle_sBIT((int)a1, a2, result);
        break;
      case 1934772034:
        png_handle_sRGB((int)a1, a2, result);
        break;
      case 1951551059:
        png_handle_tRNS(a1, a2, result);
        break;
      default:
        png_handle_unknown((int)a1, a2, result);
        break;
    }
  }
  v5 = a1[24];
  if ( (v5 & 1) == 0 || *((_BYTE *)a1 + 281) == 3 && (v5 & 2) == 0 )
    png_err((int)a1);
  if ( (v5 & 8) != 0 )
  {
    v6 = result;
    png_chunk_benign_error((int)a1);
    v5 = a1[24];
    result = v6;
  }
  a1[65] = result;
  a1[24] = v5 | 4;
  return result;
}

//----- (00440D40) --------------------------------------------------------
void __cdecl png_read_row(size_t a1, char *a2, char *a3)
{
  __int16 v3; // cx
  int v4; // edx
  int v5; // eax
  unsigned int v6; // eax
  bool v7; // zf
  int v8; // eax
  _BYTE *v9; // edx
  _BYTE *Src; // eax
  char v11; // al
  unsigned __int8 v12; // dl
  void (__cdecl *v13)(size_t, _DWORD, _DWORD, int); // eax
  int v14; // edx
  int v15; // [esp+Ch] [ebp-30h]
  int v16; // [esp+24h] [ebp-18h] BYREF
  unsigned int v17; // [esp+28h] [ebp-14h]
  __int16 v18; // [esp+2Ch] [ebp-10h]
  __int16 v19; // [esp+2Eh] [ebp-Eh]

  if ( !a1 )
    return;
  if ( (*(_BYTE *)(a1 + 100) & 0x40) == 0 )
    png_read_start_row((unsigned __int8 *)a1);
  v3 = *(_WORD *)(a1 + 284);
  v4 = *(_DWORD *)(a1 + 236);
  v18 = *(_WORD *)(a1 + 281);
  v5 = *(unsigned __int8 *)(a1 + 284);
  v16 = v4;
  v19 = __ROL2__(v3, 8);
  if ( (unsigned __int8)v5 > 7u )
    v6 = v4 * ((unsigned __int8)v5 >> 3);
  else
    v6 = (unsigned int)(v4 * v5 + 7) >> 3;
  v7 = *(_BYTE *)(a1 + 278) == 0;
  v17 = v6;
  if ( v7 || (*(_BYTE *)(a1 + 104) & 2) == 0 )
  {
LABEL_10:
    if ( (*(_BYTE *)(a1 + 96) & 4) == 0 )
      goto LABEL_29;
    v9 = *(_BYTE **)(a1 + 252);
    *v9 = -1;
    png_read_IDAT_data(a1, (int)v9, v17 + 1);
    Src = *(_BYTE **)(a1 + 252);
    if ( *Src )
    {
      if ( *Src > 4u )
        goto LABEL_29;
      png_read_filter_row(a1, (int)&v16, (int)(Src + 1), *(_DWORD *)(a1 + 248) + 1, (unsigned __int8)*Src);
      Src = *(_BYTE **)(a1 + 252);
    }
    memcpy(*(void **)(a1 + 248), Src, v17 + 1);
    if ( *(_DWORD *)(a1 + 104) )
      png_do_read_transformations(a1, (int)&v16);
    v11 = *(_BYTE *)(a1 + 289);
    v12 = HIBYTE(v19);
    if ( v11 )
    {
      if ( v11 == HIBYTE(v19) )
      {
LABEL_18:
        if ( *(_BYTE *)(a1 + 278) && (*(_DWORD *)(a1 + 104) & 2) != 0 )
        {
          v14 = *(unsigned __int8 *)(a1 + 279);
          if ( (unsigned __int8)v14 <= 5u )
          {
            v15 = *(_DWORD *)(a1 + 104);
            png_do_read_interlace(&v16, *(_DWORD *)(a1 + 252) + 1, v14);
          }
          if ( a3 )
            png_combine_row(a1, a3, 1);
          if ( a2 )
            png_combine_row(a1, a2, 0);
        }
        else
        {
          if ( a2 )
            png_combine_row(a1, a2, -1);
          if ( a3 )
            png_combine_row(a1, a3, -1);
        }
        png_read_finish_row(a1);
        v13 = *(void (__cdecl **)(size_t, _DWORD, _DWORD, int))(a1 + 376);
        if ( v13 )
          v13(a1, *(_DWORD *)(a1 + 240), *(unsigned __int8 *)(a1 + 279), v15);
        return;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 289) = HIBYTE(v19);
      if ( *(_BYTE *)(a1 + 288) >= v12 )
        goto LABEL_18;
    }
LABEL_29:
    png_err(a1);
  }
  v8 = *(_DWORD *)(a1 + 240);
  switch ( *(_BYTE *)(a1 + 279) )
  {
    case 0:
      if ( (v8 & 7) != 0 )
        goto LABEL_41;
      goto LABEL_10;
    case 1:
      if ( (v8 & 7) != 0 || *(_DWORD *)(a1 + 216) <= 4u )
        goto LABEL_41;
      goto LABEL_10;
    case 2:
      if ( (*(_DWORD *)(a1 + 240) & 7) == 4 )
        goto LABEL_10;
      if ( a3 && (v8 & 4) != 0 )
        goto LABEL_42;
      goto LABEL_39;
    case 3:
      if ( (v8 & 3) != 0 || *(_DWORD *)(a1 + 216) <= 2u )
        goto LABEL_41;
      goto LABEL_10;
    case 4:
      if ( (*(_DWORD *)(a1 + 240) & 3) == 2 )
        goto LABEL_10;
      if ( !a3 || (v8 & 2) == 0 )
        goto LABEL_39;
      goto LABEL_42;
    case 5:
      if ( (v8 & 1) == 0 && *(_DWORD *)(a1 + 216) > 1u )
        goto LABEL_10;
LABEL_41:
      if ( a3 )
LABEL_42:
        png_combine_row(a1, a3, 1);
LABEL_39:
      png_read_finish_row(a1);
      break;
    default:
      if ( (v8 & 1) != 0 )
        goto LABEL_10;
      goto LABEL_39;
  }
}
// 440F0A: variable 'v15' is possibly undefined

//----- (00441080) --------------------------------------------------------
void __cdecl png_read_row_constprop_6(size_t a1, char *a2)
{
  __int16 v2; // cx
  int v3; // edx
  int v4; // eax
  unsigned int v5; // eax
  bool v6; // zf
  int v7; // eax
  _BYTE *v8; // edx
  _BYTE *Src; // eax
  char v10; // al
  unsigned __int8 v11; // dl
  void (__cdecl *v12)(size_t, _DWORD, _DWORD, int); // eax
  int v13; // edx
  int v14; // [esp+Ch] [ebp-30h]
  int v15; // [esp+24h] [ebp-18h] BYREF
  unsigned int v16; // [esp+28h] [ebp-14h]
  __int16 v17; // [esp+2Ch] [ebp-10h]
  __int16 v18; // [esp+2Eh] [ebp-Eh]

  if ( !a1 )
    return;
  if ( (*(_BYTE *)(a1 + 100) & 0x40) == 0 )
    png_read_start_row((unsigned __int8 *)a1);
  v2 = *(_WORD *)(a1 + 284);
  v3 = *(_DWORD *)(a1 + 236);
  v17 = *(_WORD *)(a1 + 281);
  v4 = *(unsigned __int8 *)(a1 + 284);
  v15 = v3;
  v18 = __ROL2__(v2, 8);
  if ( (unsigned __int8)v4 > 7u )
    v5 = v3 * ((unsigned __int8)v4 >> 3);
  else
    v5 = (unsigned int)(v3 * v4 + 7) >> 3;
  v6 = *(_BYTE *)(a1 + 278) == 0;
  v16 = v5;
  if ( v6 || (*(_BYTE *)(a1 + 104) & 2) == 0 )
  {
LABEL_10:
    if ( (*(_BYTE *)(a1 + 96) & 4) == 0 )
      goto LABEL_27;
    v8 = *(_BYTE **)(a1 + 252);
    *v8 = -1;
    png_read_IDAT_data(a1, (int)v8, v16 + 1);
    Src = *(_BYTE **)(a1 + 252);
    if ( *Src )
    {
      if ( *Src > 4u )
        goto LABEL_27;
      png_read_filter_row(a1, (int)&v15, (int)(Src + 1), *(_DWORD *)(a1 + 248) + 1, (unsigned __int8)*Src);
      Src = *(_BYTE **)(a1 + 252);
    }
    memcpy(*(void **)(a1 + 248), Src, v16 + 1);
    if ( *(_DWORD *)(a1 + 104) )
      png_do_read_transformations(a1, (int)&v15);
    v10 = *(_BYTE *)(a1 + 289);
    v11 = HIBYTE(v18);
    if ( v10 )
    {
      if ( v10 == HIBYTE(v18) )
      {
LABEL_18:
        if ( *(_BYTE *)(a1 + 278) && (*(_DWORD *)(a1 + 104) & 2) != 0 )
        {
          v13 = *(unsigned __int8 *)(a1 + 279);
          if ( (unsigned __int8)v13 <= 5u )
          {
            v14 = *(_DWORD *)(a1 + 104);
            png_do_read_interlace(&v15, *(_DWORD *)(a1 + 252) + 1, v13);
          }
          if ( a2 )
            png_combine_row(a1, a2, 0);
        }
        else if ( a2 )
        {
          png_combine_row(a1, a2, -1);
        }
        png_read_finish_row(a1);
        v12 = *(void (__cdecl **)(size_t, _DWORD, _DWORD, int))(a1 + 376);
        if ( v12 )
          v12(a1, *(_DWORD *)(a1 + 240), *(unsigned __int8 *)(a1 + 279), v14);
        return;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 289) = HIBYTE(v18);
      if ( *(_BYTE *)(a1 + 288) >= v11 )
        goto LABEL_18;
    }
LABEL_27:
    png_err(a1);
  }
  v7 = *(_DWORD *)(a1 + 240);
  switch ( *(_BYTE *)(a1 + 279) )
  {
    case 0:
      if ( (v7 & 7) != 0 )
        goto LABEL_33;
      goto LABEL_10;
    case 1:
      if ( (v7 & 7) != 0 || *(_DWORD *)(a1 + 216) <= 4u )
        goto LABEL_33;
      goto LABEL_10;
    case 2:
      if ( (*(_DWORD *)(a1 + 240) & 7) == 4 )
        goto LABEL_10;
      goto LABEL_33;
    case 3:
      if ( (v7 & 3) != 0 || *(_DWORD *)(a1 + 216) <= 2u )
        goto LABEL_33;
      goto LABEL_10;
    case 4:
      if ( (*(_DWORD *)(a1 + 240) & 3) != 2 )
        goto LABEL_33;
      goto LABEL_10;
    case 5:
      if ( (v7 & 1) != 0 || *(_DWORD *)(a1 + 216) <= 1u )
        goto LABEL_33;
      goto LABEL_10;
    default:
      if ( (v7 & 1) != 0 )
        goto LABEL_10;
LABEL_33:
      png_read_finish_row(a1);
      break;
  }
}
// 44122A: variable 'v14' is possibly undefined

//----- (00441340) --------------------------------------------------------
void __cdecl png_read_rows(size_t a1, int a2, int a3, int a4)
{
  int i; // ebx
  char *v5; // edx
  int j; // ebx
  char *v7; // edx
  int k; // ebx
  char *v9; // eax
  char *v10; // [esp+8h] [ebp-24h]

  if ( a1 )
  {
    if ( a2 && a3 )
    {
      if ( a4 )
      {
        for ( i = 0; i != a4; ++i )
        {
          v10 = *(char **)(a3 + 4 * i);
          v5 = *(char **)(a2 + 4 * i);
          png_read_row(a1, v5, v10);
        }
      }
    }
    else if ( a2 )
    {
      if ( a4 )
      {
        for ( j = 0; j != a4; ++j )
        {
          v7 = *(char **)(a2 + 4 * j);
          png_read_row_constprop_6(a1, v7);
        }
      }
    }
    else if ( a3 && a4 )
    {
      for ( k = 0; k != a4; ++k )
      {
        v9 = *(char **)(a3 + 4 * k);
        png_read_row(a1, 0, v9);
      }
    }
  }
}

//----- (00441420) --------------------------------------------------------
int __cdecl png_read_sig(int a1, int a2)
{
  unsigned __int8 v2; // dl
  unsigned int v3; // edi
  unsigned int v4; // ebp
  int result; // eax
  unsigned __int8 v6; // [esp+1Fh] [ebp-1Dh]

  v2 = *(_BYTE *)(a1 + 287);
  if ( v2 <= 7u )
  {
    v3 = v2;
    v4 = 8 - v2;
    v6 = *(_BYTE *)(a1 + 287);
    png_read_data(a1);
    *(_BYTE *)(a1 + 287) = 8;
    result = png_sig_cmp(a2 + 32, v3, v4);
    if ( result )
    {
      if ( v6 <= 3u )
        png_sig_cmp(a2 + 32, v3, 4 - v3);
      png_err(a1);
    }
    if ( v6 <= 2u )
      *(_DWORD *)(a1 + 96) |= 0x1000u;
  }
  return result;
}

//----- (004414D0) --------------------------------------------------------
int __cdecl png_read_start_row(unsigned __int8 *Block)
{
  unsigned int v1; // eax
  int v2; // ecx
  int v3; // esi
  int v4; // edx
  unsigned int v5; // edi
  int v6; // edx
  unsigned int v7; // edx
  int v8; // ebp
  unsigned __int8 v9; // al
  unsigned int v10; // esi
  unsigned int v11; // ecx
  int v12; // eax
  size_t v13; // esi
  char *v14; // eax
  int v15; // edi
  int v16; // eax
  void *v17; // eax
  unsigned __int32 v18; // eax
  unsigned int v19; // eax
  bool v20; // zf
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int result; // eax
  unsigned __int8 v25; // al
  int v26; // edx
  unsigned __int32 v27[23]; // [esp+20h] [ebp-5Ch] BYREF

  png_init_read_transformations(Block);
  if ( Block[278] )
  {
    v1 = *((_DWORD *)Block + 55);
    v2 = *((_DWORD *)Block + 26);
    v3 = *((_DWORD *)Block + 54);
    if ( (v2 & 2) == 0 )
      v1 = (v1 + 7) >> 3;
    v4 = Block[279];
    v5 = (unsigned __int8)png_pass_inc_64022[v4];
    v6 = (unsigned __int8)png_pass_start_64021[v4];
    *((_DWORD *)Block + 56) = v1;
    *((_DWORD *)Block + 59) = (v3 + v5 - 1 - v6) / v5;
  }
  else
  {
    v3 = *((_DWORD *)Block + 54);
    v2 = *((_DWORD *)Block + 26);
    *((_DWORD *)Block + 56) = *((_DWORD *)Block + 55);
    *((_DWORD *)Block + 59) = v3;
  }
  v7 = Block[284];
  if ( (v2 & 4) != 0 && Block[282] <= 7u )
    v7 = 8;
  v8 = v2 & 0x1000;
  if ( (v2 & 0x1000) != 0 )
  {
    v9 = Block[281];
    if ( v9 == 3 )
    {
      v7 = *((_WORD *)Block + 137) == 0 ? 24 : 32;
    }
    else if ( v9 )
    {
      if ( v9 == 2 && *((_WORD *)Block + 137) )
        v7 = 4 * v7 / 3;
    }
    else
    {
      if ( v7 < 8 )
        v7 = 8;
      if ( *((_WORD *)Block + 137) )
        v7 *= 2;
    }
    if ( (v2 & 0x200) != 0 && Block[282] <= 0xFu )
      v7 *= 2;
  }
  else if ( (v2 & 0x200) != 0 )
  {
    BYTE1(v2) &= ~2u;
    *((_DWORD *)Block + 26) = v2;
  }
  if ( (v2 & 0x8000) != 0 )
  {
    if ( !Block[281] )
    {
      v7 = v7 < 9 ? 16 : 32;
LABEL_20:
      v10 = (v3 + 7) & 0xFFFFFFF8;
      if ( (v2 & 0x4000) == 0 )
      {
        Block[288] = v7;
        Block[289] = 0;
        v12 = v7 >> 3;
        v11 = (v7 + 7) >> 3;
        goto LABEL_25;
      }
      if ( !*((_WORD *)Block + 137) )
        goto LABEL_23;
LABEL_22:
      if ( v8 )
        goto LABEL_23;
      goto LABEL_46;
    }
    if ( (unsigned __int8)(Block[281] - 2) <= 1u )
    {
      v7 = v7 < 0x21 ? 32 : 64;
      goto LABEL_20;
    }
  }
  v10 = (v3 + 7) & 0xFFFFFFF8;
  if ( (v2 & 0x4000) == 0 )
  {
    Block[288] = v7;
    Block[289] = 0;
    v11 = (v7 + 7) >> 3;
    if ( v7 <= 7 )
    {
      v13 = ((v7 * v10) >> 3) + 1 + v11 + 48;
      if ( v13 <= *((_DWORD *)Block + 106) )
        goto LABEL_33;
      goto LABEL_26;
    }
    v12 = v7 >> 3;
    goto LABEL_25;
  }
  if ( *((_WORD *)Block + 137) )
    goto LABEL_22;
LABEL_46:
  if ( (v2 & 0x8000) != 0 || (v25 = Block[281], v25 == 4) )
  {
LABEL_23:
    if ( v7 > 0x10 )
    {
LABEL_24:
      v11 = 8;
      v12 = 8;
      *((_WORD *)Block + 144) = 64;
      goto LABEL_25;
    }
    goto LABEL_50;
  }
  if ( v7 > 8 )
  {
    if ( v25 == 6 )
      goto LABEL_24;
    v11 = 6;
    v12 = 6;
    *((_WORD *)Block + 144) = 48;
  }
  else
  {
    if ( v25 == 6 )
    {
LABEL_50:
      v11 = 4;
      *((_WORD *)Block + 144) = 32;
      v12 = 4;
      goto LABEL_25;
    }
    v12 = 3;
    *((_WORD *)Block + 144) = 24;
    v11 = 3;
  }
LABEL_25:
  v13 = v12 * v10 + 1 + v11 + 48;
  if ( v13 <= *((_DWORD *)Block + 106) )
    goto LABEL_33;
LABEL_26:
  png_free(Block, *((void **)Block + 100));
  png_free(Block, *((void **)Block + 110));
  if ( Block[278] )
    *((_DWORD *)Block + 100) = png_calloc((int)Block, v13);
  else
    *((_DWORD *)Block + 100) = png_malloc((int)Block, v13);
  v14 = (char *)png_malloc((int)Block, v13);
  v15 = *((_DWORD *)Block + 100);
  *((_DWORD *)Block + 106) = v13;
  *((_DWORD *)Block + 110) = v14;
  *((_DWORD *)Block + 62) = v14 + 31;
  *((_DWORD *)Block + 63) = v15 + 31;
LABEL_33:
  v16 = *((_DWORD *)Block + 58);
  if ( v16 == -1 )
    goto LABEL_56;
  memset(*((void **)Block + 62), 0, v16 + 1);
  v17 = (void *)*((_DWORD *)Block + 107);
  if ( v17 )
  {
    *((_DWORD *)Block + 108) = 0;
    *((_DWORD *)Block + 107) = 0;
    png_free(Block, v17);
  }
  v18 = _byteswap_ulong(*((_DWORD *)Block + 27));
  if ( *((_DWORD *)Block + 27) )
  {
    v27[0] = v18;
    png_safecat((int)v27, 0x40u, 4u, " using zstream");
    *((_DWORD *)Block + 27) = 0;
  }
  v19 = *((_DWORD *)Block + 96);
  *((_DWORD *)Block + 28) = 0;
  *((_DWORD *)Block + 29) = 0;
  *((_DWORD *)Block + 31) = 0;
  *((_DWORD *)Block + 32) = 0;
  v20 = ((v19 >> 2) & 3) == 3;
  v21 = 15;
  if ( !v20 )
    v21 = 0;
  Block[290] = !v20;
  if ( (Block[100] & 2) == 0 )
  {
    v22 = inflateInit2_((_DWORD *)Block + 28, v21, "1.2.11", 56);
    if ( v22 )
    {
      if ( (((unsigned __int8)BYTE1(*((_DWORD *)Block + 96)) ^ 3) & 3) != 0 )
        goto LABEL_55;
    }
    else
    {
      v26 = *((_DWORD *)Block + 96);
      v23 = *((_DWORD *)Block + 25) | 2;
      *((_DWORD *)Block + 25) = v23;
      if ( ((BYTE1(v26) ^ 3) & 3) != 0 )
        goto LABEL_44;
    }
LABEL_54:
    v22 = inflateValidate((_DWORD *)Block + 28, 0);
    if ( !v22 )
      goto LABEL_43;
    goto LABEL_55;
  }
  v22 = inflateReset2((_DWORD *)Block + 28, v21);
  if ( (((unsigned __int8)BYTE1(*((_DWORD *)Block + 96)) ^ 3) & 3) == 0 )
    goto LABEL_54;
  if ( v22 )
  {
LABEL_55:
    png_zstream_error((int)Block, v22);
LABEL_56:
    png_err((int)Block);
  }
LABEL_43:
  v23 = *((_DWORD *)Block + 25);
LABEL_44:
  result = v23 | 0x40;
  *((_DWORD *)Block + 27) = 1229209940;
  *((_DWORD *)Block + 25) = result;
  return result;
}
// 4414D0: using guessed type unsigned __int32 var_5C[23];

//----- (00441A20) --------------------------------------------------------
unsigned int __cdecl png_read_transform_info(int a1, int *a2)
{
  int v2; // esi
  char v3; // bl
  char v4; // al
  int v5; // edi
  char v6; // al
  char v7; // bp
  unsigned __int8 v8; // al
  int v9; // ebx
  unsigned int result; // eax
  int v11; // ebx
  int v12; // eax
  __int16 v13; // ax

  v2 = *(_DWORD *)(a1 + 104);
  v3 = *((_BYTE *)a2 + 25);
  if ( (v2 & 0x1000) != 0 )
  {
    v13 = *(_WORD *)(a1 + 274);
    if ( v3 == 3 )
    {
      *((_BYTE *)a2 + 24) = 8;
      v11 = -(v13 == 0);
      *((_WORD *)a2 + 11) = 0;
      v12 = *(_DWORD *)(a1 + 268);
      v3 = (v11 & 0xFC) + 6;
      *((_BYTE *)a2 + 25) = v3;
      if ( !v12 )
        png_err(a1);
      if ( (v2 & 0x80) == 0 )
      {
        a2[10] = *(_DWORD *)(a1 + 460);
        goto LABEL_5;
      }
      v4 = 8;
      goto LABEL_29;
    }
    if ( v13 && (v2 & 0x2000000) != 0 )
    {
      v3 |= 4u;
      *((_BYTE *)a2 + 25) = v3;
    }
    v4 = *((_BYTE *)a2 + 24);
    if ( (unsigned __int8)v4 <= 7u )
    {
      *((_BYTE *)a2 + 24) = 8;
      v4 = 8;
    }
    *((_WORD *)a2 + 11) = 0;
  }
  else
  {
    v4 = *((_BYTE *)a2 + 24);
  }
  if ( (v2 & 0x80) != 0 )
  {
LABEL_29:
    *(int *)((char *)a2 + 138) = *(_DWORD *)(a1 + 300);
    *(int *)((char *)a2 + 142) = *(_DWORD *)(a1 + 304);
    *((_WORD *)a2 + 73) = *(_WORD *)(a1 + 308);
    a2[10] = *(_DWORD *)(a1 + 460);
    if ( v4 != 16 )
      goto LABEL_5;
    goto LABEL_30;
  }
  a2[10] = *(_DWORD *)(a1 + 460);
  if ( v4 != 16 )
    goto LABEL_5;
LABEL_30:
  if ( (v2 & 0x4000000) != 0 )
    *((_BYTE *)a2 + 24) = 8;
  if ( (v2 & 0x400) != 0 )
    *((_BYTE *)a2 + 24) = 8;
LABEL_5:
  if ( (v2 & 0x4000) != 0 )
  {
    v3 |= 2u;
    *((_BYTE *)a2 + 25) = v3;
  }
  if ( (v2 & 0x600000) != 0 )
  {
    v3 &= ~2u;
    *((_BYTE *)a2 + 25) = v3;
  }
  if ( (v2 & 0x200) != 0 && *((_BYTE *)a2 + 24) == 8 )
  {
    if ( v3 != 3 )
    {
      *((_BYTE *)a2 + 24) = 16;
      v5 = v2 & 0x40000;
      goto LABEL_15;
    }
    v5 = v2 & 0x40000;
LABEL_45:
    *((_BYTE *)a2 + 29) = 1;
    v6 = 1;
    if ( !v5 )
      goto LABEL_23;
    v3 = 3;
    goto LABEL_47;
  }
  if ( (v2 & 4) != 0 && *((_BYTE *)a2 + 24) <= 7u )
    *((_BYTE *)a2 + 24) = 8;
  v5 = v2 & 0x40000;
  if ( v3 == 3 )
    goto LABEL_45;
LABEL_15:
  if ( (v3 & 2) == 0 )
  {
    *((_BYTE *)a2 + 29) = 1;
    v6 = 2;
    v7 = 1;
    if ( !v5 )
      goto LABEL_17;
    goto LABEL_35;
  }
  *((_BYTE *)a2 + 29) = 3;
  v6 = 4;
  v7 = 3;
  if ( v5 )
  {
LABEL_35:
    v6 = v7;
LABEL_47:
    v3 &= ~4u;
    *((_BYTE *)a2 + 25) = v3;
    *((_WORD *)a2 + 11) = 0;
    goto LABEL_19;
  }
LABEL_17:
  if ( (v3 & 4) != 0 )
    *((_BYTE *)a2 + 29) = v6;
  else
    v6 = v7;
LABEL_19:
  if ( (v2 & 0x8000) != 0 && (v3 & 0xFD) == 0 )
  {
    *((_BYTE *)a2 + 29) = ++v6;
    if ( (v2 & 0x1000000) != 0 )
      *((_BYTE *)a2 + 25) = v3 | 4;
  }
LABEL_23:
  v8 = *((_BYTE *)a2 + 24) * v6;
  v9 = *a2;
  *((_BYTE *)a2 + 30) = v8;
  if ( v8 <= 7u )
    result = (v9 * (unsigned int)v8 + 7) >> 3;
  else
    result = v9 * (v8 >> 3);
  a2[3] = result;
  *(_DWORD *)(a1 + 256) = result;
  return result;
}

//----- (00441CD0) --------------------------------------------------------
int __cdecl png_read_update_info(unsigned __int8 *a1, int *a2)
{
  int result; // eax

  if ( a1 )
  {
    if ( (a1[100] & 0x40) != 0 )
    {
      return png_app_error((int)a1);
    }
    else
    {
      png_read_start_row(a1);
      return png_read_transform_info((int)a1, a2);
    }
  }
  return result;
}

//----- (00441D20) --------------------------------------------------------
int __cdecl png_reciprocal(int a1)
{
  int result; // eax
  unsigned int v2; // ebx
  unsigned int v3; // esi
  unsigned int v4; // edi
  int v5; // edx
  unsigned int v6; // ebp
  unsigned int v7; // ecx
  char v8; // cl
  int v9; // edx
  bool v10; // sf
  int v11; // [esp+4h] [ebp-14h]

  result = 0;
  v2 = a1;
  if ( !a1 )
    return result;
  v11 = 0;
  if ( a1 < 0 )
  {
    v2 = -a1;
    v11 = 1;
    result = 0;
    if ( (unsigned int)-a1 <= 2 )
      return result;
  }
  else
  {
    result = 0;
    if ( (unsigned int)a1 <= 2 )
      return result;
  }
  v3 = 1410065408;
  v4 = 2;
  v5 = 31;
LABEL_8:
  v7 = v2 << v5;
  v6 = v2 >> (32 - v5);
  while ( 1 )
  {
    if ( v4 > v6 )
    {
      v4 = (__PAIR64__(v4, v3) - __PAIR64__(v6, v7)) >> 32;
      v3 -= v7;
      result += 1 << v5;
      goto LABEL_6;
    }
    if ( v4 == v6 && v3 >= v7 )
      break;
LABEL_6:
    if ( --v5 == -1 )
      goto LABEL_13;
LABEL_7:
    v6 = 0;
    if ( v5 )
      goto LABEL_8;
    v7 = v2;
  }
  v3 -= v7;
  v8 = v5--;
  result += 1 << v8;
  v4 = 0;
  if ( v5 != -1 )
    goto LABEL_7;
LABEL_13:
  result -= (v3 < v2 >> 1) - 1;
  if ( v11 )
  {
    v9 = -result;
    v10 = result < 0;
    result = 0;
    if ( !v10 )
      return v9;
  }
  else if ( result < 0 )
  {
    return 0;
  }
  return result;
}

//----- (00441E20) --------------------------------------------------------
int __usercall png_reciprocal_part_4@<eax>(int a1@<eax>)
{
  unsigned int v1; // ebx
  int result; // eax
  unsigned int v3; // esi
  unsigned int v4; // edi
  int v5; // edx
  unsigned int v6; // ebp
  unsigned int v7; // ecx
  char v8; // cl
  int v9; // edx
  bool v10; // sf
  int v11; // [esp+0h] [ebp-18h]

  v1 = a1;
  v11 = 0;
  if ( a1 < 0 )
  {
    v11 = 1;
    v1 = -a1;
  }
  result = 0;
  if ( v1 > 2 )
  {
    v3 = 1410065408;
    v4 = 2;
    v5 = 31;
LABEL_8:
    v7 = v1 << v5;
    v6 = v1 >> (32 - v5);
    while ( v4 <= v6 )
    {
      if ( v4 != v6 || v3 < v7 )
        goto LABEL_6;
      v3 -= v7;
      v8 = v5--;
      result += 1 << v8;
      v4 = 0;
      if ( v5 == -1 )
      {
LABEL_13:
        result -= (v3 < v1 >> 1) - 1;
        if ( v11 )
        {
          v9 = -result;
          v10 = result < 0;
          result = 0;
          if ( !v10 )
            return v9;
        }
        else if ( result < 0 )
        {
          return 0;
        }
        return result;
      }
LABEL_7:
      v6 = 0;
      v7 = v1;
      if ( v5 )
        goto LABEL_8;
    }
    v4 = (__PAIR64__(v4, v3) - __PAIR64__(v6, v7)) >> 32;
    v3 -= v7;
    result += 1 << v5;
LABEL_6:
    if ( --v5 == -1 )
      goto LABEL_13;
    goto LABEL_7;
  }
  return result;
}

//----- (00441EF0) --------------------------------------------------------
int __cdecl png_reciprocal2(int a1, int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // ebx
  int v6; // esi
  unsigned int v7; // ecx
  unsigned int v8; // edx
  int v9; // eax
  int v10; // ecx
  unsigned int v11; // edx
  __int64 v12; // rax
  int v13; // esi
  int v14; // ebx
  unsigned int v15; // edi
  unsigned int v16; // ecx
  char v17; // cl
  int v18; // esi
  int result; // eax
  unsigned int v20; // ebx
  unsigned int v21; // ebp
  int v22; // edx
  unsigned int v23; // edi
  unsigned int v24; // ecx
  char v25; // cl
  int v26; // edx
  bool v27; // sf
  int v28; // [esp+4h] [ebp-14h]

  v2 = a1;
  v3 = a2;
  if ( !a1 || !a2 )
    return 0;
  if ( a1 < 0 )
  {
    v2 = -a1;
    v4 = 0;
    v28 = 1;
  }
  else
  {
    v28 = 0;
    v4 = 1;
  }
  if ( a2 < 0 )
  {
    v28 = v4;
    v3 = -a2;
  }
  v5 = (unsigned __int16)v2;
  v6 = (unsigned __int16)v3;
  v7 = HIWORD(v3);
  v8 = HIWORD(v2);
  v9 = v7 * (unsigned __int16)v2;
  v10 = v8 * v7;
  v11 = v9 + v6 * v8;
  LODWORD(v12) = (v11 << 16) + v5 * v6;
  HIDWORD(v12) = v10 + HIWORD(v11) - (!__CFADD__(v11 << 16, v5 * v6) - 1);
  if ( HIDWORD(v12) > 0x1869F )
    return 0;
  v13 = 0;
  v14 = 31;
LABEL_12:
  v16 = 100000 << v14;
  v15 = 0x186A0u >> (32 - v14);
  while ( 1 )
  {
    if ( v15 < HIDWORD(v12) )
    {
      v12 -= v16;
      HIDWORD(v12) -= v15;
      v13 += 1 << v14;
LABEL_10:
      if ( --v14 == -1 )
        break;
      goto LABEL_11;
    }
    if ( v15 != HIDWORD(v12) || v16 > (unsigned int)v12 )
      goto LABEL_10;
    LODWORD(v12) = v12 - v16;
    v17 = v14--;
    v13 += 1 << v17;
    v12 = (unsigned int)v12;
    if ( v14 == -1 )
      break;
LABEL_11:
    v15 = 0;
    v16 = 100000;
    if ( v14 )
      goto LABEL_12;
  }
  v18 = v13 - (((unsigned int)v12 < 0xC350) - 1);
  if ( !v28 )
  {
    if ( v18 > 0 )
      goto LABEL_19;
    return 0;
  }
  result = 0;
  if ( v18 <= 0 )
    return result;
LABEL_19:
  result = 0;
  if ( (unsigned int)v18 <= 2 )
    return result;
  v20 = 1410065408;
  v21 = 2;
  v22 = 31;
  while ( 2 )
  {
    v24 = v18 << v22;
    v23 = (unsigned int)v18 >> (32 - v22);
LABEL_25:
    if ( v21 > v23 )
    {
      v21 = (__PAIR64__(v21, v20) - __PAIR64__(v23, v24)) >> 32;
      v20 -= v24;
      result += 1 << v22;
      goto LABEL_22;
    }
    if ( v21 != v23 || v20 < v24 )
    {
LABEL_22:
      if ( --v22 == -1 )
        break;
      goto LABEL_23;
    }
    v20 -= v24;
    v25 = v22--;
    v21 = 0;
    result += 1 << v25;
    if ( v22 != -1 )
    {
LABEL_23:
      v23 = 0;
      if ( v22 )
        continue;
      v24 = v18;
      goto LABEL_25;
    }
    break;
  }
  result -= (v20 < (unsigned int)v18 >> 1) - 1;
  if ( v28 )
  {
    v26 = -result;
    v27 = result < 0;
    result = 0;
    if ( !v27 )
      return v26;
  }
  else if ( result < 0 )
  {
    return 0;
  }
  return result;
}

//----- (004420E0) --------------------------------------------------------
int __cdecl png_reset_crc(int a1)
{
  int result; // eax

  result = crc32(0, 0, 0);
  *(_DWORD *)(a1 + 264) = result;
  return result;
}

//----- (00442110) --------------------------------------------------------
int __cdecl png_reset_zstream(int a1)
{
  if ( a1 )
    return inflateReset((_DWORD *)(a1 + 112));
  else
    return -2;
}

//----- (00442130) --------------------------------------------------------
void __cdecl __noreturn png_safe_error(int a1, char *a2)
{
  int *v2; // ebx
  int v3; // eax
  int *Buf; // eax
  unsigned int v5; // eax

  v2 = *(int **)(a1 + 80);
  if ( v2 )
  {
    png_safecat_part_0((int)(v2 + 8), 64, 0, a2);
    v3 = *v2;
    v2[7] |= 2u;
    if ( v3 )
    {
      Buf = *(int **)(v3 + 8);
      if ( Buf )
        longjmp(Buf, 1);
    }
    v5 = png_safecat_part_0((int)(v2 + 8), 64, 0, "bad longjmp: ");
    if ( v5 <= 0x3F )
      png_safecat_part_0((int)(v2 + 8), 64, v5, a2);
  }
  png_safe_error_cold_2();
}

//----- (004421C0) --------------------------------------------------------
int __cdecl png_safe_execute(int a1, int (__cdecl *a2)(int), int a3)
{
  int v3; // eax
  int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  char v7[72]; // [esp+20h] [ebp-48h] BYREF

  v6 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  v3 = _setjmp3(v7, 0);
  v5 = v3 == 0;
  if ( !v3 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 8) = v7;
    v5 = a2(a3);
  }
  *(_DWORD *)(*(_DWORD *)a1 + 8) = v6;
  if ( v5 )
    return v5;
  png_image_free(a1);
  return 0;
}
// 424E70: using guessed type int __cdecl _setjmp3(_DWORD, _DWORD);

//----- (00442240) --------------------------------------------------------
unsigned int __cdecl png_safecat(int a1, unsigned int a2, unsigned int a3, char *a4)
{
  unsigned int result; // eax
  char v5; // dl

  result = a3;
  if ( a1 && a3 < a2 )
  {
    if ( a4 )
    {
      v5 = *a4;
      if ( *a4 )
      {
        if ( a2 - 1 > a3 )
        {
          do
          {
            ++result;
            *(_BYTE *)(a1 + result - 1) = v5;
            v5 = a4[result - a3];
          }
          while ( v5 && a2 - 1 > result );
        }
      }
    }
    *(_BYTE *)(a1 + result) = 0;
  }
  return result;
}

//----- (00442290) --------------------------------------------------------
unsigned int __usercall png_safecat_part_0@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, char *a4)
{
  char v4; // bl
  char *v5; // esi

  if ( a4 )
  {
    v4 = *a4;
    if ( *a4 )
    {
      if ( a2 - 1 > a3 )
      {
        v5 = &a4[-a3];
        do
        {
          ++a3;
          *(_BYTE *)(a1 + a3 - 1) = v4;
          v4 = v5[a3];
        }
        while ( v4 && a3 < a2 - 1 );
      }
    }
  }
  *(_BYTE *)(a1 + a3) = 0;
  return a3;
}

//----- (004422D0) --------------------------------------------------------
__int16 __cdecl png_save_uint_16(_WORD *a1, __int16 a2)
{
  __int16 result; // ax

  result = __ROL2__(a2, 8);
  *a1 = result;
  return result;
}

//----- (004422F0) --------------------------------------------------------
unsigned __int32 __cdecl png_save_uint_32(unsigned __int32 *a1, unsigned int a2)
{
  unsigned __int32 result; // eax

  result = _byteswap_ulong(a2);
  *a1 = result;
  return result;
}

//----- (00442300) --------------------------------------------------------
void __cdecl png_set_IHDR(
        int a1,
        int a2,
        unsigned int a3,
        int a4,
        unsigned __int8 a5,
        unsigned __int8 a6,
        unsigned __int8 a7,
        unsigned __int8 a8,
        unsigned __int8 a9)
{
  char v9; // dl
  char v10; // al
  char v11; // cl
  unsigned __int8 v12; // al
  unsigned int v13; // eax
  __int64 v14; // [esp+18h] [ebp-14h]

  if ( a1 && a2 )
  {
    *(_DWORD *)a2 = a3;
    *(_DWORD *)(a2 + 4) = a4;
    *(_BYTE *)(a2 + 24) = a5;
    *(_BYTE *)(a2 + 25) = a6;
    *(_BYTE *)(a2 + 26) = a8;
    *(_BYTE *)(a2 + 27) = a9;
    *(_BYTE *)(a2 + 28) = a7;
    HIDWORD(v14) = a9;
    LODWORD(v14) = a8;
    png_check_IHDR(a1, a3, a4, a5, a6, a7, v14);
    v9 = *(_BYTE *)(a2 + 25);
    if ( v9 == 3 )
    {
      *(_BYTE *)(a2 + 29) = 1;
      v10 = 1;
    }
    else
    {
      if ( (v9 & 2) != 0 )
      {
        *(_BYTE *)(a2 + 29) = 3;
        v10 = 4;
        v11 = 3;
      }
      else
      {
        *(_BYTE *)(a2 + 29) = 1;
        v10 = 2;
        v11 = 1;
      }
      if ( (v9 & 4) != 0 )
        *(_BYTE *)(a2 + 29) = v10;
      else
        v10 = v11;
    }
    v12 = *(_BYTE *)(a2 + 24) * v10;
    *(_BYTE *)(a2 + 30) = v12;
    if ( v12 <= 7u )
      v13 = (a3 * v12 + 7) >> 3;
    else
      v13 = a3 * (v12 >> 3);
    *(_DWORD *)(a2 + 12) = v13;
  }
}

//----- (00442410) --------------------------------------------------------
void __cdecl png_set_PLTE(void *a1, int a2, void *Src, int a4)
{
  void *v4; // eax
  void *v5; // ebp

  if ( a1 && a2 )
  {
    if ( *(_BYTE *)(a2 + 25) == 3 )
    {
      if ( 1 << *(_BYTE *)(a2 + 24) < a4 || a4 < 0 )
        goto LABEL_11;
    }
    else if ( (unsigned int)a4 > 0x100 )
    {
      return;
    }
    if ( (Src != 0 || a4 <= 0) && a4 )
    {
      png_free_data(a1, a2, 4096, 0);
      v4 = png_calloc((int)a1, 0x300u);
      *((_DWORD *)a1 + 67) = v4;
      v5 = v4;
      memcpy(v4, Src, 3 * a4);
      *(_DWORD *)(a2 + 16) = v5;
      *((_WORD *)a1 + 136) = a4;
      *(_WORD *)(a2 + 20) = a4;
      *(_DWORD *)(a2 + 148) |= 0x1000u;
      *(_DWORD *)(a2 + 8) |= 8u;
      return;
    }
LABEL_11:
    png_err((int)a1);
  }
}

//----- (004424F0) --------------------------------------------------------
void __cdecl png_set_add_alpha(int a1, __int16 a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // eax

  if ( a1 )
  {
    if ( *(char *)(a1 + 97) >= 0 )
    {
      png_app_error(a1);
      v5 = *(_DWORD *)(a1 + 104);
      if ( (v5 & 0x8000) == 0 )
        return;
    }
    else
    {
      v3 = *(_DWORD *)(a1 + 100);
      *(_WORD *)(a1 + 292) = a2;
      v5 = *(_DWORD *)(a1 + 104);
      v4 = v3;
      LOBYTE(v3) = v3 | 0x80;
      LOBYTE(v4) = v4 & 0x7F;
      BYTE1(v5) |= 0x80u;
      if ( a3 != 1 )
        v3 = v4;
      *(_DWORD *)(a1 + 104) = v5;
      *(_DWORD *)(a1 + 100) = v3;
    }
    *(_DWORD *)(a1 + 104) = v5 | 0x1000000;
  }
}

//----- (00442560) --------------------------------------------------------
void __cdecl png_set_alpha_mode_fixed(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // edx
  int v6; // eax
  bool v7; // cc
  int v8; // edx
  int v9; // edx
  int v10; // eax
  int v11; // ecx

  v3 = a3;
  if ( !a1 )
    return;
  v4 = *(_DWORD *)(a1 + 100);
  if ( (v4 & 0x40) != 0 )
  {
    png_app_error(a1);
    return;
  }
  v5 = *(_DWORD *)(a1 + 100);
  BYTE1(v5) = BYTE1(v4) | 0x40;
  *(_DWORD *)(a1 + 100) = v5;
  if ( a3 == -1 || a3 == -100000 )
  {
    BYTE1(v4) |= 0x50u;
    v3 = 220000;
    *(_DWORD *)(a1 + 100) = v4;
  }
  else
  {
    if ( a3 == -2 || a3 == -50000 )
    {
      v3 = 151724;
      v6 = png_reciprocal(151724);
      v7 = a2 <= 1;
      if ( a2 != 1 )
        goto LABEL_11;
LABEL_28:
      *(_DWORD *)(a1 + 104) &= ~0x800000u;
      v3 = 100000;
      *(_DWORD *)(a1 + 100) &= ~0x2000u;
      goto LABEL_14;
    }
    if ( (unsigned int)(a3 - 1000) > 0x989298 )
      goto LABEL_8;
  }
  v6 = png_reciprocal(v3);
  v7 = a2 <= 1;
  if ( a2 == 1 )
    goto LABEL_28;
LABEL_11:
  if ( !v7 )
  {
    if ( a2 != 2 )
    {
      if ( a2 != 3 )
        goto LABEL_8;
      v8 = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(a1 + 104) |= 0x800000u;
      *(_DWORD *)(a1 + 100) &= ~0x2000u;
      if ( !v8 )
        goto LABEL_15;
      goto LABEL_22;
    }
    *(_DWORD *)(a1 + 104) &= ~0x800000u;
    *(_DWORD *)(a1 + 100) |= 0x2000u;
LABEL_14:
    v8 = *(_DWORD *)(a1 + 460);
    if ( !v8 )
    {
LABEL_15:
      *(_WORD *)(a1 + 534) |= 1u;
      *(_DWORD *)(a1 + 460) = v6;
      *(_DWORD *)(a1 + 324) = v3;
LABEL_16:
      *(_DWORD *)(a1 + 296) = v6;
      *(_WORD *)(a1 + 308) = 0;
      v9 = *(_DWORD *)(a1 + 104);
      *(_DWORD *)(a1 + 300) = 0;
      v10 = v9;
      *(_BYTE *)(a1 + 294) = 2;
      *(_DWORD *)(a1 + 304) = 0;
      BYTE1(v10) = BYTE1(v9) & 0xFE;
      if ( (v9 & 0x80) == 0 )
      {
        LOBYTE(v10) = v10 | 0x80;
        *(_DWORD *)(a1 + 104) = v10;
        return;
      }
      *(_DWORD *)(a1 + 104) = v10;
LABEL_8:
      png_err(a1);
    }
LABEL_22:
    *(_DWORD *)(a1 + 324) = v3;
    v6 = v8;
    goto LABEL_16;
  }
  if ( a2 )
    goto LABEL_8;
  v11 = *(_DWORD *)(a1 + 460);
  *(_DWORD *)(a1 + 104) &= ~0x800000u;
  *(_DWORD *)(a1 + 100) &= ~0x2000u;
  if ( !v11 )
  {
    *(_DWORD *)(a1 + 460) = v6;
    *(_WORD *)(a1 + 534) |= 1u;
  }
  *(_DWORD *)(a1 + 324) = v3;
}

//----- (00442740) --------------------------------------------------------
int __cdecl png_set_bKGD(int a1, int a2, int *a3)
{
  int result; // eax
  int v4; // ecx
  __int16 v5; // dx

  result = a2;
  if ( a3 != 0 && a2 != 0 )
  {
    if ( a1 )
    {
      v4 = *a3;
      *(_DWORD *)(a2 + 8) |= 0x20u;
      *(_DWORD *)(a2 + 138) = v4;
      v5 = *((_WORD *)a3 + 4);
      *(_DWORD *)(a2 + 142) = a3[1];
      *(_WORD *)(a2 + 146) = v5;
    }
  }
  return result;
}

//----- (00442790) --------------------------------------------------------
int __cdecl png_set_background_fixed(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int v6; // edx
  int v7; // ebx
  int v8; // ebx
  unsigned int v9; // ebx
  __int16 v10; // dx
  unsigned int v11; // edx

  result = a1;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a1 + 100);
    if ( (v6 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 100);
      BYTE1(v7) = BYTE1(v6) | 0x40;
      *(_DWORD *)(a1 + 100) = v7;
      if ( a3 && a2 )
      {
        v8 = *(_DWORD *)(a1 + 104);
        *(_DWORD *)(a1 + 296) = a5;
        BYTE1(v6) = BYTE1(v6) & 0x9F | 0x40;
        *(_DWORD *)(a1 + 100) = v6;
        v9 = v8 & 0xFF7BFE7F | 0x40180;
        *(_DWORD *)(a1 + 300) = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 304) = *(_DWORD *)(a2 + 4);
        v10 = *(_WORD *)(a2 + 8);
        *(_BYTE *)(a1 + 294) = a3;
        *(_WORD *)(a1 + 308) = v10;
        v11 = *(_DWORD *)(a1 + 104) & 0xFF7BFE7F | 0x40080;
        if ( a4 )
          v11 = v9;
        *(_DWORD *)(a1 + 104) = v11;
      }
    }
  }
  return result;
}

//----- (00442840) --------------------------------------------------------
unsigned int __cdecl png_set_benign_errors(int a1, int a2)
{
  int v2; // ecx
  unsigned int result; // eax
  int v4; // ecx

  v2 = *(_DWORD *)(a1 + 100);
  result = v2 & 0xFF8FFFFF;
  v4 = v2 | 0x700000;
  if ( a2 )
    result = v4;
  *(_DWORD *)(a1 + 100) = result;
  return result;
}

//----- (00442860) --------------------------------------------------------
int __cdecl png_set_bgr(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    *(_DWORD *)(a1 + 104) |= 1u;
  return result;
}

//----- (00442870) --------------------------------------------------------
void __cdecl png_set_cHRM_XYZ_fixed(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  int v11[12]; // [esp+1Ch] [ebp-30h] BYREF

  if ( a1 && a2 )
  {
    v11[0] = a3;
    v11[1] = a4;
    v11[2] = a5;
    v11[3] = a6;
    v11[4] = a7;
    v11[5] = a8;
    v11[6] = a9;
    v11[7] = a10;
    v11[8] = a11;
    if ( png_colorspace_set_endpoints(a1, a2 + 40, v11, 2) )
      *(_WORD *)(a2 + 114) |= 0x10u;
    png_colorspace_sync_info(a1, a2);
  }
}

//----- (00442910) --------------------------------------------------------
void __cdecl png_set_cHRM_fixed(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10[11]; // [esp+10h] [ebp-2Ch] BYREF

  if ( a1 && a2 )
  {
    v10[0] = a5;
    v10[1] = a6;
    v10[2] = a7;
    v10[3] = a8;
    v10[4] = a9;
    v10[5] = a10;
    v10[6] = a3;
    v10[7] = a4;
    if ( png_colorspace_set_chromaticities(a1, a2 + 40, v10, 2) )
      *(_WORD *)(a2 + 114) |= 0x10u;
    png_colorspace_sync_info(a1, a2);
  }
}

//----- (004429A0) --------------------------------------------------------
_DWORD *__cdecl png_set_compression_buffer_size(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a1 )
  {
    if ( a2 <= 0 )
      png_err(a1);
    if ( *(char *)(a1 + 97) < 0 )
    {
      *(_DWORD *)(a1 + 436) = a2;
    }
    else
    {
      result = *(_DWORD **)(a1 + 108);
      if ( !result && (unsigned int)a2 > 5 && *(_DWORD *)(a1 + 172) != a2 )
      {
        result = png_free_buffer_list((void *)a1, (_DWORD **)(a1 + 168));
        *(_DWORD *)(a1 + 172) = a2;
      }
    }
  }
  return result;
}

//----- (00442A10) --------------------------------------------------------
int __cdecl png_set_crc_action(int a1, int a2, int a3)
{
  int result; // eax
  bool v4; // cc
  int v5; // edx
  int v6; // edx
  int v7; // ecx

  result = a1;
  if ( !a1 )
    return result;
  if ( a2 == 4 )
  {
    *(_DWORD *)(a1 + 100) |= 0xC00u;
    v4 = a3 <= 3;
    if ( a3 != 3 )
      goto LABEL_7;
LABEL_14:
    v6 = *(_DWORD *)(a1 + 100);
    BYTE1(v6) = BYTE1(v6) & 0xFC | 1;
    *(_DWORD *)(a1 + 100) = v6;
    return result;
  }
  if ( a2 != 5 )
  {
    if ( a2 == 3 )
    {
      v7 = *(_DWORD *)(a1 + 100);
      BYTE1(v7) = BYTE1(v7) & 0xF3 | 4;
      *(_DWORD *)(a1 + 100) = v7;
    }
    else
    {
      *(_DWORD *)(a1 + 100) &= 0xFFFFF3FF;
    }
  }
  v4 = a3 <= 3;
  if ( a3 == 3 )
    goto LABEL_14;
LABEL_7:
  if ( v4 )
  {
    if ( a3 == 1 )
    {
      v5 = *(_DWORD *)(a1 + 100);
      BYTE1(v5) = BYTE1(v5) & 0xFC | 2;
      *(_DWORD *)(a1 + 100) = v5;
      return result;
    }
LABEL_17:
    *(_DWORD *)(a1 + 100) &= 0xFFFFFCFF;
    return result;
  }
  if ( a3 == 4 )
  {
    *(_DWORD *)(a1 + 100) |= 0x300u;
    return result;
  }
  if ( a3 != 5 )
    goto LABEL_17;
  return result;
}

//----- (00442AB0) --------------------------------------------------------
int __cdecl png_set_error_fn(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 80) = a2;
    *(_DWORD *)(a1 + 76) = a3;
  }
  return result;
}

//----- (00442AD0) --------------------------------------------------------
int __cdecl png_set_expand(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x2001000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00442B10) --------------------------------------------------------
int __cdecl png_set_expand_16(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x2001200u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00442B50) --------------------------------------------------------
int __cdecl png_set_expand_gray_1_2_4_to_8(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x1000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00442B90) --------------------------------------------------------
int __cdecl png_set_filler(int a1, __int16 a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ebx

  result = a1;
  if ( a1 )
  {
    if ( *(char *)(a1 + 97) >= 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      *(_WORD *)(a1 + 292) = a2;
      v4 = *(_DWORD *)(a1 + 100);
      *(_DWORD *)(a1 + 104) |= 0x8000u;
      v5 = v4;
      LOBYTE(v4) = v4 | 0x80;
      LOBYTE(v5) = v5 & 0x7F;
      if ( a3 != 1 )
        v4 = v5;
      *(_DWORD *)(a1 + 100) = v4;
    }
  }
  return result;
}

//----- (00442BE0) --------------------------------------------------------
int __cdecl png_set_filter(int a1, int a2, char a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a2 )
      png_err(a1);
    if ( a3 )
      return png_app_error(a1);
    else
      *(_BYTE *)(a1 + 280) = 8;
  }
  return result;
}

//----- (00442C30) --------------------------------------------------------
int __cdecl png_set_gAMA_fixed(int a1, int a2, int a3)
{
  int result; // eax

  result = a3;
  if ( a1 )
  {
    if ( a2 )
    {
      png_colorspace_set_gamma(a1, a2 + 40, a3);
      return png_colorspace_sync_info(a1, a2);
    }
  }
  return result;
}

//----- (00442C80) --------------------------------------------------------
int __cdecl png_set_gamma_fixed(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // esi
  int v7; // ebx

  result = a1;
  v4 = a2;
  v5 = a3;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a1 + 100);
    if ( (v6 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 100);
      BYTE1(v7) = BYTE1(v6) | 0x40;
      *(_DWORD *)(a1 + 100) = v7;
      if ( a2 == -1 || a2 == -100000 )
      {
        v4 = 220000;
        v7 = v6 | 0x5000;
        *(_DWORD *)(a1 + 100) = v6 | 0x5000;
      }
      else if ( a2 == -2 || a2 == -50000 )
      {
        v4 = 151724;
      }
      if ( a3 == -1 || a3 == -100000 )
      {
        BYTE1(v7) |= 0x10u;
        v5 = 45455;
        *(_DWORD *)(a1 + 100) = v7;
      }
      else if ( a3 == -2 || a3 == -50000 )
      {
        v5 = 65909;
      }
      else if ( a3 <= 0 )
      {
        goto LABEL_12;
      }
      if ( v4 <= 0 )
LABEL_12:
        png_err(a1);
      *(_WORD *)(a1 + 534) |= 1u;
      *(_DWORD *)(a1 + 460) = v5;
      *(_DWORD *)(a1 + 324) = v4;
    }
  }
  return result;
}

//----- (00442D80) --------------------------------------------------------
int __cdecl png_set_gray_to_rgb(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x5000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00442DC0) --------------------------------------------------------
int __cdecl png_set_interlace_handling(int a1)
{
  int result; // eax

  result = 1;
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 278) )
    {
      *(_DWORD *)(a1 + 104) |= 2u;
      return 7;
    }
  }
  return result;
}

//----- (00442DF0) --------------------------------------------------------
int __cdecl png_set_invalid(int a1, int a2, int a3)
{
  int result; // eax

  result = a2;
  if ( a1 )
  {
    if ( a2 )
      *(_DWORD *)(a2 + 8) &= ~a3;
  }
  return result;
}

//----- (00442E10) --------------------------------------------------------
_DWORD *__cdecl png_set_longjmp_fn(_DWORD *Size, int a2, size_t a3)
{
  _DWORD *result; // eax
  int v4; // edx

  if ( !Size )
    return 0;
  result = (_DWORD *)Size[17];
  if ( !result )
  {
    Size[18] = 0;
    if ( a3 > 0x40 )
    {
      result = png_malloc_warn((size_t)Size, a3);
      Size[17] = result;
      if ( !result )
        return 0;
      Size[18] = a3;
    }
    else
    {
      result = Size;
      Size[17] = Size;
    }
LABEL_7:
    Size[16] = a2;
    return result;
  }
  v4 = Size[18];
  if ( !v4 )
  {
    if ( result != Size )
      png_err((int)Size);
    v4 = 64;
  }
  if ( v4 == a3 )
    goto LABEL_7;
  return 0;
}

//----- (00442E90) --------------------------------------------------------
int __cdecl png_set_option(int a1, unsigned int a2, int a3)
{
  int result; // eax
  int v4; // esi
  int v5; // ebx

  if ( !a1 || a2 > 0xB )
    return 1;
  result = a2 & 1;
  if ( (a2 & 1) == 0 )
  {
    v4 = 2 << a2;
    v5 = *(_DWORD *)(a1 + 384);
    if ( a3 )
      v4 = 3 << a2;
    *(_DWORD *)(a1 + 384) = (unsigned __int8)(v4 | v5 & ~(unsigned __int8)(3 << a2));
    return (v5 & (3 << a2)) >> a2;
  }
  return result;
}

//----- (00442F00) --------------------------------------------------------
int __cdecl png_set_packing(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 282) <= 7u )
    {
      *(_DWORD *)(a1 + 104) |= 4u;
      *(_BYTE *)(a1 + 283) = 8;
    }
  }
  return result;
}

//----- (00442F20) --------------------------------------------------------
int __cdecl png_set_palette_to_rgb(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x2001000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00442F60) --------------------------------------------------------
_DWORD *__cdecl png_set_read_fn(_DWORD *a1, int a2, void (__cdecl *a3)(int a1, void *Buffer, size_t ElementCount))
{
  _DWORD *result; // eax
  void (__cdecl *v4)(int, void *, size_t); // edx

  result = a1;
  v4 = a3;
  if ( a1 )
  {
    a1[23] = a2;
    if ( !a3 )
      v4 = png_default_read_data;
    a1[22] = v4;
    if ( a1[21] )
      a1[21] = 0;
  }
  return result;
}

//----- (00442F90) --------------------------------------------------------
int __cdecl png_set_read_status_fn(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
    *(_DWORD *)(a1 + 376) = a2;
  return result;
}

//----- (00442FB0) --------------------------------------------------------
void __cdecl png_set_rgb_to_gray_fixed(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax

  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 100);
    if ( (v4 & 0x40) != 0 || (*(_BYTE *)(a1 + 96) & 1) == 0 )
    {
      png_app_error(a1);
      return;
    }
    BYTE1(v4) |= 0x40u;
    *(_DWORD *)(a1 + 100) = v4;
    switch ( a2 )
    {
      case 2:
        v5 = *(_DWORD *)(a1 + 104) | 0x400000;
        *(_DWORD *)(a1 + 104) = v5;
        break;
      case 3:
        v5 = *(_DWORD *)(a1 + 104) | 0x200000;
        *(_DWORD *)(a1 + 104) = v5;
        break;
      case 1:
        v5 = *(_DWORD *)(a1 + 104) | 0x600000;
        *(_DWORD *)(a1 + 104) = v5;
        break;
      default:
        png_err(a1);
    }
    if ( *(_BYTE *)(a1 + 281) == 3 )
    {
      BYTE1(v5) |= 0x10u;
      *(_DWORD *)(a1 + 104) = v5;
    }
    if ( a3 >= 0 && a4 >= 0 )
    {
      if ( a3 + a4 <= 100000 )
      {
        *(_BYTE *)(a1 + 393) = 1;
        *(_WORD *)(a1 + 394) = (unsigned int)((175921861 * (unsigned __int64)((a3 << 10) & 0x7FFFFFF)) >> 32) >> 7;
        *(_WORD *)(a1 + 396) = (unsigned int)((175921861 * (unsigned __int64)((a4 << 10) & 0x7FFFFFF)) >> 32) >> 7;
        return;
      }
      png_app_warning(a1);
    }
    if ( !*(_WORD *)(a1 + 394) && !*(_WORD *)(a1 + 396) )
      *(_DWORD *)(a1 + 394) = 1535777592;
  }
}

//----- (004430F0) --------------------------------------------------------
int __cdecl png_set_sBIT(int a1, int a2, int *a3)
{
  int result; // eax
  int v4; // ecx
  char v5; // dl

  result = a2;
  if ( a3 != 0 && a2 != 0 )
  {
    if ( a1 )
    {
      v4 = *a3;
      v5 = *((_BYTE *)a3 + 4);
      *(_DWORD *)(a2 + 8) |= 2u;
      *(_DWORD *)(a2 + 116) = v4;
      *(_BYTE *)(a2 + 120) = v5;
    }
  }
  return result;
}

//----- (00443130) --------------------------------------------------------
int __cdecl png_set_sRGB(int a1, int a2, unsigned int a3)
{
  int result; // eax

  result = a3;
  if ( a1 )
  {
    if ( a2 )
    {
      png_colorspace_set_sRGB(a1, a2 + 40, a3);
      return png_colorspace_sync_info(a1, a2);
    }
  }
  return result;
}

//----- (00443180) --------------------------------------------------------
int __cdecl png_set_sRGB_gAMA_and_cHRM(int a1, int a2, unsigned int a3)
{
  int result; // eax

  result = a3;
  if ( a1 && a2 )
  {
    if ( png_colorspace_set_sRGB(a1, a2 + 40, a3) )
      *(_WORD *)(a2 + 114) |= 0x18u;
    return png_colorspace_sync_info(a1, a2);
  }
  return result;
}

//----- (004431E0) --------------------------------------------------------
int __cdecl png_set_scale_16(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x4000000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00443220) --------------------------------------------------------
int __cdecl png_set_sig_bytes(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a1 )
  {
    if ( a2 < 0 )
    {
      result = 0;
    }
    else if ( a2 > 8 )
    {
      png_err(a1);
    }
    *(_BYTE *)(a1 + 287) = result;
  }
  return result;
}

//----- (00443250) --------------------------------------------------------
int __cdecl png_set_strip_16(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x400u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00443290) --------------------------------------------------------
int __cdecl png_set_strip_alpha(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x40000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (004432D0) --------------------------------------------------------
int __cdecl png_set_swap(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 282) == 16 )
      *(_DWORD *)(a1 + 104) |= 0x10u;
  }
  return result;
}

//----- (004432F0) --------------------------------------------------------
int __cdecl png_set_swap_alpha(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    *(_DWORD *)(a1 + 104) |= 0x20000u;
  return result;
}

//----- (00443300) --------------------------------------------------------
void __cdecl png_set_tRNS(void *a1, int a2, void *Src, size_t Size, int a5)
{
  __int16 v5; // di
  void *v6; // edx
  void *v7; // eax
  void *v8; // [esp+1Ch] [ebp-20h]

  v5 = Size;
  if ( a1 && a2 )
  {
    if ( Src )
    {
      png_free_data(a1, a2, 0x2000, 0);
      if ( Size - 1 <= 0xFF )
      {
        v7 = png_malloc((int)a1, 0x100u);
        *(_DWORD *)(a2 + 124) = v7;
        v8 = v7;
        memcpy(v7, Src, Size);
        v6 = v8;
      }
      else
      {
        v6 = *(void **)(a2 + 124);
      }
      *((_DWORD *)a1 + 90) = v6;
    }
    if ( a5 )
    {
      *(_DWORD *)(a2 + 128) = *(_DWORD *)a5;
      *(_DWORD *)(a2 + 132) = *(_DWORD *)(a5 + 4);
      *(_WORD *)(a2 + 136) = *(_WORD *)(a5 + 8);
      if ( !Size )
        v5 = 1;
      *(_WORD *)(a2 + 22) = v5;
      goto LABEL_11;
    }
    *(_WORD *)(a2 + 22) = Size;
    if ( Size )
    {
LABEL_11:
      *(_DWORD *)(a2 + 8) |= 0x10u;
      *(_DWORD *)(a2 + 148) |= 0x2000u;
    }
  }
}

//----- (004433F0) --------------------------------------------------------
int __cdecl png_set_tRNS_to_alpha(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 100);
    if ( (v2 & 0x40) != 0 )
    {
      return png_app_error(a1);
    }
    else
    {
      BYTE1(v2) |= 0x40u;
      *(_DWORD *)(a1 + 104) |= 0x2001000u;
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
  return result;
}

//----- (00443430) --------------------------------------------------------
_DWORD *__cdecl png_set_write_fn(_DWORD *a1, int a2, void (__cdecl *a3)(int a1, void *Buffer, size_t ElementCount))
{
  _DWORD *result; // eax
  void (__cdecl *v4)(int, void *, size_t); // edx

  result = a1;
  v4 = a3;
  if ( a1 )
  {
    a1[23] = a2;
    if ( !a3 )
      v4 = png_default_write_data;
    a1[21] = v4;
    if ( a1[22] )
      a1[22] = 0;
  }
  return result;
}

//----- (00443460) --------------------------------------------------------
int __cdecl png_set_write_status_fn(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
    *(_DWORD *)(a1 + 380) = a2;
  return result;
}

//----- (00443480) --------------------------------------------------------
int __cdecl png_sig_cmp(int a1, unsigned int a2, unsigned int a3)
{
  size_t Size; // edx
  int v5[5]; // [esp+18h] [ebp-14h] BYREF

  Size = a3;
  v5[0] = 1196314761;
  v5[1] = 169478669;
  if ( a3 > 8 )
  {
    Size = 8;
  }
  else if ( !a3 )
  {
    return -1;
  }
  if ( a2 > 7 )
    return -1;
  if ( Size + a2 > 8 )
    Size = 8 - a2;
  return memcmp((const void *)(a1 + a2), (char *)v5 + a2, Size);
}

//----- (00443500) --------------------------------------------------------
unsigned __int8 *__cdecl png_start_read_image(unsigned __int8 *Block)
{
  unsigned __int8 *result; // eax

  result = Block;
  if ( Block )
  {
    if ( (Block[100] & 0x40) != 0 )
      return (unsigned __int8 *)png_app_error((int)Block);
    else
      return (unsigned __int8 *)png_read_start_row(Block);
  }
  return result;
}

//----- (00443540) --------------------------------------------------------
int __cdecl png_user_version_check(int a1, char *a2)
{
  unsigned int v2; // eax
  char v3; // si
  char v4; // bl
  BOOL v5; // edi
  char v6; // bl
  char v7; // bl
  char v8; // bl
  char v9; // bl
  char v10; // bl

  v2 = *(_DWORD *)(a1 + 100);
  if ( a2 )
  {
    v3 = *a2;
    v4 = *a2;
    if ( *a2 == 49 )
    {
      v5 = 0;
      v6 = a2[1];
      if ( v6 != 46 )
      {
LABEL_5:
        v2 |= 0x20000u;
        *(_DWORD *)(a1 + 100) = v2;
        if ( !v6 )
          return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
LABEL_6:
        v7 = a2[2];
        if ( v7 != 54 )
        {
          v2 |= 0x20000u;
          *(_DWORD *)(a1 + 100) = v2;
          if ( v7 != 46 )
          {
            if ( !v7 )
              return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
            v8 = a2[3];
            if ( v8 != 46 )
            {
LABEL_11:
              v2 |= 0x20000u;
              *(_DWORD *)(a1 + 100) = v2;
              if ( !v8 )
                return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
              goto LABEL_12;
            }
LABEL_28:
            if ( v5 )
              return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
            v5 = 1;
LABEL_12:
            v9 = a2[4];
            if ( v9 != 51 )
            {
              v2 |= 0x20000u;
              *(_DWORD *)(a1 + 100) = v2;
              if ( v9 == 46 )
              {
                if ( v5 )
                  return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
                v5 = 1;
              }
              else if ( !v9 )
              {
                return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
              }
            }
            v10 = a2[5];
            if ( v10 == 52 )
              goto LABEL_19;
            v2 |= 0x20000u;
            *(_DWORD *)(a1 + 100) = v2;
            if ( v10 == 46 )
            {
              if ( !v5 )
                goto LABEL_19;
            }
            else if ( v10 )
            {
LABEL_19:
              if ( a2[6] )
              {
                v2 |= 0x20000u;
                *(_DWORD *)(a1 + 100) = v2;
              }
            }
            return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
          }
          if ( v5 )
            return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
          v5 = 1;
        }
        v8 = a2[3];
        if ( v8 != 46 )
          goto LABEL_11;
        goto LABEL_28;
      }
    }
    else
    {
      v2 |= 0x20000u;
      *(_DWORD *)(a1 + 100) = v2;
      v5 = v4 == 46;
      if ( !v3 )
        return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
      v6 = a2[1];
      if ( v6 != 46 )
        goto LABEL_5;
    }
    if ( v5 )
      return ((unsigned __int8)(v2 >> 17) ^ 1) & 1;
    v5 = 1;
    goto LABEL_6;
  }
  *(_DWORD *)(a1 + 100) = v2 | 0x20000;
  return 0;
}

//----- (004436B0) --------------------------------------------------------
int __cdecl png_write_IEND(int a1)
{
  int result; // eax
  int v2[4]; // [esp+1Ch] [ebp-10h] BYREF

  if ( a1 )
  {
    v2[0] = 1145980233;
    png_write_data(a1);
    *(_DWORD *)(a1 + 244) = 1229278788;
    png_reset_crc(a1);
    png_calculate_crc(a1, v2, 4u);
    result = png_write_data(a1);
  }
  *(_DWORD *)(a1 + 96) |= 0x10u;
  return result;
}
// 4436B0: using guessed type int var_10[4];

//----- (00443760) --------------------------------------------------------
int __cdecl png_write_IHDR(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  char v5; // bp
  unsigned __int8 v6; // al
  unsigned int v7; // eax
  int result; // eax
  int v9; // [esp+1Ch] [ebp-30h] BYREF
  int v10[2]; // [esp+23h] [ebp-29h] BYREF
  char v11; // [esp+2Bh] [ebp-21h]
  char v12; // [esp+2Ch] [ebp-20h]
  __int16 v13; // [esp+2Dh] [ebp-1Fh]
  char v14; // [esp+2Fh] [ebp-1Dh]

  switch ( a5 )
  {
    case 0:
      if ( a4 <= 0x10 && ((1 << a4) & 0x10116) != 0 )
        goto LABEL_13;
      goto LABEL_18;
    case 2:
      if ( ((a4 - 8) & 0xFFFFFFF7) != 0 )
        goto LABEL_18;
      *(_BYTE *)(a1 + 285) = 3;
      v5 = 3;
      break;
    case 3:
      if ( a4 > 8 || ((1 << a4) & 0x116) == 0 )
        goto LABEL_18;
LABEL_13:
      *(_BYTE *)(a1 + 285) = 1;
      v5 = 1;
      break;
    case 4:
      if ( ((a4 - 8) & 0xFFFFFFF7) != 0 )
        goto LABEL_18;
      *(_BYTE *)(a1 + 285) = 2;
      v5 = 2;
      break;
    case 6:
      if ( ((a4 - 8) & 0xFFFFFFF7) != 0 )
        goto LABEL_18;
      *(_BYTE *)(a1 + 285) = 4;
      v5 = 4;
      break;
    default:
LABEL_18:
      png_err(a1);
  }
  *(_BYTE *)(a1 + 282) = a4;
  *(_BYTE *)(a1 + 281) = a5;
  v6 = a4 * v5;
  *(_BYTE *)(a1 + 278) = 0;
  *(_BYTE *)(a1 + 404) = 0;
  *(_DWORD *)(a1 + 216) = a2;
  *(_DWORD *)(a1 + 220) = a3;
  *(_BYTE *)(a1 + 284) = a4 * v5;
  if ( (unsigned __int8)(a4 * v5) <= 7u )
    v7 = (a2 * v6 + 7) >> 3;
  else
    v7 = a2 * (v6 >> 3);
  *(_DWORD *)(a1 + 232) = v7;
  *(_BYTE *)(a1 + 286) = v5;
  *(_BYTE *)(a1 + 283) = a4;
  *(_DWORD *)(a1 + 228) = a2;
  v12 = a5;
  v10[0] = _byteswap_ulong(a2);
  v11 = a4;
  v13 = 0;
  v10[1] = _byteswap_ulong(a3);
  v14 = 0;
  v9 = 1380206665;
  png_write_data(a1);
  *(_DWORD *)(a1 + 244) = 1229472850;
  png_reset_crc(a1);
  png_calculate_crc(a1, &v9, 4u);
  png_write_data(a1);
  png_calculate_crc(a1, v10, 0xDu);
  result = png_write_data(a1);
  if ( *(_BYTE *)(a1 + 280) )
    goto LABEL_10;
  if ( *(_BYTE *)(a1 + 281) != 3 && *(_BYTE *)(a1 + 282) > 7u )
  {
    *(_BYTE *)(a1 + 280) = -8;
LABEL_10:
    *(_DWORD *)(a1 + 96) = 1;
    return result;
  }
  *(_BYTE *)(a1 + 280) = 8;
  *(_DWORD *)(a1 + 96) = 1;
  return result;
}
// 443760: using guessed type int var_30;

//----- (004439D0) --------------------------------------------------------
int __cdecl png_write_PLTE(int a1, char *a2, unsigned int a3)
{
  int result; // eax
  char *v4; // ebp
  char v5; // dl
  unsigned __int16 v6; // ax
  char v7[3]; // [esp+15h] [ebp-27h] BYREF
  int v8; // [esp+18h] [ebp-24h]
  int v9[8]; // [esp+1Ch] [ebp-20h] BYREF

  result = *(unsigned __int8 *)(a1 + 281);
  if ( (_BYTE)result == 3 )
  {
    if ( 1 << *(_BYTE *)(a1 + 282) < a3 || !a3 )
      png_err(a1);
  }
  else if ( a3 - 1 > 0xFF || (result & 2) == 0 )
  {
    return result;
  }
  *(_WORD *)(a1 + 272) = a3;
  v8 = _byteswap_ulong(3 * a3);
  v9[0] = 1163152464;
  png_write_data(a1);
  *(_DWORD *)(a1 + 244) = 1347179589;
  png_reset_crc(a1);
  png_calculate_crc(a1, v9, 4u);
  if ( a3 )
  {
    v4 = a2;
    do
    {
      v5 = *v4;
      v4 += 3;
      v7[0] = v5;
      v7[1] = *(v4 - 2);
      v7[2] = *(v4 - 1);
      png_write_data(a1);
      png_calculate_crc(a1, v7, 3u);
    }
    while ( &a2[3 * a3] != v4 );
  }
  LOBYTE(v6) = HIBYTE(*(_DWORD *)(a1 + 264));
  HIBYTE(v6) = BYTE2(*(_DWORD *)(a1 + 264));
  v8 = (*(_DWORD *)(a1 + 264) << 24) | ((unsigned __int8)BYTE1(*(_DWORD *)(a1 + 264)) << 16) | v6;
  result = png_write_data(a1);
  *(_DWORD *)(a1 + 96) |= 2u;
  return result;
}
// 4439D0: using guessed type int var_20[8];

//----- (00443B40) --------------------------------------------------------
int __cdecl png_write_chunk(int a1, int *a2, _BYTE *a3, signed int a4)
{
  int result; // eax
  unsigned int v5; // ebp
  unsigned __int32 v6[8]; // [esp+1Ch] [ebp-20h] BYREF

  result = *a2;
  if ( a1 )
  {
    if ( a4 < 0 )
      png_err(a1);
    v5 = _byteswap_ulong(result);
    v6[0] = _byteswap_ulong(v5);
    png_write_data(a1);
    *(_DWORD *)(a1 + 244) = v5;
    png_reset_crc(a1);
    png_calculate_crc(a1, v6, 4u);
    if ( a3 )
    {
      if ( a4 )
      {
        png_write_data(a1);
        png_calculate_crc(a1, a3, a4);
      }
    }
    return png_write_data(a1);
  }
  return result;
}
// 443B40: using guessed type unsigned __int32 var_20[8];

//----- (00443C50) --------------------------------------------------------
int __cdecl png_write_chunk_data(int a1, _BYTE *a2, unsigned int a3)
{
  int result; // eax

  if ( a1 && a2 )
  {
    if ( a3 )
    {
      png_write_data(a1);
      return png_calculate_crc(a1, a2, a3);
    }
  }
  return result;
}

//----- (00443CA0) --------------------------------------------------------
int __cdecl png_write_chunk_end(int a1)
{
  int result; // eax

  if ( a1 )
    return png_write_data(a1);
  return result;
}

//----- (00443D00) --------------------------------------------------------
int __cdecl png_write_chunk_start(int a1, unsigned int *a2)
{
  unsigned __int32 v2; // esi
  int result; // eax
  unsigned int v4[4]; // [esp+1Ch] [ebp-10h] BYREF

  if ( a1 )
  {
    v2 = _byteswap_ulong(*a2);
    v4[0] = *a2;
    png_write_data(a1);
    *(_DWORD *)(a1 + 244) = v2;
    png_reset_crc(a1);
    return png_calculate_crc(a1, v4, 4u);
  }
  return result;
}
// 443D00: using guessed type unsigned int var_10[4];

//----- (00443D70) --------------------------------------------------------
int __usercall png_write_complete_chunk@<eax>(int result@<eax>, unsigned int a2@<edx>, _BYTE *a3@<ecx>, signed int a4)
{
  int v6; // ebx
  unsigned __int32 v7[8]; // [esp+1Ch] [ebp-20h] BYREF

  if ( result )
  {
    v6 = result;
    if ( a4 < 0 )
      png_err(result);
    v7[0] = _byteswap_ulong(a2);
    png_write_data(result);
    *(_DWORD *)(v6 + 244) = a2;
    png_reset_crc(v6);
    png_calculate_crc(v6, v7, 4u);
    if ( a3 )
    {
      if ( a4 )
      {
        png_write_data(v6);
        png_calculate_crc(v6, a3, a4);
      }
    }
    return png_write_data(v6);
  }
  return result;
}
// 443D70: using guessed type unsigned __int32 var_20[8];

//----- (00443E70) --------------------------------------------------------
int __cdecl png_write_data(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(a1 + 84);
  if ( !v1 )
    png_err(a1);
  return v1();
}

//----- (00443E90) --------------------------------------------------------
void __cdecl png_write_end(int a1)
{
  int v1; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 96);
    if ( (v1 & 4) == 0 )
      png_err(a1);
    *(_DWORD *)(a1 + 96) = v1 | 8;
    png_write_IEND(a1);
  }
}

//----- (00443EC0) --------------------------------------------------------
unsigned int __cdecl png_write_find_filter(_DWORD *a1, int a2)
{
  unsigned int result; // eax

  png_compress_IDAT(a1, a1[63], *(_DWORD *)(a2 + 4) + 1, 0);
  result = a1[60] + 1;
  a1[60] = result;
  if ( result >= a1[56] )
    return png_compress_IDAT(a1, 0, 0, 4);
  return result;
}

//----- (00443F30) --------------------------------------------------------
unsigned int __cdecl png_write_finish_row(_DWORD *a1)
{
  unsigned int result; // eax

  result = a1[60] + 1;
  a1[60] = result;
  if ( result >= a1[56] )
    return png_compress_IDAT(a1, 0, 0, 4);
  return result;
}

//----- (00443F80) --------------------------------------------------------
void __cdecl png_write_image(_BYTE *a1, int a2)
{
  unsigned int i; // esi
  const void *Src; // ebp
  char v4; // dl
  int v5; // ecx
  char v6; // al
  unsigned __int8 v7; // al
  unsigned int Size; // ecx
  void *v9; // eax
  void (__cdecl *v10)(_BYTE *, _DWORD, _DWORD); // eax
  int v11[2]; // [esp+14h] [ebp-28h] BYREF
  char v12; // [esp+1Ch] [ebp-20h]
  char v13; // [esp+1Dh] [ebp-1Fh]
  char v14; // [esp+1Eh] [ebp-1Eh]
  unsigned __int8 v15; // [esp+1Fh] [ebp-1Dh]

  if ( a1 )
  {
    for ( i = 0; *((_DWORD *)a1 + 55) > i; ++i )
    {
      while ( 1 )
      {
        Src = *(const void **)(a2 + 4 * i);
        if ( !*((_DWORD *)a1 + 60) && !a1[279] )
        {
          if ( (a1[97] & 4) == 0 )
            goto LABEL_18;
          png_write_start_row((int)a1);
        }
        v4 = a1[283];
        v5 = *((_DWORD *)a1 + 57);
        v12 = a1[281];
        v6 = a1[286];
        v11[0] = v5;
        v14 = v6;
        v7 = v4 * v6;
        v13 = v4;
        v15 = v7;
        if ( v7 <= 7u )
          Size = ((unsigned int)v7 * v5 + 7) >> 3;
        else
          Size = (v7 >> 3) * v5;
        v9 = (void *)(*((_DWORD *)a1 + 63) + 1);
        v11[1] = Size;
        memcpy(v9, Src, Size);
        if ( v15 != a1[284] || v15 != a1[289] )
LABEL_18:
          png_err((int)a1);
        png_write_find_filter(a1, (int)v11);
        v10 = (void (__cdecl *)(_BYTE *, _DWORD, _DWORD))*((_DWORD *)a1 + 95);
        if ( !v10 )
          break;
        ++i;
        v10(a1, *((_DWORD *)a1 + 60), (unsigned __int8)a1[279]);
        if ( i >= *((_DWORD *)a1 + 55) )
          return;
      }
    }
  }
}

//----- (004440E0) --------------------------------------------------------
int __cdecl png_write_info(int a1, int a2)
{
  int result; // eax

  if ( a1 && a2 )
  {
    if ( (*(_BYTE *)(a1 + 97) & 4) == 0 )
    {
      png_write_sig(a1);
      result = png_write_IHDR(
                 a1,
                 *(_DWORD *)a2,
                 *(_DWORD *)(a2 + 4),
                 *(unsigned __int8 *)(a2 + 24),
                 *(unsigned __int8 *)(a2 + 25));
      *(_DWORD *)(a1 + 96) |= 0x400u;
    }
    if ( (*(_BYTE *)(a2 + 8) & 8) != 0 )
    {
      return png_write_PLTE(a1, *(char **)(a2 + 16), *(unsigned __int16 *)(a2 + 20));
    }
    else if ( *(_BYTE *)(a2 + 25) == 3 )
    {
      png_err(a1);
    }
  }
  return result;
}

//----- (00444190) --------------------------------------------------------
int __cdecl png_write_info_before_PLTE(int a1, int a2)
{
  int result; // eax

  if ( a1 && a2 && (*(_BYTE *)(a1 + 97) & 4) == 0 )
  {
    png_write_sig(a1);
    result = png_write_IHDR(
               a1,
               *(_DWORD *)a2,
               *(_DWORD *)(a2 + 4),
               *(unsigned __int8 *)(a2 + 24),
               *(unsigned __int8 *)(a2 + 25));
    *(_DWORD *)(a1 + 96) |= 0x400u;
  }
  return result;
}

//----- (00444210) --------------------------------------------------------
void __cdecl png_write_row(_BYTE *a1, void *Src)
{
  char v2; // dl
  int v3; // ecx
  char v4; // al
  unsigned __int8 v5; // al
  unsigned int Size; // eax
  int v7; // ecx
  void (__cdecl *v8)(_BYTE *, _DWORD, _DWORD); // eax
  int v9[2]; // [esp+14h] [ebp-18h] BYREF
  char v10; // [esp+1Ch] [ebp-10h]
  char v11; // [esp+1Dh] [ebp-Fh]
  char v12; // [esp+1Eh] [ebp-Eh]
  unsigned __int8 v13; // [esp+1Fh] [ebp-Dh]

  if ( a1 )
  {
    if ( !*((_DWORD *)a1 + 60) && !a1[279] )
    {
      if ( (a1[97] & 4) == 0 )
        goto LABEL_14;
      png_write_start_row((int)a1);
    }
    v2 = a1[283];
    v3 = *((_DWORD *)a1 + 57);
    v10 = a1[281];
    v4 = a1[286];
    v9[0] = v3;
    v12 = v4;
    v5 = v2 * v4;
    v11 = v2;
    v13 = v5;
    if ( v5 > 7u )
      Size = v3 * (v5 >> 3);
    else
      Size = (v3 * (unsigned int)v5 + 7) >> 3;
    v7 = *((_DWORD *)a1 + 63);
    v9[1] = Size;
    memcpy((void *)(v7 + 1), Src, Size);
    if ( v13 == a1[284] && v13 == a1[289] )
    {
      png_write_find_filter(a1, (int)v9);
      v8 = (void (__cdecl *)(_BYTE *, _DWORD, _DWORD))*((_DWORD *)a1 + 95);
      if ( v8 )
        v8(a1, *((_DWORD *)a1 + 60), (unsigned __int8)a1[279]);
      return;
    }
LABEL_14:
    png_err((int)a1);
  }
}

//----- (00444320) --------------------------------------------------------
void __cdecl png_write_rows(_BYTE *a1, int a2, int a3)
{
  int v3; // esi
  const void *Src; // ebp
  char v5; // dl
  int v6; // ecx
  char v7; // al
  unsigned __int8 v8; // al
  unsigned int Size; // ecx
  void *v10; // eax
  void (__cdecl *v11)(_BYTE *, _DWORD, _DWORD); // eax
  int v12[2]; // [esp+14h] [ebp-28h] BYREF
  char v13; // [esp+1Ch] [ebp-20h]
  char v14; // [esp+1Dh] [ebp-1Fh]
  char v15; // [esp+1Eh] [ebp-1Eh]
  unsigned __int8 v16; // [esp+1Fh] [ebp-1Dh]

  if ( a1 )
  {
    v3 = 0;
    if ( a3 )
    {
      do
      {
        while ( 1 )
        {
          Src = *(const void **)(a2 + 4 * v3);
          if ( !*((_DWORD *)a1 + 60) && !a1[279] )
          {
            if ( (a1[97] & 4) == 0 )
              goto LABEL_17;
            png_write_start_row((int)a1);
          }
          v5 = a1[283];
          v6 = *((_DWORD *)a1 + 57);
          v13 = a1[281];
          v7 = a1[286];
          v12[0] = v6;
          v15 = v7;
          v8 = v5 * v7;
          v14 = v5;
          v16 = v8;
          if ( v8 <= 7u )
            Size = ((unsigned int)v8 * v6 + 7) >> 3;
          else
            Size = (v8 >> 3) * v6;
          v10 = (void *)(*((_DWORD *)a1 + 63) + 1);
          v12[1] = Size;
          memcpy(v10, Src, Size);
          if ( v16 != a1[284] || v16 != a1[289] )
LABEL_17:
            png_err((int)a1);
          png_write_find_filter(a1, (int)v12);
          v11 = (void (__cdecl *)(_BYTE *, _DWORD, _DWORD))*((_DWORD *)a1 + 95);
          if ( !v11 )
            break;
          ++v3;
          v11(a1, *((_DWORD *)a1 + 60), (unsigned __int8)a1[279]);
          if ( v3 == a3 )
            return;
        }
        ++v3;
      }
      while ( a3 != v3 );
    }
  }
}

//----- (00444460) --------------------------------------------------------
int __cdecl png_write_sig(int a1)
{
  int result; // eax

  result = png_write_data(a1);
  if ( *(_BYTE *)(a1 + 287) <= 2u )
    *(_DWORD *)(a1 + 96) |= 0x1000u;
  return result;
}

//----- (004444B0) --------------------------------------------------------
int __cdecl png_write_start_row(int a1)
{
  int v1; // edx
  int v2; // eax
  unsigned int v3; // eax
  char v4; // cl
  _BYTE *v5; // eax
  int v6; // edx
  int result; // eax

  v1 = *(unsigned __int8 *)(a1 + 283) * *(unsigned __int8 *)(a1 + 286);
  v2 = *(_DWORD *)(a1 + 216);
  if ( v1 <= 7 )
    v3 = (unsigned int)(v1 * v2 + 7) >> 3;
  else
    v3 = ((unsigned int)v1 >> 3) * v2;
  v4 = *(_BYTE *)(a1 + 284);
  *(_BYTE *)(a1 + 288) = v1;
  *(_BYTE *)(a1 + 289) = v4;
  v5 = png_malloc(a1, v3 + 1);
  v6 = *(_DWORD *)(a1 + 220);
  *(_DWORD *)(a1 + 252) = v5;
  *v5 = 0;
  result = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(a1 + 224) = v6;
  *(_DWORD *)(a1 + 228) = result;
  return result;
}

//----- (00444540) --------------------------------------------------------
BOOL __usercall png_xy_from_XYZ@<eax>(int *a1@<eax>, int *a2@<edx>)
{
  int v2; // ebp
  int v3; // esi
  int v6; // edx
  int v7; // edx
  int v8; // ebp
  int v9; // edx
  int v10; // edx
  int v11; // edx
  int v12; // esi
  int v13; // ebp
  int v14; // edx
  int v16; // [esp+4h] [ebp-24h]
  int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+Ch] [ebp-1Ch]
  int v19; // [esp+10h] [ebp-18h]
  int v20; // [esp+14h] [ebp-14h]

  v2 = *a2;
  v3 = a2[2] + *a2 + a2[1];
  if ( !v3 )
    return 1;
  if ( v2 )
  {
    if ( !png_muldiv_part_3(a1, v2, 100000, v3) )
      return 1;
    v6 = a2[1];
    if ( v6 )
      goto LABEL_5;
  }
  else
  {
    *a1 = 0;
    v6 = a2[1];
    if ( v6 )
    {
LABEL_5:
      if ( !png_muldiv_part_3(a1 + 1, v6, 100000, v3) )
        return 1;
      v7 = a2[3];
      v8 = a2[5] + v7 + a2[4];
      if ( !v8 )
        return 1;
      goto LABEL_7;
    }
  }
  a1[1] = 0;
  v7 = a2[3];
  v8 = a2[5] + v7 + a2[4];
  if ( !v8 )
    return 1;
LABEL_7:
  v17 = *a2;
  v18 = a2[1];
  if ( v7 )
  {
    if ( !png_muldiv_part_3(a1 + 2, v7, 100000, v8) )
      return 1;
  }
  else
  {
    a1[2] = 0;
  }
  v9 = a2[4];
  if ( v9 )
  {
    if ( !png_muldiv_part_3(a1 + 3, v9, 100000, v8) )
      return 1;
  }
  else
  {
    a1[3] = 0;
  }
  v10 = a2[6];
  v16 = a2[8] + v10 + a2[7];
  if ( !v16 )
    return 1;
  v19 = a2[3];
  v20 = a2[4];
  if ( v10 )
  {
    if ( !png_muldiv_part_3(a1 + 4, v10, 100000, v16) )
      return 1;
  }
  else
  {
    a1[4] = 0;
  }
  v11 = a2[7];
  if ( v11 )
  {
    if ( !png_muldiv_part_3(a1 + 5, v11, 100000, v16) )
      return 1;
  }
  else
  {
    a1[5] = 0;
  }
  v12 = v16 + v8 + v3;
  if ( !v12 )
    return 1;
  v13 = a2[7];
  if ( a2[6] + v17 + v19 )
  {
    if ( png_muldiv_part_3(a1 + 6, a2[6] + v17 + v19, 100000, v12) )
      goto LABEL_19;
    return 1;
  }
  a1[6] = 0;
LABEL_19:
  v14 = v18 + v20 + v13;
  if ( v14 )
    return png_muldiv_part_3(a1 + 7, v14, 100000, v12) == 0;
  a1[7] = 0;
  return 0;
}

//----- (00444770) --------------------------------------------------------
void *__cdecl png_zalloc(int a1, size_t a2, unsigned int a3)
{
  if ( a1 && 0xFFFFFFFF / a3 > a2 )
    return png_malloc_warn(a1, a2 * a3);
  else
    return 0;
}

//----- (004447C0) --------------------------------------------------------
int __cdecl png_zlib_inflate(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 290) || !*(_DWORD *)(a1 + 116) )
    return inflate(a1 + 112, a2);
  if ( **(char **)(a1 + 112) >= 0 )
  {
    *(_BYTE *)(a1 + 290) = 0;
    return inflate(a1 + 112, a2);
  }
  *(_DWORD *)(a1 + 136) = "invalid window size (libpng)";
  return -3;
}

//----- (00444810) --------------------------------------------------------
int __cdecl png_zstream_error(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( !*(_DWORD *)(a1 + 136) )
  {
    switch ( a2 )
    {
      case -7:
        *(_DWORD *)(a1 + 136) = "unexpected zlib return";
        break;
      case -6:
        *(_DWORD *)(a1 + 136) = "unsupported zlib version";
        break;
      case -5:
        *(_DWORD *)(a1 + 136) = "truncated";
        break;
      case -4:
        *(_DWORD *)(a1 + 136) = "insufficient memory";
        break;
      case -3:
        *(_DWORD *)(a1 + 136) = "damaged LZ stream";
        break;
      case -2:
        *(_DWORD *)(a1 + 136) = "bad parameters to zlib";
        break;
      case -1:
        *(_DWORD *)(a1 + 136) = "zlib IO error";
        break;
      case 1:
        *(_DWORD *)(a1 + 136) = "unexpected end of LZ stream";
        break;
      case 2:
        *(_DWORD *)(a1 + 136) = "missing LZ dictionary";
        break;
      default:
        *(_DWORD *)(a1 + 136) = "unexpected zlib return code";
        break;
    }
  }
  return result;
}

//----- (004448E0) --------------------------------------------------------
int __usercall pqdownheap_constprop_1@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ebp
  int v3; // edx
  int v4; // edi
  int v5; // ebx
  unsigned __int16 v6; // si
  int v7; // edi
  unsigned __int16 v8; // cx
  int v9; // [esp+0h] [ebp-24h]
  int v10; // [esp+4h] [ebp-20h]
  unsigned __int16 v12; // [esp+Eh] [ebp-16h]
  int v13; // [esp+10h] [ebp-14h]

  v13 = *(_DWORD *)(result + 2912);
  v10 = *(_DWORD *)(result + 5200);
  if ( v10 <= 1 )
  {
    v2 = 1;
  }
  else
  {
    v2 = 1;
    v9 = 2;
    v12 = *(_WORD *)(a2 + 4 * *(_DWORD *)(result + 2912));
    do
    {
      v3 = v9;
      v4 = result + 4 * v9;
      v5 = *(_DWORD *)(v4 + 2908);
      v6 = *(_WORD *)(a2 + 4 * v5);
      if ( v9 < v10 )
      {
        v7 = *(_DWORD *)(v4 + 2912);
        v3 = v9 + 1;
        v8 = *(_WORD *)(a2 + 4 * v7);
        if ( v8 < v6 )
        {
          v6 = *(_WORD *)(a2 + 4 * v7);
          v5 = v7;
        }
        else if ( v8 == v6 && *(_BYTE *)(result + v7 + 5208) <= *(_BYTE *)(result + v5 + 5208) )
        {
          v5 = v7;
        }
        else
        {
          v3 = v9;
        }
      }
      if ( v12 < v6 || v12 == v6 && *(_BYTE *)(result + v13 + 5208) <= *(_BYTE *)(result + v5 + 5208) )
        break;
      *(_DWORD *)(result + 4 * v2 + 2908) = v5;
      v2 = v3;
      v9 = 2 * v3;
    }
    while ( 2 * v3 <= v10 );
  }
  *(_DWORD *)(result + 4 * v2 + 2908) = v13;
  return result;
}

//----- (004449D0) --------------------------------------------------------
_WORD *__usercall scan_tree@<eax>(_WORD *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi
  int v4; // ebx
  int v5; // ebp
  int v6; // edi
  unsigned __int16 *v7; // ecx
  int v8; // edx
  int v9; // esi
  int v10; // [esp+0h] [ebp-18h]
  int v11; // [esp+4h] [ebp-14h]

  v3 = 4 * a3 + 4;
  v4 = *(unsigned __int16 *)(a2 + 2);
  *(_WORD *)(a2 + v3 + 2) = -1;
  v5 = 4 - (v4 == 0);
  v6 = v4 == 0 ? 138 : 7;
  if ( a3 >= 0 )
  {
    v7 = (unsigned __int16 *)(a2 + 6);
    v10 = -1;
    v11 = a2 + v3 + 6;
    v8 = 0;
    while ( 1 )
    {
      ++v8;
      v9 = *v7;
      if ( v8 < v6 )
      {
        if ( v9 == v4 )
          goto LABEL_10;
        if ( v8 < v5 )
        {
          result[2 * v4 + 1342] += v8;
          if ( v9 )
            goto LABEL_15;
LABEL_17:
          v8 = 0;
          v10 = v4;
          v5 = 3;
          v6 = 138;
          goto LABEL_10;
        }
      }
      if ( v4 )
      {
        if ( v4 != v10 )
          ++result[2 * v4 + 1342];
        ++result[1374];
      }
      else if ( v8 > 10 )
      {
        ++result[1378];
      }
      else
      {
        ++result[1376];
      }
      if ( !v9 )
        goto LABEL_17;
      if ( v9 == v4 )
      {
        v10 = v9;
        v5 = 3;
        v6 = 6;
        v8 = 0;
LABEL_10:
        v7 += 2;
        v4 = v9;
        if ( (unsigned __int16 *)v11 == v7 )
          return result;
      }
      else
      {
LABEL_15:
        v10 = v4;
        v5 = 4;
        v6 = 7;
        v8 = 0;
        v7 += 2;
        v4 = v9;
        if ( (unsigned __int16 *)v11 == v7 )
          return result;
      }
    }
  }
  return result;
}

//----- (00444AD0) --------------------------------------------------------
int __usercall send_tree@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // ecx
  int v8; // edx
  int v9; // edi
  int v10; // ebx
  int v11; // esi
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // esi
  int v16; // eax
  int v17; // ecx
  int v18; // ebx
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // esi
  int v23; // eax
  int v24; // esi
  int v25; // eax
  int v26; // edi
  int v27; // eax
  int v28; // edx
  int v29; // ebx
  int v30; // edx
  int v31; // ecx
  int v32; // esi
  int v33; // eax
  int v34; // esi
  int v35; // esi
  int v36; // ebx
  int v37; // edx
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // esi
  int v42; // ecx
  int v43; // edx
  int v44; // ebx
  int v45; // edi
  int v46; // ecx
  __int16 v47; // ax
  int v48; // eax
  int v49; // ecx
  int v50; // eax
  int v51; // edx
  int v52; // eax
  int v53; // ebx
  int v54; // eax
  int v55; // edx
  int v56; // ecx
  int v57; // eax
  int v58; // edx
  int v59; // esi
  int v60; // ecx
  int v61; // edx
  int v62; // ecx
  __int16 v63; // ax
  int v64; // edx
  int v65; // eax
  int v66; // edx
  int v67; // eax
  int v68; // esi
  int v69; // eax
  int v70; // edx
  int v71; // ecx
  int v72; // eax
  int v73; // edx
  int v74; // ebx
  int v75; // ecx
  int v76; // edx
  int v77; // ecx
  __int16 v78; // ax
  int v79; // edx
  int v80; // eax
  int v81; // edx
  int v82; // eax
  int v83; // edx
  int v84; // eax
  char v85; // cl
  int v86; // edx
  int v87; // ecx
  int v88; // eax
  char v89; // bl
  int v90; // ebx
  unsigned __int16 *v91; // [esp+0h] [ebp-28h]
  int v92; // [esp+4h] [ebp-24h]
  int v93; // [esp+8h] [ebp-20h]
  int v94; // [esp+Ch] [ebp-1Ch]
  int v95; // [esp+10h] [ebp-18h]
  int v96; // [esp+10h] [ebp-18h]
  int v97; // [esp+10h] [ebp-18h]
  int v98; // [esp+14h] [ebp-14h]

  result = *(unsigned __int16 *)(a2 + 2);
  v92 = result;
  v5 = 4 - (result == 0);
  v6 = result == 0 ? 138 : 7;
  if ( a3 >= 0 )
  {
    v94 = 0;
    v91 = (unsigned __int16 *)(a2 + 6);
    v98 = a2 + 4 * a3 + 10;
    v95 = -1;
    do
    {
      v26 = v94 + 1;
      v93 = *v91;
      if ( v94 + 1 < v6 )
      {
        if ( *v91 == v92 )
        {
          ++v94;
          goto LABEL_14;
        }
        v7 = *(_DWORD *)(a1 + 5820);
        v8 = *(unsigned __int16 *)(a1 + 5816);
        if ( v26 < v5 )
        {
          v9 = a1 + 4 * v92;
          v10 = *(unsigned __int16 *)(v9 + 2684);
          v11 = *(unsigned __int16 *)(v9 + 2686);
          v12 = v8 | (v10 << v7);
          *(_WORD *)(a1 + 5816) = v12;
          if ( 16 - v11 < v7 )
          {
            v83 = *(_DWORD *)(a1 + 20);
            *(_DWORD *)(a1 + 20) = v83 + 1;
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + v83) = v12;
            v84 = *(_DWORD *)(a1 + 20);
            v85 = *(_BYTE *)(a1 + 5817);
            *(_DWORD *)(a1 + 20) = v84 + 1;
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + v84) = v85;
            v86 = *(_DWORD *)(a1 + 5820);
            v13 = v86 + v11 - 16;
            v12 = v10 >> (16 - v86);
            *(_WORD *)(a1 + 5816) = v12;
          }
          else
          {
            v13 = v11 + v7;
          }
          *(_DWORD *)(a1 + 5820) = v13;
          if ( v94 )
          {
            v14 = *(unsigned __int16 *)(v9 + 2684);
            v15 = *(unsigned __int16 *)(v9 + 2686);
            v16 = (v14 << v13) | v12;
            *(_WORD *)(a1 + 5816) = v16;
            if ( 16 - v15 < v13 )
            {
              v87 = *(_DWORD *)(a1 + 20);
              *(_DWORD *)(a1 + 20) = v87 + 1;
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + v87) = v16;
              v88 = *(_DWORD *)(a1 + 20);
              v89 = *(_BYTE *)(a1 + 5817);
              *(_DWORD *)(a1 + 20) = v88 + 1;
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + v88) = v89;
              v90 = *(_DWORD *)(a1 + 5820);
              v17 = v90 + v15 - 16;
              v16 = v14 >> (16 - v90);
              *(_WORD *)(a1 + 5816) = v16;
            }
            else
            {
              v17 = v15 + v13;
            }
            *(_DWORD *)(a1 + 5820) = v17;
            if ( v94 != 1 )
            {
              v18 = *(unsigned __int16 *)(v9 + 2684);
              v19 = *(unsigned __int16 *)(v9 + 2686);
              v20 = (v18 << v17) | v16;
              *(_WORD *)(a1 + 5816) = v20;
              if ( 16 - v19 >= v17 )
              {
                *(_DWORD *)(a1 + 5820) = v19 + v17;
              }
              else
              {
                v21 = *(_DWORD *)(a1 + 20);
                v22 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v21 + 1;
                *(_BYTE *)(v22 + v21) = v20;
                v23 = *(_DWORD *)(a1 + 20);
                LOBYTE(v21) = *(_BYTE *)(a1 + 5817);
                v24 = *(_DWORD *)(a1 + 8);
                *(_DWORD *)(a1 + 20) = v23 + 1;
                *(_BYTE *)(v24 + v23) = v21;
                v25 = *(_DWORD *)(a1 + 5820);
                *(_DWORD *)(a1 + 5820) = v25 + v19 - 16;
                *(_WORD *)(a1 + 5816) = v18 >> (16 - v25);
              }
            }
          }
          v94 = 0;
          v95 = v92;
          v5 = 4 - (v93 == 0);
          v6 = v93 == 0 ? 138 : 7;
          goto LABEL_14;
        }
      }
      else
      {
        v7 = *(_DWORD *)(a1 + 5820);
        v8 = *(unsigned __int16 *)(a1 + 5816);
      }
      v27 = v8;
      if ( v92 )
      {
        if ( v92 != v95 )
        {
          v28 = a1 + 4 * v92;
          v29 = *(unsigned __int16 *)(v28 + 2686);
          v30 = *(unsigned __int16 *)(v28 + 2684);
          v27 |= v30 << v7;
          *(_WORD *)(a1 + 5816) = v27;
          if ( 16 - v29 >= v7 )
          {
            v7 += v29;
            LOWORD(v26) = v94;
          }
          else
          {
            v31 = *(_DWORD *)(a1 + 20);
            v32 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v31 + 1;
            *(_BYTE *)(v32 + v31) = v27;
            v33 = *(_DWORD *)(a1 + 20);
            LOBYTE(v31) = *(_BYTE *)(a1 + 5817);
            v34 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v33 + 1;
            LOWORD(v26) = v94;
            *(_BYTE *)(v34 + v33) = v31;
            v35 = *(_DWORD *)(a1 + 5820);
            v27 = v30 >> (16 - v35);
            v7 = v35 + v29 - 16;
            *(_WORD *)(a1 + 5816) = v27;
          }
          *(_DWORD *)(a1 + 5820) = v7;
        }
        v36 = *(unsigned __int16 *)(a1 + 2748);
        v37 = *(unsigned __int16 *)(a1 + 2750);
        v38 = (v36 << v7) | v27;
        *(_WORD *)(a1 + 5816) = v38;
        if ( 16 - v37 >= v7 )
        {
          v42 = v37 + v7;
        }
        else
        {
          v39 = *(_DWORD *)(a1 + 20);
          *(_DWORD *)(a1 + 20) = v39 + 1;
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + v39) = v38;
          v40 = *(_DWORD *)(a1 + 20);
          LOBYTE(v39) = *(_BYTE *)(a1 + 5817);
          *(_DWORD *)(a1 + 20) = v40 + 1;
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + v40) = v39;
          v41 = *(_DWORD *)(a1 + 5820);
          v38 = v36 >> (16 - v41);
          v42 = v41 + v37 - 16;
          *(_WORD *)(a1 + 5816) = v38;
        }
        *(_DWORD *)(a1 + 5820) = v42;
        v43 = (unsigned __int16)(v26 - 3);
        if ( v42 <= 14 )
        {
          v51 = v38 | (v43 << v42);
          *(_DWORD *)(a1 + 5820) = v42 + 2;
        }
        else
        {
          v44 = *(_DWORD *)(a1 + 8);
          v45 = v43 << v42;
          v46 = *(_DWORD *)(a1 + 20);
          v47 = v45 | v38;
          *(_WORD *)(a1 + 5816) = v47;
          *(_DWORD *)(a1 + 20) = v46 + 1;
          *(_BYTE *)(v44 + v46) = v47;
          v48 = *(_DWORD *)(a1 + 20);
          LOBYTE(v44) = *(_BYTE *)(a1 + 5817);
          v49 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v48 + 1;
          *(_BYTE *)(v49 + v48) = v44;
          v50 = *(_DWORD *)(a1 + 5820);
          v51 = v43 >> (16 - v50);
          *(_DWORD *)(a1 + 5820) = v50 - 14;
        }
        *(_WORD *)(a1 + 5816) = v51;
      }
      else if ( v26 > 10 )
      {
        v68 = *(unsigned __int16 *)(a1 + 2758);
        v97 = *(unsigned __int16 *)(a1 + 2756);
        v69 = v8 | (v97 << v7);
        *(_WORD *)(a1 + 5816) = v69;
        if ( 16 - v68 >= v7 )
        {
          v75 = v68 + v7;
        }
        else
        {
          v70 = *(_DWORD *)(a1 + 20);
          v71 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v70 + 1;
          *(_BYTE *)(v71 + v70) = v69;
          v72 = *(_DWORD *)(a1 + 20);
          LOBYTE(v71) = *(_BYTE *)(a1 + 5817);
          v73 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v72 + 1;
          *(_BYTE *)(v73 + v72) = v71;
          v74 = *(_DWORD *)(a1 + 5820);
          v69 = v97 >> (16 - v74);
          v75 = v74 + v68 - 16;
          *(_WORD *)(a1 + 5816) = v69;
        }
        *(_DWORD *)(a1 + 5820) = v75;
        if ( v75 <= 9 )
        {
          *(_DWORD *)(a1 + 5820) = v75 + 7;
          *(_WORD *)(a1 + 5816) = v69 | (((_WORD)v94 - 10) << v75);
        }
        else
        {
          v76 = (unsigned __int16)(v94 - 10) << v75;
          v77 = *(_DWORD *)(a1 + 8);
          v78 = v76 | v69;
          v79 = *(_DWORD *)(a1 + 20);
          *(_WORD *)(a1 + 5816) = v78;
          *(_DWORD *)(a1 + 20) = v79 + 1;
          *(_BYTE *)(v77 + v79) = v78;
          v80 = *(_DWORD *)(a1 + 20);
          LOBYTE(v77) = *(_BYTE *)(a1 + 5817);
          v81 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v80 + 1;
          *(_BYTE *)(v81 + v80) = v77;
          v82 = *(_DWORD *)(a1 + 5820);
          *(_DWORD *)(a1 + 5820) = v82 - 9;
          *(_WORD *)(a1 + 5816) = (int)(unsigned __int16)(v94 - 10) >> (16 - v82);
        }
      }
      else
      {
        v53 = *(unsigned __int16 *)(a1 + 2754);
        v96 = *(unsigned __int16 *)(a1 + 2752);
        v54 = v8 | (v96 << v7);
        *(_WORD *)(a1 + 5816) = v54;
        if ( 16 - v53 >= v7 )
        {
          v60 = v53 + v7;
          *(_DWORD *)(a1 + 5820) = v60;
          if ( v60 > 13 )
          {
LABEL_34:
            v61 = (unsigned __int16)(v94 - 2) << v60;
            v62 = *(_DWORD *)(a1 + 8);
            v63 = v61 | v54;
            v64 = *(_DWORD *)(a1 + 20);
            *(_WORD *)(a1 + 5816) = v63;
            *(_DWORD *)(a1 + 20) = v64 + 1;
            *(_BYTE *)(v62 + v64) = v63;
            v65 = *(_DWORD *)(a1 + 20);
            LOBYTE(v62) = *(_BYTE *)(a1 + 5817);
            v66 = *(_DWORD *)(a1 + 8);
            *(_DWORD *)(a1 + 20) = v65 + 1;
            *(_BYTE *)(v66 + v65) = v62;
            v67 = *(_DWORD *)(a1 + 5820);
            LOBYTE(v62) = 16 - v67;
            *(_DWORD *)(a1 + 5820) = v67 - 13;
            v52 = v93;
            *(_WORD *)(a1 + 5816) = (int)(unsigned __int16)(v94 - 2) >> v62;
            if ( v93 )
            {
LABEL_28:
              if ( v52 == v92 )
              {
                v95 = v52;
                v5 = 3;
                v6 = 6;
              }
              else
              {
                v95 = v92;
                v5 = 4;
                v6 = 7;
              }
              v94 = 0;
              goto LABEL_14;
            }
            goto LABEL_35;
          }
        }
        else
        {
          v55 = *(_DWORD *)(a1 + 20);
          v56 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v55 + 1;
          *(_BYTE *)(v56 + v55) = v54;
          v57 = *(_DWORD *)(a1 + 20);
          LOBYTE(v56) = *(_BYTE *)(a1 + 5817);
          v58 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 20) = v57 + 1;
          *(_BYTE *)(v58 + v57) = v56;
          v59 = *(_DWORD *)(a1 + 5820);
          v54 = v96 >> (16 - v59);
          v60 = v59 + v53 - 16;
          *(_WORD *)(a1 + 5816) = v54;
          *(_DWORD *)(a1 + 5820) = v60;
          if ( v60 > 13 )
            goto LABEL_34;
        }
        *(_DWORD *)(a1 + 5820) = v60 + 3;
        *(_WORD *)(a1 + 5816) = v54 | (((_WORD)v94 - 2) << v60);
      }
      v52 = v93;
      if ( v93 )
        goto LABEL_28;
LABEL_35:
      v5 = 3;
      v6 = 138;
      v94 = 0;
      v95 = v92;
LABEL_14:
      v91 += 2;
      result = (int)v91;
      v92 = v93;
    }
    while ( (unsigned __int16 *)v98 != v91 );
  }
  return result;
}

//----- (004451B0) --------------------------------------------------------
int __usercall updatewindow@<eax>(size_t Size@<ecx>, int a2@<eax>, size_t a3@<edx>)
{
  int v5; // ebx
  char *v6; // eax
  size_t v7; // esi
  int v8; // ebp
  char *v9; // eax
  const void *Src; // ecx
  unsigned int v11; // ecx
  size_t v12; // eax
  unsigned int v13; // edx
  int result; // eax
  int v15; // ecx
  int v16; // eax
  size_t v17; // ebp
  int v18; // eax
  size_t v19; // [esp+18h] [ebp-24h]
  size_t v20; // [esp+18h] [ebp-24h]
  size_t v21; // [esp+1Ch] [ebp-20h]

  v5 = *(_DWORD *)(a2 + 28);
  v6 = *(char **)(v5 + 56);
  if ( !v6 )
  {
    v20 = a3;
    v6 = (char *)(*(int (__cdecl **)(_DWORD, int, int))(a2 + 32))(*(_DWORD *)(a2 + 40), 1 << *(_DWORD *)(v5 + 40), 1);
    a3 = v20;
    *(_DWORD *)(v5 + 56) = v6;
    if ( !v6 )
      return 1;
  }
  v7 = *(_DWORD *)(v5 + 44);
  if ( v7 )
  {
    if ( Size < v7 )
      goto LABEL_4;
LABEL_11:
    memcpy(v6, (const void *)(a3 - v7), v7);
    v16 = *(_DWORD *)(v5 + 44);
    *(_DWORD *)(v5 + 52) = 0;
    *(_DWORD *)(v5 + 48) = v16;
    return 0;
  }
  v15 = *(_DWORD *)(v5 + 40);
  *(_DWORD *)(v5 + 52) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  v7 = 1 << v15;
  *(_DWORD *)(v5 + 44) = 1 << v15;
  if ( Size >= 1 << v15 )
    goto LABEL_11;
LABEL_4:
  v8 = *(_DWORD *)(v5 + 52);
  v21 = a3;
  v9 = &v6[v8];
  v19 = v7 - v8;
  Src = (const void *)(a3 - Size);
  if ( Size >= v7 - v8 )
  {
    memcpy(v9, Src, v7 - v8);
    v17 = Size + v8 - v7;
    if ( v17 )
    {
      memcpy(*(void **)(v5 + 56), (const void *)(v19 - Size + v21), v17);
      v18 = *(_DWORD *)(v5 + 44);
      *(_DWORD *)(v5 + 52) = v17;
      *(_DWORD *)(v5 + 48) = v18;
      return 0;
    }
    Size = v19;
  }
  else
  {
    memcpy(v9, Src, Size);
  }
  v11 = *(_DWORD *)(v5 + 44);
  v12 = Size + *(_DWORD *)(v5 + 52);
  if ( v12 == v11 )
    v12 = 0;
  v13 = *(_DWORD *)(v5 + 48);
  *(_DWORD *)(v5 + 52) = v12;
  result = 0;
  if ( v11 > v13 )
    *(_DWORD *)(v5 + 48) = v13 + Size;
  return result;
}

//----- (00445320) --------------------------------------------------------
char *__cdecl zError(int a1)
{
  return z_errmsg[2 - a1];
}
// 515D00: using guessed type char *z_errmsg[2];

//----- (00445340) --------------------------------------------------------
void *__cdecl zcalloc(size_t Size, int a2, int a3)
{
  return malloc(a2 * a3);
}

//----- (00445360) --------------------------------------------------------
void __cdecl zcfree(void *Block, void *a2)
{
  free(a2);
}

//----- (00445370) --------------------------------------------------------
int zlibCompileFlags()
{
  return 85;
}

//----- (00445380) --------------------------------------------------------
const char *zlibVersion()
{
  return "1.2.11";
}

//----- (00445398) --------------------------------------------------------
void __noreturn __report_error(char *Format, ...)
{
  FILE *Stream; // eax
  FILE *v2; // eax
  va_list va; // [esp+24h] [ebp+8h] BYREF

  va_start(va, Format);
  Stream = __acrt_iob_func(2u);
  fwrite("Mingw-w64 runtime failure:\n", 1u, 0x1Bu, Stream);
  v2 = __acrt_iob_func(2u);
  vfprintf(v2, Format, va);
  abort();
}

// nfuncs=1008 queued=921 decompiled=921 lumina nreq=0 worse=0 better=0
// ALL OK, 921 function(s) have been successfully decompiled